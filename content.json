{"meta":{"title":"芝麻的blog","subtitle":"百 事 可 乐","description":"芝麻的blog","author":"芝麻","url":"https://li-zhi.net.cn","root":"/"},"pages":[{"title":"about","date":"2022-01-26T14:34:59.000Z","updated":"2022-01-26T14:35:42.811Z","comments":true,"path":"about/index.html","permalink":"https://li-zhi.net.cn/about/index.html","excerpt":"","text":"这个是about页面"},{"title":"分类","date":"2022-01-27T03:28:29.000Z","updated":"2022-10-23T00:50:10.215Z","comments":false,"path":"categories/index.html","permalink":"https://li-zhi.net.cn/categories/index.html","excerpt":"","text":""},{"title":"常用配置","date":"2023-01-14T12:54:05.000Z","updated":"2023-01-14T13:14:47.638Z","comments":true,"path":"commonlyUsedConfiguration/index.html","permalink":"https://li-zhi.net.cn/commonlyUsedConfiguration/index.html","excerpt":"","text":"MySQL配置123456789101112131415spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/xxx?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8 username: username password: password hikari: connection-timeout: 10000 validation-timeout: 3000 idle-timeout: 60000 login-timeout: 5 max-lifetime: 60000 maximum-pool-size: 10 minimum-idle: 5 read-only: false Redis配置1234567891011spring: redis: host: r-2zec1xnklp1y8ipk4vpd.redis.rds.aliyuncs.com password: Root9275 port: 6379 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 Mail配置12345678spring: mail: # 不同的邮箱是不同的邮箱服务器域名 # qq是smtp.qq.com host: smtp.163.com protocol: smtp username: 邮箱 password: 密钥 MyBatis-Plus配置12345678mybatis-plus: mapper-locations: classpath:com/wisdom/mapper/*/*.xml configuration: map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl default-enum-type-handler: org.apache.ibatis.type.EnumOrdinalTypeHandler type-aliases-package: com.zhima.entity type-enums-package: com.zhima.enums"},{"title":"标签","date":"2022-01-27T03:32:41.000Z","updated":"2022-10-04T13:44:08.523Z","comments":false,"path":"tags/index.html","permalink":"https://li-zhi.net.cn/tags/index.html","excerpt":"","text":""},{"title":"有料","date":"2022-01-26T14:36:13.000Z","updated":"2023-01-28T07:30:12.335Z","comments":true,"path":"sometips/index.html","permalink":"https://li-zhi.net.cn/sometips/index.html","excerpt":"","text":"Windows下端口占用问题解决1234567891011121314# 查看端口netstat -ano# 查询指定端口netstat -ano | findstr &quot;端口号&quot;# 根据进程pid查询进程名称netstat |findstr &quot;进程pid&quot;# 根据pid杀死任务taskkill /f /pid &quot;进程pid&quot;# 根据进程名杀死任务taskkill -f -t -im &quot;进程名称&quot; Spring核心配置文件的模板1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Docker命令图 Dockerfile文件格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 基础镜像，tag不写默认为latest# 只能写一次FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;# example# FROM centos# 作者信息name一般为邮箱MAINTAINER &lt;name&gt;# example# MAINTAINER zhima&lt;1158778689@qq.com&gt;# 设置镜像的元数据标签信息LABEL &lt;info&gt;# example# LABEL version=&quot;1.0&quot;# LABEL description=&quot;this is description&quot;# 设置环境变量ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...# example# ENV DIRPATH /path# 设置运行RUN CMD ENTRYPOINT的用户名USER &lt;userName&gt;USER &lt;UID&gt;# 设置工作目录# 对RUN,CMD,ENTRYPOINT,COPY,ADD生效# 如果不存在则会创建WORKDIR 镜像内地址# example# 使用$读取环境变量# WORKDIR $DIRPATH# 定义变量# 在docker build创建镜像的时候，使用 --build-arg &lt;varname&gt;=&lt;value&gt;来指定参数ARG &lt;name&gt;[=&lt;default value&gt;]# 为子镜像设置命令# 当本镜像作为其他容器的基础镜像的时候，INSTRUCTION会在子镜像运行的时候执行ONBUILD [INSTRUCTION]# example# ONBUILD RUN ls -al# 添加文件到镜像# source可写# 宿主机的绝对路径# 本Dockerfile所在目录的相对路径# url，如果使用url，则此ADD相当于wget# source如果是压缩包，则会自动解压ADD &lt;source&gt; &lt;dest&gt;# 复制文件到镜像中# COPY的&lt;source&gt;只能是本地文件，其他用法与ADD一致COPY &lt;source&gt; &lt;dest&gt;# 在**构建**镜像的时候运行的命令，一般是安装命令RUN &lt;command&gt;RUN [&quot;executable&quot;,&quot;param1&quot;]# example# RUN yum install -y gcc# 下面三行RUN命令是为了解决以下这个错误的# Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist# RUN cd /etc/yum.repos.d/# RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*# RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*# 暴露容器运行时的监听端口给外部EXPOSE &lt;port&gt;# 但是EXPOSE并不会使容器访问主机的端口# 如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -p参数# 数据卷# 这种是匿名数据卷 宿主机会在/var/lib/docker/volumes下生成一个随机命名的目录# 可以在运行容器的时候，指定挂载卷的名字# -v 卷名:镜像内想要被挂载的地址2VOLUME [&quot;镜像内想要被挂载的地址1&quot;,&quot;镜像内想要被挂载的地址2&quot;]VOLUME &quot;镜像内想要被挂载的地址1&quot; &quot;镜像内想要被挂载的地址2&quot; # 容器**运行**的时候运行的命令CMD &lt;command&gt;CMD [&quot;executable&quot;,&quot;param1&quot;]# example# CMD [&quot;cd&quot;,&quot;/usr/local&quot;]# CMD cd /usr/local # 容器运行的时候运行的命令ENTRYPOINT java -jar demo.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;]# ENTRYPOINT和CMD的区别# 不同之处# 1.ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖# 2.如果我们在Dockerfile种同时写了ENTRYPOINT和CMD# 并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数# 3.docker run image &lt;参数&gt;# 传入的参数会追加在ENTRYPOINT之后# 如果是CMD，会直接覆盖此CMD# 相同之处# 只能写一条，如果写了多条，那么只有最后一条生效# 容器启动时才运行# 如果我们在Dockerfile种同时写了ENTRYPOINT和完整的CMD，ENTRYPOINT一定会执行，CMD不会执行 Docker-compose格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 指定compose版本，一般3.1就可以了version: &#x27;3.1&#x27;# 服务列表services: # 自定义服务名 service_name1: # 使用docker build构建镜像 # Dockerfile的地址 build: context: . dockerfile: custom-Dockerfile # 如果dockerfile文件名就叫Dockerfile，则可以使用简写模式 # build: . # 如果有build则是指定构建出来的镜像的镜像名 # 如果没有build则是指定运行的镜像 image: &lt;imageName&gt;:&lt;tag&gt; # 指定运行容器的名称 container_name: &lt;container_name&gt; # 容器卷技术 volumes: - /usr/local/mysql # 匿名挂载 - VolumeName:/home/zhima #具名挂载 - /temp/mysql/config:/etc/mysql/conf.d # 宿主机挂载 # 端口映射 ports: - &quot;宿主机端口:容器端口&quot; # 运行容器的时候的参数 command: [ &quot;param1&quot;, &quot;param2&quot; ] # 指定加入的网络 networks: - network1 - network2 # 第二个服务 service_name2: # 使用构建好的镜像 image: &lt;imageName&gt;:&lt;tag&gt; stdin_open: true # 类似于docker run -d tty: true # 类似于docker run -t depends_on: - service_name1networks: network1: driver: bridge network2: driver: bridge Git命令图 SpringMVC的web.xml模板123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 数据库模板配置文件123spring.datasource.url=jdbc:mysql://locoalhost:3306/dbname?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 MyBatis配置文件的模板核心配置文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;/configuration&gt; 映射器xml文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.youkeda.comment.dao.UserDAO&quot;&gt;&lt;/mapper&gt; druid连接池配置文件maven坐标12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 一部分核心配置文件12345678910111213141516171819202122232425262728293031323334spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC&amp;useUnicodestrue&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid druid特有配置 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxwait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计栏截的filters，stat: 监控统计、Log4j: 日志记录、wall: 防御sqL注入 #如果允许时报借 java.Lang.CLassNotFoundException: org.apache.Log4j.Priority filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourcestat: true connectionProperties: druid.stat.mergesqletrue;druid.stat.slowSq1Millis=500 stat-view-servlet: enabled: true url-pattern: /druid/* login-password: admin login-username: 123456 allow: deny: 后台监控页面也可以通过以下方式配置 12345678910@Beanpublic ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;Servlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(&quot;loginUserName&quot;,&quot;admin&quot;); params.put(&quot;loginPassword&quot;,&quot;123456&quot;); params.put(&quot;allow&quot;,&quot;localhost&quot;); bean.setInitParameters(params); return bean;&#125; 去除druid的广告1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.lizhi.springbootdata;import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure;import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;import com.alibaba.druid.util.Utils;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.*;import java.io.IOException;@Configuration@ConditionalOnWebApplication@AutoConfigureAfter(DruidDataSourceAutoConfigure.class)@ConditionalOnProperty(name = &quot;spring.datasource.druid.stat-view-servlet.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)public class RemoveDruidAdConfig &#123; /** * 方法名: removeDruidAdFilterRegistrationBean * 方法描述: 除去页面底部的广告 * @param properties * @return org.springframework.boot.web.servlet.FilterRegistrationBean * @throws */ @Bean public FilterRegistrationBean removeDruidAdFilterRegistrationBean(DruidStatProperties properties) &#123; // 获取web监控页面的参数 DruidStatProperties.StatViewServlet config = properties.getStatViewServlet(); // 提取common.js的配置路径 String pattern = config.getUrlPattern() != null ? config.getUrlPattern() : &quot;/druid/*&quot;; String commonJsPattern = pattern.replaceAll(&quot;\\\\*&quot;, &quot;js/common.js&quot;); final String filePath = &quot;support/http/resources/js/common.js&quot;; //创建filter进行过滤 Filter filter = new Filter() &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(request, response); // 重置缓冲区，响应头不会被重置 response.resetBuffer(); // 获取common.js String text = Utils.readFromResource(filePath); // 正则替换banner, 除去底部的广告信息 text = text.replaceAll(&quot;&lt;a.*?banner\\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;, &quot;&quot;); text = text.replaceAll(&quot;powered.*?shrek.wang&lt;/a&gt;&quot;, &quot;&quot;); response.getWriter().write(text); &#125; @Override public void destroy() &#123; &#125; &#125;; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(filter); registrationBean.addUrlPatterns(commonJsPattern); return registrationBean; &#125;&#125; GitHub加速https://gitee.com/docmirror/dev-sidecar?_from=gitee_search 高质量项目https://github.com/kon9chunkit/Github-Chinese-Top-Charts#%E7%9B%AE%E5%BD%95 官方文档https://docs.github.com/cn maven中资源导出出现问题123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; CORS跨域请求的配置1234567891011121314151617import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowCredentials(true) .allowedOriginPatterns(&quot;*&quot;) .maxAge(2000); &#125;&#125; 12345678910111213141516171819202122232425import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig1 &#123; private static final long MAX_AGE=24*60*60; private CorsConfiguration buildConfig()&#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.setMaxAge(MAX_AGE); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter()&#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;,buildConfig()); return new CorsFilter(source); &#125;&#125; SpringSession的配置123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.session.MapSessionRepository;import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;import org.springframework.session.web.http.CookieSerializer;import org.springframework.session.web.http.DefaultCookieSerializer;import java.util.concurrent.ConcurrentHashMap;@Configuration@EnableSpringHttpSessionpublic class SpringHttpSessionConfig &#123; @Bean public CookieSerializer cookieSerializer() &#123; DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(&quot;JSESSIONID&quot;); // 用正则表达式配置匹配的域名，可以兼容 localhost、127.0.0.1 等各种场景 serializer.setDomainNamePattern(&quot;^.+?\\\\.(\\\\w+\\\\.[a-z]+)$&quot;); serializer.setCookiePath(&quot;/&quot;); serializer.setUseHttpOnlyCookie(false); // 最大生命周期的单位是秒 serializer.setCookieMaxAge(48 * 60 * 60); return serializer; &#125; @Bean public MapSessionRepository sessionRepository() &#123; return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); &#125;&#125; Log4j 核心配置文件12345678910111213141516171819202122232425#将等级为DEBUG的志信息输出到console和file这两个目的地。console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#范制台偷出的相关设置log4j.appender.console =org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.Threshold=DEBUglog4j.appender.console.layout =org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file =org.apache.log4j.RollingFileAppender#日志文件输出的磁盘路径log4j.appender.file.File=./log/lizhi.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日去输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.Preparedstatement=DEBUG 字体图标的使用使用字体图标前，添加字体申明，参考如下或者直接在style.css文件中复制 1234567891011@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?suef9x&#x27;); src: url(&#x27;fonts/icomoon.eot?suef9x#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?suef9x&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?suef9x&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?suef9x#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block;&#125; 记得修改字体（font-family）为icomoon 更新服务器时间12345[root@localhost ~]# date -RFri, 27 Jan 2023 00:23:13 +0800[root@localhost /]# yum install -y ntp[root@localhost /]# date -RSat, 28 Jan 2023 15:27:20 +0800"}],"posts":[{"title":"Linux-系统管理","slug":"Linux-系统管理","date":"2023-01-09T07:35:23.000Z","updated":"2023-01-10T12:07:04.295Z","comments":true,"path":"javaEE/2023/01/09/Linux-系统管理/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2023/01/09/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","excerpt":"","text":"系统管理find作用根据给定路径和搜索条件查找文件 使用说明1234567891011121314# 格式：find [路径] [参数] 待搜索字段# 常用参数 -name 匹配名称 -user 匹配所有者 -perm 匹配权限（mode为完全匹配，-mode为包含即可） -type b(块设备)/d(目录)/c(字符设备)/p(管道)/l(链接文件)/f(文本文件) 匹配文件类型 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n指n天以内，+n指n天以前） -atime -n +n 匹配访问文件的时间（-n指n天以内，+n指n天以前） -ctime -n +n 匹配修改文件权限的时间（-n指n天以内，+n指n天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -size 匹配文件的大小（+50KB为查找超过50KB的文件，而-1M为查找小于1M的文件） -exec [处理搜索结果的命令] &#123;&#125;\\; 后面可跟用于进一步处理搜索结果的命令 locate作用locate命令的功能是用于快速查找文件或目录 与find命令进行全局搜索不同，locate命令是基于了数据文件（&#x2F;var&#x2F;lib&#x2F;locatedb）进行的定点查找 此命令缩小了搜索范围，因此快速快很多 使用说明123456# 格式：locate 关键词# 更新数据库文件[root@zhima home]# updatedb# 查找系统中文件名中有network的文件[root@zhima home]# locate network which作用找到命令本身所在的路径 使用说明1# 格式：which [参数] 命令 参考案例123456[root@zhima home]# which yum/usr/bin/yum[root@zhima home]# which rpm/usr/bin/rpm[root@zhima home]# which docker/usr/bin/docker whereis作用定位命令的二进制程序、源代码文件和man手册页等相关文件的路径 它不是在磁盘中乱找，而是在一个数据库文件中查询 此数据库文件是包含有本地所有文件的信息，需要自己手动使用updatedb更新数据库 正因为这样，whereis命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。 使用说明1234567891011121314# 格式：whereis [参数] 命令名# 常用参数 # 只搜索二进制文件 -b search only for binaries # 指定路径搜索二进制文件 -B &lt;dirs&gt; define binaries lookup path # 只搜索man手册 -m search only for manuals # 指定路径下搜索man手册 -M &lt;dirs&gt; define man lookup path # 只搜索源代码 -s search only for sources # 指定路径下搜索源代码 -S &lt;dirs&gt; define sources lookup path rpm作用包管理器（RedHat Package Manager） 使用说明123456789101112131415161718# 格式：rpm [参数] 软件包名# 常用参数 # 列出所有软件包 -a, --all query/verify all packages # 卸载软件包 -e, --erase=&lt;package&gt;+ erase (uninstall) package # 查询文件或命令属于哪个软件包 -f, --file query/verify package(s) owning file # 下载软件包 -i, --install install package(s) # 显示软件包的文件列表 -l, --list list files in package # 查询指定的rpm软件包 -p, --package query/verify a package file # 安装软件包时列出标记 -h, --hash print hash marks as package installs (good with -v) # 显示命令执行过程 -v, --verbose provide more detailed output 参考案例1234567891011121314# 安装软件包[root@zhima home]# rmp ivh cockpit-185-2.el8.x86_64.rpm # 列出系统安装的所有软件[root@zhima home]# rpm -qa# 查看cockpit的文件列表[root@zhima home]#rpm -ql cockpit# 升级指定软件包[root@zhima home]#rpm -Uvh cockpit-185-2.el8.x86_64.rpm # 卸载cockpit[root@zhima home]#rpm -evh cockpit ps作用查看进程状态（process status） 使用说明12345678910# 格式：ps [参数]# 常用参数 a 显示现行终端机下的所有程序，包括其他用户的程序 u 以用户为主的格式来显示程序状况 x 显示所有程序，不以终端机来区分 r 只列出现行终端机正在执行中的程序 e 列出程序时，显示每个程序所使用的环境变量 -f 显示UID,PPIP,C与STIME栏位 -l 采用详细的格式来显示程序状况 -y 配合选项”-l”使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位 参考案例123456789101112# 显示系统中全部的进程信息，包含详细信息# 结合输出重定向，将当前进程信息保留备份至指定文件ps aux &gt; now_process_status.txt# 显示当前系统运行状态详细信息ps -ely# 显示当前系统运行状态ps -ef# 依据内存使用量（第四列）情况降序排序ps aux | sort -rnk 4 nohup作用后台启动程序 使用说明1# 格式：nohup [参数] 程序名 参考案例12345# 以后台模式运行xxx.jar包nohup java -jar xxx.jar &amp;# 以后台模式运行xxx.jar包并讲输出结果都写入xxx_log.txt文件nohup java -jar xxx.jar &amp; &gt; xxx_log.txt systemctl作用管理系统服务（后台进程） 使用说明1234567891011121314151617181920# 开启服务systemctl start servieName# 重启服务systemctl restart servieName# 关闭服务systemctl stop servieName# 查看服务状态systemctl status servieName# 关闭后台服务自启动systemctl disable serviceName# 开启后台服务自启动systemctl enable serviceName# 查看所有后台服务状态systemctl list-units --type service --all uname作用显示系统内核内容 使用说明12345678910111213141516171819# 格式：uname [参数]# 常用参数 # 显示全部信息 -a, --all print all information, in the following order, except omit -p and -i if unknown: # 显示主机名 -n, --nodename print the network node hostname # 显示内核名 -s, --kernel-name print the kernel name # 显示硬件架构 -m, --machine print the machine hardware name # 显示内核发行号 -r, --kernel-release print the kernel release # 显示内核版本 -v, --kernel-version print the kernel version # 显示处理器的类型 -p, --processor print the processor type or &quot;unknown&quot; # 显示操作系统类型 -o, --operating-system print the operating system shutdown作用关机 使用说明123456789101112131415161718# Linux系统中为了提高磁盘的读写效率，对磁盘采用了“预读迟写”操作方式。当用户保存文件时，Linux核心并不一定立即将数据写入物理磁盘中，而是将数据保存在缓存区中，等到缓存区被填满了之后再将数据写入磁盘，这种方式确实极大地提高了读写效率，但是也有其所在的一些问题，当服务器遭受到断电或者其他意外情况的时候，缓存中的数据会直接丢失，这就会导致一些问题，sync就是将缓存中的东西直接写入到磁盘中去，无需等待缓存被填满#将数据同步到硬盘（关机前必须做）sync#服务器在十分钟后关机shutdown -h 10#立即关机shutdown -h now#在20:35关机shutdown -h 20:35#立马重启shutdown -r now#立马重启reboot","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-文件编辑","slug":"Linux-文件编辑","date":"2023-01-08T03:58:38.000Z","updated":"2023-01-10T11:51:20.533Z","comments":true,"path":"javaEE/Linux/2023/01/08/Linux-文件编辑/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2023/01/08/Linux-%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91/","excerpt":"","text":"Linux-文件编辑chgrp作用修改文件属组（change group） 使用说明12345678910# 格式：chgrp [参数] [目录]# 常用参数 # 和-v类似，但是-c是只显示发生修改的部分 -c, --changes like verbose but report only when a change is made # 不显示报错 -f, --silent, --quiet suppress most error messages # 输出对每个文件的处理过程 -v, --verbose output a diagnostic for every file processed # 递归处理子目录 -R, --recursive operate on files and directories recursively chown作用修改文件属组和属主（change owner） 使用说明12345678910# 格式：chown [参数] 属主:属组 目标文件# 常用参数 # 和-v类似，但是-c是只显示发生修改的部分 -c, --changes like verbose but report only when a change is made # 不显示报错 -f, --silent, --quiet suppress most error messages # 输出对每个文件的处理过程 -v, --verbose output a diagnostic for every file processed # 递归处理子目录 -R, --recursive operate on files and directories recursively chomd作用修改文件的权限（change mode） 使用说明12345678910# 格式：chomd 参数 目标文件# 常用参数 # 和-v类似，但是-c是只显示发生修改的部分 -c, --changes like verbose but report only when a change is made # 不显示报错 -f, --silent, --quiet suppress most error messages # 输出对每个文件的处理过程 -v, --verbose output a diagnostic for every file processed # 递归处理子目录 -R, --recursive operate on files and directories recursively 权限说明Linux中权限可以以两种方式说明，一种是符号，一种是数字 两者存在的对应关系如下 1r:4 w:2 x:1 使用chmod修改文件权限 1234567chmod rwxrw---x filename# 两者作用一致chmod 761 filename# 说明：# 7 -&gt; r + w + x =&gt; 4 + 2 + 1 = 7# 6 -&gt; r + w + - =&gt; 4 + 2 + 0 = 6# 1 -&gt; - + - + x =&gt; 0 + 0 + 1 = 1 cat作用查看文件内容 使用说明12345678910# cat [参数] 目标文件# 常用参数 # 显示行号（空行也编号） -n, --number number all output lines # 显示行号（多个连续空行算一行） -s, --squeeze-blank suppress repeated empty output lines # 显示行号（空行不编号） -b, --number-nonblank number nonempty output lines, overrides -n # 在每一行结尾处加上一个$ -E, --show-ends display $ at end of each line 参考案例1234567891011121314151617181920212223242526# 将file1.txt文件中的内容输出到copy.txt[root@zhima home]# cat file1.txt &gt; copy.txt [root@zhima home]# lscopy.txt file1.txt university zhima[root@zhima home]# cat copy.txt abcdefg[root@zhima home]# cat file1.txt abcdefg# 持续写入输入的内容到文件input.txt# 直到输入了END，退出并保存[root@zhima home]# cat &gt; input.txt &lt;&lt; END&gt; Hello&gt; world&gt; end&gt; END[root@zhima home]# cat input.txt Helloworldend# 再次执行就会覆盖原先文件[root@zhima home]# cat &gt; input.txt &lt;&lt; e&gt; overide&gt; e[root@zhima home]# cat input.txt overide more作用分页显示文件（只能向后浏览，不能向前） 使用说明123456789101112# 格式：more [参数] 目标文件# 常用参数 # 每页显示几行 -NUM specify the number of lines per screenful # 不滚动，先清除屏幕再展示文本 -p do not scroll, clean screen and display text # 不滚动，先展示文本再取出旧内容 -c do not scroll, display text and clean line ends # 压缩多行连续空白到一行 -s squeeze multiple blank lines into one # 从第几行开始显示 +NUM display file beginning from line number NUM less作用分页显示文件内容（既可以向前浏览又可以向后浏览） 使用说明12345678910111213# 格式：less [参数] 目标文件# 常用参数 -b 设置缓冲区的大小 -e 当文件显示结束后自动退出 -f 强制打开文件 -i 忽略搜索时的大小写 -m 显示阅读进度百分比 -N 显示每行的行号 -o 将输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 在单行显示较长的内容，而不换行显示 -x 将TAB字符显示为指定个数的空格字符 head作用显示文件开头内容（默认前10行） 使用说明1234567891011121314# 格式：head [参数] 目标文件# 常用参数 # 只显示开头前k个字符 # 加了-就是除了倒数k个字符不显示，其他都显示 -n, --lines=[-]K print the first K lines instead of the first 10; with the leading &#x27;-&#x27;, print all but the last K lines of each file # 只显示开头前k行 # 加了-就是除了倒数k行不显示，其他都显示 -c, --bytes=[-]K print the first K bytes of each file; with the leading &#x27;-&#x27;, print all but the last K bytes of each file # 显示文件名的头信息 -v, --verbose always print headers giving file names tail作用查看文件尾部内容（默认倒数10行） 使用说明123456789101112# 格式：tail [参数] 目标文件# 常用参数 # 显示最后k个字符 -c, --bytes=K output the last K bytes; or use -c +K to output bytes starting with the Kth of each file # 持续显示文件最新追加的内容 -f, --follow[=&#123;name|descriptor&#125;] output appended data as the file grows; an absent option argument means &#x27;descriptor&#x27; # 显示最后k行 -n, --lines=K output the last K lines, instead of the last 10; or use -n +K to output starting with the Kth rm作用删除文件 使用说明12345678910# 格式：rm [参数] 目标文件# 常用参数 # 强制删除 -f, --force ignore nonexistent files and arguments, never prompt # 删除前询问 -i prompt before every removal # 递归删除子文件夹 -r, -R, --recursive remove directories and their contents recursively # 显示详细的命令执行过程 -v, --verbose explain what is being done echo作用输出字符串或提取后的变量值 使用说明1# 格式：echo [参数] 字符串/$变量名 参考案例123456789101112# 显示study[root@zhima home]# echo studystudy# 显示系统变量PATH的值[root@zhima home]# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin# 将内容重定向到path.txt文件中[root@zhima home]# echo $PATH &gt; path.txt[root@zhima home]# cat path.txt /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin grep作用文本搜索工具 与之容易混淆的是egrep命令和fgrep命令 egrep等价于grep -E，支持扩展的正则表达式。 fgrep等价于grep -F，不支持正则表达式，直接按照字符串内容进行匹配。 使用说明12345678910111213141516# 格式：grep [参数] 待搜索文本 目标文件1 目标文件2 ...# 常用参数 # 忽略大小写 -i, --ignore-case ignore case distinctions # 只显示匹配的行数 -c, --count print only a count of matching lines per FILE # 不提示文件名 -h, --no-filename suppress the file name prefix on output # 输出关键词位置的行号及内容 -n, --line-number print line number with output lines # 显示不匹配的行 -v, --invert-match select non-matching lines # 递归搜索 -r, --recursive like --directories=recurs # 只列出匹配的文件名 -l, --files-with-matches print only names of FILEs containing matches","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-文件管理","slug":"Linux-文件管理","date":"2023-01-07T07:25:34.000Z","updated":"2023-01-10T12:02:12.501Z","comments":true,"path":"javaEE/2023/01/07/Linux-文件管理/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2023/01/07/Linux-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"文件管理ls作用显示当前工作目录下的所有文件和文件夹 使用说明1234567891011121314151617181920212223242526272829# 格式：ls [参数] [路径]# 常用可选参数 # 不要忽略以.开头的文件，即不忽略隐藏文件 -a, --all do not ignore entries starting with . # 以列表形式展示所有的文件 -l use a long listing format # 输出每个文件的索引值 -i, --inode print the index number of each file # 按照文件大小排序 -S sort by file size # 以相反次序展示 -r, --reverse reverse order while sorting # 同 -a ，但不列出 “.” (当前目录) 及 “..” (父目录) -A, --almost-all do not list implied . and .. # 显示每个文件的作者，和-l配合使用 --author with -l, print the author of each file # 递归显示所有的子文件夹 -R, --recursive list subdirectories recursively # 水平列出文件，以逗号分隔 -m fill width with a comma separated list of entries # 文件颜色说明 白色 普通文件 蓝色 文件夹 绿色 可执行文件 红色 压缩文件 浅蓝色 链接文件 红色闪烁 链接的文件有问题 黄色 设备文件 参考案例12345678910111213141516171819202122232425262728# 显示当前目录的所有文件# PS：文件夹也是一种文件，叫文件夹文件[root@zhima /]# lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 以列表形式显示当前目录下的所有文件，不显示.和..[root@zhima home]# ls -A -ltotal 20-rw-r--r-- 1 root root 4 Jan 8 10:37 file1-rw-r--r-- 1 root root 4 Jan 8 10:41 file2drwxr-xr-x 2 root root 4096 Jan 8 10:47 tempdrwxr-xr-x 3 root root 4096 Jan 5 16:05 universitydrwxr-xr-x 3 root root 4096 Jan 5 16:14 zhima# 以列表形式显示当前目录下的所有文件，包括隐藏文件[root@zhima home]# ls -a -ltotal 28drwxr-xr-x. 5 root root 4096 Jan 8 10:47 .dr-xr-xr-x. 19 root root 4096 Jan 8 11:19 ..-rw-r--r-- 1 root root 4 Jan 8 10:37 file1-rw-r--r-- 1 root root 4 Jan 8 10:41 file2drwxr-xr-x 2 root root 4096 Jan 8 10:47 tempdrwxr-xr-x 3 root root 4096 Jan 5 16:05 universitydrwxr-xr-x 3 root root 4096 Jan 5 16:14 zhima# 显示 / 目录下的所有文件[root@zhima home]# ls /bin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 文件属性这里说一下ls -al中展示了文件的哪些属性，分别都代表什么意思 1234567[root@zhima home]# ls -Altotal 20-rw-r--r-- 1 root root 4 Jan 8 10:37 file1-rw-r--r-- 1 root root 4 Jan 8 10:41 file2drwxr-xr-x 2 root root 4096 Jan 8 10:47 tempdrwxr-xr-x 3 root root 4096 Jan 5 16:05 universitydrwxr-xr-x 3 root root 4096 Jan 5 16:14 zhima 将每一行分为6组来看 第一组 12345678910111213141516# 这一组固定10个字符# 第一个字符是表示文件类型，有下面常见的几种 d 文件夹 - 普通文件 l 链接文件（Linked File） b 装置文件，里面可能有供存储的接口设备 c 装置文件里面的串行端口设备，例如键盘或者鼠标# 后9个字符表示操作权限，每3个字符为一组# 下面是四种权限类型的表示 r read（可读） w write（可写） x execute（可执行） - 没有此权限# 第一组三个字符是表示 属主（文件的所有者） 对此文件的权限# 第二组三个字符是表示 属组（文件的所有者的同组的用户） 对此文件的权限# 第三组三个字符是表示 其他用户 对此文件的权限说明 第二组 1234# 此文件是文件夹文件 此位数字表示的是文件夹内的文件数量# 此文件夹是文件 此位数字固定是1 第三组 12# 第一列是属主# 第一列是属组 第四组 1# 文件大小 第五组 1# 文件创建时间 第六组 1# 文件名 cp作用复制文件或目录 使用说明12345678910111213141516171819202122# 格式：cp [参数] 源文件 目标文件[root@zhima home]# cp file1 file2# 常用可选参数 # 若目标文件已存在，直接覆盖 -f, --force if an existing destination file cannot be opened, remove it and try again # 递归复制文件夹 -R, -r, --recursive copy directories recursively # 覆盖前询问 -i, --interactive prompt before overwrite # 详细显示复制过程 -v, --verbose explain what is being done # 建立硬链接 -l, --link hard link files instead of copying # 建立软链接（符号链接） -s, --symbolic-link make symbolic links instead of copying # 保留源文件或者目录的所有属性 -p same as --preserve=mode,ownership,timestamps # 当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 -d same as --no-dereference --preserve=links # 等同于 -p -d -r -a, --archive same as -dR --preserve=all 参考案例1234567891011121314# 将源文件file1复制到目标文件file2[root@zhima home]# lsfile1 temp university zhima[root@zhima home]# cp file1 file2[root@zhima home]# lsfile1 file2 temp university zhima# 将源文件file1复制到目标文件file2，如果存在file2，则拷贝一份[root@zhima home]# lsfile1 file2 temp university zhima[root@zhima home]# cp -b file1 file2cp: overwrite ‘file2’? y[root@zhima home]# lsfile1 file2 file2~ temp university zhima mkdir作用创建目录文件 使用说明123456789# 格式：mkdir [参数] 目录名[root@zhima home]# mkdir temp# 常用参数 # 创建目录的时候设置权限 -m, --mode=MODE set file mode (as in chmod) # 递归创建多级目录 -p, --parents no error if existing, make parent directories as needed # 显示创建过程 -v, --verbose print a message for each created directory 参考案例12345678910111213141516171819202122# 创建dir1、dir2两个目录文件[root@zhima home]# lsfile1 temp university zhima[root@zhima home]# mkdir dir1 dir2[root@zhima home]# lsdir1 dir2 file1 temp university zhima# 递归创建目录# 错误示范[root@zhima home]# mkdir a/b/c/dmkdir: cannot create directory ‘a/b/c/d’: No such file or directory# 正确示范[root@zhima home]# mkdir -p a/b/c/d[root@zhima home]# lsa dir1 dir2 file1 temp university zhima# 创建目录的时候指定权限[root@zhima home]# mkdir -m 700 dir3[root@zhima home]# ls -l# ...省略无关文件...drwx------ 2 root root 4096 Jan 8 11:32 dir3# ...省略无关文件... pwd作用显示当前工作目录 参考案例123# 显示当前工作目录[root@zhima c]# pwd/home/a/b/c mv作用移动文件或者重命名 使用说明1234567891011# 格式：mv [参数] 源文件 目标文件 # 覆盖前询问 -i, --interactive prompt before overwrite # 直接覆盖，不询问 -f, --force do not prompt before overwriting # 当文件存在时，覆盖前为其创建一个备份 -b like --backup but does not accept an argument # 当源文件比目标文件新或者目标文件不存在的时候才执行移动操作 -u, --update move only when the SOURCE file is newer than the destination file or when the destination file is missing 参考案例123456789101112131415161718# 将dir1重命名为dir4[root@zhima home]# lsa dir1 file1 temp university zhima[root@zhima home]# mv dir1 dir4[root@zhima home]# lsa dir4 file1 temp university zhima# 将file1移动到temp文件夹中[root@zhima home]# lsfile1 temp university zhima[root@zhima home]# mv file1 temp/[root@zhima home]# lstemp university zhima# 将/home/temp目录中的所有内容都复制到当前工作路径下，并且重命名为dir[root@zhima zhima]# mv -f /home/temp/ ./dir[root@zhima zhima]# lsnextcloud dir cd作用切换工作目录 Linux目录结构在Linux系统中，一切皆文件，下面是Linux系统中的目录结构 &#x2F;bin: bin是Binary的缩写，这个目录存放着最经常使用的命令 &#x2F;boot: 这里存放的是启动Linux的时候使用的一些核心文件（不要动） &#x2F;dev: dev是Device的缩写，存放的是Linux的外设设备， &#x2F;etc: 这个目录是用来存放所有的系统管理所需要的配置文件和子目录 &#x2F;home: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是使用用户的账号来命名的 &#x2F;lib: 这里存放着系统最基本的动态连接共享库（不要动） &#x2F;lost+found: 这个目录一般是空的，但是当服务器意外关闭的时候，里面会存在一些错误文件（不要动） &#x2F;media: Linux系统会自动识别一些设备，例如u盘，光驱等等 &#x2F;mnt: 这个目录是给用户来临时挂载别的文件系统的（后面会把本地文件挂载在这个目录下） &#x2F;opt: 给主机额外安装软件所在的目录 &#x2F;proc: 这是一个虚拟的目录，他是系统内存的映射，我们可以通过直接访问这个目录来获得系统信息（不用管） &#x2F;root（也就是 ~ ）: 该目录是系统管理员目录，也称作超级权限者的用户主目录 &#x2F;sbin: s就是super的意思，这里存放的是系统管理员使用的系统管理程序 &#x2F;srv: 该目录用来存放一些守护进程启动之后需要提取的数据 &#x2F;sys: 这是Linux2.6内核的一个很大的改变，该目录下安装了2.6内核中新出现的一个文件系统sysfs &#x2F;tmp: 这个目录使用来存放一些临时文件的 &#x2F;usr: 这个目录用来存放用户的应用程序和文件 &#x2F;usr&#x2F;bin: 系统用户使用的应用程序 &#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护进程 **&#x2F;usr&#x2F;src: ** 内核源代码默认存放的地址 &#x2F;var: 这个目录用来存放着一些不断在拓充的东西，习惯性的将一些经常修改的目录放在该目录下 &#x2F;run: 是一个临时文件系统，存储系统启动以来的信息，当系统重启时，该目录下的文件应该被删掉（不用管） &#x2F;www: 存放服务器网站的相关的资源，环境，网站 不是每一个目录都一定会存在 然后就是要知道这两个概念 决定路径 相对路径 绝对路径：指的是资源的全路径，比如D:\\APP\\Typora 相对路径：指的是资源在当前目录下的路径，比如我现在在D:\\APP目录下，我要定位到Typora这个目录，我可以直接使用Typora来表示该文件夹 使用说明12345678#进入根路径下的usr目录[root@iZbp18qscowpmxk6xpk38iZ /]#cd /usr#当前在根路径下，我要进入usr目录[root@iZbp18qscowpmxk6xpk38iZ /]#cd usr#返回上一级目录[root@iZbp18qscowpmxk6xpk38iZ usr]#cd ..","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"算法-遍历二维矩阵的各种花样","slug":"算法-遍历二维矩阵的各种花样","date":"2022-10-23T08:05:15.000Z","updated":"2023-03-06T06:45:09.780Z","comments":true,"path":"算法/技巧篇/2022/10/23/算法-遍历二维矩阵的各种花样/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/10/23/%E7%AE%97%E6%B3%95-%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E7%9A%84%E5%90%84%E7%A7%8D%E8%8A%B1%E6%A0%B7/","excerpt":"","text":"遍历二维矩阵的各种花样 PS：干货很多，建议分多次食用 常规遍历1# 输出以下序列: [1 2 3 4...15 16] 这个就是按行遍历即可 示例代码 123456int len = matrix.length;for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; System.out.print(matrix[i][j]+&quot; &quot;); &#125;&#125; 旋转遍历 PS：本遍历方法使用生成以下矩阵来讲述，生成会了，遍历自然也会了 示意图 遍历思路 12345# [0,0] [0,1] [0,2] [0,3] 👉向右# [0,4] [1,4] [2,4] [3,4] 👇向下# [4,4] [4,3] [4,2] [4,1] 👆向上# [4,0] [3,0] [2,0] [1,0] 👈向左# ...... 圈圈法第一个思路就是一圈一圈的遍历 将每一个圈拆为四个部分 第一个循环用来生成水平向左的数据 第二个循环用来生成垂直向下的数据 第三个循环用来生成水平向右的数据 第四个循环用来生成垂直向上的数据 流程图粉红色的是标注为每次大循环的开始处 PS：图片很多，过程很详细 示例代码123456789101112131415161718192021222324252627282930public int[][] rotateNumber(int n) &#123; int[][] matrix = new int[n][n]; int counter = 1; // n / 2即这个矩阵有几个圈 for (int i = 0; i &lt; n / 2; i++) &#123; // end即本次这个圈的宽-1 int end = n - i - 1; // → for (int j = i; j &lt; end; j++) &#123; matrix[i][j] = counter++; &#125; // ↓ for (int j = i; j &lt; end; j++) &#123; matrix[j][end] = counter++; &#125; // ← for (int j = end; j &gt; i; j--) &#123; matrix[end][j] = counter++; &#125; // ↑ for (int j = end; j &gt; i; j--) &#123; matrix[j][i] = counter++; &#125; &#125; // 如果是奇数，单独处理中间那一格数据 if (n % 2 != 0) &#123; matrix[n / 2][n / 2] = n * n; &#125; return matrix;&#125; 横平竖直法（推荐）这种方法是通过四个边界来辅助生成矩阵 四个边界的示意图 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243public int[][] rotateNumber(int n)&#123; // 用来存放生成的旋转数字矩阵 int[][] matrix = new int[n][n]; // 计数器 int counter = 1; // 上边界 int up = 0; // 下边界 int down = n-1; // 左边界 int left = 0; // 右边界 int right = n-1; // 当 counter 比 n * n 小就一直循环 while (counter &lt;= n * n) &#123; // 遍历上边界的那一行 for (int j = left; j &lt;= right; j++) &#123; matrix[up][j] = counter++; &#125; // 上边界向下移动一行 up++; // 遍历右边界的那一行 for (int i = up; i &lt;= down; i++) &#123; matrix[i][right] = counter++; &#125; // 右边界向左移动一行 right--; // 遍历下边界的那一行 for (int j = right; j &gt;= left; j--) &#123; matrix[down][j] = counter++; &#125; // 下边界向上移动一行 down--; // 遍历左边界的那一行 for (int i = down; i &gt;= up; i--) &#123; matrix[i][left] = counter++; &#125; // 左边界向右移动那一行 left++; &#125; // 返回结果数组 return matrix;&#125; 斜遍历1# 输出所有由左上向右下方向的对角线: [13 9 14 5 10 15 1 6 11 16 2 7 12 3 8 4] 偏移X法和往常一样遍历第一行，[0,0] [0,1] [0,2] [0,3] [0,4] 可以发现中间那个对角线是这一行向下偏移的结果，但是不同的位置在 X 方向上的偏移量是不一样的 遍历第二行[1,0] [1,1] [1,2] [1,3] [1,4] 可以看到和刚刚第一行一样，每一列向下偏移一定量就可以得到主对角线下面的那个对角线了 （这里先不要管越界的问题，先把思路理清楚，再在代码里面解决越界问题） 先写出遍历每一行的初始代码，然后我们在这个上面改造 12345for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; System.out.println(matrix[i][j]); &#125;&#125; 在遍历每一行的情况，向下偏移就是对角线了 每一列的偏移量都是不一样的，接下来要解决的就是如何算出每一列的偏移量 经过观察可以发现，当前这一列的偏移量就是当前的列值，那么就好办了直接用j就可以了 12345for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; System.out.println(matrix[i + j][j]); &#125;&#125; 现在还有一个问题，就是得到的对角线是部分不合法的，那么接下来就是如何截取合法的对角线部分 因为对角线是由每一行向下偏移而来，对角线越界的根本原因是每一行遍历多了 那么只要逐渐减少每一行的遍历长度即可，每一行少遍历 i 的长度即可 12345for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len - i; j++) &#123; System.out.println(matrix[i + j][j]); &#125;&#125; 完整示例代码 PS：注意右上角 123456789101112for (int i = len - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; len - i; j++) &#123; System.out.println(matrix[i + j][j]); &#125;&#125;for (int i = len - 2; i &gt;= 0; i--) &#123; for (int j = len - 1 - i; j &lt; len; j++) &#123; // 偏移量 int offset = len - 1 - j; System.out.println(matrix[i - offset][j]); &#125;&#125; 偏移Y法这个方法和偏移 X 法有异曲同工之妙 只不过从遍历每一行变成了遍历每一列 和刚刚一样，先写出遍历每一列 12345for (int j = 0; j &lt; len; j++) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.println(matrix[i][j]); &#125;&#125; 然后向右边偏移 12345for (int j = 0; j &lt; len; j++) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.println(matrix[i][j + i]); &#125;&#125; 对角线不合法，截取合法部分 12345for (int j = 0; j &lt; len; j++) &#123; for (int i = 0; i &lt; len - j; i++) &#123; System.out.println(matrix[i][j + i]); &#125;&#125; 完整示例代码 PS：注意左下角 1234567891011for (int j = 0; j &lt; len; j++) &#123; for (int i = len - 1 - j; i &lt; len; i++) &#123; int offset = len - 1 - i; System.out.println(matrix[i][j - offset]); &#125;&#125;for (int j = 1; j &lt; len; j++) &#123; for (int i = 0; i &lt; len - j; i++) &#123; System.out.println(matrix[i][i + j]); &#125;&#125; 偏移对角线法（推荐）可以发现偏移 X 法和偏移 Y 法都比较麻烦 所以我比较推荐这种方法，根据对角线来做偏移就会简单很多 从左上顶角到右下顶角的那条对角线如下[0,0] [1,1] [2,2] [3,3] @表示越界舍弃 整体往下偏移 1 位，就是[1,0] [2,1] [3,2] [4,3](@) 整体往下偏移 2 位，就是[2,0] [3,1] [4,2](@) [5,3](@) 整体往下偏移 3 位，就是[3,0] [4,1] [5,2](@) [6,3](@) 整体往上偏移 1 位，就是[-1,0](@) [0,1] [1,2] [2,3] 整体往上偏移 2 位，就是[-2,0](@) [-1,1](@) [-1,0][0,2] [1,3] 整体往上偏移 3 位，就是[-3,0](@) [-2,1](@) [-1,2](@) [0,3] 如何解决越界 既然完整的对角线偏移会出现越界，那就偏移部分的对角线不就行了 1234567891011121314151617181920212223int len = matrix.length;// 输出部分对角线，从完整开始逐渐变短for (int offset = 0; offset &lt; len; offset++) &#123; for (int i = 0; i &lt; len - offset; i++) &#123; System.out.println(matrix[i][i]); &#125;&#125;// 这时候输出的依次是// [0,0] [1,1] [2,2] [3,3] (offset=0)// [0,0] [1,1] [2,2] (offset=1)// [0,0] [1,1] (offset=2)// [0,0] (offset=3)// 那么只需要根据部分的对角线向下偏移即可for (int offset = 0; offset &lt; len; offset++) &#123; for (int i = 0; i &lt; len - offset; i++) &#123; System.out.println(matrix[i + offset][i]); &#125;&#125;// 这样的输出结果就是// [0,0] [1,1] [2,2] [3,3] (offset=0)// [1,0] [2,1] [3,2] (offset=1)// [2,0] [3,1] (offset=2)// [3,0] (offset=3) 在理解了上述的方法后，修改下来完成第一部分的遍历，即这一块的遍历 这个和刚刚不同的地方在于它的偏移量是从大到小的，上面那个理解了，这个应该也不难 1234567891011// [3,0]// [2,0] [3,1]// [1,0] [2,1] [3,2]// [0,0] [1,1] [2,2] [3,3]// offset是对角线在x方向的偏移量for (int offset = len - 1; offset &gt;= 0; offset--) &#123; for (int i = 0; i &lt; len - offset; i++) &#123; // 向下偏移 System.out.println(matrix[i + offset][i]); &#125;&#125; 完整示例代码123456789101112131415public void tiltPrint(int[][] matrix)&#123; int len = matrix.length; for (int offset = len - 1; offset &gt;= 0; offset--) &#123; for (int i = 0; i &lt; len - offset; i++) &#123; // 向下偏移 System.out.println(matrix[i + offset][i]); &#125; &#125; for (int offset = 1; offset &lt; len; offset++) &#123; for (int i = offset; i &lt; len; i++) &#123; // 向上偏移 System.out.println(matrix[i - offset][i]); &#125; &#125;&#125; 螺旋遍历1# 输出螺旋遍历顺序: [1 2 3 4 5 6 7 8 9 10 11 ... 21] 拆解法将这个路径拆解开 拆解如下 123# [0,0] -- [0,1] [1,0]# [2,0] [1,1] [0,2] --- [0,3] [1,2] [2,1] [3,0]# [4,0] [3,1] [2,2] [1,3] [0,4] --- [0,5] [1,4] [2,3] [3,2] [4,1] [5,0] 流程图粉红色的是标注为每次大循环的开始处 标注内层循环初始化的是该循环刚要开始时候的数据 PS：图片很多，过程很详细 示例代码12345678910111213141516171819202122232425// i记录了次数和每一次输出开始的点的row// 0 2 4for (int i = 0; i &lt; matrix.length; i+=2) &#123; // 第一个输出的数字的column坐标开头都是0 // [0,0][2,0][4,0] int j = 0; // 第一个内循环是左下角往右上角方向的 // k（row）从i自减 // j（column）自增到row到0 for (int k = i; k &gt;= 0; k--) &#123; System.out.print(matrix[k][j++]+&quot; &quot;); &#125; // 记录结束位置 int end=j; // 如果n是奇数，在最后一次大循环中就不会有这个小循环了 if(j &gt;= matrix.length)&#123; break; &#125; // 第二个内循环是右上角往左下角方向的 // k（row）从0开始自增到end // j（column）自减到k到end for (int k = 0; k &lt;= end; k++) &#123; System.out.print(matrix[k][j--]+&quot; &quot;); &#125;&#125; 连续法把这些路径当作是连续的 维护一个[rowIndex,columnIndex]来走这一条连续的路径 示例代码123456789101112131415161718192021int row = matrix.length;int column = matrix[0].length;int whole = row * column;int counter = 0;int rowIndex = 0;int columnIndex = 0;// 只要计数器比一半少，就说明还没走完while (counter &lt; whole / 2) &#123; while (rowIndex &gt;= 0) &#123; System.out.println(matrix[rowIndex--][columnIndex++]); counter++; &#125; // 复位 rowIndex = 0; while (columnIndex &gt;= 0) &#123; System.out.println(matrix[rowIndex++][columnIndex--]); counter++; &#125; // 复位 columnIndex = 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【37-Hard】解数独","slug":"【37-Hard】解数独","date":"2022-10-20T03:14:43.000Z","updated":"2023-03-06T06:46:27.181Z","comments":true,"path":"算法/刷题篇/2022/10/20/【37-Hard】解数独/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/10/20/%E3%80%9037-Hard%E3%80%91%E8%A7%A3%E6%95%B0%E7%8B%AC/","excerpt":"","text":"解数独编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1： 123输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 &#39;.&#39; 题目数据 保证 输入数独仅有一个解 Related Topics 数组 回溯 矩阵 回溯这里需要关注一下题目给的提示，我们来一一分析 第一条和第二条告诉我们，传入的数组是一个固定9 * 9的矩阵 第三条告诉我们&#39;.&#39;指的是空位 第四条告诉我们题目传入的数独只有一个答案，这就代表着我最后穷举出来解满足条件的只有一个 回溯三要素 1、路径：填上的数字，就是棋盘上的数字 2、选择列表：&#39;1&#39;-&#39;9&#39; 3、结束条件：穷举到最后一个格子（由第四条提示可得） 下面直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public void solveSudoku(char[][] board) &#123; // 辅助函数 solveSudoku(board,0,0); &#125; // 路径：已经被填上数字的棋盘，即row之前 // 对每一个格子的选择列表: 1 - 9 // 结束条件：穷举到最后一行 private boolean solveSudoku(char[][] board, int row, int column) &#123; // 返回true，结束递归 // 到了最后一行 if (row==board.length)&#123; return true; &#125; // 到了这一行的结尾了，换行 if (column==board[0].length)&#123; return solveSudoku(board,row+1,0); &#125; // 如果已经有数字了，直接下一列 // 因为给出的棋盘中有的格子中是有数字的 if (board[row][column]!=&#x27;.&#x27;)&#123; return solveSudoku(board,row,column+1); &#125; // 穷举 for (char ch = &#x27;1&#x27;; ch &lt;= &#x27;9&#x27;; ch++) &#123; // 如果要填写的数字不合法，直接跳过此次选择 if (!valid(board,row,column,ch))&#123; continue; &#125; // 做出选择 board[row][column] = ch; // 如果已经得到答案，直接结束穷举，返回true if(solveSudoku(board,row,column+1))&#123; return true; &#125; // 撤销选择 board[row][column] = &#x27;.&#x27;; &#125; // [row][column]这个格子填1-9都不合法，回退上一个格子，撤销上一次的选择 return false; &#125; // 判断要填入[row,column]的这个key是否符合规则 private boolean valid(char[][] board, int row, int column, char key) &#123; for (int i = 0; i &lt; board.length; i++) &#123; // 这一列不能有重复数字 if (board[i][column]==key)&#123; return false; &#125; // 这一行不能用重复数字 if (board[row][i]==key)&#123; return false; &#125; // 九宫格不能有重复数字 // 这里要斟酌一下的 if (board[(row / 3) * 3 + i / 3][(column / 3) * 3 + i % 3]==key)&#123; return false; &#125; &#125; return true; &#125;&#125; 我们来看下这个valid函数中判断九宫格内是否有重复数字的代码 123if (board[(row / 3) * 3 + i / 3][(column / 3) * 3 + i % 3]==key)&#123; return false;&#125; 12345row/3 可以将其映射到其对应的九宫格行column/3 可以将其映射到其对应的九宫格列i -&gt; [0,1,2,3,4,5,6,7,8]i/3 -&gt; [0,0,0,1,1,1,2,2,2]i%3 -&gt; [0,1,2,0,1,2,0,1,2] 进阶如果我将提示的第四条，即只有一个正确答案这个条件删除，那这道题该怎么做？ 其实也不难，只要改变结束条件即可，上述代码是直接将可以穷举到最后的答案返回 因为题目说了只有唯一解，所以我不需要再对其进行判断 既然删除了只有唯一解这个条件，那我就要对穷举到最后的答案进行验证 怎么验证呢，那就是验证每一行每一列对角线加起来都是一样的 12345678910111213141516171819202122232425262728293031private boolean valid(int[][] board)&#123; int sum = Arrays.stream(board[0]).sum(); int row = 0; int column = 0; int downCatercorner = 0; int upCatercorner = 0; // 计算行列和对角线的和 for (int i = 0; i &lt; board.length; i++) &#123; row = 0; for (int j = 0; j &lt; board[0].length; j++) &#123; row += board[i][j]; column += board[j][i]; // 从左上角到右下角的对角线 if (i==j)&#123; downCatercorner+=board[i][j]; &#125; // 从左下角到右上角的对角线 if (i+j==board.length-1)&#123; upCatercorner += board[i][j]; &#125; &#125; // 每一次循环中对比行和列的和 if (row!=sum||column!=sum)&#123; return false; &#125; row = 0; column=0; &#125; // 最后对比对角线的和 return downCatercorner == sum &amp;&amp; upCatercorner == sum;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【22-Medium】括号生成","slug":"【22-Medium】括号生成","date":"2022-10-18T12:44:00.000Z","updated":"2023-03-06T06:45:49.804Z","comments":true,"path":"算法/刷题篇/2022/10/18/【22-Medium】括号生成/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/10/18/%E3%80%9022-Medium%E3%80%91%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"","text":"括号生成数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 12输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;] 示例 2： 12输入：n = 1输出：[&quot;()&quot;] 提示： 1 &lt;= n &lt;= 8 Related Topics 字符串 动态规划 回溯 回溯直接穷举所有情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public List&lt;String&gt; generateParenthesis(int n) &#123; // 结果集 LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;(); // 路径 char[] track = new char[n * 2]; // 回溯 generateParenthesis(track, 0, res, n); return res;&#125;private void generateParenthesis(char[] track, int index, LinkedList&lt;String&gt; res, int n) &#123; // 走到头了 if (index == track.length) &#123; // 判断路径组成的字符串是否合法 if (isValid(track)) &#123; res.add(new String(track)); &#125; return; &#125; // 判断这次是否可以加入左括号 if (canAdd(track, index, LEFT_BRACKET)) &#123; track[index] = LEFT_BRACKET; generateParenthesis(track, index + 1, res, n); &#125; // 判断这次是否可以加入右括号 if (canAdd(track, index, RIGHT_BRACKET)) &#123; track[index] = RIGHT_BRACKET; generateParenthesis(track, index + 1, res, n); &#125;&#125;private boolean isValid(char[] sArray) &#123; // left为剩余多少左括号没有被匹配 int left = 0; for (int i = 0; i &lt; sArray.length; i++) &#123; char curr = sArray[i]; if (curr == LEFT_BRACKET) &#123; left++; &#125; else if (curr == RIGHT_BRACKET) &#123; left--; // 每出现一个右括号，就对应一个左括号被匹配 if (left &lt; 0) &#123; return false; &#125; &#125; &#125; // 如果全部匹配成功，说明合法 return left == 0;&#125;private boolean canAdd(char[] sArray, int index, char bracket) &#123; int left = 0; int right = 0; for (int i = 0; i &lt; index; i++) &#123; char curr = sArray[i]; if (curr == LEFT_BRACKET) &#123; left++; &#125; else if (curr == RIGHT_BRACKET) &#123; left--; right++; &#125; // 如果右括号数目已经比左括号多了，说明已经不合法了 if (right &gt; left) &#123; return false; &#125; &#125; if (bracket == RIGHT_BRACKET) &#123; right++; &#125; else &#123; left++; &#125; // 左括号数目比右括号多即可 return left &gt;= right;&#125; 这种方法的递归树会很大 原因在于修剪的力度不够大，canAdd只能判断当前的index位是否可以加入choice 但是无法保证最后生成的字符串是符合左右括号数目相等的 所以需要在满足推出条件的时候，再次判断是否符合左右括号数目一致 原因在于我无法根据已作出选择的左右括号数量来判断最后是否合法 换下思路，用左右括号的剩余数量就可以来判断最后是否合法，只要right&gt;=left即可 代码优化 12345678910111213141516171819202122232425262728293031323334353637383940public List&lt;String&gt; generateParenthesis(int n) &#123; LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;(); char[] track = new char[n * 2]; // index从0开始 // 还剩下n个左括号 // 还剩下n个右括号 // trace用来记录路径 // res用来收集结果 generateParenthesis(track, 0, n, n, res); return res;&#125;private void generateParenthesis(char[] track, int index, int leftBract, int rightBract, LinkedList&lt;String&gt; res) &#123; // 如果剩余的左括号个数小于0，说明左括号已经超标了 if (left &lt; 0)&#123; return; &#125; // 如果剩下的右括号比左括号少 // n = 5 // 剩下了4个左括号，1个右括号 ，这是错的情况 // 剩下了4个右括号，1个左括号 ，这是对的情况 // 剩下了3个右括号，3个左括号 ，这是对的情况 // 说明左括号多放了 if (rightBract &lt; leftBract) &#123; return; &#125; // 长度到达要，因为不符合要求的字符串已经被修剪 // 所以能走到这里的肯定是合法的字符串了 // 将其加入到结果集合中 if (index == track.length) &#123; res.add(new String(track)); return; &#125; // 选择左括号 track[index] = LEFT_BRACKET; generateParenthesis(track, index + 1, leftBract - 1, rightBract, res); // 选择右括号 track[index] = RIGHT_BRACKET; generateParenthesis(track, index + 1, leftBract, rightBract - 1, res);&#125; 这里给出优化后 n=2 的递归树 优化前的 n=2 的递归树 n=2 看不出优化后明显的增加修剪的力度 感兴趣的可以自己画一画 n=3 的递归树，你就会发现有很明显的区别","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"并发中Interrupt的相关知识","slug":"并发中Interrupt的相关知识","date":"2022-07-25T08:21:32.000Z","updated":"2023-01-13T03:24:38.359Z","comments":true,"path":"javaEE/JUC/2022/07/25/并发中Interrupt的相关知识/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/07/25/%E5%B9%B6%E5%8F%91%E4%B8%ADInterrupt%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Interruptinterrupt()是线程类的成员方法，作用是打断线程 与之有关的还有isInterrupted()和interrupted() interrupt()的作用是分情况的 当线程被join()、sleep()、wait()阻塞的时候 使用此方法，会设置打断标记为false，并且抛出异常InterruptedException 当线程正在运行的时候 使用此方法，会设置打断标记为true，但是不会影响线程继续运行 当线程使用LockSupport.park()挂起 使用此方法，会设置打断标记为true，但是不会抛出异常 Tips：在打断状态下，无法使用LockSupport.park()挂起当前线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Interrupts this thread. * * &lt;p&gt; Unless the current thread is interrupting itself, which is * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method * of this thread is invoked, which may cause a &#123;@link * SecurityException&#125; to be thrown. * * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125; * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;, * methods of this class, then its interrupt status will be cleared and it * will receive an &#123;@link InterruptedException&#125;. * * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125; * then the channel will be closed, the thread&#x27;s interrupt * status will be set, and the thread will receive a &#123;@link * java.nio.channels.ClosedByInterruptException&#125;. * * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125; * then the thread&#x27;s interrupt status will be set and it will return * immediately from the selection operation, possibly with a non-zero * value, just as if the selector&#x27;s &#123;@link * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked. * * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt * status will be set. &lt;/p&gt; * * &lt;p&gt; Interrupting a thread that is not alive need not have any effect. * * @throws SecurityException * if the current thread cannot modify this thread * * @revised 6.0 * @spec JSR-51 */public void interrupt() &#123; if (this != Thread.currentThread()) &#123; checkAccess(); // thread may be blocked in an I/O operation synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // set interrupt status b.interrupt(this); return; &#125; &#125; &#125; // set interrupt status interrupt0();&#125; isInterrupted此方法也是线程类的成员方法，作用是返回打断标记 12345678910111213141516/** * Tests whether this thread has been interrupted. The &lt;i&gt;interrupted * status&lt;/i&gt; of the thread is unaffected by this method. * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &#123;@code true&#125; if this thread has been interrupted; * &#123;@code false&#125; otherwise. * @see #interrupted() * @revised 6.0 */public boolean isInterrupted() &#123; return isInterrupted(false);&#125; interrupted此方法是Thread的静态方法，作用是重置当前运行线程的打断标记（就是将打断标记置为false），并返回之前的打断标记 1234567891011121314151617181920/** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &#123;@code true&#125; if the current thread has been interrupted; * &#123;@code false&#125; otherwise. * @see #isInterrupted() * @revised 6.0 */public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://li-zhi.net.cn/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Docker-基础","slug":"Docker-基础","date":"2022-07-13T10:18:52.000Z","updated":"2023-02-27T09:11:55.097Z","comments":true,"path":"javaEE/Docker/2022/07/13/Docker-基础/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Docker/2022/07/13/Docker-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Docker-基础回顾hello-world我们先来回顾一下hello-world的案例 下面是完整的流程图 12345678先在本地查找是否存在hello-world镜像 有则直接使用此镜像创建一个容器并运行 没有则连接镜像服务器查找是否存在hello-world镜像 如果在镜像服务器查找到了该镜像，则将该镜像下载到本地，然后建一个容器并运行 如果没有，则报错 下面介绍关于镜像和容器的命令 Docker镜像命令搜索镜像123456789101112131415[root@zhima ~]# docker search --help# 使用说明Usage: docker search [OPTIONS] TERM# 在docker hub上搜索TERM镜像Search the Docker Hub for images# 可选参数Options:# 过滤# 栗子 -f=STARS=3000意思的筛选出STARS大于3000的 -f, --filter filter Filter output based on conditions provided# 格式化输出，使用go语言的模板 --format string Pretty-print search using a Go template# 限制数量 --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output 拉取镜像1234567891011121314[root@zhima ~]# docker pull --helpUsage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 从仓库拉取一个镜像或者一个仓库Pull an image or a repository from a registry# 可选项Options:# 下载全部的版本 -a, --all-tags Download all tagged images in the repository# 跳过镜像认证，默认开启 --disable-content-trust Skip image verification (default true) --platform string Set platform if server is multi-platform capable# 跳过冗长的输出，等到下载结束后再输出镜像id -q, --quiet Suppress verbose output 查看本地镜像123456789101112131415161718[root@zhima ~]# docker images --helpUsage: docker images [OPTIONS] [REPOSITORY[:TAG]]# 列举镜像List imagesOptions:# 展示全部的镜像，默认添加 -a, --all Show all images (default hides intermediate images)# 显示完整的镜像id --digests Show digests# 过滤 -f, --filter filter Filter output based on conditions provided# 格式化输出 --format string Pretty-print images using a Go template --no-trunc Don&#x27;t truncate output# 只显示镜像简写id -q, --quiet Only show image IDs 删除本地镜像12345678910[root@zhima ~]# docker rmi --helpUsage: docker rmi [OPTIONS] IMAGE [IMAGE...]# 删除镜像Remove one or more imagesOptions:# 强制删除 -f, --force Force removal of the image --no-prune Do not delete untagged parents 查看镜像层级构建信息1234567891011121314[root@zhima ~]# docker history --helpUsage: docker history [OPTIONS] IMAGE# 展示镜像的历史（构建信息）Show the history of an imageOptions:# 格式化输出 --format string Pretty-print images using a Go template# 以可读化好的方式展示 -H, --human Print sizes and dates in human readable format (default true) --no-trunc Don&#x27;t truncate output# 只显示镜像id -q, --quiet Only show image IDs 打标签12345[root@zhima ~]# docker tag --helpUsage: docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]# 给SOURCE_IMAGE打上新的标签，并使用TARGET_IMAGE保存Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE Docker容器命令创建一个容器 这里因为可选项太多，我只放一些常用的 12345678910111213141516171819202122232425262728293031[root@zhima ~]# docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 创建并使用COMMAND运行一个容器Run a command in a new containerOptions:# 后台启动容器 -d, --detach Run container in background and print container ID# 保持标准输出流打开 -i, --interactive Keep STDIN open even if not attached# 挂载宿主机文件系统 --mount mount Attach a filesystem mount to the container# 指定容器名字 --name string Assign a name to the container# 指定容器所在网络 --network network Connect a container to a network# 给容器登录用户的特权 --privileged Give extended privileges to this container# 指定端口映射 -p 宿主机端口:容器暴露端口 -p, --publish list Publish a container&#x27;s port(s) to the host# 随机指定端口映射 -P, --publish-all Publish all exposed ports to random ports# 容器的根文件系统只读 --read-only Mount the container&#x27;s root filesystem as read only# 推出容器的时候，自动删除容器 --rm Automatically remove the container when it exits# 分配一个伪终端并绑定到容器的标准输入上 -t, --tty Allocate a pseudo-TTY# 数据卷，将容器内的目录挂载到宿主机的目录 -v, --volume list Bind mount a volume 12345678[root@zhima ~]# docker create --helpUsage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]# 创建一个容器，但是不运行Create a new containerOptions: # 与docker run 一致，这里不重复了 删除一个容器1234567891011[root@zhima ~]# docker rm --helpUsage: docker rm [OPTIONS] CONTAINER [CONTAINER...]# 删除一个或者多个容器Remove one or more containersOptions:# 强制删除，即使它在运行状态 -f, --force Force the removal of a running container (uses SIGKILL)# 删除挂载的宿主机目录 -v, --volumes Remove anonymous volumes associated with the container 查看容器12345678910111213141516171819202122[root@zhima ~]# docker ps --helpUsage: docker ps [OPTIONS]# 展示容器List containersOptions:# 展示所有的容器 -a, --all Show all containers (default shows just running)# 条件过滤 -f, --filter filter Filter output based on conditions provided# 格式化输出 --format string Pretty-print containers using a Go template# 控制显示个数，包括停止的容器 -n, --last int Show n last created containers (includes all states) (default -1)# 显示最近创建的容器，包括停止的容器 -l, --latest Show the latest created container (includes all states) --no-trunc Don&#x27;t truncate output# 只显示容器id -q, --quiet Only display container IDs# 显示容器占用内存 -s, --size Display total file sizes 停止容器123456789[root@zhima ~]# docker stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]# 停止一个或者多个容器Stop one or more running containersOptions:# 在ints后停止容器 -t, --time int Seconds to wait for stop before killing it (default 10) 运行容器1234567891011[root@zhima ~]# docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]# 启动一个或者多个已经停止的容器Start one or more stopped containersOptions:# 启动并进入容器 -a, --attach Attach STDOUT/STDERR and forward signals# 启动并进入容器的标准输出设备 -i, --interactive Attach container&#x27;s STDIN 重启容器12345678[root@zhima ~]# docker restart --helpUsage: docker restart [OPTIONS] CONTAINER [CONTAINER...]Restart one or more containersOptions: -t, --time int Seconds to wait for stop before killing the container (default 10) 暂停容器12345[root@zhima ~]# docker pause --helpUsage: docker pause CONTAINER [CONTAINER...]Pause all processes within one or more containers 取消暂停容器12345[root@zhima ~]# docker unpause --helpUsage: docker unpause CONTAINER [CONTAINER...]Unpause all processes within one or more containers 查看容器的源数据12345678910111213[root@zhima ~]# docker inspect --helpUsage: docker inspect [OPTIONS] NAME|ID [NAME|ID...]Return low-level information on Docker objectsOptions:# 格式化输出 -f, --format string Format the output using the given Go template# 展示容器的占用内存 -s, --size Display total file sizes if the type is container# 将JSON数据转化为特殊类型 --type string Return JSON for specified type 查看容器日志123456789101112131415[root@zhima ~]# docker logs --helpUsage: docker logs [OPTIONS] CONTAINERFetch the logs of a containerOptions:# 显示详细的数据 --details Show extra details provided to logs# 日志继续输出 -f, --follow Follow log output# 只展示尾部n条数据 -n, --tail string Number of lines to show from the end of the logs (default &quot;all&quot;)# 展示时间戳 -t, --timestamps Show timestamps 进入容器内部12345[root@zhima ~]# docker attach --helpUsage: docker attach [OPTIONS] CONTAINER# 直接进入容器当前正在运行的标准输出Attach local standard input, output, and error streams to a running container 12345678910111213141516171819[root@zhima ~]# docker exec --helpUsage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]# 在运行的容器中运行一个新的commandRun a command in a running containerOptions:# 在后台运行command -d, --detach Detached mode: run command in the background# 设置环境变量 -e, --env list Set environment variables# 读取文件中的环境变量 --env-file list Read in a file of environment variables# 保持输出流开启 -i, --interactive Keep STDIN open even if not attached# 给予此command登录用户的权力 --privileged Give extended privileges to the command# 分配一个伪终端 -t, --tty Allocate a pseudo-TTY 一般我们都会使用docker exec -it containerId|containerName /bin/bash进入容器 退出容器1234# 关闭当前的输出流，如果容器中没有其他输出流，容器就会自己关闭exit# 保持当前输出流开启Ctrl+p+q 如果容器中没有前台运行的command，则会自动关闭容器 查看容器开放端口12345[root@zhima ~]# docker port --helpUsage: docker port CONTAINER [PRIVATE_PORT[/PROTO]]List port mappings or a specific mapping for the container 查看容器内进程信息12345[root@zhima ~]# docker top --helpUsage: docker top CONTAINER [ps OPTIONS]Display the running processes of a container 宿主机和容器内的文件复制123456789101112131415[root@zhima ~]# docker cp --helpUsage: # 将容器内的文件复制到宿主机内docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-# 将宿主机中的文件复制到容器内docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATHCopy files/folders between a container and the local filesystemUse &#x27;-&#x27; as the source to read a tar archive from stdinand extract it to a directory destination in a container.Use &#x27;-&#x27; as the destination to stream a tar archive of acontainer source to stdout. 命令总结 镜像的理解什么是镜像镜像是一种轻量级、可执行的独立软件包 它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 镜像加载原理 UnionFS UnionFS (联合文件系统) 是一种分层、轻量级并且高性能的文件系统 它支持对文件系统的修改作为一次一次的提交做一层层的叠加 联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录 BootFS BootFS(Boot file system)主要包含Bootloader和Kernel Bootloader主要是引导加载Kernel内核，Linux刚启动时会加载Bootfs文件系统 当Bootloader加载完成之后整个内核就都在内存中了 此时内存的使用权已由Bootfs转交给内核，系统也会卸载BootFS RootFS RootFS (root file system) ，在Bootfs之上。包含的就是典型Linux系统中的&#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc等标准目录和文件。Rootfs就是各种不同的操作系统发行版,比如Ubuntu , Centos等等。 docker的centos镜像为什么那么小？ 对于一个精简的OS，RootFS可以很小，只包含一些最基本的命令、工具、库就可以了 当我们启动了一个容器，它底层可以直接使用宿主机已经加载好的Kernel 就不需要自己再虚拟一套环境，重新使用BootFS加载一个新的内核，大大节省了开销 Union 文件系统是Docker镜像的基础。 镜像可以通过分层来进行继承,基于基础镜像(没有父镜像) , 可以制作各种具体的应用镜像。 当我们拉取一个镜像 我们可以发现 该镜像是一层一层下载的而不是一整个下载的 这就符合了UnionFS的特性 前面几层是在我下载其他镜像的时候已经下载过了 就可以直接拿来使用，不需要再次下载，实现了资源共享，极大的节省了内存 查看镜像分层1docker image inspect imageId|imageName 特点Docker镜像都是只读的 当使用命令启动了一个新的容器的时候 该镜像先被复制 接着一个新的可写层被添加到该复制后的镜像的顶层 这一层就是容器层 所以当我们新建了一个容器后，如果想将本次修改后的容器打包成一个新的镜像，就需要使用docker commit命令 1234567891011[root@zhima volumes]# docker commit --helpUsage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container&#x27;s changesOptions: -a, --author string Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;) -c, --change list Apply Dockerfile instruction to the created image -m, --message string Commit message -p, --pause Pause container during commit (default true) 数据卷数据卷技术，说白了，其实就是文件的同步 我们创建了一个MySQL的容器，我们不对其做任何措施 如果我们误删除或者有人恶意删除了该容器 那么里面保存的数据也就随之丢失了 这是一件十分恶劣的事情 所以为了防止这种事情 我们就需要使用一种技术，将容器内保存数据的目录挂载到宿主机上 这种技术就是数据卷技术 使用这里我们部署一个MySQL来让大家明白如何使用卷技术 12345678910111213# -v 宿主机目录:容器内目录# -p 宿主机短裤:容器端口# -d 后台启动# -e 设置环境变量[root@zhima home]# docker run --name mysql01 -v /home/mysql:/usr/share/mysql -v /home/mysql/conf:/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd49309c0ab18 mysql &quot;docker-entrypoint.s…&quot; 6 seconds ago Up 4 seconds 33060/tcp, 0.0.0.0:49102-&gt;3306/tcp mysql01[root@zhima conf]# cd /home/mysql/data/[root@zhima data]# lsauto.cnf binlog.000002 ca-key.pem client-cert.pem #ib_16384_0.dblwr ib_buffer_pool ib_logfile0 ibtmp1 mysql performance_schema public_key.pem server-key.pem undo_001binlog.000001 binlog.index ca.pem client-key.pem #ib_16384_1.dblwr ibdata1 ib_logfile1 #innodb_temp mysql.ibd private_key.pem server-cert.pem sys undo_002 删除容器之后，宿主机中仍然保存着容器内的数据 12345[root@zhima data]# docker stop mysql01mysql01[root@zhima data]# lsauto.cnf binlog.000002 ca-key.pem client-cert.pem #ib_16384_0.dblwr ib_buffer_pool ib_logfile0 #innodb_temp mysql.ibd private_key.pem server-cert.pem sys undo_002binlog.000001 binlog.index ca.pem client-key.pem #ib_16384_1.dblwr ibdata1 ib_logfile1 mysql performance_schema public_key.pem server-key.pem undo_001 具名挂载和匿名挂载12345# 匿名挂载，我不指定宿主句的路径，指定容器内的路径[root@zhima home]# docker run --name mysql01 -v /usr/share/mysql -v /etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql# 具名挂载，我不指定宿主句的路径，但是指定一个名字，并指定容器内的路径[root@zhima home]# docker run --name mysql01 -v mysql_data:/usr/share/mysql -v mysql_config:/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql 不管是具名挂载还是匿名挂载都是docker自动在/var/lib/docker/volumes目录下创建文件夹 只不过具名挂载可以自己指定该文件夹的名字 数据卷容器如何做到多个容器间数据共享呢？ 那就需要使用数据卷容器技术，其实就是一个可选项，下面看使用 123[root@zhima home]# docker run --name mysql01 -v mysql_data:/usr/share/mysql -v mysql_config/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker run --name mysql02 --volumes-from mysql01 -p 49103:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker run --name mysql03 --volumes-from mysql01 -p 49103:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql mysql01就叫数据卷容器 mysql02、mysql03就会和mysql01的挂载是一样的 即mysql02和mysql03都和mysql01一样挂载到了宿主机的同个目录 /var/lib/docker/volumes/mysql_data和/var/lib/docker/volumes/mysql_cofig 对数据卷的操作12345678910111213# 对卷的操作[root@zhima etc]# docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes DockerfileDockerfile就是用来构建docker镜像的文件 1、Dockerfile中的保留关键词使用的时候都必须是大写 2、指令是从上到下执行的 3、#表示注释 4、每一个指令都会创建并提交一层镜像层 指令Dockerfile中的指令 指令 说明 FROM 说明镜像使用的基础镜像 MAINTAINER 设置镜像的作者 ADD 构建镜像的时候复制文件到容器内 COPY 构建镜像的时候复制文件到容器内 RUN 设置容器的启动命令 ONBUILD 设置镜像的ONBUILD指令 WORKDIR 设置运行RUN CMD ENTRYPOINT COPY ADD指令的工作目录 USER 设置运行RUN CMD ENTRYPOINT的用户名 STOPSIGNAL 设置容器退出的时候的信号量 ARG 设置编译镜像的时候加入的参数 LABEL 设置镜像的标签 CMD 编译镜像的时候运行的脚本 ENV 设置容器的环境变量 EXPOSE 设置镜像暴露的端口 ENTRYPOINT 设置容器的入口程序 VOLUME 设置容器的挂载卷 小试牛刀自己制作一个带网络配置和vim的centos镜像 123456789101112131415161718192021222324252627FROM centosMAINTAINER zhima&lt;1158778689@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATH# 下面三行RUN命令是为了解决以下这个错误的# Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlistRUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD [&quot;ls&quot;,&quot;-l&quot;]CMD /bin/bash 构建构建命令 12345678910111213[root@zhima home]# docker build --helpUsage: docker build [OPTIONS] PATH | URL | -Build an image from a DockerfileOptions:# Dockerfile的名字 -f, --file string Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)# 生成的镜像的标签 -t, --tag list Name and optionally a tag in the &#x27;name:tag&#x27; format docker build -f Dockerfile -t myImageName:tag ./ 构建镜像 1[root@zhima lizhi]# docker build -t mycentos:1.0 . 启动容器12[root@zhima lizhi]# docker run -it --name centos1 mycentos:1.0[root@49ea92e17942 local]# CMD和ENTRYPOINT我们来试一下构建这个Dockerfile，并运行 123FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;] 构建 12345678910[root@zhima lizhi]# docker build -t mycentos .Sending build context to Docker daemon 17.92kBStep 1/2 : FROM centos ---&gt; 5d0da3dc9764Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in a1e70a05d8ddRemoving intermediate container a1e70a05d8dd ---&gt; 00433fd4c299Successfully built 00433fd4c299Successfully tagged mycentos:latest 运行 123[root@zhima lizhi]# docker run -it --name &quot;centos1&quot; mycentos. .dockerenv dev home lib64 media opt root sbin sys usr.. bin etc lib lost+found mnt proc run srv tmp var 可以发现，进入容器之后，就执行了ls -a命令 我们尝试一下在启动的时候加入一些参数 12[root@zhima lizhi]# docker run -it --name &quot;centos2&quot; mycentos -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown. 我们发现容器并没有执行ls -al，而是直接报错了 其实这就是CMD的特性，当我在启动容器的时候添加了一个CMD后 镜像中定义的CMD就被覆盖掉了 单独的-l当然会报错了 我们来看一下使用ENTRYPOINT会怎么样 修改Dockerfile 123FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] 重新构建 12345678910[root@zhima lizhi]# docker build -t mycentos .Sending build context to Docker daemon 17.92kBStep 1/2 : FROM centos ---&gt; 5d0da3dc9764Step 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 22ef40dea625Removing intermediate container 22ef40dea625 ---&gt; 73a3d51b4d84Successfully built 73a3d51b4d84Successfully tagged mycentos:latest 运行容器 123456789101112131415161718192021222324[root@zhima lizhi]# docker run -it --name &quot;centos1&quot; mycentos -ltotal 56drwxr-xr-x 1 root root 4096 Jul 14 08:52 .drwxr-xr-x 1 root root 4096 Jul 14 08:52 ..-rwxr-xr-x 1 root root 0 Jul 14 08:52 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 2020 bin -&gt; usr/bindrwxr-xr-x 5 root root 360 Jul 14 08:52 devdrwxr-xr-x 1 root root 4096 Jul 14 08:52 etcdrwxr-xr-x 2 root root 4096 Nov 3 2020 homelrwxrwxrwx 1 root root 7 Nov 3 2020 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Sep 15 2021 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 2020 mediadrwxr-xr-x 2 root root 4096 Nov 3 2020 mntdrwxr-xr-x 2 root root 4096 Nov 3 2020 optdr-xr-xr-x 191 root root 0 Jul 14 08:52 procdr-xr-x--- 2 root root 4096 Sep 15 2021 rootdrwxr-xr-x 11 root root 4096 Sep 15 2021 runlrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 2020 srvdr-xr-xr-x 13 root root 0 Jan 29 10:27 sysdrwxrwxrwt 7 root root 4096 Sep 15 2021 tmpdrwxr-xr-x 12 root root 4096 Sep 15 2021 usrdrwxr-xr-x 20 root root 4096 Sep 15 2021 var 可以发现，容器执行的是ls -al，-l指令被追加给了ENTRYPOINT定义的语句","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"}]},{"title":"Docker-导言","slug":"Docker-导言","date":"2022-07-13T10:18:48.000Z","updated":"2023-02-25T09:15:18.505Z","comments":true,"path":"javaEE/Docker/2022/07/13/Docker-导言/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Docker/2022/07/13/Docker-%E5%AF%BC%E8%A8%80/","excerpt":"","text":"Docker-导言Docker出现的原因每一款产品的出示都是为了解决一些痛点问题 相信我们都经历过这种场景 我们的项目在本地跑起来一点毛病都没有 开心地将jar包分享给同学 过了一会，同学一脸嫌弃地找你去看他在服务器上运行后齐刷刷的报错信息，觉得你写的代码不行，跑都跑不起来 看了报错，发现他没有安装redis，没有安装es，没有安装mysql等等软件 这时候就很无奈了，只能帮其一步步进行安装，进行配置 安装完成后，可能还要调一堆的bug，浪费了大量的时间 我们现在的结构是(Linux + jar + Redis环境 + ES环境 + Mysql环境… ) 这就会导致上面出现的问题，就算他早就安装了这些软件，如果版本和你使用的不一致，那么也有可能报错 这时候，就希望有样东西可以帮我们解决这个问题 那么这个东西就是Docker 在使用Docker之后，结构就变成了(Linux+（jar + Redis环境 + ES环境 + Mysql环境… ）) 将jar包和环境一起打包，就不会出现开头出现的问题啦 下面让我们来学习Docker吧 认识Docker传统运行应用 所有的应用都是跑在同一个宿主机上 使用共同的类库（Lib） 所以请你想象这种场景： APP1(将其比作放射物质)+APP2(将其比作食物) 那么这种情况下，APP2会被APP1破坏 如果有些应用又依赖APP1，那么就会牵扯很多应用无故躺枪 导致Linux大环境牵连受损，很难处理 当我们使用了Docker技术之后 所有的应用都是在Docker的管理下运行的 这里的应用就要换个名字了，叫容器 每一个容器都有一套自己的环境，并且不会受到其他容器环境的影响，容器之间是相互隔绝的 就算有两个水火不容的应用出现在了同一个容器中，也不会影响到其他容器的环境 下面看一下Docker官方给出的一张体系架构图 优势传统虚拟机技术 VS Docker容器技术 虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的 Docker比虚拟机有更少的抽象层，不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源 而虚拟机加载GuestOs是分钟级启动的 docker利用的是宿主机的内核，而不需要Guest OS。 因此，Docker通过镜像新建一个容器的时候，不需要像虚拟机一样重新加载一个虚拟机内核 我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。 而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。 另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的 所以docker对比虚拟机在资源消耗上也占有比较大的优势。 在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机 安装Docker123456789101112131415161718192021222324252627282930313233#卸载之前的Dockersudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#下载需要的安装包sudo yum install -y yum-utils#设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https:\\\\download.docker.com\\linux\\centos\\docker-ce.repo#默认是国外的 sudo yum-config-manager \\ --add-repo \\ https:\\\\mirrors.aliyun.com\\docker-ce\\linux\\centos\\docker-ce.repo#阿里云的 # 更新yum软件包索引sudo yum makecache fast#安装Docker引擎 docker-ce docker-ee sudo yum install docker-ce docker-ce-cli containerd.io#启动docker sudo systemctl start docker #测试是否启动成功docker version 如果你购买了阿里云、百度云、腾讯云的服务器，可以配置一个容器镜像加速 这个镜像加速走的是服务器内网，写我的也没有用哦 卸载Docker123456#卸载docker依赖sudo yum remove docker-ce docker-ce-cli containerd.io#删除资源sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-07-09T03:19:07.000Z","updated":"2023-01-27T03:54:43.227Z","comments":true,"path":"琐碎的知识/2022/07/09/正则表达式/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式前言相信大家对正则的态度就是 但是当每次在需要做校验或者的时候，都会十分狼狈的去百度，去CSDN 将找到的正则表达式直接copy过来，也不会去看里面写的啥 直接就信心满满的去运行 然后就要么报错，要么啥也没匹配到 看别人写的java代码，我们是痛苦的 看别人写的正则表达式，我们感受不到痛苦，是绝望的，直接放弃了 实在受不了这种任人宰割的感觉，所以就花了几天彻彻底底地将正则学了一遍 最真实地感觉就是，正则不简单，得把它当作一种语言去学 这样才可以拿出态度去接受它 下面是学习笔记 介绍正则表达式是由普通字符（如英文字母）以及特殊字符（也称为元字符）组成的文字模式 该模式对文本查找时需要匹配的一个或多个字符串描述，给出一个匹配模板。 它可以大大简化文本识别工作，现已超出了某种语言或某个系统的局限，成为被人们广为使用的工具。 先给大家介绍一个在线检测正则表达式的网站，十分好用！ 链接如下：https://regex101.com 声明：以下我使用的某些概念在不同网站上，不同视频中，都会有不同的叫法，我会尽量将所有的讲法都标注 修饰符下面在开始正题之前，我要先给大家讲一个修饰符的概念。 我自己在学这个的时候，没有哪一个视频或者教程会将修饰符放到最前面 但是在我学下来，我觉得如果将这个知识点放在最前面，而且这个知识点也不难，只是一个概念 这可能会有利于大家的学习，所以我就尝试将此知识点前置 在正则表达式中有很多修饰符 我们只看常用的四个 大家注意这个地方，这个地方显示的就是当前开启的修饰符 global 可以看到这其中的区别就是 非全局模式只匹配了第一个匹配成功的 而全局模式则匹配了所有匹配成功的 multi line这里只演示^的情况 这里要有个前置知识，就是 ^匹配文本开头 $匹配文本结尾 我们都知道文本只有一个开头和一个结尾 但是开启了multi line之后 ^不仅可以匹配文本开头而且可以匹配行首 $不仅可以匹配文本结尾而且可以匹配行尾 single line 这里也需要有前置知识 .可以匹配除了\\n之外的所有字符 开启了single line之后 .可以匹配所有的字符，包括\\n insensitive 该修饰符就是关闭大小写敏感 即a和A是一样的 简单匹配固定字符串假如我要在下列文本中匹配export字符串，我们可以这么写 这就是对固定字符串的匹配，这很简单 范围字符 又叫元字符 在正则表达式中，我们有以下表示一定范围的字符 符号 名称 . 匹配除 \\n 以外的任何一个字符 \\d 匹配单个数字字符，相当于[0-9] \\D 匹配单个非数字字符，相当于[^0-9] \\w 匹配单个数字、大小写字母、下划线字符，相当于[0-9a-zA-Z_] \\W 匹配单个非数字、非大小写字母字符，非下划线，相当于[^0-9a-zA-Z_] \\s 匹配任意一个\\n、空格、tab \\S 与\\s匹配的相反 \\b 匹配每一个单词的前和后 \\B 与\\b匹配的相反 注意：一个范围字符只可以匹配一个属于该范围的字符 ​ 一个！一个！一个！ ​ 输入.发现除了\\n全亮了是因为开启了global修饰符！ 这里没什么好说的，背下，下面给一张图帮助记忆 自定义范围字符对于十六进制的颜色，#后面只能出现数字和a-f的字符 我们发现内置的这些范围字符都不太好用 这时候就需要使用自定义范围字符 想要定义自定义范围字符，就需要使用[] 下面我们来写匹配十六进制的自定义范围字符 自己写全 [0123456789abcdef] 使用-连接符 [0-9a-f] []还有几种写法，我们使用案例来说明 栗一数据如下，匹配80年代和90年代以外的 123456姓名 生日芝麻 2001-05-22章一 1993-08-09沈家怡 1999-05-22陆力丹 1989-02-19王子怡 2002-12-15 在[]内部的开头写^表示匹配除了方括号里面出现的字符 栗二匹配特殊字符^或者$或者. 但是小伙伴可能写的顺序不是这样的，你可能是这样写的[^$.] 这里如果^放在第一位，他就会使用栗一种的功能 如果我就是想要用这种顺序写，但是还想匹配^特殊字符本身，可不可以呢？ 当然可以啦，这里需要使用转义字符\\登场了 栗三这个案例就有点难了，我们来匹配正确的车牌号，匹配规则如下 普通车牌特征： 第1位是表籍贯的汉字 第2位是表城市的大写字母，不包括I和O。因为容易和数字0和1混淆 后5位是字母加数字，也不包括I和O 测试数据如下 1234567891011121314湘C4ASF7湘G9AWSE湘O392LEY鲁E2S1EF湘D219U5湘AS2BKN皖91L2IZ鲁I0H8F鲁R10Y2FA湘1R9GJ3鲁REF02H鲁2319G7鲁3RGN90N鲁23G90K 基本逻辑控制在正则表达式中只有且和或这两种逻辑关系，我们这里用一个案例来引出或 匹配规则：匹配所有的http状态码 401：未授权 403：无权限访问 404：找不到资源 500：服务内部错误 测试数据如下 1234567891011121314404500309403230401400234325401923482340325 那且呢？ 其实我们早就使用过且了 就比如我们这个案例中，404不就是且么？ 4并且0并且4 这三个数字同时满足，才匹配出来404 数量控制我们回顾一下之前的匹配十六进制颜色的案例 测试数据如下： 12345678910111213.el-header &#123; background-color: #BC0D13 color: #CCCCCC line-height: 60px;&#125;.el-aside &#123; color: #5fe3a1&#125;.active &#123; background-color: #0086b3;&#125; &#123;&#125;就是数量控制的语法，我们来看看不使用数量控制的时候应该怎么写 &#123;n&#125; 指定出现固定次数 &#123;n,&#125; 指定至少出现n次 &#123;n,m&#125; 指定出现n到m次 简写形式 符号 等价 * &#123;0,&#125; + &#123;1,&#125; ? &#123;0,1&#125; 懒惰匹配和贪婪匹配该知识点我们配合案例来食用 匹配所有的span标签 测试数据 1&lt;span&gt;span1&lt;/span&gt;kongge&lt;span&gt;span2&lt;/span&gt; 我们先来尝试一下 我们发现，它竟然全匹配了，这是为什么呢？ 解释 +会尽量一直往后匹配，一直到无法匹配.为止 本来匹配到span1后面的&lt;符号的时候，就可以停止匹配了 但是因为默认开启的是贪婪匹配，啥意思呢？ 就是&lt;还是符合.的吧，那就继续匹配 直到匹配到span2后面的&lt;的时候，发现如果再匹配span2后面的&lt;了 那么我们正则表达式中最后的&lt;/span&gt;就没法匹配了，所以.就匹配到span2中的2为止 那让我们开启懒惰模式看看结果 解释 +会尽量一直往后匹配，一直到无法匹配为止 匹配到span1后面的&lt;符号的时候 发现其实这个&lt;已经可以匹配正则最后的&lt;了 那就结束匹配吧，所以就匹配出了第一组span标签 注意点： 开启懒惰模式中的?和我们在数量控制中的?是不一样的 懒惰模式中的?只能写在数量控制&#123;&#125;后面 数量控制&#123;&#125;只可以写在范围字符后面[a-f]或者\\d这种 这里需要好好理解一下 删除所有的HTML注释测试数据如下 有三种注释哦 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;!-- &lt;div&gt;&lt;/div&gt;--&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;test&quot;/&gt; &lt;!-- &#123;&#123;test&#125;&#125; --&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; test: &#x27;&#x27; &#125;, /* methods: &#123; &#125;,*/ watch: &#123; test: &#123; handler: function (newData,oldData) &#123; console.log(newData); console.log(oldData); &#125;, // immediate: true &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 进阶分组分组指将匹配的内容，使用()划分成多个组块，分好的组可用于在匹配后提取、反向引用以及替换操作。 下面使用两个案例来做说明 提取信息转sql什么意思呢？就是将提取出来的数据转化为DML语句 栗：insert into user(name,age,sex,birthday) values(&#39;芝麻&#39;,&#39;19&#39;,&#39;男&#39;,&#39;2001-05-22&#39;) 测试数据如下 12345芝麻 2001/05/22 19岁 男章一 1993-08-09 20岁 女沈家怡 1999.05.22 21岁 女陆力丹 1989-02-19 19岁 男王子怡 2002-12-15 19岁 男 $组号可以拿到括号中匹配的内容 匹配正确的自闭和标签测试数据如下 1234567&lt;span&gt;span1&lt;/span&gt;&lt;h2&gt;h22&lt;/h2&gt;&lt;h2&gt;h23&lt;/h3&gt;&lt;h3&gt;h32&lt;/h2&gt;&lt;h1&gt;h11&lt;/h1&gt;&lt;div&gt;d iv1&lt;/div&gt;&lt;span&gt;wrong&lt;/dspan&gt; 在正则表达式中使用\\组号来反向引用前面匹配的组 $0表示整个匹配的字符串 注意反向引用只用在表达式中引用之前的分组 匹配所有的JavaScript中的字符串JavaScript中有三种字符串 1231、&#x27;&#x27;2、&quot;&quot;3、`` 测试文本 12345678910111213141516171819const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const server = http.createServer();server.on(&quot;request&quot;,(req,resp)=&gt;&#123; let url = req.url; if(url===&#x27;/favicon.ico&#x27;)&#123; resp.end(); return; &#125; resp.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); console.log(`访问的网址的$&#123;url&#125;，访问方法是$&#123;req.method&#125;`); let data = fs.readFileSync(path.join(__dirname,url)); resp.end(data);&#125;)server.listen(&#x27;80&#x27;,()=&gt;&#123; console.log(&#x27;服务启动\\&quot;成功\\&quot;，80端口&#x27;);&#125;) 下面做个拓展分组还有以下四种情况 ?&lt;名称&gt;命名分组 (?:)移除分组 (())嵌套分组 (\\d)+分组中使用量词 命名分组默认情况下通过组号来取值，此外也可以自定义命名组，语法是(?&lt;名称&gt; ) 然后在程序中就可以通过&lt;&gt;中的名称来取值。 如：&lt;(?&lt;title&gt;(\\S+?))&gt;.*&lt;\\/\\1&gt; 该表达式就命名了一个title的组，在js的结果中就可通过title属性取值。 注意： 这种命名组只能用于在程序中提取操作，不能进行反向引用，也不能用在替换操作中。 也正因为这种局限性所以命名组使用的很少。 移除分组()即用于子表达式，同时也是一个分组。 如果只想用作子表达式，而不想用于分组就可以使用(?: )从分组列表中移除。 比如(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;) 该表达式就只存在两个组，月$1和日$2。 嵌套分组比如：((\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)) 其组号的命名顺序是以开括号出现顺序为准。 $1指的是一个整体 $2指的是年 $3指的是月 $4指的是日 按照(的顺序进行编组 大小写转换在Idea、VS Code、Sublime、Notepad++等工具进行替换操作时，还可以使用下表中操作符进行大小写转换 操作符 描述 \\u 单个转大写 转换下一个字符为大写 \\U 全部转大写 转换\\U后所有字符转大写 \\U…\\E 区间转大写 \\U与\\E区间的内容转大写 \\l 单个转小写 转换一下个字符为小写 \\L 全部转小写 转换\\L后所有字符转小写 \\L…\\E 区间转小写 \\L与\\U区间的内容转小写 边界断言介绍是边界断言让正则表达式有了条件判断的能力 先来看个栗子感受一下 匹配所以姓名，不能带着表头中的姓名 测试数据 123456姓名 生日 年龄 性别芝麻 2001/05/22 19岁 男章一 1993-08-09 20岁 女沈家怡 1999.05.22 21岁 女陆力丹 1989-02-19 19岁 男王子怡 2002-12-15 19岁 男 这里面的(?!)就是前置否定断言 在断言这里，网上的，视频的教程对其的称呼真的是层出不穷， 表达式 环视 预查 边界断言 零宽断言 (?= ) 向前肯定环视 正向肯定预查 边界前置肯定断言 零宽度正预测先行断言 (?! ) 向前否定环视 正向否定预查 边界前置否定断言 零宽度负预测先行断言 (?&lt;= ) 向后肯定环视 反向肯定预查 边界后置肯定断言 零宽度正回顾后发断言 (?&lt;! ) 向后否定环视 反向否定预查 边界后置否定断言 零宽度负回顾后发断言 管他叫什么呢，反正我们只要知道它是断言，然后怎么使用就行了 这里只需要四组图就可以记住这四个断言的作用了 (?=芝)就是芝前面的那个地方 (?!芝)就是除了芝前面地方的其他所有地方 (?=芝)就是芝后面的那个地方 (?!芝)就是除了芝后面地方的其他所有地方 虽然案例很简陋，但是只要理解了这四句话，边界断言就轻轻松松拿下 匹配错误的十六进制颜色测试数据如下 正确的16进制颜色规则 1、#开头 2、6个16进制数字或者3个 12345678#BC0D13#a3e32d#a656e3#e00#91e376#assdas##14e3ce 实现这种题目的步骤就是 先找到符合要求的16进制颜色 然后使用向前否定环视 即可找到不符合要求的16进制颜色 找出所有符合条件的密码 密码长度是8-20位 大小写字母以及数字必须都有一个。 测试数据 12345678e3c3d2D322386e374W2e3a34fDas213498h94DIOJ239830239ur23u90asdasasd5fe362IKds2ab93Fbf45bbaSd9 提取JavaScript中的合法变量名测试数据 12345678910111213141516171819const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const 1server = http.createServer();server.on(&#x27;request&#x27;,(req,resp)=&gt;&#123; var url = req.url; if(url===&#x27;/favicon.ico&#x27;)&#123; resp.end(); return; &#125; resp.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); console.log(`访问的网址的$&#123;url&#125;，访问方法是$&#123;req.method&#125;`); let _data = fs.readFileSync(path.join(__dirname,url)); resp.end(data);&#125;)server.listen(&#x27;80&#x27;,()=&gt;&#123; console.log(&#x27;服务启动成功，80端口&#x27;);&#125;) 添加千分号每三位加入一个,做分割 测试数据 12345671234997813241230981240941270491277124091247014387413129932908723451972 JAVA中的正则java.util.regex 是一个用正则表达式所定制的模式来对字符串进行匹配工作的类库包 它主要包括两个类：Pattern 和 Matcher 。 Pattern： 一个 Pattern 是一个正则表达式经编译后的表现模式。 Matcher：一个 Matcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 首先一个 Pattern 实例定制了一个所用语法与 PERL 类似的正则表达式经编译后的模式 然后一个 Matcher 实例在这个给定的 Pattern 实例的模式控制下进行字符串匹配后的后续工作，比如替换啊 PatternPattern 的主要方法如下 方法名称 解释 static Pattern compile(String regex) 将给定的正则表达式编译并赋予给 Pattern 类 static Pattern compile(String regex, int flags) 对指定字符串的截取，参数配置如下 int flags() 返回当前 Pattern 的匹配 flag 参数 Matcher matcher(CharSequence input) 生成一个给定命名的 Matcher 对象 static boolean matches(String regex, CharSequence input) 编译给定的正则表达式并对输入的字串以该正则表达式为模开展匹配 String pattern() 返回该Patter对象所编译的正则表达式 一个正则表达式，也就是一串有特定意义的字符 可以首先要编译成为一个 Pattern 类的实例 这个 Pattern 对象可以使用 matcher(String str) 方法来生成一个 Matcher 实例 接着便可以使用该 Matcher 实例对目标字符串进行匹配后的后续工作 现在我们先来看一个简单的例子 123456789101112// 生成一个 Pattern，同时编译一个正则表达式Pattern p = Pattern.compile(&quot;[/\\\\]+&quot;);//用 Pattern 的 split() 方法把字符串按 &quot;/&quot; 和 &quot;\\&quot;分割String[] result = p.split( &quot;Kevin has seen《LEON》seveal times,because it is a good film.&quot; +&quot;/ 凯文已经看过《这个杀手不太冷》几次了\\因为它是一部&quot; +&quot;好电影。/名词:凯文。&quot;);for (int i = 0; i &lt; result.length; i++)&#123; System.out.println(result[i]);&#125; 上述代码的运行结果为： Kevin has seen《LEON》seveal times,because it is a good film.凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。名词:凯文。 MatcherMatcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 例：下面是一个对单词 dog 出现在输入字符串中出现次数进行计数的例子： 123456789101112String regex = &quot;\\\\bdog\\\\b&quot;;String input = &quot;dog dog dogtie&quot;;Pattern p = Pattern.compile(regex);Matcher m = p.matcher(input); // 获取 matcher 对象int count = 0;while (m.find()) &#123; count++; System.out.println(&quot;Match number &quot; + count); System.out.println(&quot;start(): &quot; + m.start()); System.out.println(&quot;end(): &quot; + m.end());&#125; 上述代码的执行结果为： Match number 1 &#x2F;&#x2F; 第一次出现 （下标 0-2）start(): 0 &#x2F;&#x2F; 开始下标 0end(): 3 &#x2F;&#x2F; 结束下标 3Match number 2 &#x2F;&#x2F; 第二次出现（下标 4-6）start(): 4 &#x2F;&#x2F; 开始下标 4end(): 7 &#x2F;&#x2F; 结束下标 7 dogtie中的dog没有被匹配是因为我们要的是单独的单词dog而不是在其他单词中的dog matches 和 lookingAt 这两个方法都用来尝试匹配一个输入序列模式。 它们的不同是 matches 要求整个序列都匹配 而lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。 1234567891011String regex = &quot;foo&quot;;String input = &quot;fooooooooooooooooo&quot;;String input2 = &quot;ooooofoooooooooooo&quot;;Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(input);Matcher matcher2 = pattern.matcher(input2);System.out.println(&quot;lookingAt(): &quot; + matcher.lookingAt());System.out.println(&quot;matches(): &quot; + matcher.matches());System.out.println(&quot;lookingAt(): &quot; + matcher2.lookingAt()); 上述代码的执行结果为： lookingAt(): truematches(): falselookingAt(): false replaceFirst 和 replaceAll 这两个方法用来替换匹配正则表达式的文本。 不同的是，replaceFirst 只会替换第一次匹配 replaceAll 替换所有匹配。 下面的例子来解释这个功能： 123456789101112131415String regex = &quot;dog&quot;;String input1 = &quot;The dog says meow. All dogs say meow.&quot;;String input2 = &quot;The dog says meow. All dogs say meow.&quot;;String replace = &quot;cat&quot;;Pattern p = Pattern.compile(regex);Matcher m1 = p.matcher(input1);Matcher m2 = p.matcher(input2);input1 = m1.replaceAll(replace);input2 = m2.replaceFirst(replace);System.out.println(input1);System.out.println(input2); 上述代码的执行结果为： The cat says meow. All cats say meow.The cat says meow. All dogs say meow. 从上面的结果，我们可以发现，replaceFirst 方法只将第一个 dog 替换成了 cat。而 replaceAll 方法却将两个 dog 都替换成了 cat。 好啦，结束了 正则差不多就这些内容了 如果你发现了错误 望留言批评指正！","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Vue2-基础5","slug":"Vue2-基础5","date":"2022-06-30T23:45:18.000Z","updated":"2022-09-27T13:58:04.332Z","comments":true,"path":"前端/Vue2/2022/07/01/Vue2-基础5/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/07/01/Vue2-%E5%9F%BA%E7%A1%805/","excerpt":"","text":"Vue2-基础5动画效果在隐藏元素之前执行一段动画 在显示元素之前显示一段动画 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;show=!show&quot;&gt;显示/隐藏&lt;/button&gt; &lt;transition name=&quot;come&quot; appear&gt; &lt;h2 v-show=&quot;show&quot;&gt;Hello，World！&lt;/h2&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Test&quot;, data()&#123; return &#123; show: true &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.come-enter-active &#123; animation: move 1s linear;&#125;.come-leave-active &#123; animation: move 1s linear reverse;&#125;@keyframes move &#123; from &#123; transform: translateX(-100%); &#125; to &#123; transform: translateX(0px); &#125;&#125;h2 &#123; background: greenyellow; width: 300px&#125;&lt;/style&gt; 过渡效果1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;show = !isShow&quot;&gt;显示/隐藏&lt;/button&gt; &lt;transition-group name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;!show&quot; key=&quot;1&quot;&gt;Hello！&lt;/h1&gt; &lt;h1 v-show=&quot;show&quot; key=&quot;2&quot;&gt;World!&lt;/h1&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Test&#x27;, data() &#123; return &#123; show:true &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; h1&#123; background-color: orange; &#125; /* 进入的起点、离开的终点 */ .hello-enter,.hello-leave-to&#123; transform: translateX(-100%); &#125; .hello-enter-active,.hello-leave-active&#123; transition: 0.5s linear; &#125; /* 进入的终点、离开的起点 */ .hello-enter-to,.hello-leave&#123; transform: translateX(0); &#125;&lt;/style&gt; 配置代理发起网络请求我们有以下四种方式 12341.xhr window上的对象，原生2.jQuery 内置了ajax请求，但是本身注重的是DOM节点操作3.axios 封装了chr，十分轻量，promise风格4.fetch window上的对象，原生，包装了两层promise 这里我们使用axios来做网络请求 1npm i axios CORS(Cross-Origin Resource Sharing ) 前端中发出ajax请求的时候经常会出现的一种错误，叫做跨域请求 这是因为违背了同源策略 1、同协议 2、主机名 3、端口号 解决方案 1、后端返回数据的时候，加上一些特殊的响应头即可 2、配置代理服务器 服务器之间互相访问是不受同源策略的限制的 所以我们可以配置一个和我们自己的端口号一致的代理服务器 将请求转发给它 让它去请求其他端口上的服务器得到数据后再将其返回 我们可以使用nginx或者借助vue-cli来配置一个代理服务器 这里我们借助vue-cli 开启代理服务器（方式一） 12345module.exports = &#123; devServer: &#123; proxy: &#x27;http://localhost:5000&#x27; &#125;, &#125; 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 开启代理服务器（方式二） 12345678910111213141516module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/hello&#x27;: &#123; target: &#x27;http://localhost:5000&#x27;, // ws: true, //用于支持websocket // changeOrigin: true //用于控制请求头中的host值 &#125;, &#x27;/demo&#x27;: &#123; target: &#x27;http://localhost:5001&#x27;, // ws: true, //用于支持websocket // changeOrigin: true //用于控制请求头中的host值 &#125; &#125; &#125;&#125; 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 。 默认插槽父组件： 123&lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt;&lt;/Category&gt; 子组件： 123456&lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽父组件： 123456789&lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt;&lt;/Category&gt; 子组件： 1234567&lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽作用：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。 父组件： 123456789101112131415&lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt;&lt;/Category&gt; 子组件： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125;&lt;/script&gt; 路由每一个Vue的大型项目都会用到路由，所以这部分十分重要 无路由，无SPA应用 我们回顾一下以前写的web应用的结构 1234- index.html- user.html- pay.html- category.html 然后每个页面中又有链接可以实现互相跳转，这就是典型的多页面应用 SPA应用（Single page web application）：单页面应用 只要点击侧边栏的目录，功能区就会切换到特定的页面，不会刷新页面，实现局部刷新，这就是单页面应用 路由就是用来实现这个切换，路由器就是用来管理这些路由的 概念路由就是一组key-value的对应关系 多个路由，由一个路由器统一管理 路由分类 后端路由 key就是路径 value就是函数，函数返回对这次请求响应的数据 前端路由 key就是理解 value就是组件，什么样的路径，展示什么样的组件 基本路由实现以下功能 默认显示pageA组件 点击pageA按钮，切换pageA组件 点击pageB按钮切换pageB组件 安装Vue-router 1npm i vue-router 安装插件 1234567891011import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;Vue.config.productionTip = falseVue.use(VueRouter)new Vue(&#123; render: h =&gt; h(App), router&#125;).$mount(&quot;#app&quot;) 创建pageA和pageB组件 123456789101112131415&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageA&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;div&gt; 我是pageB的内容 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageB&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 创建/router文件夹并创建index.js 1234567891011121314151617181920212223// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 我们先写声明式路由 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;点以下按钮切换页面&lt;/h3&gt; &lt;div style=&quot;margin-bottom: 30px;display: flex;width: 120px;justify-content: space-between&quot;&gt; &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt; &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageB&quot;&gt;PageB&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt;&lt;style scoped&gt;.container &#123; padding: 30px;&#125;.active &#123; color: red; text-decoration: none;&#125;.item &#123; text-decoration: none;&#125;&lt;/style&gt; 总结： 12345678910111. 被切换走的组件实际上是被销毁了2. router-link经过编译后，实际上生成的是a标签，这是声明式路由的一个小弊端 我们后面会使用编程式路由来实现跳转功能，会更加灵活3. pageA和pageB的实例上都多了两个属性$route和$router $route指的是自身的路由规则和状况 $router是全局的路由器 4. 路由组件（pageA和pageB这种需要路由规则才会显示的组件）一般放在pages文件夹下 一般组件放在components文件夹下 嵌套路由 1234567891011121314151617181920212223242526272829303132333435// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;,//这里千万不要加上/ component: PageAA &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) PageA.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;ul&gt; &lt;!--这里要写完整的路径，因为我们有可能会跳转到其他页面去，所以我们必须得写完整的路径--&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAA&quot;&gt;pageAA&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAB&quot;&gt;pageAB&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageA&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 命名路由在创建路由器的时候，为路由起名字 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;import PageContent from &quot;@/components/PageContent&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;, component: PageAA, &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; //起名 name: &quot;detailRoute&quot;, path: &quot;pageContent&quot;, component: PageContent &#125; ] &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 那么在切换的时候，就可以使用名字来选择路由了 12345678&lt;router-link :to=&quot;&#123; name: &#x27;detailRoute&#x27;, query: &#123; pageDetail: p &#125;&#125;&quot;&gt;&#123;&#123;p.title&#125;&#125;&lt;/router-link&gt; query参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; 我是pageAB的内容 &lt;ul&gt; &lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;router-link :to=&quot;&#123; path: &#x27;/pageA/pageAB/pageContent&#x27;, query: &#123; pageDetail: p &#125; &#125;&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageAB&quot;, data()&#123; return &#123; pageList: [ &#123; id: &#x27;001&#x27;, content: &#x27;我是pageABA的内容&#x27;, title: &#x27;pageABA&#x27;, &#125;, &#123; id: &#x27;002&#x27;, content: &#x27;我是pageABB的内容&#x27;, title: &#x27;pageABB&#x27;, &#125;, &#123; id: &#x27;003&#x27;, content: &#x27;我是pageABC的内容&#x27;, title: &#x27;pageABC&#x27;, &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.id&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.title&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.content&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageContent&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; params参数123456789101112131415161718192021&lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;router-link exact-active-class=&quot;active&quot; :to=&quot;`/pageA/pageAB/pageContent/$&#123;p.id&#125;/$&#123;p.title&#125;/$&#123;p.content&#125;`&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt;&lt;/li&gt;&lt;!--或者这样写--&gt;&lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;!--这里必须使用name参数来指定路由，不然会失效--&gt; &lt;router-link :to=&quot;&#123; name: &#x27;detailRoute&#x27;, params: &#123; id: p.id, title: p.title, content: p.title &#125; &#125;&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt;&lt;/li&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;import PageContent from &quot;@/components/PageContent&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;, component: PageAA, &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; name: &quot;detailRoute&quot;, path: &quot;pageContent/:id/:title/:content&quot;, component: PageContent, &#125; ] &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.params.title&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.params.content&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageContent&quot;&#125;&lt;/script&gt; query和params的区别 12341. query的对象写法中，path可以是路径也可以是路由名 但是params必须是路由名2. params需要在路由器的配置文件中提前声明 props配置我们发现读取query和params传过来的参数的时候 需要不断使用$route.query.xxx或者$route.params.xxx，十分繁琐 如果需要简化，则需要使用props配置项 12345678910111213141516171819202122232425262728&#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; name: &quot;detailRoute&quot;, path: &quot;pageContent/:id/:title/:content&quot;, component: PageContent, //第一种写法，该对象的所有kv都会以props的形式传给该组件 // props: &#123; // a: &#x27;a&#x27;, // b: &#x27;b&#x27;, // &#125; //props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给该组件。 //props: true, //props的第三种写法，值为函数,推荐 props($route)&#123; return &#123; id:$route.query.id, title:$route.query.title, content:$route.query.content &#125; &#125; &#125; ]&#125; replace属性使用router-link标签实现跳转，浏览器对于历史记录的存储是这样的 这种模式叫push模式 它将一条条记录压入栈中 如果我们想实现以下这种模式 这种模式叫replace模式 它将上一条记录覆盖下一条记录 router-link默认是push模式 增加replace属性以使用replace模式 1&lt;router-link class=&quot;item&quot; replace active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt; 编程式路由修改以上案例 1、切换pageA、pageB的a改为button 2、以push模式切换pageA 3、以replace模式切换pageB 4、前进、后退 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;点以下按钮切换页面&lt;/h3&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button @click=&quot;goBack&quot;&gt;后退&lt;/button&gt; &lt;button @click=&quot;goForward&quot;&gt;前进&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button @click=&quot;gotoPageA&quot;&gt;PageA&lt;/button&gt; &lt;button @click=&quot;gotoPageB&quot;&gt;PageB&lt;/button&gt;&lt;!-- &lt;router-link class=&quot;item&quot; replace active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt;--&gt;&lt;!-- &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageB&quot;&gt;PageB&lt;/router-link&gt;--&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods:&#123; gotoPageA()&#123; this.$router.push(&quot;/pageA&quot;) &#125;, gotoPageB()&#123; this.$router.replace(&quot;/pageB&quot;) &#125;, goBack()&#123; this.$router.back(); &#125;, goForward()&#123; this.$router.forward(); &#125;, &#125;&#125;&lt;/script&gt;&lt;style&gt;.container &#123; padding: 30px;&#125;.active &#123; color: red; text-decoration: none;&#125;.item &#123; text-decoration: none;&#125;.buttons &#123; margin-bottom: 30px; display: flex; width: 120px; justify-content: space-between;&#125;&lt;/style&gt; 编程式路由导航就是不通过router-link实现 而是手动使用router控制的路由跳转 123456789101112131. 如果要传入参数，就不能使用字符串了，而是要使用对象写法gotoDetail(p)&#123; this.$router.push(&#123; name: &#x27;detailRoute&#x27;, params: &#123; id: p.id, title: p.title, content: p.title &#125; &#125;);&#125;2. 编程式路由会更加灵活，不是说router-link不好 缓存路由组件现在再加一个需求在下图出加入一个input组件，然后再pageAA和pageAB之间跳转的时候，input中的数据不会丢失 之前我们说过，组件被切换走后，会被销毁 那么我们如何阻止这次的销毁呢 只要在pageA的组件中将router-view用keep-alive包裹即可 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAA&quot; active-class=&quot;active&quot;&gt;pageAA&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAB&quot; active-class=&quot;active&quot;&gt;pageAB&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;keep-alive include=&quot;PageAB&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 这里也可以这样写，缓存这个路由视图中的PageAB组件 &lt;keep-alive :include=&quot;[&#x27;PageAB&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; --&gt; &lt;!-- 这里不写inclue属性的话，这个视图中所有的组件都会被缓存 &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;PageA&quot; &#125;&lt;/script&gt; 新的生命周期钩子在这个地方展示一个透明度一直发生改变的文字 123&lt;li :style=&quot;&#123;opacity&#125;&quot;&gt; 加油！！！&lt;/li&gt; 然后开启一个定时器，对opacity的值进行操作 123456789mounted() &#123; this.timer = setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0) this.opacity=1 &#125;,16);&#125;,beforeDestroy() &#123; clearInterval(this.timer);&#125; 这里其实就出现了问题 我们已经将其设置为了缓存路由 那么当我们切换到其他组件的时候 该定时器还在周而复始的跑，这是不对的 这时候就需要两个新的路由钩子 这是路由独有的两个钩子 1234567891011activated() &#123; // 当切换到该组件，则该回调被调用 this.timer = setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0) this.opacity=1 &#125;,16);&#125;,deactivated() &#123; // 当该组件被切换走，则调用该回调 clearInterval(this.timer);&#125; 路由守卫全局路由守卫12345678910//全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用，使用next()放行// to和from都是route信息router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;前置路由守卫&#x27;,to,from,next)&#125;)//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123; console.log(&#x27;后置路由守卫&#x27;,to,from)&#125;) 独享路由守卫在路由器的路由规则中配置以下逻辑 独享路由守卫没有后置的守卫 12345678&#123; name:&#x27;detailRoute&#x27;, path:&#x27;pageContent&#x27;, component:News, beforeEnter: (to, from, next) =&gt; &#123; console.log(&#x27;独享前置路由守卫&#x27;,to,from) &#125;&#125;, 组件路由守卫在组件中加入以下逻辑 123456789//通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123; console.log(&#x27;beforeRouteEnter&#x27;,to,from)&#125;,//通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123; console.log(&#x27;beforeRouteLeave&#x27;,to,from)&#125; 三个路由守卫可以配合使用哦 history模式和hash模式我们看到地址栏中始终有#号 #后面的路径都不会发送给服务器 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 那么如何切换模式呢？ vue-router默认开启的是hash模式，如果想要切换模式，只需要在创建路由器的时候，传入一个配置项mode: &#39;history&#39; 这时候你会发现地址栏的#都不见了 讲到这里，有的小伙伴肯定要说了，那我肯定要使用history模式，这样的路径看着才舒服 history模式下，路径确实舒服，但是hash模式的兼容性比较好，history涉及到一个项目上线的问题 我们使用npm run build打包 然后你就发现了出现了一个特殊的文件夹 history模式部署上线我们使用express搭建一个微型的服务器来部署我们的前端项目 1、新建文件夹 mkdir server 2、初始化项目 npm init 3、安装express npm i express 4、创建static文件夹将dist目录下的所有文件放到其中 5、创建server.js并编写服务器端代码 1234567891011const express = require(&#x27;express&#x27;);const app = express();app.use(express.static(__dirname+&#x27;/static&#x27;));app.listen(5005,(err)=&gt;&#123; if(!err)&#123; console.log(&#x27;服务器启动成功&#x27;); &#125;&#125;) 6、启动服务器 node server.js 7、访问localhost:5005并点击 出现问题这时候这个大问题就出现了，我们刷新页面 我们发现了404错误，这是为什么呢？因为服务器并没有该资源 hash模式部署上线那我们使用hash模式再次build，访问尝试 再次刷新，发现并没有出现404 解决history模式的问题我们再次回到history模式，来解决该问题 这个问题需要后端来配合 我们这里使用nodejs做后端，所以我们使用nodejs的技术来解决问题 安装一个库npm install --save connect-history-api-fallback 123456789101112const express = require(&#x27;express&#x27;);const history = require(&#x27;connect-history-api-fallback&#x27;);const app = express();app.use(history())app.use(express.static(__dirname+&#x27;/static&#x27;));app.listen(5005,(err)=&gt;&#123; if(!err)&#123; console.log(&#x27;服务器启动成功&#x27;); &#125;&#125;) 组件库我们真正开发项目的时候，我们不会所有的页面结构都是自己写，我们会使用第三方的组件库，接下来我来介绍几个比较常用的组件库 移动端 Vant https://2x.antdv.com/components/overview-cn CubeUI https://didi.github.io/cube-ui/#/zh-CN MintUI http://mint-ui.github.io/#!/zh-cn nutUI https://nutui.jd.com/#/zh-CN/component/button 京东打造 PC端 Ant Design https://2x.antdv.com/components/overview-cn 蚂蚁金服打造 ElementUI https://element.eleme.cn/#/zh-CN 饿了么打造 如果想使用这些组件库，我们只需要去这些官网查看官方文档即可","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础4","slug":"Vue2-基础4","date":"2022-06-28T06:51:46.000Z","updated":"2022-07-09T10:08:53.929Z","comments":true,"path":"前端/Vue2/2022/06/28/Vue2-基础4/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/28/Vue2-%E5%9F%BA%E7%A1%804/","excerpt":"","text":"Vue2基础4修改默认配置通过vue inspect &gt; output.js可以查看Vue脚手架的默认配置 创建vue.config.js 可选配置项可以去官网查看 123456789module.exports = &#123; pages: &#123; index: &#123; // page 的入口 entry: &#x27;src/main.js&#x27; &#125; &#125;, lintOnSave: false&#125; ref属性123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出按钮的DOM元素和School的Vc对象&lt;/button&gt; &lt;School ref=&quot;sch&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;School&#125;, methods: &#123; showDOM()&#123; console.log(this.$refs.btn) //真实DOM元素 console.log(this.$refs.sch) //School组件的实例对象（vc） &#125; &#125; &#125;&lt;/script&gt; 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素 应用在组件标签上是组件实例对象（vc） props配置项父组件想给子组件传数据，即可通过props配置项来实现 Student.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, //简单声明接收 props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;] &#125;&lt;/script&gt; 使用该组件 1&lt;School name=&#x27;zs&#x27; age=18 sex=&#x27;男&#x27;/&gt; 我们来观察一下props接收到的数据放在了哪里 可以看到，使用props接收到的数据都被放在了vc对象上 我们还发现_data中并没有这些数据 props接收的数据不可修改 1&lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt; 12345methods: &#123; updateAge()&#123; this.age++ &#125;&#125; 如果一定想修改，则需要使用data配置一下数据做个中转 并且展示的时候也使用data中中转的那个变量 1&lt;h2&gt;学生年龄：&#123;&#123;myAge&#125;&#125;&lt;/h2&gt; 12345data()&#123; return &#123; myAge: this.age &#125;&#125; 接收的同时对数据进行类型限制 如果要对类型做限制，需要通过以下写法 12345props:&#123; name:String, age:Number, sex:String&#125; 传入数据 1&lt;Student name=&quot;芝麻&quot; :age=&quot;19&quot; sex=&quot;男&quot;/&gt; 如果是这样传入的 1&lt;Student name=&quot;芝麻&quot; age=&quot;19&quot; sex=&quot;男&quot;/&gt; 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制 1234567891011121314props:&#123; name:&#123; type:String, //name的类型是字符串 required:true, //必要的，父亲组件一定要传该数据 &#125;, age:&#123; type:Number, default:99 //默认值 &#125;, sex:&#123; type:String, required:true &#125;&#125; mixin混入就是子组件可以共享mixin中配置的配置项 达到全局共享的效果，达到复用的目的，减少代码重复性 混合文件就是我们在构造vc的时候传入的配置项 只不过单独将其拿了出来 1234567891011121314151617export const hooks = &#123; created()&#123; console.log(&#x27;数据代理、数据劫持已完成&#x27;) &#125;, mounted() &#123; console.log(&#x27;挂载完成！&#x27;) &#125;&#125;export const getData = &#123; data() &#123; return &#123; x:100, y:200 &#125; &#125;,&#125; 全局混入（全局配置）：Vue.mixin(xxx) 局部混入（配置项）：mixin: [&#39;aaa&#39;] 注意点： 123451、钩子以外的配置项 如果混合中有，则以配置项中优先级高 如果混合中没有，则整合进配置项中2、将两者的生命周期组合在一起 先执行自己的钩子，然后执行mixin中的钩子 插件我们在平时生活工作中，一款好用的插件可以极大地提高我们的生产效率，在Vue中也有这样的插件 我们来定义一个插件试一试 123456789101112131415161718192021222324252627282930313233export default &#123; //...代表使用插件的时候传入的参数 install(Vue,...)&#123; //全局过滤器 Vue.filter(&#x27;filterName&#x27;,function(value)&#123; return ... &#125;) //定义全局指令 Vue.directive(&#x27;directiveName&#x27;,&#123; //指令与元素成功绑定时 bind(element,binding)&#123; //... &#125;, //指令所在元素被插入页面时 inserted(element,binding)&#123; //... &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; //... &#125; &#125;) //定义混入 Vue.mixin(&#123; //... &#125;) //给Vue原型上添加一个方法（vm和vc就都能用了） Vue.prototype.hello = ()=&gt;&#123;alert(&#x27;你好啊&#x27;)&#125; &#125;&#125; 在main.js中使用 123import plugins from &#x27;./plugins&#x27;Vue.use(plugins) style标签scoped属性1234&lt;style scoped&gt;在这个里面写的css样式只会作用于该文件的结构 如果不加scoped则会作用于所有符合条件的html结构&lt;/style&gt; lang属性12345&lt;style scoped lang=&quot;scss&quot;&gt; 如果你想使用Less或者Scss来写css则需要下载编译工具 npm i less-loader npm i scss-loader&lt;/style&gt; Todos案例 提前声明：此案例会循序渐进地讲到很多知识点，请务必不要跳过 静态页面代码App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot;&gt; &lt;/div&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;敲代码&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;睡觉&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;吃饭&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot;&gt;&lt;span&gt;已经完成0/全部3&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.todos &#123; list-style: none; padding: 0; border: 1px solid #ccc;&#125;.todo &#123; height: 50px; padding: 0 0 0 20px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: space-between;&#125;.task &#123; width: 100%; height: 40px; padding-left: 20px; box-sizing: border-box&#125;.container &#123; border: 1px solid black; padding: 10px; width: 30%; margin: 40px auto&#125;.buttons &#123; margin-right: 20px; width: 20%; display: none; justify-content: space-between;&#125;.todo:hover .buttons &#123; display: flex;&#125;.todo:hover &#123; background: #4dd9d5;&#125;.delete &#123; background: red; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;.update &#123; background: #2e6da4; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;&lt;/style&gt; 动态数据现在将数据放到data中，再补充一点逻辑吧 接下来就不写style标签啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot; @keydown.enter=&quot;insertNewTask&quot;&gt; &lt;/div&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt; &lt;span&gt;&#123;&#123; todo.content &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot;&gt;&lt;span&gt;已经完成&#123;&#123;hasDone&#125;&#125;/全部&#123;&#123;totalSum&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; task: &#x27;&#x27;, todos: [ &#123;id: &#x27;002&#x27;,content: &#x27;睡觉&#x27;,done: true&#125;, &#123;id: &#x27;001&#x27;,content: &#x27;打代码&#x27;,done: true&#125;, &#123;id: &#x27;003&#x27;,content: &#x27;吃饭&#x27;,done: false&#125;, &#123;id: &#x27;004&#x27;,content: &#x27;刷抖音&#x27;,done: true&#125;, ], hasDone: 0, &#125; &#125;, mounted() &#123; this.hasDone = this.todos.filter(t=&gt;t.done).length; &#125;, methods:&#123; deleteSelf(id)&#123; &#125;, updateSelf(id)&#123; &#125;, insertNewTask()&#123; &#125; &#125;, computed: &#123; totalSum()&#123; return this.todos.length; &#125; &#125;&#125;&lt;/script&gt; 抽离组件App作为王者居然写了这么多结构代码，哪里有什么组件化的思想，所以我们抽离出一个个组件 Top.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot; @keydown.enter=&quot;insertNewTask&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Top&quot;, data()&#123; return &#123; task: &#x27;&#x27;, &#125; &#125;, methods:&#123; insertNewTask()&#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.task &#123; width: 100%; height: 40px; padding-left: 20px; box-sizing: border-box&#125;&lt;/style&gt; ShowTodosContainer.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot; @click=&quot;choose(todo.id)&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt; &lt;span&gt;&#123;&#123; todo.content &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ShowTodosContainer&quot;, props: [&#x27;todos&#x27;], data()&#123; return &#123; todos: this.todos &#125; &#125;, methods:&#123; deleteSelf(id)&#123; &#125;, updateSelf(id)&#123; &#125;, choose(id)&#123; this.todos.forEach(t=&gt;&#123; if(t.id===id)&#123; t.done=!t.done; &#125; &#125;) &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.todos &#123; list-style: none; padding: 0; border: 1px solid #ccc;&#125;.todo &#123; height: 50px; padding: 0 0 0 20px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: space-between;&#125;.buttons &#123; margin-right: 20px; width: 20%; display: none; justify-content: space-between;&#125;.todo:hover .buttons &#123; display: flex;&#125;.todo:hover &#123; background: #4dd9d5;&#125;.delete &#123; background: red; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;.update &#123; background: #2e6da4; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;&lt;/style&gt; 这里补充一个知识点 123456对于&lt;input type=&quot;checkbox&quot;&gt;1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 PageFooter.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;footer&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot; v-model=&quot;allHasDone&quot;&gt; &lt;span&gt;已经完成&#123;&#123;hasDone&#125;&#125;/全部&#123;&#123;totalSum&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button class=&quot;deleteAll&quot; @click=&quot;deleteAllTodos&quot;&gt; 删除所有代办 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageFooter&quot;, props: [&#x27;todos&#x27;], data()&#123; return &#123; allHasDone: false &#125; &#125;, computed: &#123; totalSum()&#123; return this.todos.length; &#125;, hasDone()&#123; let length = this.todos.filter(t=&gt;t.done).length; this.allHasDone = length === this.todos.length; return length; &#125;, &#125;, methods: &#123; deleteAllTodos()&#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.footer &#123; display: flex; justify-content: space-between;&#125;.deleteAll &#123; background: red; height: 30px; width: 200px; cursor:pointer; color: #4dd9d5&#125;&lt;/style&gt; 实现所有功能插入新代办1234567891011insertNewTask()&#123; if(this.task === &#x27;&#x27;)&#123; return alert(&#x27;请不要输入空的代办！&#x27;) &#125; this.todos.push(&#123; id:nanoid(), content: this.task, hasDone: false &#125;) this.task=&#x27;&#x27;&#125; 删除单个代办123deleteSelf(id)&#123; this.todoList.splice(0,this.todoList.length,...this.todoList.filter(t=&gt;t.id!==id));&#125;, 删除所有代办123deleteAllTodos()&#123; this.todoList.splice(0,this.totalSum,...this.todoList.filter(t=&gt;!t.done))&#125; 勾选1&lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot; v-model=&quot;allHasDone&quot; @click=&quot;chooseAll&quot;&gt; 123chooseAll()&#123; this.todoList.forEach(t=&gt;t.done=!this.allHasDone);&#125; 注意点：先处理点击事件，然后数据才更新，所以要取反 更新代办这个有点麻烦，需要再添加一个组件，使用动态样式来控制其显示 UpdateDialog.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;dialog&quot;:class=&quot;&#123;&#x27;clear&#x27;:showDialog&#125;&quot; @click.self=&quot;close&quot;&gt; &lt;div class=&quot;form&quot;&gt; &lt;h2&gt;请修改代办&lt;/h2&gt; &lt;span class=&quot;close&quot; @click=&quot;close&quot;&gt;X&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;updatedTaskContent&quot;&gt; &lt;button style=&quot;margin-right: 20px&quot; @click=&quot;updateTask&quot;&gt; 修改 &lt;/button&gt; &lt;button @click=&quot;close&quot;&gt; 取消 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;UpdateDialog&quot;, props: [&#x27;task&#x27;,&#x27;showDialog&#x27;], data()&#123; return &#123; updatedTaskContent: this.task.content, propTask: this.task &#125; &#125;, methods:&#123; close()&#123; this.$emit(&#x27;closeDialog&#x27;) &#125;, updateTask()&#123; this.propTask.content=this.updatedTaskContent &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.dialog &#123; position: absolute; display: none; top: 0px; bottom: 0; left: 0px; right: 0px; background: rgba(0,0,0,0.2);&#125;input &#123; width: 400px; margin-bottom: 20px;&#125;.form &#123; position: relative; width: 30%; height: 300px; margin: 40px auto; background: beige; padding: 20px;&#125;.close &#123; display: block; position: absolute; top: -10px; right: 0px; cursor: pointer;&#125;.clear &#123; display: block;&#125;&lt;/style&gt; 这里使用的自定义事件 我在使用该组件的时候传入一个函数，然后组件内部就可以使用this.$emit(&#39;自定义事件名&#39;)来调用该事件 1&lt;UpdateDialog :showDialog=&quot;showUpdateDialog&quot; :task=&quot;choosedTask&quot; @closeDialog=&quot;closeDialog&quot;/&gt; 这个如果这样写会产生一个问题，就是我的task确实是动态传的，但是因为我可能会取消本次更新操作 所以我不可以这样写，这样写的话，取消按钮就是一个小丑 1&lt;input type=&quot;text&quot; v-model=&quot;task.content&quot;&gt; 所以就必须得先存一份传入的值是吧，所以就应该像我刚刚那么写 但是你会发现还是有问题，检查之后发现是我存储的数据是固定在第一次传入的数据，可是我什么时候改变data中的数据呢？ 监视属性我们监视一下task，当其发生了改变，将其覆盖data中的数据 123456watch:&#123; task()&#123; this.updatedTaskContent=this.task.content; this.propTask = this.task; &#125;&#125; 使用v-if配合使用1234&lt;UpdateDialog v-if=&quot;JSON.stringify(choosedTask)!==&#x27;&#123;&#125;&#x27;&quot; :showDialog=&quot;showUpdateDialog&quot; :task=&quot;choosedTask&quot; @closeDialog=&quot;closeDialog&quot;/&gt; 如果使用这种方法的话，我在closeDialog中需要将choosedTask赋值为空对象 自动获取焦点1&lt;input ref=&quot;input&quot; type=&quot;text&quot; v-model=&quot;updatedTaskContent&quot; @keyup.enter=&quot;updateTask&quot;&gt; 如果是监视属性实现的话 需要在监视方法中加入以下逻辑 12345678task()&#123; this.updatedTaskContent=this.task.content; this.propTask = this.task; //当页面解析完成之后再执行回调函数 this.$nextTick(function ()&#123; this.$refs.input.focus(); &#125;)&#125; 如果是v-if实现的话 需要再挂载的时候加入以下逻辑 123456mounted() &#123; this.$nextTick(function ()&#123; console.log(this); this.$refs.input.focus(); &#125;)&#125;, 存储在App中封装一个save函数，将其传递给子组件，在所有对数组造成更新的地方都使用this.$emit(&#39;save&#39;)调用该函数 123save()&#123; sessionStorage.setItem(&quot;todos&quot;,JSON.stringify(this.todos))&#125; 自定义事件 这个是相对于js中内置事件（keyup、click等等）的存在 js内置事件是给HTML元素使用的 自定义事件是给组件用的 主要作用就是实现父子组件之间的通信 绑定事件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt;&lt;div class=&quot;app&quot;&gt; &lt;h1&gt;学生姓名是:&#123;&#123;studentName&#125;&#125;&lt;/h1&gt; &lt;!-- 通过父组件给子组件传递函数类型的props实现：子给父传递数据 --&gt; &lt;Teacher :getSchoolName=&quot;getSchoolName&quot;/&gt; &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据 --&gt; &lt;Student @getStudentName=&quot;getStudentName&quot;/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Student from &#x27;./components/Student&#x27; import School from &#x27;./components/School&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;School,Student&#125;, data() &#123; return &#123; studentName:&#x27;&#x27; &#125; &#125;, methods: &#123; getTeacherName(name)&#123; console.log(&#x27;App收到了学校名：&#x27;,name) &#125;, getStudentName(name)&#123; console.log(&#x27;App收到了学生名：&#x27;,name) this.studentName = name &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .app&#123; background-color: gray; padding: 5px; &#125;&lt;/style&gt; 绑定事件的另一种方式 123mount()&#123; this.$refs.student.$on(&#x27;getStudentName&#x27;,this.getStudentName) //绑定自定义事件 &#125; 触发事件School.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendSchoolName&quot;&gt;把学校名给App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;School&#x27;, props:[&#x27;getSchoolName&#x27;], data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, methods: &#123; sendSchoolName()&#123; this.getSchoolName(this.name) &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .school&#123; background-color: skyblue; padding: 5px; &#125;&lt;/style&gt; Student.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;student&quot;&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, data() &#123; return &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#125; &#125;, methods: &#123; sendStudentlName()&#123; //触发Student组件实例身上的getStudentName事件 this.$emit(&#x27;getStudentName&#x27;,this.name) &#125; &#125;, &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; .student&#123; background-color: pink; padding: 5px; margin-top: 30px; &#125;&lt;/style&gt; 自定义事件的触发本质还是由html的原生事件触发后，我们自己决定触发哪一个自定义事件的 props实现和自定义事件实现的区别：props需要手动接收 解绑事件1this.$off(&#x27;getStudentName&#x27;) //解绑一个自定义事件 组件使用js原生事件1&lt;Student ref=&quot;student&quot; @click.native=&quot;show&quot;/&gt; 组件间通信我们发现，组件之间的通信十分地重要，我们来理一理到现在我们学会了那些组件之间通信的方法， 1231.props ===》适用于父给子传递数据和函数 ===》特点：需要手动接收，并且传递地如果是数据则不能修改2.自定义事件 ===》适用于子给父传递数据 ===》特点：使用$emit调用 我们发现如果两个兄弟之间想要通信 则只能将数据状态提升 将数据放到两者共同地父组件上面去 然后父组件使用上述方法向两者传递信息 如果嵌套层级比较多，则需要多次多层传递数据，会比较麻烦 难道就只能这样了吗？NO！接下来我会讲解三种强大的方法实现任意组件之间的通信 全局事件总线全局事件总线其实十分简单，就是使用自定义事件来实现的 只不过我们事件全部绑定在vm对象上 安装全局事件总线12345678//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this //安装全局事件总线 &#125;,&#125;) 不是一定要叫$bus 绑定事件123this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123; console.log(&#x27;我是School组件，收到了数据&#x27;,data)&#125;) 触发事件1this.$bus.$emit(&#x27;hello&#x27;,this.name) 解绑事件在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。 123beforeDestroy() &#123; this.$bus.$off(&#x27;hello&#x27;)&#125; 原理：1、自定义事件 2、VueComponent.prototype.__proto__ === Vue.prototype 消息订阅与发布消息发布与订阅是一种思想，具体实现有很多种，我们这里选用pubsub-js库 1npm i pubsub-js 订阅和取消订阅消息即设置事件和回调 即需要数据的组件 123456789mounted() &#123; this.pubId = pubsub.subscribe(&#x27;hello&#x27;,(msgName,data)=&gt;&#123; console.log(this) // console.log(&#x27;有人发布了hello消息，hello消息的回调执行了&#x27;,msgName,data) &#125;)&#125;,beforeDestroy() &#123; pubsub.unsubscribe(this.pubId)&#125;, 发布消息即发送数据的组件 1pubsub.publish(&#x27;hello&#x27;,666) Vuex它是专门在Vue中实现集中式状态管理的一个插件，对Vue应用中多个组件的共享状态进行集中式的管理，也是一种任意组件间通信的方式 状态其实指的就是数据 x是所有组件都需要使用的，所以我们将x存入Vuex中 Vuex原理图 此图摘自官网 我们可以看到该图被虚线包起来的部分即Vuex的三大重要的工具，Actions，Mutations，State State译为状态，我们将需要共享的数据放入其中 Actions译为行为，我们会将对于数据的前置操作放入其中，比如条件判断，发出Ajax请求等 Mutations译为加工，我们真正对于数据的修改就是在这里进行的 Vue组件和Vuex工具之间的通信，有以下API，dispatch，commit，mutate，render 只有dispatch和commit是我们手动调用的，其他两个都是由Vuex帮我们调用的，无需我们操心 dispatch是我们在组件内调用的，发出对数据操作的请求 commit是我们在actions或者Vue组件中调用的，让其对数据做出真正的改变 接下来我们直接使用案例来驱动 求和案例效果图 我们先将这个功能实现 因为还没有到组件共享的时候，所以现在先不使用Vuex 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; &lt;h2&gt;当前求和为&#123;&#123;sum&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;select name=&quot;step&quot; id=&quot;stepSelect&quot; v-model=&quot;step&quot;&gt; &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;addOnCondition&quot;&gt;当前为奇数再加&lt;/button&gt; &lt;button @click=&quot;addAfter&quot;&gt;过一秒再加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Count&quot;, data()&#123; return &#123; sum: 0, step: 1 &#125; &#125;, methods:&#123; add()&#123; this.sum+=this.step; &#125;, sub()&#123; this.sum-=this.step; &#125;, addOnCondition()&#123; if(this.sum % 2)&#123; this.add(); &#125; &#125;, addAfter()&#123; setTimeout(()=&gt;&#123; this.add(); &#125;,1000); &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;button &#123; margin-left: 10px;&#125;&lt;/style&gt; 准备接下来我们做些使用Vuex前的准备 创建store/index.js文件 123456789101112131415import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; &#125;, mutations:&#123; &#125;, state:&#123; &#125;,&#125;) 在main.js中引入该文件并并在创建vm的时候传入 123456789import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &quot;./store&quot;;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App), store&#125;).$mount(&#x27;#app&#x27;) 使用接下来我们新建一个组件ShowSum组件，该组件的功能就是用来展示Count组件中的sum，现在我们就使用Vuex来实现此功能 先将数据都交给Vuex管理 Count.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; &lt;h2&gt;当前求和为&#123;&#123;$store.state.sum&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;select name=&quot;step&quot; id=&quot;stepSelect&quot; v-model=&quot;step&quot;&gt; &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;addOnCondition&quot;&gt;当前为奇数再加&lt;/button&gt; &lt;button @click=&quot;addAfter&quot;&gt;过一秒再加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Count&quot;, data()&#123; return &#123; step: 1 &#125; &#125;, methods:&#123; add()&#123; this.$store.dispatch(&#x27;add&#x27;,this.step); &#125;, sub()&#123; this.$store.dispatch(&#x27;sub&#x27;,this.step) &#125;, addOnCondition()&#123; this.$store.dispatch(&#x27;addOnCondition&#x27;,this.step) &#125;, addAfter()&#123; this.$store.dispatch(&#x27;addAfter&#x27;,this.step) &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;button &#123; margin-left: 10px;&#125;&lt;/style&gt; store/index.js 1234567891011121314151617181920212223242526272829303132333435import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; add(context,value)&#123; context.commit(&#x27;INCREASE&#x27;,value); &#125;, sub(context,value)&#123; context.commit(&#x27;DECREASE&#x27;,value) &#125;, addOnCondition(context,value)&#123; if(value%2!==0)&#123; context.commit(&#x27;INCREASE&#x27;,value) &#125; &#125;, addAfter(context,value)&#123; setTimeout(()=&gt;&#123; context.commit(&#x27;INCREASE&#x27;,value) &#125;,1000); &#125;, &#125;, mutations:&#123; INCREASE(state,value)&#123; state.sum+=value; &#125;, DECREASE(state,value)&#123; state.sum-=value; &#125; &#125;, state:&#123; sum: 0, &#125;,&#125;) ShowSum.vue 1234567891011&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; Count组件的sum值是：&#123;&#123;$store.state.sum&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ShowSum&quot;&#125;&lt;/script&gt; 当我们想要拿到state中的数据的时候，需要使用$store.state.xxx，十分麻烦，所以Vuex就为我们提供了工具mapState 1234567891011121314151617&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; Count组件的sum值是：&#123;&#123;sum&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from &quot;vuex&quot;;export default &#123; name: &quot;ShowSum&quot;, computed:&#123; ...mapState([&#x27;sum&#x27;]) &#125;&#125;&lt;/script&gt; 拓展1、getters的使用 getters我们可以理解为计算属性，就是将state中的数据加工后返回给用户 1234567891011121314151617181920import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; &#125;, mutations:&#123; &#125;, getters:&#123; bigSum(state)&#123; return state.sum*10 &#125; &#125;, state:&#123; &#125;,&#125;) 2、mapGetters，mapActions，mapMutations工具 我们对于state中的数据可以使用mapState来将其方便地从Vuex中拿出来 对于getters、actions、mutations中的方法和数据我们也有对应的工具将其从Vuex中拿出 3、模块化开发 如果数据还有分类，我们就可以使用模块化开发 store/index.js 1234567891011121314151617181920212223import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)import teacher from &quot;@/store/roles/teacher&quot;;import student from &quot;@/store/roles/student&quot;;import enterprise from &quot;@/store/roles/enterprise&quot;;import log from &#x27;@/store/log&#x27;import constant from &quot;@/store/constant&quot;;import common from &quot;@/store/common&quot;;const store = new Vuex.Store(&#123; modules: &#123; log, constant, common, teacher, student, enterprise &#125;&#125;)export default store; 使用模块化开发要注意一个点，就是在各个文件中需要开启命名空间 采用模块化开发使用后，mapXXX工具的使用方法就发生了改变，改变如下 1234...mapState(&#x27;模块名&#x27;,[&#x27;state参数名&#x27;]),...mapGetters(&#x27;模块名&#x27;,[&#x27;getters参数名&#x27;]),...mapActions(&#x27;模块名&#x27;,[&#x27;actions函数名&#x27;]),...mapMutations(&#x27;模块名&#x27;,[&#x27;mutations函数名&#x27;]),","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础3","slug":"Vue2-基础3","date":"2022-06-22T07:53:57.000Z","updated":"2022-07-09T10:08:49.344Z","comments":true,"path":"前端/Vue2/2022/06/22/Vue2-基础3/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/22/Vue2-%E5%9F%BA%E7%A1%803/","excerpt":"","text":"Vue2基础3条件渲染 案例：如图 使用v-if12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;span&gt;现在的n值是&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;n++&quot;&gt;点我n自增1&lt;/button&gt;&lt;br&gt; &lt;button @click=&quot;n--&quot;&gt;点我n自减1&lt;/button&gt;&lt;br&gt; &lt;div v-if=&quot;n&lt;3&quot;&gt;我在n小于3的时候出现&lt;/div&gt; &lt;div v-else-if=&quot;n&lt;7&quot;&gt;我在n大于3小于7的时候出现&lt;/div&gt; &lt;div v-else&gt;我在n&gt;7的时候显示&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; n: 0 &#125; &#125; &#125;)&lt;/script&gt; 使用v-show123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;span&gt;现在的n值是&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;n++&quot;&gt;点我n自增1&lt;/button&gt;&lt;br&gt; &lt;button @click=&quot;n--&quot;&gt;点我n自减1&lt;/button&gt;&lt;br&gt; &lt;div v-show=&quot;n&lt;3&quot;&gt;我在n小于3的时候出现&lt;/div&gt; &lt;div v-show=&quot;n&gt;=3&quot;&gt;我在n大于3的时候出现&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; n: 0 &#125; &#125; &#125;)&lt;/script&gt; 区别12341. v-show的原理是将被此指令标记的DOM元素的display属性设置为none，从而实现隐藏的效果 v-if的原理是直接将此DOM元素直接从DOM树中删除2. 如果这个元素会频繁切换显示隐藏，则使用v-show，不需要频繁创建节点 如果这个元素不会频繁切换显示隐藏，只是在初始化的时候进行判断显示隐藏，则使用v-if 列表渲染 案例：将数组数据展示在页面上 123456789data()&#123; return &#123; people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125; ] &#125;&#125; 使用v-for指令 12345&lt;ul&gt; &lt;li v-for=&quot;item in people&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 这样就完成了最基本的遍历，如果我需要得到每一次遍历的索引，只需要加入一个形参即可 12345&lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; OK，这里其实遗漏了一个很重要很重要的一个属性key，这个key就是每一个节点的标识，所以可以直接使用数组每一个对象的id属性，或者是index 123456&lt;ul&gt; &lt;!--&lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt;--&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 这个key是干嘛的呢？这就要好好扒一扒了，来吧，整活！ 虚拟DOM的DIFF算法啥啊这是，怎么从key直接跳到了什么虚拟DOM的DIFF算法了？走错片场了？ 没有没有，要解释key就要先知道这个知识 现在的代码，很简单，就是比刚刚多了一个添加一个人的按钮和一个input框 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;button @click.once=&quot;addPerson&quot;&gt;添加一个人&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125;&lt;input type=&quot;text&quot; v-model=&quot;item.name&quot;&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125; ] &#125; &#125;, methods: &#123; addPerson()&#123; this.people.unshift(&#123;id: &#x27;002&#x27;,name: &#x27;小马&#x27;,age: 21,sex: &#x27;男&#x27;&#125;) &#125; &#125; &#125;)&lt;/script&gt; 说明问题 然后点击添加一个人，你会发现一个很严重的错误，输入塌陷 加入:key=&quot;index&quot;之后，一样出现这个错误 加入:key=&quot;item.id&quot;之后，我们发现，这个错误就消失了 既然意识到了错误和解决错误的方法，那我们就来好好捋一下为什么，下面看图，图有点乱，请仔细观看 key为index的情况 解释几个点吧： 1、粉色的×表示匹配失败，不可以复用，蓝色的√表示匹配成功，可以复用 2、左下角的橙色的删除号表示该元素直接删除 3、下半部分的橙色箭头表示直接复用之前生成的真实DOM节点 4、左半部分的绿色箭头表示需要从虚拟节点重新生成真实DOM节点 key为id的情况 key不写的情况如果不写key的话，Vue默认将index作为key，所以这种情况和key为index的情况是一样的 总结123456789101112131、key的作用 作为每一个DOM虚拟节点的唯一性标识，当数据发生改变的时 在Diff算法时，新虚拟DOM节点找到与自身key相同的旧虚拟DOM节点进行比较 如果相同，则直接将旧虚拟DOM节点生成的真实DOM节点直接拿来复用 如果不同，则将新虚拟DOM节点生成新真实DOM节点2、用index做key会出现的问题 (1)如果出现了对顺序改变的操作，则会导致旧真实DOM无法复用，效率降低 (2)如果有输入类控件，则会出现输入塌陷的问题3、如何设置key (1)如果只是展示，不会产生逆序插入，逆序删除等会影响顺序的情况，则使用index即可 (2)如果会对顺序造成影响，则不能使用index作为key，而是需要使用唯一性标识 列表过滤 需求：输入姓关键词，回车出现名字中带有该关键词的 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;请输入姓关键词&quot; @keyup.enter=&quot;filterData&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125;&lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; keyword: &#x27;&#x27;, people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125;, ], showData: people &#125; &#125;, methods: &#123; filterData()&#123; this.showData = this.people.filter(p=&gt;p.name.indexOf(this.keyword)!==-1); &#125; &#125; &#125;)&lt;/script&gt; 列表排序1234567&lt;button @click=&quot;sortByAge&quot;&gt;按年龄排序&lt;/button&gt;methods: &#123; sortByAge()&#123; this.showData = this.people.sort((p1,p2)=&gt;p2.age-p1.age); &#125;&#125; 修改列表第一个人的信息(奏效)12345678&lt;button @click=&quot;updatePerson&quot;&gt;修改第一个人的年龄为20&lt;/button&gt;methods: &#123; updatePerson()&#123; this.people[0].age = 20; this.showData = this.people; &#125;&#125; 彻底修改列表一个人的信息(失效)123456&lt;button @click=&quot;updatePersonComplete&quot;&gt;彻底修改一个人的信息&lt;/button&gt;updatePersonComplete()&#123; this.people[0] = &#123;id: &#x27;004&#x27;,name: &#x27;老马&#x27;,age: 18,sex: &#x27;女&#x27;&#125;; this.showData = this.people;&#125; 为什么这种方式修改数据，Vue没有检测到呢？ 这就要讲到Vue监测数据变化(响应式)的原理了 响应式原理之前我在讲数据代理的时候，其实已经讲到了Vue响应式的原理，现在我们来正式给小伙伴讲一讲 Vue监测数据分为两种，一种是数组，还有一种是对象。我们先从监测对象开始，然后再讲监测数组。 监测对象前期准备 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;div&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;div&gt;学校：&#123;&#123;school&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let data = &#123; name: &#x27;zhima&#x27;, sex: &#x27;男&#x27;, age: 19, hobbies: [&#x27;王者&#x27;,&#x27;原神&#x27;,&#x27;睡觉&#x27;,&#x27;干饭&#x27;], school: &#123; name: &#x27;南京某高校&#x27;, address: &#x27;南京&#x27; &#125; &#125; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data &#125;);&lt;/script&gt; 我们先来回顾一下数据代理是什么 先输出一下vm对象 我们在data中配置的对象先经过Vue加工变成Observer对象 然后将其放到vm对象上的_data属性中 然后将_data中的数据全部代理到vm对象上 让我们可以直接使用&#123;&#123;&#125;&#125;读取vm身上的属性 这就是数据代理 我们修改了vm身上的属性实际上修改的是_data中的数据 , 然后页面就更新成了修改后的新的数据 或者直接修改_data中的数据,页面也会更新为修改后的数据 这样看来,响应式数据的原理是在_data中.还记得我之前提到的数据劫持吗? Vue的响应式就是通过数据劫持来实现的,而数据劫持又是通过Object.defineProperty实现的,_data的每一个属性都有一个setter函数,当_data中任何一个数据 发生了改变,都会走这个setter方法,那么在这个时候,我就可以执行一遍重新渲染页面的方法,从而使得页面数据更新 监测数组我们先来观察一下_data中的hobbies数组的样子,我们发现它没有给每一个元素设置一个getter&#x2F;setter,那它是怎么实现响应式的呢 这里就不绕弯了 Vue里面对于数组的监测是 通过包装数组方法,先对页面进行更新,然后再调用原生的数组上的方法对数组进行更改 有以下这几种 push() pop() shift() unshift() splice() sort() reverse() Vue中的push不是原生的push 所以只有当你使用以上这些方法的时候,Vue才会监测到,然后对页面进行更新,这就解释了先前的那个案例,直接将数组第一个元素替换的时候,Vue并没有监测到. 但如果数组元素是对象,它一样还是会有getter&#x2F;setter 过滤器功能：先将数据作出处理再将数据进行显示 案例：显示格式化后的时间 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;div&gt; 时间戳：&#123;&#123;nowTime&#125;&#125; &lt;/div&gt; &lt;div&gt; 计算属性格式化后的时间是：&#123;&#123;fmtTime&#125;&#125; &lt;/div&gt; &lt;div&gt; 方法格式化后的时间是:&#123;&#123;getFmtTime()&#125;&#125; &lt;/div&gt; &lt;div&gt; 过滤器格式化后的时间：&#123;&#123;nowTime | timeFormatter&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; nowTime: Date.now() &#125; &#125;, computed:&#123; fmtTime() &#123; return dayjs(this.nowTime).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;); &#125; &#125;, methods: &#123; getFmtTime(value) &#123; return dayjs(value).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;); &#125; &#125;, filters:&#123; timeFormatter(value)&#123; return dayjs(value).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 以上这个过滤器叫局部过滤器，还有一种过滤器，叫全局过滤器 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;!--这里的过滤器第一个传入的参数永远是待处理的数据，这里传入的就直接是第二个参数第三个第四个参数--&gt; 过滤器格式化后的时间：&#123;&#123;nowTime | globalTimeFormatter(&#x27;YYYY-MM-DD&#x27;)&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //全局过滤器 Vue.filter(&#x27;globalTimeFormatter&#x27;,(value,formatStr=&#x27;YYYY-MM-DD HH:mm:ss&#x27;)=&gt;&#123; return dayjs(value).format(formatStr); &#125;)&lt;/script&gt; 注意点：过滤器不是必要的，因为我们使用计算属性或者方法都可以实现，这只是一种方式 自定义指令 指令是什么？ 指令就是v-on开头的一些语法，就是自己封装一些逻辑 需求1：定义一个v-big指令，会把绑定的数值放大10倍。 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data() &#123; return &#123; n: 1 &#125; &#125;, directives:&#123; // big函数何时会被调用？ // 1.指令与元素成功绑定时。 // 2.指令所在的模板被重新解析时。 big(element,binding)&#123; console.log(&#x27;big&#x27;,this) //注意此处的this是window element.innerText = binding.value * 10 &#125; &#125; &#125;&lt;/script&gt; 需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#root&#x27;, data() &#123; return &#123; n: 1 &#125; &#125;, directives:&#123; fbind:&#123; //指令与元素成功绑定时（一上来） bind(element,binding)&#123; element.value = binding.value &#125;, //指令所在元素被插入页面时 inserted(element,binding)&#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; element.value = binding.value &#125; &#125; &#125; &#125;&lt;/script&gt; 这两个都是局部指令，我们来看看全局指令 123456789101112 Vue.directive(&#x27;fbind&#x27;,&#123; bind(element,binding)&#123; element.value = binding.value &#125;, inserted(element,binding)&#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; element.value = binding.value &#125;&#125;) 注意点： 123指令定义时不加v-，但使用时要加v-；指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。 生命周期定义：Vue中每一个生命周期都对应着一个钩子（函数），当Vue走到该生命周期阶段的时候，就会自己调用该钩子。 黄色的标签是我加的注释，其他的流程都是从Vue官网查看的 最常用的就是mounted和destoryed 一般在mounted钩子中初始化数据（Ajax请求），在destoryed钩子中删除定时器，解绑自定义事件等收尾工作 组件 模块化的概念 如果所有的js代码都在一个文件中，那么后期维护和更新会非常吃力。所以就有了模块化的概念了，这里可以看看我之前写的JavaScript的模块化规范 组件的定义 用来实现局部功能效果的所有代码和资源的集合（HTML、CSS、JavaScript） 传统开发我们先来看看传统开发的结构 其存在的问题是 1、代码复用率不高 2、依赖关系混乱，后期难以维护 组件开发 我们来看看官网给我们的图 最上层的就是vm对象，它管理所有的组件对象 在Vue中有两种使用组件化开发的思路 1、非单文件组件 2、单文件组件 非单文件组件定义组件123456789101112const hello = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return &#123; name:&#x27;Tom&#x27; &#125; &#125;&#125;) 这里的data配置项我们说过可以写成两种形式 1、函数式 2、对象式 到了组件开发，这个data配置项就必须是函数式 避免组件被复用时，数据存在引用关系。 注册组件 局部注册 1234567new Vue(&#123; el:&#x27;#app&#x27;, //第二步：注册组件（局部注册） components:&#123; hello &#125;&#125;) 全局注册 1Vue.component(&#x27;hello&#x27;,hello) 使用组件123&lt;div id=&quot;app&quot;&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt; 注意点： 123456789101112131415161718192021222324252627282930313233343536373839401.关于组件名: 一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： (1)组件名尽可能回避HTML中已有的元素名称 (2)可以使用name配置项指定组件在开发者工具中呈现的名字2.关于组件标签: 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt;不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。3.关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。4.关于this指向： (1).组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。 (2).new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。6.Vc和Vm的区别 两者最大的差别就是vc没有el配置项，vc只能依附vm 其他的配置项可以说是一样的 7.重要的内置关系 函数上的prototype属性叫显示原型属性 对象上的__proto__属性叫隐式原型属性 两者指向的都是同一个原型对象 实例对象的隐式原型属性指向自己缔造者的原型对象 VueComponent.prototype.__proto__ === Vue.prototype 让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 单文件组件（脚手架）这里我们就可以使用脚手架（Vue CLI）啦！ CLI（Command Line Interface）命令行接口，我们就叫它脚手架 首先，你必须要有node和gitbash的环境 在gitbash的命令行中输入以下命令 12345678# 下载脚手架npm i @vue/cli -g# 创建Vue项目vue create 项目名# 启动Vue项目npm run serve 注意 如果你是在idea中的终端运行的vue create 项目名报了以下错误，有以下两种解决方案 1、以管理员身份打开idea 2、使用命令行到当前目录下使用该命令 这是正常启动成功的界面 脚手架的HelloWorld案例界面 观察项目结构 main.js12345678910// 引入Vueimport Vue from &#x27;vue&#x27;// 引入App根组件import App from &#x27;./App.vue&#x27;// 关闭生产提示Vue.config.productionTip = false// 创建vm对象new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 我们之前是这么写的 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; template: `&lt;App&gt;&lt;/App&gt;`, components: &#123;App&#125;&#125;).$mount(&#x27;#app&#x27;) 我们运行，发现报错了，报错如下 大概意思是脚手架使用的运行时版本的Vue，它没有模板解析器 你可以将模板放入render函数中，或者使用完整版的Vue 来解决问题 使用完整版Vue1import Vue from &#x27;vue/dist/vue&#x27; 发现不报错了，页面也正常显示了 使用render函数12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render(createElement)&#123; return createElement(App) &#125;&#125;).$mount(&#x27;#app&#x27;) 一个参数省略小括号 12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: createElement=&gt;&#123; return createElement(App) &#125;&#125;).$mount(&#x27;#app&#x27;) 直接写返回语句省略花括号和return 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: createElement =&gt; createElement(App)&#125;).$mount(&#x27;#app&#x27;) 换个参数名 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 为什么要使用残缺版的Vue呢？ 模板解析器占了Vuejs源码的1&#x2F;3的体积，为了减少打包后的体积，所以就将模板解析器删去，用更小的render函数来完成该任务 App.vue12345678910111213141516171819202122232425262728&lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import HelloWorld from &#x27;./components/HelloWorld.vue&#x27; export default &#123; name: &#x27;App&#x27;, components: &#123; HelloWorld &#125; &#125;&lt;/script&gt;&lt;style&gt; #app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125;&lt;/style&gt; 我们可以看到一个vue文件可以分为三部分 第一部分是用来写HTML结构的 第二部分是用来写JavaScript的 第三部分是用来写样式的 index.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--针对IE，让IE浏览器最高级别渲染页面--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;!--引入页面图标&lt;%= BASE_URL %&gt;可以拿到项目根路径，就是public文件夹--&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;!--设置网站名字，拿着package.json中配置的name作为网站名--&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--当网站不支持JavaScript的时候，显示noscript中的内容--&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;!--容器--&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础2","slug":"Vue2-基础2","date":"2022-06-21T03:33:37.000Z","updated":"2022-07-09T10:08:43.822Z","comments":true,"path":"前端/Vue2/2022/06/21/Vue2-基础2/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/21/Vue2-%E5%9F%BA%E7%A1%802/","excerpt":"","text":"Vue2基础2事件处理v-on这里我们要接触一个全新的配置项methods和一个新的指令语法v-on，我们以需求为导向来学习这一节 需求一：点击按钮，控制台显示欢迎信息 HTML 123456&lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;!--按钮绑定点击事件，回调函数是welcome--&gt; &lt;button v-on:click=&quot;welcome&quot;&gt;欢迎&lt;/button&gt;&lt;/div&gt; JavaScript 1234567891011121314new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; name: &#x27;kerwin&#x27;, msg: &#x27;坚持很难，但很酷&#x27; &#125; &#125;, methods:&#123; welcome()&#123; console.log(`Hello,$&#123;this.name&#125;`) &#125; &#125;&#125;) 这里有几个知识点 1、模板字符串 1被``包裹的字符串被叫做模板字符串，它的特点是，在其中可以使用$&#123;&#125;语法读取变量 2、methods中配置的函数，this指的应该是vm对象，这就对应着前面我说的一句话 所有被Vue管理的函数(不能是箭头函数)，其内部的this都是vm对象，所以可以使用this.xxx直接获取属性的值 3、观察vm对象，发现在methods中配置的函数，都出现在了vm身上 4、简写形式，常用 1&lt;button @click=&quot;welcome&quot;&gt;欢迎&lt;/button&gt; 需求二：点击按钮，提示当前鼠标位置 这就需要使用事件参数，其实在welcome方法的参数列表中，Vue默认为咱们传递了一个参数，只不过刚刚我们没有使用而已，我们接收打印一下看看 123welcome($event)&#123; console.log($event)&#125; 既然有了这个对象($event)，那我获取当前鼠标位置，只需要读取该对象的pageX属性和pageY属性即可 这里也可以不叫$event，叫它a啊b啊都可以，但是习惯起见，我就以$event来接收它了 需求3：我想将name传参进去，而不是使用this去读取 HTML 1&lt;button @click=&quot;welcome($event,name)&quot;&gt;欢迎&lt;/button&gt; JavaScript 123welcome($event,name)&#123; console.log(`Hello,$&#123;name&#125;`)&#125; 这里有个注意点，如果我在这里是这样写的&lt;button v-on:click=&quot;welcome(name)&quot;&gt;欢迎&lt;/button&gt; 那么welcome函数只有一个入参，那就是name，点击事件对象就没了 事件修饰符 需求1：点击一个a标签，然后提示弹窗，但是不跳转页面 HTML 123&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;https://baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我跳转百度&lt;/a&gt;&lt;/div&gt; JavaScript 12345678let vm = new Vue(&#123; el: &#x27;#app&#x27;, methods:&#123; showInfo()&#123; alert(&#x27;Hello&#x27;) &#125; &#125;&#125;); 这里面的prevent就是事件修饰符。 Vue为我们提供了6种事件修饰符，用的都不是很多，大家过个眼就行 事件修饰符 作用 prevent 阻止默认事件（常用） stop 阻止事件冒泡（常用） once 事件只触发一次（常用） capture 使用事件的捕获模式 self 只有event.target是当前操作的元素时才触发事件 passive 事件的默认行为立即执行，无需等待事件回调执行完毕 这里讲一下passive的作用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .list&#123; width: 200px; height: 200px; background-color: peru; overflow: auto; &#125; li&#123; height: 100px; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul @wheel.passive=&quot;bigWork&quot; class=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;!-- wheel事件 当鼠标滚轮滚动，则触发该事件，并且当滚动条到达边界后，滚动也会触发该事件 scroll事件 当滚动条滚动则触发该事件，滚动条到了边界后，再滚动就不会触发该事件了 --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#app&#x27;, methods:&#123; bigWork()&#123; for (let i = 0; i &lt; 100000; i++) &#123; console.log(&#x27;===&#x27;) &#125; console.log(&#x27;活终于干完了&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 现在滚动鼠标滚轮的时候，滚动条就会卡住不动，当我加上passive后，即变正常。这是为什么呢？ 当触发滚轮事件后，先执行事件回调，然后再执行默认事件，如果任务量很大，则默认事件就会堆积，导致页面卡顿 但是当我换成scroll的时候，就算我不加passive修饰符，滚动条依旧正常。 passive在pc端用的很少，在移动端用的较多一点 键盘事件键盘事件最常用的就两个事件keydown和keyup 前者是当按键按下后触发，后者是当按键回弹起来后触发 案例1：输入文字，当按下回车控制台打印 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; v-on:keyup.enter=&quot;showInfo&quot;&gt; &lt;!-- 简写模式 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; @keyup.enter=&quot;showInfo&quot;&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; msg: &#x27;&#x27; &#125; &#125;, methods:&#123; showInfo()&#123; console.log(`输入框中的句子是$&#123;this.msg&#125;`) &#125; &#125; &#125;);&lt;/script&gt; 总结： 12345678910111213141516171.Vue中常用的按键别名： 回车 =&gt; enter 删除 =&gt; delete、backspace (包括“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab (特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right2.系统修饰键（用法特殊）：ctrl、alt、shift、meta(win) (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 (2).配合keydown使用：正常触发事件。3.当按下Ctrl+y的时候，再触发事件&lt;input type=&quot;text&quot; v-model=&quot;msg&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt; 计算属性与监视 案例：根据输入的姓和名展示姓名 插值语法实现123456789101112131415161718&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;firstName&#125;&#125;-&#123;&#123;secondName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125; &#125;)&lt;/script&gt; methods实现123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;!--这里的方法必须加上小括号，不然读取的就是方法的源码--&gt; &lt;span&gt;全名：&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, methods:&#123; fullName()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125; &#125; &#125;)&lt;/script&gt; 这里需要注意一个点：当data中的数据发生了改变，就会重新解析模板，所以所有在插值语法中的函数都会再执行一遍 计算属性实现全写1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, computed:&#123; fullName: &#123; get()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125;, set(value)&#123; const arr = value.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125; &#125; &#125;) 总结： 1234561、get何时被调用？ (1)页面加载好后，对此变量初次读取 (2)get中使用到的任何变量发生变化的时候2、set何时被调用 (1)当fullName被修改时 3、计算属性会被放到vm上 简写在只读不写的情况下才可以使用简写模式 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, computed:&#123; fullName()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125; &#125; &#125;)&lt;/script&gt; 计算属性是一个名词，不是动词 这一点搞明白之后，就可以理解计算属性的作用其实就是拿着我现有的东西加工后再展示在页面上 既然插值语法和methods都可以实现该功能，为什么还要学一个计算属性呢？这不是经典白学吗？ NO！大NO特NO 计算属性的优势有两点 1、职责分明 2、与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。 证明：计算属性有缓存 123456computed:&#123; fullName()&#123; console.log(&#x27;我被读取了&#x27;) return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125;&#125; 页面上多次使用fullName 修改姓 由此可以证明计算属性具有缓存 缓存什么时候刷新呢？当get中使用到的任何变量发生变化的时候 监视实现监视是一个全新的配置项，作用是监视一个属性的变化 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27; &#125; &#125;, watch:&#123; firstName:&#123; handler(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125; &#125;, secondName: &#123; handler(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125; &#125;)&lt;/script&gt; 这样写就有一个问题，当firstName和secondName有初始值的情况下，页面加载后，fullName是没有值的 这时候就需要使用一个配置项immediate，使得页面加载后立即执行一次监视的回调函数 1234567891011121314watch:&#123; firstName:&#123; immediate: true, handler(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125; &#125;, secondName: &#123; immediate: true, handler(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125;&#125; 这时候小马觉得所有的数据直接写在data中不太好，他想使用一个对象来放这些数据，所以他把data改成了这样，然后他想监视person的变化 12345678910111213data()&#123; return &#123; person: &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, school: &#123; name: &#x27;南京某大学&#x27;, age: 18 &#125; &#125; &#125;&#125;, 于是乎页面就成了这样 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;person.secondName&quot;&gt; &lt;/br&gt; 学校名：&lt;input type=&quot;text&quot; v-model=&quot;person.school.name&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; person: &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, school: &#123; name: &#x27;南京某大学&#x27;, age: 18 &#125; &#125; &#125; &#125;, watch:&#123; person:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;我被修改了&#x27;); console.log(newValue); &#125; &#125; &#125; &#125;)&lt;/script&gt; 小马开心的修改了学校名，发现控制台啥也没有，又修改了姓和名，发现控制台都没有输出， 其实这不是小马的错，这时候就需要另一个配置项了deep，开启对对象的深度监视 123456789watch:&#123; person:&#123; deep: true, handler(newValue,oldValue)&#123; console.log(&#x27;我被修改了&#x27;); console.log(newValue); &#125; &#125;&#125; 小马发现这样写完之后，就又可以监视这个person对象了 简写模式123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27;, fullName: &#x27;&#x27; &#125; &#125;, watch: &#123; firstName(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125;, secondName(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125;)&lt;/script&gt; 另一种写法123456789101112 vm.$watch(&#x27;firstName&#x27;,&#123; immediate:true, deep:true, handler(newValue,oldValue)&#123; console.log(&#x27;firstName被修改了&#x27;,newValue,oldValue) &#125;&#125;) //简写形式，所有被vm所管理的函数，都不要写成箭头函数 vm.$watch(&#x27;secondName&#x27;,function (newValue,oldValue)&#123; console.log(&#x27;secondName被修改了&#x27;,newValue,oldValue,this)&#125;) 区别计算属性和监视的区别 就按照这个案例看的话，好像计算属性比监视好多了，但是如果我再加一个需求：姓名输入防抖动 防抖动：就是一段时间内不展示结果，等到用户输入完毕后，再将结果放到页面中 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, timer: &#x27;&#x27;, &#125; &#125;, watch:&#123; firstName:&#123; immediate: true, handler(newValue,oldValue)&#123; clearTimeout(this.timer); this.timer = setTimeout(()=&gt;&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName; &#125;,2000); &#125; &#125;, secondName:&#123; immediate: true, handler(newValue,oldValue)&#123; clearTimeout(this.timer); this.timer = setTimeout(()=&gt;&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue; &#125;,2000); &#125; &#125; &#125; &#125;)&lt;/script&gt; 这里大家可能会有个疑惑 这里如果不写成箭头函数的话，函数里面的this就是window 但是写成箭头函数的话，在2s过后，vs引擎执行此回调的时候，就会在函数中找this，没有找到 然后向外找，就找到了handler函数，这里面的this就是vm，那么就可以找到data中的属性了 这时候就有人说了，那我也可以用计算属性啊 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27; &#125; &#125;, computed: &#123; fullName()&#123; setTimeout(()=&gt;&#123; return this.firstName + &#x27;-&#x27; + this.secondName; &#125;,2000); &#125; &#125; &#125;)&lt;/script&gt; 当你写下这个代码的时候，你得反思一下基本功了 这个函数的返回值会返回到哪里去？ 所以，当需要使用异步计算的时候，就需要使用属性监视 小总结 1234567computed和watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以对数据进行异步的操作。两个重要的小原则： 1.所被Vue管理的函数，最好写成普通函数的形式，这样this的指向才是vm或组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数） 最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。 绑定style与class这里就不写案例了 1234567891. class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。 :class=&quot;&quot; 字符串写法适用于：类名不确定，要动态获取。 :class=&quot;&#123;classA:xxx,classB:xxx&#125;&quot; 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用，xxx是布尔值 :class=&quot;[&#x27;classA&#x27;]&quot;数组写法适用于：要绑定多个样式，个数不确定，名字也不确定2. style样式 :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。 :style=&quot;[a,b]&quot;其中a、b是样式对象。 :style=&quot;obj&quot;其中obj是样式对象或者数组","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础1","slug":"Vue2-基础1","date":"2022-06-20T13:54:45.000Z","updated":"2022-07-09T10:08:38.295Z","comments":true,"path":"前端/Vue2/2022/06/20/Vue2-基础1/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/20/Vue2-%E5%9F%BA%E7%A1%801/","excerpt":"","text":"Vue2基础1官网地址：https://cn.vuejs.org/ 相信大家学习什么都是以HelloWorld开头的，那我们就以一个HelloWorld的栗子开启我们的Vue学习吧 HelloWorld案例安装Vue 这里大家要注意，不要使用CLI创建Vue项目 新手阶段最好使用标签静态引入CDN的方式来安装Vue 这里补充一个知识点： script标签的src属性可以写成./???.js的形式 也可以写成一个网址，为了使用这种方式引入的加载速度更快一点，所以使用了CDN加速 这是官网提供的两种Vue.js，两者有什么区别呢？ 开发版本的体积比生产版本的体积大，其中包含了完整的警告和调试模式，在学习阶段，我们使用开发版本的即可 引入Vue.js 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; 安装开发者工具它是一个谷歌插件，如果你可以访问外网，可以直接在谷歌插件商场直接搜索下载，如果没有的话，我也在这里提供插件的文件， 12链接：https://pan.baidu.com/s/18AFI8MpW397L6obmKnAZCw 提取码：iupu 点击开发者模式 如果使用的是我提供的文件的话，直接将crx文件拖入该页面即可安装开发者工具 使用Vue123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;我的第一个Vue页面&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--这里的&#123;&#123;&#125;&#125;是Vue中的插值语法，可以读取data配置项中配置的数据--&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //关闭vue的生产提示。 //创建Vue实例 new Vue(&#123; el:&#x27;#app&#x27;, //el用于指定当前创建的Vue实例为哪个容器服务，值为css选择器。 data:&#123; //data中用于存储我们需要用到的数据，数据供el所指定的容器去使用，值是一个对象。 msg:&#x27;Hello World&#x27; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解释： 1234567891011121314151617181920212223242526272829303132333435361、&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性 js表达式 VS js语句 (1)js表达式是一个值 (2)js语句是一个语句，控制代码走向 if()&#123;&#125; for()&#123;&#125; switch()&#123;&#125;2、容器和Vue实例的关系是一对一的3、id为app的容器内部的代码就是模板4、一旦data中的数据发生改变，页面中使用到该数据的地方都会自动更新5、el的两种写法，该配置的作用叫挂载，就是将创建的Vue实例与HTML元素绑定在一起 (1) el:&#x27;#app&#x27; (2) new Vue(&#123; data:&#123; msg:&#x27;Hello World&#x27; &#125; &#125;).$mount(&#x27;#app&#x27;) 这个$mount是Vue原型对象上提供的6、data的两种写法 (1) 对象式，data是一个对象 data:&#123; msg:&#x27;Hello World&#x27; &#125; (2) 函数式，data是个函数，返回的是一个对象 data()&#123; return &#123; msg: &#x27;Hello World&#x27; &#125; &#125; (3) 只要是Vue管理的函数，其中的this对象都是自己创建的Vue实例对象，**前提是不能是箭头函数** (4) 我们最常使用的是函数式的，大家要多写这种形式的，具体原因的话，这里埋个伏笔，以后在讲组件的时候解释 如果我们不使用new关键词创建Vue对象的话会怎么样呢？ 控制台就会出现报错 开发版 生产版 这里可以体现生产版本和开发版本之间的区别 我们来看下Vue的构造函数 1234567function Vue (options) &#123; //先判断当前调用函数的是否是Vue的实例，如果不是，则在控制台报错 if (!(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125; 模板语法刚刚我们在写HelloWorld案例的时候使用的&#123;&#123;&#125;&#125;叫插值语法 模板语法一共两种，插值语法就是其中的一种，另一种模板语法叫指令语法 1234567插值语法： 作用：解析标签体内的内容 写法：&#123;&#123;xxx&#125;&#125;双括号内是js表达式，可以直接读取到data中的所有属性。 指令语法： 功能：解析标签（包括：标签属性、标签体内容、绑定事件.....）。 写法：v-xxx(xxx为具体指令) 我们来看看指令语法是个什么东东 为了节省代码量，这里只写核心代码 v-text这个最简单，其作用就是插值语法，将其指定的内容替换标签体内的所有内容，不解析HTML 与之对应的还有一个指令v-html，那这个指令就是将内容放入标签体内后，如果内容有HTML元素，它也会解析 v-bind主要使用在给HTML元素属性动态赋值的时候使用 HTML 12345&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;点我去&#123;&#123;name&#125;&#125;学习1&lt;/a&gt; &lt;!--这是v-bind的简写模式--&gt; &lt;a :href=&quot;url&quot;&gt;点我去&#123;&#123;name&#125;&#125;学习2&lt;/a&gt;&lt;/div&gt; JavaScript 1234567new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;百度&#x27;, url:&#x27;http://www.baidu.com&#x27;, &#125;&#125;) bind的英文意思是绑定，这里先理解一下这个名词的意思，这里的v-bind是单向绑定 什么叫单向绑定？ 就是我在Vue实例中的data中的数据发生了改变，页面中的数据就会跟着更新， 但是页面中的数据发送了改变，data中的数据不会发生改变 证明： 因为我们还没学其他可以修改data中的数据的方法，我们这里就使用开发者工具开帮我们完成该任务 修改data中数据，页面更新 修改页面数据，data不更新 1document.getElementById(&#x27;app&#x27;).children[0].href=&#x27;https://juejin.cn/&#x27; 这就是单向绑定了 既然有单向绑定，那肯定与之对应的还有一个双向绑定啦，下面我们来看看双向绑定 v-model只使用在一些表单类的HTML标签 这个指令十分十分十分的重要，请一定要理解这个指令双向绑定的作用 HTML 1234&lt;div id=&quot;app&quot;&gt; &lt;!--将input的value属性和data中的name属性双向绑定起来--&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;/div&gt; JavaScript 123456new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;芝麻芝麻&#x27; &#125;&#125;) 单向绑定，是页面中的数据修改后，data中的数据不会更新 那双向绑定的情况下，是不是就会更新了？是的 我们来证明一下这一点 说明： 12341、简写模式 &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;2、作用范围 只可以作用在表单元素上 MVVM模型123M: 模型(Model)对应data中的数据V: 视图/模板(View)HTML元素VM: 视图模型(ViewModel)托管数据的Vue实例，所以以后我们叫Vue的实例对象就叫vm对象 我们来输出一下vm来看看它长啥样 我们发现，橙色框中就是我们data中配置的数据，奇怪的是，它是三个点，但是点开看确实是我们刚刚配置的数据 Vue经过一些操作（我可不会告诉你这叫数据代理），将咱们在data中配置的数据直接放到了vm实例对象上 其实插值语法中可以看到vm身上所有的属性，所以可以直接写我们在data中配置的属性 数据代理回顾Object.defineProperty()在说这个之前，我们先来回顾一下Object上的一个方法defineProperty 123let person=&#123; name: &#x27;lisi&#x27;&#125; 现在我要给person对象上添加一个属性age 第一种写法 1person.age=18 第二种写法 123Object.defineProperty(person,&#x27;age&#x27;,&#123; value: 18&#125;) 那有人就要说了，谁选第二种方式啊，第一种方式那么简单，此言差矣 第二种写的方式定义的age属性有两个特性 第一个，他无法被遍历，删除，修改 无法被遍历，是什么意思？ 1234567891011121314151617// 遍历person中的所有属性for(p in person)&#123; console.log(p)&#125;// 拿到person中的属性数组console.log(Object.keys(person))// 除了age属性，其他的属性都可以被遍历到//用Object.defineProperty定义的数据有很多限制，但是可以通过一些配置项来使其解除限制Object.defineProperty(person,&#x27;age&#x27;,&#123; value: 18, enumerable: true,//可被遍历，默认值是false writable:true, //可以被修改，默认值是false configurable:true //可以被删除，默认值是false &#125;&#125;) 第二个，它可以做数据劫持 这就需要一些其他的配置项了，即get和set 1234567891011121314let number = 18;Object.defineProperty(person,&#x27;age&#x27;,&#123; // 当有人读取person的age的时候，即点了那三个点的时候 // 就会将这个函数的返回值作为person.age的值展示出来 get()&#123; console.log(&#x27;嘿嘿，旧数据被我劫持了！！&#x27;) return number &#125;, // 当有人修改person的age的时候 set(newValue)&#123; console.log(&#x27;嘿嘿，新数据被我劫持了！！我要做坏事了&#x27;) number = newValue; &#125;&#125;) 定义给数据代理下个定义：通过一个对象代理对另一个对象中属性的操作（R&#x2F;W） 我们看一下Vue中的数据代理 vm实例对象代理了data中配置的属性 我们先来证明一个事情：我们传入的data配置项和vm身上的_data是同一个对象 1234567let data = &#123; name:&#x27;芝麻芝麻&#x27;&#125;let vm = new Vue(&#123; el:&#x27;#app&#x27;, data&#125;) 这里我们观察到data已经不是原来的那个对象了，它已经被Vue加工过了 那么Vue中的数据代理就是vm代理了_data中的数据修改 当_data中的数据发生了修改，_data就会检测到这次的修改（数据劫持），页面中使用到该数据的地方都会发生更新 模拟Vue中的数据代理和数据劫持123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script type=&quot;text/javascript&quot;&gt; // 我的Vue的构造函数 function MyVue(options)&#123; // 拿到配置项传入的data let data = options[&#x27;data&#x27;]; // 数据代理，将data中出现的属性代理给实例对象 Object.keys(data).forEach((p)=&gt;&#123; Object.defineProperty(this,p,&#123; get()&#123; return data[p]; &#125;, set(newValue)&#123; data[p] = newValue; &#125; &#125;) &#125;) // 数据劫持 // 将data进行一些加工，使其可以检测属性的变化，当属性变化的时候，对页面做出更新 function Observer(data)&#123; Object.keys(data).forEach((p)=&gt;&#123; Object.defineProperty(this,p,&#123; get()&#123; console.log(&#x27;有人读取配置项中的数据&#x27;); return data[p]; &#125;, set(newValue)&#123; console.log(&#x27;有人修改配置项中的数据，我要更新页面了&#x27;); data[p]=newValue; &#125; &#125;) &#125;) &#125; // 对传入的data数据进行加工，并将其赋值给_data this._data=new Observer(data); options.data=this._data &#125; const vm = new MyVue(&#123; data: &#123; name: &#x27;zhima&#x27; &#125; &#125;)&lt;/script&gt; 证明： 123456789101112131415// 问题一// 对于嵌套类型的对象,是无效的,因为我没有写递归语句,源码是写了递归语句,将对象的每一层都加了getter/setter// 问题二// 这里的_data对象和传入的data对象是不一致的// 这里我不知道怎么实现这一点，有会的大佬可以发一下评论区 let data = &#123; name: &#x27;zhima&#x27;&#125;const vm = new MyVue(&#123; data&#125;)//consolevm._data===datafalse 这里的代码看不懂不要紧哦，我接下来还会再提一遍的，慢慢地会懂的 加油加油💪","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-导言","slug":"Vue2-导言","date":"2022-06-18T13:17:13.000Z","updated":"2022-07-15T09:33:20.774Z","comments":true,"path":"前端/Vue2/2022/06/18/Vue2-导言/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/18/Vue2-%E5%AF%BC%E8%A8%80/","excerpt":"","text":"Vue学习Vue之前，我们先来看三个问题 导言什么是Vue这是官网的介绍 构建用户界面 即将数据展示在页面上，给用户看 渐进式框架 渐进即逐渐递进，简单来说就是 在简单应用中，可以只需要一个小巧的库 在复杂应用中，可以引入各种各样复杂的组件 就是一种可以从易到难开发的一种框架 谁开发的 它有什么特点Angular.js的特点是模块化开发 React.js的特点是虚拟DOM Vue则是集两家之长，它具有以下特点 组件化开发提高代码复用率和维护性 每一个框就是一个组件，就是一个文件 当我需要修改哪一块的界面，我只需要到哪个文件去修改即可 声明式编程让编码人员无需直接操作DOM，提高开发效率 需求：将下列数据显示在一个列表(&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;)中 123456789101112131415let persons = [ &#123; id: &#x27;1&#x27;, name: &#x27;zhima&#x27; &#125;, &#123; id: &#x27;2&#x27;, name: &#x27;lizhi&#x27; &#125;, &#123; id: &#x27;3&#x27;, name: &#x27;kerwin&#x27; &#125;] 命令式编程 123456let list = document.getElementById(&#x27;container&#x27;)persons.forEach(p=&gt;&#123; let li=document.createElement(&#x27;li&#x27;); li.innerHtml=`id:$&#123;p.id&#125;-name:$&#123;name&#125;` list.append(li);&#125;) 声明式编程 12345&lt;ul id=&quot;container&quot;&gt; &lt;li v-for=&quot;p in persons&quot;&gt; id:&#123;&#123;p.id&#125;&#125;-name:&#123;&#123;p.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 虚拟DOM优秀的DIFF算法，提高DOM的复用率 这就有点让人摸不着头脑了，DOM还有复用率？ 还是刚才那个案例，如果我的数据变成了这样 123456789101112131415let persons = [ &#123; id: &#x27;1&#x27;, name: &#x27;zhima&#x27; &#125;, &#123; id: &#x27;2&#x27;, name: &#x27;lizhi&#x27; &#125;, &#123; id: &#x27;4&#x27;, name: &#x27;txy&#x27; &#125;] 传统的使用JavaScript进行命令式操作的话，直接将数据转化为页面真实DOM（Real-DOM），确实和DOM的复用率没有啥关系 但是在Vue里面，在数据变成页面上的DOM节点的之前，它会在内存中生成虚拟DOM（Virtual-DOM） 然后使用DIFF算法，比较新旧虚拟DOM，如果有一样的，则直接复用之前已经生成好的虚拟DOM，从而提高了DOM的复用率。 那么通过什么来判断两个虚拟DOM是否相同呢？ 这就要说说刚刚写的代码的一处错误了，下面看正确的代码 12345&lt;ul id=&quot;container&quot;&gt; &lt;li v-for=&quot;p in persons&quot; :key=&quot;p.id&quot;&gt; id:&#123;&#123;p.id&#125;&#125;-name:&#123;&#123;p.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 我们看到，上面的代码就是加了一处地方，就是:key=&quot;p.id&quot;，就是给每一个遍历的元素加上了唯一性标识 具体的DIFF算法，我们后面讲到虚拟DOM 的时候再说 学之前要掌握什么知识 ES6模块化开发规范 包管理器NPM 数组常用方法 axios promise","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"【19-Medium】删除链表的倒数第N个节点","slug":"【19-Medium】删除链表的倒数第N个节点","date":"2022-05-01T05:16:28.000Z","updated":"2023-03-06T06:45:44.853Z","comments":true,"path":"算法/刷题篇/2022/05/01/【19-Medium】删除链表的倒数第N个节点/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/05/01/%E3%80%9019-Medium%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ Related Topics 链表 双指针 双指针这道题典型的用快慢指针法来解决 将slow和fast指向头部，将fast指针先往后走n步 然后两者齐头并进，当fast.next为null的时候，slow已经在倒数第n-1个节点的位置了，此时进行删除操作 该方法的原理是利用步长，fast先走的那几步，在fast到了链表末尾的null的时候，slow则表示的是倒数第n个节点， 因为这里需要执行删除操作，所以需要将fast走到链表末尾即可 示例代码 123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; for (int i = 0; i &lt; n; i++) &#123; fast = fast.next; &#125; if(fast == null)&#123; return head.next; &#125; while(fast.next != null)&#123; slow = slow.next; fast = fast.next; &#125; slow.next = slow.next.next; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JVM-内存分区","slug":"JVM-内存分区","date":"2022-03-18T09:27:35.000Z","updated":"2022-11-08T06:51:50.009Z","comments":true,"path":"javaEE/JVM/2022/03/18/JVM-内存分区/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/18/JVM-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"JVM内存分区内存分区和内存模型是两个概念 操作系统内存分区 栈（Stack） 堆（Heap） 未初始化数据段（BSS） 数据段（Data Segment） 文本段（Literal Segment） 代码段（Code Segment） JVM内存分区 程序计数器（PC） 虚拟机栈（JVM Stack） 本地方法栈（Native Method Stack） 堆（Heap） 方法区（Method Area） 橙色虚线包裹的就是线程共享的，被红色实现包裹的是线程隔离的 程序计数器在硬件层面，程序计数器是寄存器，是用来存储指令地址给处理器执行， 在JVM中，它的作用就是用来存储字节码指令的地址，提供给执行引擎去执行 这里我们从侧面去查看该特新 1234567public class Demo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); &#125; &#125;&#125; 然后先编译javac Demo.java反编译javap -l -c Demo.class 得到以下字节码 123456789101112131415161718192021222324252627282930313233Compiled from &quot;Demo.java&quot;public class com.lizhi.Demo &#123; public com.lizhi.Demo(); descriptor: ()V Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V Code: // 这里的数字就是字节码指令的偏移量 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 21 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: iload_1 12: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 15: iinc 1, 1 18: goto 2 21: return // 这里可以解释断点的原理，将源码行数和字节码行数进行映射 LineNumberTable: line 5: 0 line 6: 8 line 5: 15 line 8: 21&#125; 虚拟机栈也叫java方法栈，java方法的调用对应着栈帧的入栈与出栈。 3个重点： 栈帧 栈帧出现时机 栈帧的构成 栈帧栈帧主要有四部分组成：局部变量表、操作数栈、动态连接、返回地址 局部变量表 主要存储方法的参数、定义在方法内的局部变量，包括基本数据类型（8大）对象的引用地址，返回值地址。 局部变量表中存储的基本单元为变量槽（Slot），32位（4字节）以内的数据类型占一个slot，64位（long，double）的占两个slot。 局部变量表是一个数字数组，byte、short、char都会被转化为int,boolean类型也会被转化为int，O代表false、非0代表true。局部变量表的大小是在编译期间决定下来的，所以在运行时它的大小是不会变的。 局部变量表中含有直接或者间接指向的引用类型变量时，不会被垃圾回收处理。 操作数栈 就是用来存储操作数的栈，这里的操作数大部分就是方法内的变量 作用： 存储操作数 操作数栈可以方便指令顺序读取操作数 指令 含义 iload int型变量入栈 istore 栈顶数值存入局部变量 iadd 弹出栈顶两个操作数，并将求和的int值压入栈中 动态连接 java中的多态就是通过动态连接实现的 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用都是为了支持方法调用过程中的动态连接 连接是将部分符号引用替换为直接引用，对于有些方法，JVM并不能判断它们的具体实现，只有在真正运行的时候，才可以根据实际类型进行连接，这就是动态连接 本地方法栈本地方法是由非java语言实现的函数，一般是一些和操作系统底层相关的函数","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"JavaScript-模块化开发","slug":"JavaScript-模块化开发","date":"2022-03-16T12:34:07.000Z","updated":"2022-10-04T13:53:00.487Z","comments":true,"path":"前端/JavaScript/2022/03/16/JavaScript-模块化开发/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/JavaScript/2022/03/16/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"javaScript模块化 什么是模块化？ 即将一个复杂的程序依据一定的规则(规范)封装成几个块(文件)，并用规定语法将其组合在一起，块的内部数据&#x2F;实现是私有的,只是向外部暴露一些接口(方法)与外部其他模块通信 以前的代码 全局模式 123456function foo()&#123; &#125;function abc()&#123; &#125; 问题：所有的函数都被绑定在了window上，容易产生命名冲突和产生对window的污染 namespace模式 将函数或者数据绑定在对象上 123456789let obj = &#123; k: &#x27;asd&#x27;, foo()&#123; console.log(this.k) &#125;, abc()&#123; &#125;&#125; 问题：对象中的数据可以随意被修改，所以数据不安全 IIFE(Immedicately-invoked-function-expression) 该方法就是利用函数的作用域和即使函数的特性 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=&#123;foo&#125;&#125;)(window);-----------------------------module.foo(); 或者 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=foo&#125;)(window);-----------------------------module(); IIFE就是现代化模块化的基石 模块化的好处 避免命名冲突 根据功能点进行更好的分离 更高的复用性 高可维护性 但是以此同时就出现了问题 一个页面需要引入多个js文件，如果多个文件之间有依赖关系，先后顺序的错误就会导致报错 请求过多 依赖模糊 难以维护 这时候我们就需要引入一种模块化的规范来避免这种问题，下面我们来看看有哪些模块化规范 模块化的规范 CommonJS（nodejs就是基于这种规范） AMD （用的少） CMD（阿里的人写的。用的少） ES6 CommonJS说明： 每一个文件都是一个模块 服务器端：模块的加载是运行时同步加载的 浏览器端：需要自己编译打包将所有的模块js合并到一个js中 定义模块： 123456module.exports=&#123;&#125;---expoets.foo = function()&#123; &#125;exports.n = 2 引入模块： 1234let module1 = require(..)// 这里的..// 引入第三方的包 直接写包名// 引入自己写的js 写路径 服务器端例子： 先创建项目结构 123456-modules --module1.js --module2.js --module3.js-app.js-package.json module1.js 12345module.exports = &#123; foo()&#123; console.log(`&#x27;module1&#x27;s foo()`) &#125;&#125; module2.js 123456exports.foo = function()&#123; console.log(`&#x27;module2&#x27;s foo()`)&#125;exports.abc = function()&#123; console.log(`&#x27;module2&#x27;s abc()`)&#125; module3.js 123module.exports = function()&#123; console.log(`&#x27;module3&#x27;s foo()`)&#125; app.js 12345678let module1 = require(&#x27;./modules/module1.js&#x27;)let module2 = require(&#x27;./modules/module2.js&#x27;)let module3 = require(&#x27;./modules/module3.js&#x27;)module1.foo()module2.foo()module2.abc()module3() package.json 1234&#123; name: &#x27;applicationname&#x27;,// 这里写项目名字，不能有大写字母，不能有中文 version: &#x27;1.0.0&#x27;&#125; 可以使用npm init生成该文件 客户端例子： 结构树如下 123456789-test --dist --src ---module1.js ---module2.js ---module3.js ---app.js --index.html --package.json js代码如上 下载编译工具 12npm install browserify -g # 全局安装npm install browserify --save-dev # 开发依赖，在上线阶段不需要此工具了 使用该工具 1browserify src/app.js -o dist/budle.js index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&#x27;./dist/budle.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; AMD说明：AMD(（Asynchronous Module Definition）)专门用户浏览器端，模块的加载是异步的 此规范依赖于一个Require.js 基本语法： 定义模块： 12345678// 没有依赖其他模块define(function()&#123; return 模块&#125;)// 定义有依赖的模块define([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; return 模块&#125;) 引入模块 123456require([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;)requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;) 例子： 目录结构 12345678910-test --js ---libs ----require.js//这是引入的第三方js ---modules ----module1.js ----module2.js ----modlue3.js ---main.js --index.html mudule1.js 1234567define(function()&#123; lett msg = &#x27;module1&#x27;; function foo()&#123; console.log(msg) &#125; return &#123;foo&#125;&#125;) module2.js 1234567define([&#x27;module1&#x27;],function(m1)&#123; let msg = &#x27;module2.js&#x27; function foo()&#123; console.lopg(msg,m1.foo()) &#125; return &#123;foo&#125;&#125;) main.js 12345678910111213(function()&#123; require.config(&#123; baseUrl: &#x27;js/&#x27;, path: &#123; module1: &#x27;./modules/module1.js&#x27;, module2: &#x27;./modules/module2.js&#x27; jquery: &#x27;./libs/jquery.js&#x27;//引入第三方库，不是所有的第三方库都支持AMD语法 &#125; &#125;) requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; m1.foo(); &#125;)&#125;)() 页面中只要引入该标签即可 1&lt;script data-main=&quot;js/main.js&quot; src=js/libs/require.js&gt;&lt;/script&gt; ES6规范说明：该规范也需要编译打包处理，先使用babel将ES6转化为ES5，然后使用browserify将其并为一个js文件 基本语法： 导出模板： 1234567891011121314151617181920212223export function foo()&#123; &#125;export function abc()&#123; &#125;------------------------------------------------------------------------------------------------------function foo()&#123; &#125;function abc()&#123; &#125;export &#123;foo,abc&#125;------------------------------------------------------------------------------------------------------export default &#123; function foo()&#123; &#125; function abc()&#123; &#125;&#125; 引入模块： 12345// 常规导出，这边用对象接import &#123;&#125; from &#x27;路径&#x27; //自己的js// 默认导出，这边用变量来接impoet module from &#x27;路径&#x27; 例子： 项目结构 123456789101112-test --js ---dist ---build ---src ----module1.js ----module2.js ----module3.js ----main.js --index.html --.babelrc --package.json 安装依赖 12345npm install browserify --save-devnpm install babel-cli -gnpm install babel-preset-es2015 --save-dev 创建.babelrc rc就是run control运行时控制文件 123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; module1.js 123456export function foo()&#123; &#125;export function abc()&#123; &#125; module2.js 1234567function f1()&#123; &#125;function f2()&#123; &#125;export &#123;f1,f2&#125; module3.js 12345678export default &#123; function d1()&#123; &#125; function d2()&#123; &#125;&#125; main.js 123456789import &#123;foo,abc&#125; from &#x27;./module1.js&#x27;import &#123;f1,f2&#125; from &#x27;./module2.js&#x27;import module3 from &#x27;./module3.js&#x27;foo();abc();f1();module3.d1();module3.d2(); es6转es5 1babel js/src -d js/build 这里如果出现这个错误： 1babel : 无法加载文件 C:\\Users\\win\\AppData\\Roaming\\npm\\babel.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/ go.micros 那么你输入以下命令一定是这样的 12get-ExecutionPolicy# restricted 这时候，先使用管理员身份打开Windows Powershell然后输入以下命令 12set-ExecutionPolicy RemoteSigned然后输入y回车 合并文件 1browserify js/build/main.js -o js/dist/bundle.js index.html导入js 1&lt;script src=&quot;js/src/dist/bundle.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"JVM-内存模型","slug":"JVM-内存模型","date":"2022-03-12T02:41:34.000Z","updated":"2022-10-04T13:53:24.374Z","comments":true,"path":"javaEE/JVM/2022/03/12/JVM-内存模型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/12/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"内存模型硬件的内存模型在讲java内存模型之前，先来看看硬件的内存模型 CPU的处理速度和内存的读写不是一个数量级的，所以在CPU和主存之间加上了一层缓存 这种结构在单CPU的时候，处理的很好 但是当多CPU的时候， 这时候就会出现缓存一致性问题 当CPUA读取主存中的数据之后，对其进行修改，在将其刷新回主存的之前，CPUB读取主存中的数据，对其进行修改，将其刷新回主存，这时候CPUA也同时将其修改后的数据刷新回主存，那么这个数据到底以哪一个为准，这个就是缓存一致性问题 针对这个问题，就出现了缓存一致性协议 1、窥探性 2、目录型 有了这一层协议，在硬件层面，就解决了缓存一致性问题，即汇编语言能够运行在一个具有缓存一致性的内存视图中 Java的内存模型设计编程语言的内存模型是为了能够该语言也可以拥有一个内存一致性的视图，于是在硬件内存模型之上，就有了高级语言的内存模型 Java内存模型就屏蔽了各种硬件的操作系统的内存差异，使得java可以正常的运行在各大操作系统上 虚拟机栈也可以叫做java方法栈，该栈中存放8大基础类型的数据和对象的引用 堆中存放着所有的java对象 内存读写指令 作用于主存 作用于工作内存 lock：锁定 load：加载数据 unlock：解锁 store：存储数据 read：读取 use：使用数据 write：写入 assign：赋值 上面的图只是一种理想状态，会出现以下两种问题 1、可见性 当线程A将本地内存中的数据修改后，刷新回主存后，线程B直接使用本地内存中的数据，没有使用刷新后的数据，这就是可见性问题 2、原子性 当线程A修改了数据，还没刷新回主存，线程B也修改了数据，也要刷新回主存，那么这时候主存中应该刷新成哪个线程修改后的值呢 线程通信之间的同步问题，当多个线程在并发操作同一个数据的时候，会引发很多的问题，这些问题被总结为并发三要素 1、可见性 2、原子性 3、有序性 可见性当一个线程修改了共享变量的值之后，其他所有使用该变量的线程都应该立刻得知此修改 两层含义 第一种含义 线程A修改了数据X，线程B需要使用到最新的数据X（这是线程B没有重新读取主存导致的） 12345678910111213141516public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 控制台不会返回响应码，而是一直死循环。 当thread1开始循环的时候，本地内存中a=1，当thread2修改了a为0的时候，thread1并不知道，而是一直使用着a=1，所以会一直循环 两种解决方法 1、将a变量加一个修饰词volatile 如果一个共享变量被volatile修饰，那么该共享变量被修改后，将会直接写入主存，当其他线程读取该共享变量的时候，也会直接从主存中读取 2、使用synchronized包裹，并使用该数据 synchronized块中读写变量会隐式调用lock和unlock指令 123456789101112131415161718public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; synchronized(this)&#123; int b = a + 1; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 第二层含义 线程B需要读取到线程A修改后的数据x，但是因为指令重排，在线程A未修改数据x之前，线程B读到了数据x 123456789101112131415161718public class Demo2 &#123; static int a =0; static boolean b =false; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; a = 1;//1 b = true;//2 &#125;); Thread thread2 = new Thread(() -&gt; &#123; if (b) &#123;//3 int x = a;// 4 // 这个x一定是1吗? System.out.println(x); // 5 &#125; &#125;); thread1.start(); thread2.start(); &#125;&#125; 在硬件内存模型的时候就说过，在底层会存在指令重排的情况， 我们觉得的顺序应该是 1-&gt;2-&gt;3-&gt;4 但是在编译后顺序有可能就变成了 2-&gt;3-&gt;4-&gt;1 这也是一种可见性的问题 同样的这里我们也可以使用上述两种方法来解决这种问题 volatile是禁止了当前变量与之前的代码语句进行指令重排 synchronized就是将两段代码分别捆绑在一起，那么无论在thread1中怎么指令重排，都不会影响thread2对于变量的读取 Happens-Before原则我们平时很少遇到可见性问题，因为我们站在了前人的肩膀上，设计内存模型的前辈已经帮我们解决了此问题，这就是Happens-Before原则 定义：对于两个操作A和操作B，这两个操作可以在不同的线程中执行，如果A Happens-Before B（即A先于B执行），那么可以保证当A操作执行完后，A操作的执行结果对B操作是可见的 程序顺序原则 锁定原则 volatile原则 线程启动原则 线程结束原则 中断规则 终结器规则 传递性原则 原子性一个操作要么全部执行成功，要么全部执行失败 1、单指令原子操作 2、利用锁的组合指令原子操作 有序性指令重排在单线程环境下不会出现什么问题，但是在多线程环境下，可能导致有的代码执行顺序修改后可能会导致与顺序执行的结果不同 这里可以使用Happens-Before原则来解决问题","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"JVM-类加载器","slug":"JVM-类加载器","date":"2022-03-11T14:47:01.000Z","updated":"2022-10-04T13:53:16.497Z","comments":true,"path":"javaEE/JVM/2022/03/11/JVM-类加载器/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/11/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"类的加载过程类的加载过程分三个阶段 类的加载 &#x3D;&#x3D;》类的链接 &#x3D;&#x3D;》类的初始化 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中（方法区）生成一个代表该类的Class对象，作为类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程 类构造器方法是由编译期按顺序收集类中所有类变量的赋值动作和静态代码块中的语句合并而成的（类构造器是构造类信息的，不是对象构造器） 当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 JVM会保证类构造器在多线程环境下被正确加锁 类的链接为黑盒实现 类的主动引用（一定会发生类的初始化） 当JVM启动的时候，先初始化main方法所在的类 new 一个类的对象 调用该类的静态成员（除了final）和静态方法 使用反射对其类进行反射调用 当初始化一个类时，其父类若没有初始化，则先初始化其父类 类的被动引用（不会发生类的初始化） 当访问一个静态域的时候，只有真正声明该域的类才会被初始化。举个栗子：当通过子类调用父类的静态变量，该子类是不会被初始化的 通过数组定义类引用，不会导致初始化 引用常量不会导致初始化 类加载器市面上有三种JVM，不同的JVM对类加载器的实现是不同的，我们主要学习的并且使用的是Sun公司的HotSpot 类加载器的作用就是将类（class）装进内存的 JVM规定了以下类型的加载器 引导类加载器：用C++编写的，是JVM自带的类加载器，负责java平台的核心库，用来装载核心类库，该加载器无法直接获取（获取的时候会是null） 扩展类加载器（ExtClassLoader）：负责**&#x2F;lib&#x2F;etc**目录下的jar包户或者 -d java.ext.dirs指定目录下的jar包装入工作库 系统类加载器（AppClassLoader）：负责java -classpath或者java.class.path指定目录下的类与jar包 用户加载器（User ClassLoader）：用户自定义的加载器 扩展类加载器、系统类加载器、用户加载器都是继承自java.lang.ClassLoader JVM规范：每个类加载器都有属于自己的命名空间 双亲委派机制检查顺序从下至上，加载顺序从顶至下 举个栗子：我写了一个Student类，我要加载它需要经过以下过程 先将该任务委托给AppClassLoader AppClassLoader很懒，它不想加载，将任务向上委托给ExtClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，但是在自己管理的lib目录下并没有找到该类，只能将任务再次交给ExtClassLoader去加载 那ExtClassLoader没法偷懒了，只能在自己管理的ext目录下找该类，但是也没有找到，只能将任务继续向下转交给AppClassLoader AppClassLoader不得不自己去尝试加载该类，于是加载成功 既然最后还是AppClassLoader去加载Student类何必绕一个大圈子呢？ 这是为了防止原始类被用户写的类所覆盖。 再举个栗子：我自己写了一个String类，我要加载它会经历以下过程 先将该任务委托给AppClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，于是在自己管理的lib目录下找到该类并加载，将加载结果向下一直传递到用户 对双亲委派模型的破坏1、自定义类加载器 我们写一个类继承java.lang.ClassLoader，重写loadClass方法，双亲委派的逻辑就在这个方法中，但是我自定义的类加载器可以不这么写，也就破坏了双亲委派。在jdk1.2之后，jdk增加了一个findClass方法提供给上层重写，也就有效地防止了双亲委派被破坏 1234567891011121314151617181920212223public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader myClassLoader = new ClassLoader()&#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try&#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if(is==null)&#123; return super.loadClass(name); &#125; byte[] buffer = new byte[is.available()]; is.read(buffer); return defineClass(name,buffer,0, buffer.length); &#125;catch (Exception e)&#123; e.printStackTrace(); throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object o = myClassLoader.loadClass(&quot;com.test.A&quot;).newInstance(); System.out.println(o.getClass()); System.out.println(o instanceof com.test.A);&#125; 控制台输出 12class com.test.Afalse 这不仅破坏了双亲委派，并且证明了每个类加载器都有自己的命名空间 2、SPI（Service Provider Interface）服务发现机制 JDK中定义了JDBC的接口，规范各大厂家。对于JDK中的接口，使用的是BootstrapClassLoader但是对于各大厂家的实现类，使用的是ApplClassLoader 1234567891011121314151617181920212223242526272829303132333435@CallerSensitivepublic static Driver getDriver(String url) throws SQLException &#123; println(&quot;DriverManager.getDriver(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); ensureDriversInitialized(); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); // Walk through the loaded registeredDrivers attempting to locate someone // who understands the given URL. for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if (isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if (aDriver.driver.acceptsURL(url)) &#123; // Success! println(&quot;getDriver returning &quot; + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.driver.getClass().getName()); &#125; &#125; println(&quot;getDriver: no suitable driver&quot;); throw new SQLException(&quot;No suitable driver&quot;, &quot;08001&quot;);&#125; 123456@CallerSensitivepublic static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 当前线程的ClassLoader默认为AppClassLoader ClassLoader cl = Thread.currentThread().getContextClassLoader(); return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);&#125; 3、热部署","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"【25-Hard】以k个节点为一组逆转单链表","slug":"【25-Hard】以k个节点为一组逆转单链表","date":"2022-03-08T07:00:11.000Z","updated":"2023-03-06T06:45:54.545Z","comments":true,"path":"算法/刷题篇/2022/03/08/【25-Hard】以k个节点为一组逆转单链表/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/08/%E3%80%9025-Hard%E3%80%91%E4%BB%A5k%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%BA%E4%B8%80%E7%BB%84%E9%80%86%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"以k个节点为一组逆转单链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶： 你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 12输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5] 示例 2： 12输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5] 示例 3： 12输入：head = [1,2,3,4,5], k = 1输出：[1,2,3,4,5] 示例 4： 12输入：head = [1], k = 1输出：[1] 提示： 列表中节点的数量在范围 sz 内 1 &lt;= sz &lt;= 5000 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= sz Related Topics 递归 链表 递归首先我们来分析一下这道题目，题目不难理解，就是以k个节点为一组逆转单链表，我们使用递归的思想来思考一下这道题 首先需要一个逆转前n个节点的方法 方法签名：public ListNode reverseKNode(ListNode head,int k) 123456789101112ListNode processor;// 这里的k要保证不超过链表长度public ListNode reverseKNode(ListNode head,int k)&#123; if(k == 1)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode1(head.next, k-1); head.next.next = head; head.next = processor; return node;&#125; 在此基础上写出逆转head到end之间的节点 方法签名：public ListNode reverseKNode(ListNode head,ListNode end) 123456789101112ListNode processor;// [head,end)public ListNode reverseKNode(ListNode head,ListNode end)&#123; if(head.next == end)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode(head.next, end); head.next.next = head; head.next = processor; return node;&#125; 最后就是成组逆转单链表 方法签名：public ListNode reverseKGroup(ListNode head, int k) 12345678910111213141516171819202122public ListNode reverseKGroup(ListNode head, int k)&#123; ListNode node = head; for (int i = 0; i &lt; k; i++) &#123; if(node==null)&#123; return head; &#125; node=node.next; &#125; ListNode newHead = reverseKNode(head,k,node); head.next=reverseKGroup(node,k); return newHead;&#125;private ListNode reverseKNode(ListNode head,int k,ListNode tail)&#123; if(k==1)&#123; return head; &#125; ListNode newHead=reverseKNode(head.next,k-1,tail); head.next.next=head; head.next=tail; return newHead;&#125; 迭代首先需要一个逆转前n个节点的方法 方法签名：public ListNode reverseKNode(ListNode head,int k) 123456789101112public ListNode reverseKNode(ListNode head,int k)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur!=null &amp;&amp; k--!=0)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; 在此基础上写出迭代逆转head到end之间的节点 方法签名：public ListNode reverseKNode(ListNode head,ListNode end) 12345678910111213public ListNode reverseKNode(ListNode head,ListNode end)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur != end)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; 最后就是成组逆转单链表 方法签名：public ListNode reverseKGroup(ListNode head, int k) 12345678910111213141516171819202122232425public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode end = head; for (int i = 0; i &lt; k; i++) &#123; // 如果长度不足k，则直接返回头部，不用逆转 if(end==null)&#123; return head; &#125; end = end.next; &#125; ListNode newHead = reverseKNode(head, k); head.next = reverseKGroup(end, k); return newHead;&#125;public ListNode reverseKNode(ListNode head, int k)&#123; ListNode prev=null; ListNode cur=head; ListNode suffix; while(cur!=null&amp;&amp;k--!=0)&#123; suffix=cur.next; cur.next=prev; prev=cur; cur=suffix; &#125; return prev;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript-原型和原型链","slug":"JavaScript-原型和原型链","date":"2022-03-05T12:18:26.000Z","updated":"2022-09-27T14:15:19.311Z","comments":true,"path":"前端/JavaScript/2022/03/05/JavaScript-原型和原型链/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/JavaScript/2022/03/05/JavaScript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链prototype在JavaScript中，所有的函数都有一个prototype属性，该属性指向该函数的原型对象 12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.name = &#x27;kerwin&#x27;;let p1 = new Person();let p2 = new Person();console.log(p1.name);// kerwinconsole.log(p2.name);// kerwin 函数的prototype指向的就是对象原型，这个对象是调用构造函数时创建实例的原型对象，就是说p1和p2的原型对象是同一个 _proto_每个对象都会有一个属性，叫做_proto_，该属性指向该对象的原型对象，也就是构造函数的原型属性指向的对象 constructor每个原型都有一个constructor属性，指向该对象的构造函数 12345678910function Person()&#123; &#125;let person = new Person();console.log(Person.prototype._proto_ ==== Person);// trueconsole.log(person._proto_ === Person.prototype);// true// 在person中找不到constructor属性，所以向上在原型中找到该属性console.log(person.constructor === Person);// trueconsole.log(person.constructor === Person.prototype.constructor);console.log(person.constructor === person._proto_.constructor) 实例与原型当读取实例中的属性的时候，如果不存在该属性，则会去查找该对象的原型对象中是否存在该属性，如果不存在，则一直向上查找，一直找到最顶部为止 12345678910function Person(age)&#123; this.age = age;&#125;Person.prototype.name = &#x27;zhima&#x27;;let p1 = new Person();person.name = &#x27;kerwin&#x27;console.log(p1.name);// kerwin// 删除person对象中的name属性delete person.nameconsole.log(p1.name);// zhima 可以看到p1的name属性 显示输出了自身的属性值kerwin 当删除了对象中name属性之后，输出的是原型中的数据 原因是当对象内部不存在该属性的时候，会向上在原型中找属性，所以会输出kerwin 原型的原型原型是随着使用构造函数创建对象时，生成的一个对象。 那么原型也是一个对象，既然是一个对象，那么它一定也有原型 它的原型其实是通过Object对象的构造函数创建的 原型链简单回顾一下之前的知识点， prototype是每个函数的一个属性，指向原型对象 _proto_是每一个对象的一个属性，指向原型对象 constructor是每一个原型对象的一个属性，指向其绑定的构造函数 1每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎么样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层次递进，就构成了原型和实例的链条，这就是所谓的原型链的概念 ----------《摘自JavaScript高级程序设计》 那Object.prototype的原型是什么呢？是null 图中蓝色的线就是原型链","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2022-03-02T10:06:48.000Z","updated":"2022-03-02T10:41:36.988Z","comments":true,"path":"设计模式/2022/03/02/设计模式-观察者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式定义：定义了对象之间的一对多依赖，让多个观察者监听同一个对象的行为，当该行为发生的时候，则做出一定的动作 天气变化了，发出提示 天气模型 1234567891011121314151617181920@Data@NoArgsConstructor@AllArgsConstructorpublic class Weather &#123; private String address; private Integer temperature; private List&lt;Observer&gt; observers; public void addObserver(Observer observer)&#123; observers.add(observer); &#125; public void removeObserver(Observer observer)&#123; observers.remove(observer); &#125; public void changeTemperature(int temperature)&#123; this.temperature=temperature; for (Observer observer : observers) &#123; observer.update(temperature); &#125; &#125;&#125; 观察者的接口 123public interface Observer &#123; void update(Integer temperature);&#125; 邮件的观察者 1234567public class EmailObserver implements Observer &#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发邮件告诉用户天气改变了，变为了&quot;+temperature); &#125;&#125; 短信观察者 123456public class MsgObserver implements Observer&#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发短信告诉用户气温改变了，变为了&quot;+temperature); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模板方法模式","slug":"设计模式-模板方法模式","date":"2022-03-02T09:24:31.000Z","updated":"2022-03-02T10:06:27.982Z","comments":true,"path":"设计模式/2022/03/02/设计模式-模板方法模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法模式定义：定义一个操作的算法骨架，将一些操作延迟到子类实现。Template Method使得子类可以在不改变算法结构的基础上即可重新定义算法的某些特定步骤 其实该模式很简单，就是定义一个抽象类，然后定义一个抽象方法给子类去实现。 处理器 12345678910public abstract class Handler &#123; public void operation()&#123; System.out.println(&quot;做前期准备&quot;); System.out.println(&quot;准备就绪，开始处理&quot;); doHandler(); System.out.println(&quot;处理完毕&quot;); &#125; abstract void doHandler();&#125; 字符处理器 123456public class CharHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;将字符串转化&quot;); &#125;&#125; 字符串处理器 123456public class StringHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;字符串转化&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式-策略模式","date":"2022-03-02T04:11:02.000Z","updated":"2022-03-02T10:19:04.792Z","comments":true,"path":"设计模式/2022/03/02/设计模式-策略模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式的变化独立于算法的使用者 有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 下面使用策略模式来优化 Version 1.2策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","slug":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","date":"2022-03-01T08:49:22.000Z","updated":"2023-03-06T06:46:28.764Z","comments":true,"path":"算法/刷题篇/2022/03/01/【34-Medium】在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/01/%E3%80%9034-Medium%E3%80%91%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 Related Topics 数组 二分查找 二分查找1234567891011121314151617181920212223242526class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int first = binarySearch(nums, target); if (first == -1) &#123; return new int[]&#123;-1, -1&#125;; &#125; return new int[]&#123;first, binarySearch(nums, target + 1) - 1&#125;; &#125; private int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) &#123; right = mid - 1; &#125; else if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-装饰者模式","slug":"设计模式-装饰者模式","date":"2022-03-01T03:31:14.000Z","updated":"2022-09-27T13:57:13.096Z","comments":true,"path":"设计模式/2022/03/01/设计模式-装饰者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰者模式定义：在不改变原有对象的基础上，将功能附加到对象上 这个其实大家在平时写代码的时候就已经用过了，只是不知道这是一个模式 下面看一个案例 有一个组件的接口，然后我有一个具体的实现类，现在我需要在这个具体实现类的基础上进行功能拓展 组件接口 123public interface Component &#123; void operation();&#125; 具体接口实现 123456public class ConcreteComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;实现组件功能&quot;); &#125;&#125; 拓展功能抽象类 12345678public abstract class EnhanceComponent implements Component&#123; protected Component component; public EnhanceComponent(Component component) &#123; this.component = component; &#125;&#125; 具体增强类 1234567891011public class ConcreteEnhanceComponent extends EnhanceComponent&#123; public ConcreteEnhanceComponent(Component component) &#123; super(component); &#125; @Override public void operation() &#123; component.operation(); System.out.println(&quot;拓展功能一&quot;); &#125;&#125; 优点： 不改变原有代码的情况下，对原来的类进行增强 使用不同的组合可以实现不同的人效果 符合开闭原则","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-适配器模式","slug":"设计模式-适配器模式","date":"2022-03-01T03:10:43.000Z","updated":"2022-03-01T03:30:45.584Z","comments":true,"path":"设计模式/2022/03/01/设计模式-适配器模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式定义：将一个类的接口转换为用户希望的另一个接口。这使得原本由于接口不兼容而不能一起工作的那些类就可以一起工作了 接下来我们来模拟USB转接网线口，从而使电脑上网的案例 网线接口 123public interface NetWorkThread &#123; void connectNetWork();&#125; 华为的网线 123456public class HuaWeiNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;华为网线连接网络，可以上网了&quot;); &#125;&#125; 自制的网线 123456public class CustomerNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;自制网线，可以上网了&quot;); &#125;&#125; 适配器（网线口变为USB口） 123public interface Adapter &#123; void netWorkToUSB();&#125; 华为的适配器（转接口） 1234567891011121314151617public class HuaWeiAdapter implements Adapter&#123; private NetWorkThread netWorkThread; public void setNetWorkThread(NetWorkThread netWorkThread) &#123; this.netWorkThread = netWorkThread; &#125; @Override public void netWorkToUSB() &#123; if(netWorkThread==null)&#123; System.out.println(&quot;适配器没有网线插入！&quot;); return; &#125; System.out.println(&quot;华为适配器适配了网线&quot;); netWorkThread.connectNetWork(); &#125;&#125; 电脑 123456789101112131415public class Computer &#123; private Adapter adapter; public void setAdapter(Adapter adapter) &#123; this.adapter = adapter; &#125; public void connectToNetWork()&#123; if(adapter!=null)&#123; adapter.netWorkToUSB(); &#125;else &#123; System.out.println(&quot;没有插网线！&quot;); &#125; &#125;&#125; 客户端 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); HuaWeiAdapter huaWeiAdapter = new HuaWeiAdapter(); computer.setAdapter(huaWeiAdapter); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); huaWeiAdapter.setNetWorkThread(new HuaWeiNetWorkThread()); computer.connectToNetWork(); &#125;&#125; 控制台输出 123456没有插网线！===================适配器没有网线插入！===================华为适配器适配了网线华为网线连接网络，可以上网了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【5-Medium】最长回文数","slug":"【5-Medium】最长回文数","date":"2022-02-28T13:24:51.000Z","updated":"2023-03-06T06:45:38.796Z","comments":true,"path":"算法/刷题篇/2022/02/28/【5-Medium】最长回文数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/28/%E3%80%905-Medium%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"最长回文数给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 Related Topics 字符串 动态规划 法一：暴力枚举123456789101112131415161718192021222324252627282930class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)&#123; return s; &#125; char[] chars = s.toCharArray(); int begin = 0; int end = 0; for (int i = 0; i &lt; s.length() - 1; i++) &#123; for (int j = i+1 ; j &lt; s.length(); j++) &#123; if((j - i + 1) &gt; (end - begin + 1) &amp;&amp; isValid(chars,i,j))&#123; begin = i; end = j; &#125; &#125; &#125; return s.substring(begin, end+1); &#125; private boolean isValid(char[] chars, int left, int right) &#123; while(left &lt; right)&#123; if(chars[left] != chars[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125; 法二：中心扩散将每”一位”作为中心向两边扩撒， 每次扩散分两种情况， 第一种情况是以当前那一位为中心向两边扩散 第二种情况是以当前那一位和下一位为中心向两边扩散 取这两种情况的最值max 如果max比maxLen大的话，计算得出begin‘ 最后直接返回截取的字符串 这是我的解法 12345678910111213141516171819202122232425class Solution &#123; public String longestPalindrome(String s)&#123; if (s.length() &lt; 2) &#123; return s; &#125; int begin = 0; int maxLen = 1; for (int i = 0; i &lt; s.length(); i++) &#123; int max = Math.max(expand(s,i,i),expand(s,i,i+1)); if(max &gt; maxLen)&#123; maxLen = max; begin = i - (max - 1)/2; &#125; &#125; return s.substring(begin, maxLen+begin); &#125; public int expand(String s, int left, int right) &#123; while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; return right - left - 1; &#125;&#125; 这是官方的解法 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) &#123; return &quot;&quot;; &#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 法三：动态规划对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。 例如对于字符串 “ababa’”，如果我们已经知道 “bab” 是回文串这层关系，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是a 使用dp[][]二位数组来存储这层关系 即使用dp[i][j]来表示s字符串的i到j是否是回文数 如果当前要判断的范围是dp[left][right]，字符串长度为x 第一步先看首尾是否一致， 如果不一致，则dp[left][right]直接为false， 如果一致，则进入下一步判断 如果当前判断的字符串长度小于3 为什么是3呢？ 如果长度为1，则本身就是字符串，形成自回文 如果长度为2，则首尾一致的情况下，可以直接判断为回文 如果长度为3，则首尾一致的情况下，也可以直接判断回文 这三组数据是后面做判断的支撑 则直接将dp[left][right]赋值为true 反之将dp[left+1][right-1]（即去掉首尾的时候是否为回文数）的回文结构赋值给dp[i][j] 这些结束后，当dp[left][right]是true时， 则将当前循环长度和存储的maxLen进行比较， 如果当前循环长度较大，则将其赋值给maxLen，将left赋值给begin 反之，直接进行下一次循环 官方代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) &#123; // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) &#123; // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) &#123; break; &#125; if (charArray[i] != charArray[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125;&#125; 下面是我理解思路后写的 对于变量的命名更贴近其本身的含义 可能会更好理解一点 1234567891011121314151617181920212223242526272829303132333435363738public String longestPalindrome1(String s) &#123; int len = s.length(); if(len &lt; 2)&#123; return s; &#125; int begin = 0; int maxLen = 1; char[] chars = s.toCharArray(); boolean[][] dp = new boolean[len][len]; // dp[i][j]即表示s[i..j]是否为回文数 // 对角线即为每个字符本身那就可以直接初始化为true // 也可以不初始化这个，但是为了语义完整，最好还是加上 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; //x表示长度，从长度为2开始，因为长度为1的情况可以直接判断 for (int x = 2 ; x &lt;= len; x++) &#123; //循环次数为总长度减当前循环的长度再加一 for (int left = 0; left &lt; len - x + 1; left++) &#123; //x=right-left+1 int right = x + left - 1; if(chars[left] != chars[right])&#123; dp[left][right] = false; &#125;else &#123; if(x &lt; 4)&#123; dp[left][right] = true; &#125;else &#123; dp[left][right] = dp[left+1][right-1]; &#125; &#125; if(dp[left][right] &amp;&amp; x &gt; maxLen)&#123; begin = left; maxLen = x; &#125; &#125; &#125; return s.substring(begin, maxLen+begin);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于权限修饰符protected","slug":"关于权限修饰符protected","date":"2022-02-28T10:05:05.000Z","updated":"2022-10-04T13:56:03.490Z","comments":true,"path":"琐碎的知识/2022/02/28/关于权限修饰符protected/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/28/%E5%85%B3%E4%BA%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6protected/","excerpt":"","text":"权限修饰符我们先回顾一下java中的权限修饰符 权限修饰符 同类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 对于public和private大家都很了解了，但是对于protected，大家可能对它的概念可能就一句话：被protected修饰的成员对于本包和其子类可见。 该权限修饰符的关键是 基类的protected成员属性是包内可见的，并且对所有子类可见 若子类与基类不在同一包下，则在子类中，子类实例可以访问从基类继承来的protected方法，而不能访问基类实例的protected方法 遇到protected 首先思考这个protected来自何方 接着看其和这个地方是不是同包 最后看其是否有父子类关系 可以通过以下几个Test来掌握protected的用法 注意：观察包限定名 模型 12345678910package com.lizhi.protect.p1;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 1234package com.lizhi.protect.p1;public class Son1 extends Feather1&#123;&#125; 123456package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;public class Son11 extends Feather1 &#123;&#125; 测试 1234567891011121314151617package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译通过，因为该测试类与Feather1处于同一包下 son1.clone();//编译通过，因为该测试类与Feather1处于同一包下 son2.f();//编译通过，因为该测试类与Feather1处于同一包下 son2.clone();//编译通过，因为该测试类与Feather1处于同一包下 feather1.f();//编译通过，因为该测试类与Feather1处于同一包下 feather1.clone();//编译通过，因为该测试类与Feather1处于同一包下 &#125;&#125; 测试 12345678910111213141516171819package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 &#125;&#125; 测试 123456789101112131415161718package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;public class Son11 extends Feather1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类所在的地方是Feather1的子类 son2.clone();//编译通过，因为该测试类所在的地方是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 &#125;&#125; 测试 1234567891011121314151617181920212223package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类是Son1和Son11的父类 son2.clone();//编译通过，因为该测试类是Son1和Son11的父类 feather1.f();//编译通过，因为该测试类是Son1和Son11的父类 feather1.clone();//编译通过，因为该测试类是Son1和Son11的父类 son1.f();//编译通过，因为该测试类是Son1和Son11的父类 son1.clone();//编译通过，因为该测试类是Son1和Son11的父类 &#125;&#125; 测试 12345678910package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译不通过 &#125;&#125; 说明：myobject4的clone直接来自MyObject4类本身 其范围是MyObjcet4的子类与其同包的类 Test4都不满足 所以编译不通过 测试 1234567package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; &#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译通过 &#125;&#125; 说明：myobject4的clone直接来源于Test4 范围是Test4子类及其同包的类 满足与其同包 编译通过","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"设计模式-门面模式","slug":"设计模式-门面模式","date":"2022-02-28T00:38:22.000Z","updated":"2022-02-28T00:59:19.367Z","comments":true,"path":"设计模式/2022/02/28/设计模式-门面模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式定义：为子系统中的一组接口提供一个一致的高层接口，使得这一子系统更加容易使用 实现子系统1 12345public class System1 &#123; public void operateA()&#123; System.out.println(&quot;子系统1的A操作&quot;); &#125;&#125; 子系统2 12345public class System2 &#123; public void operateB()&#123; System.out.println(&quot;子系统2的B操作&quot;); &#125;&#125; 子系统3 12345public class System3 &#123; public void operateC()&#123; System.out.println(&quot;子系统3的C操作&quot;); &#125;&#125; 系统门面 1234567891011public class SystemFacade &#123; private System1 system1 = new System1(); private System2 system2 = new System2(); private System3 system3 = new System3(); public void operateABC()&#123; system1.operateA(); system2.operateB(); system3.operateC(); &#125;&#125; 客户端调用 12345public class Client &#123; public static void main(String[] args) &#123; new SystemFacade().operateABC(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-享元模式","slug":"设计模式-享元模式","date":"2022-02-26T05:05:48.000Z","updated":"2022-02-28T00:36:16.964Z","comments":true,"path":"设计模式/2022/02/26/设计模式-享元模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式定义：运用共享技术有效地支持大量细粒度的对象 优点：如果系统有大量类似的对象，可以节省大量的内存和CPU资源 实现场景：假如我要开发一款游戏，然后游戏里面的地图有很多树木 这个时候，我们不可能创建几万个树的对象 Tree 123456@Data@AllArgsConstructor@ToStringpublic class Tree &#123; private final String name;&#125; TreeNode 1234567@Data@AllArgsConstructorpublic class TreeNode &#123; private final Tree tree; private int x; private int y;&#125; TreeFactory 12345678910111213public class TreeFactory &#123; private static ConcurrentHashMap&lt;String, Tree&gt; map = new ConcurrentHashMap&lt;&gt;(); public static Tree getTree(String name)&#123; if(map.containsKey(name))&#123; return map.get(name); &#125; return null; &#125; public static void addTree(String name)&#123; map.put(name,new Tree(name)); &#125;&#125; 主函数 123456789public static void main(String[] args) &#123; TreeFactory.addTree(&quot;梧桐树&quot;); TreeFactory.addTree(&quot;香樟树&quot;); TreeFactory.addTree(&quot;银杏树&quot;); TreeFactory.addTree(&quot;面包树&quot;); TreeNode treeNode1 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,1); TreeNode treeNode2 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,2); TreeNode treeNode3 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,3);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis-缓存穿透和雪崩","slug":"Redis-缓存穿透和雪崩","date":"2022-02-25T13:37:11.000Z","updated":"2022-10-04T13:54:23.136Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-缓存穿透和雪崩/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"缓存穿透和雪崩缓存的时候，大大提高了应用程序的性能和效率，特别是数据查询方面。但同时，它带来好处的同时，也带来了问题。 缓存穿透和雪崩就是两个经典的问题，当然业界也已经有了比较流行的解决方案 缓存穿透（查不到）概念：缓存穿透的概念很简单，用户想要查询一个数据，发现Redis内存数据库中没有，也就是缓存没有命中，于是去持久层数据库查询。发现也没有，于是本次查询失败。当这种查询情况很多的时候，缓存都没有命中，都时去请求了持久层数据库。就是意味着该缓存无用，也就是缓存穿透。 解决方案： 布隆过滤器 布隆过滤器是一种数据结构，对所有能查询到的参数以hash的形式存储，在控制层先进行校验，不符合则该请求直接丢弃，从而解决问题 置空缓存 当存储层未命中的时候，及时返回的是null对象，缓存也将其存储起来同时设置一个过期时间，之后再从数据库中查询，保护了mysql 问题： 有可能会存放很多很多值为空的键值对，浪费文件 及时设置了过期时间，但是如果mysql在这个过期时间还没到的时候，已经有查询结果了，但是因为过期时间没到，却还是访问不了mysql，从而查询到数据 缓存击穿（查得太多了）概述：这里需要注意和缓存击穿的区别，缓存击穿，是指一个key在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。解决方案： 设置热点数据永不过期，从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 加互斥锁分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限 雪崩概念：指的是在某一时间段，缓存集中过期失效或者集中宕机 正常： 雪崩： 如果是自然key过期，倒是影响不大，但是如果是节点宕机或者断电，这就很有可能会将数据库冲垮 解决方案： redis集群 限流降级：在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程个数 数据预热：在正式部署前，先把可能的数据预先访问一遍，这样的话可能大量访问的数据就会加载到缓存中去，在即将发生高并发访问前，手动触发加载器缓存不同的key，设置不同的过期时间，让缓存过期时间点比较均匀","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-主从复制","slug":"Redis-主从复制","date":"2022-02-25T03:40:53.000Z","updated":"2022-10-04T13:54:59.148Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-主从复制/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"主从复制主从复制，是指将一台Redis服务器中的数据，复制到其他的Redis服务器上。 前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower) 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。 且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 作用主从复制的作用主要包括： 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。4、高可用（集群）基石：主从复制还是哨兵模式和部署集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，最少三台（一主二从） ​ 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大​ 2、从容量上，不能将一台服务所有内存用作Redis存储内存，单台Redis最大使用内存不应该超过20G。 配置子节点我们这里使用docker来做 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 复制两份配置文件给从节点镜像使用[root@iZbp18qscowpmxk6xpk38iZ redis]# lsredis-01.conf redis-02.conf redis.conf# 需要修改这三份文件，将绑定本地的配置注释掉，关闭安全模式# 分别以后台方式启动两个从节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-01.conf:/etc/redis/redis.conf --name=salveRedis01 redisa593c51bc1100e892f5d18c34ba5a05f637d1b3a4a29e5840cfeb18a633355f5[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-02.conf:/etc/redis/redis.conf --name=salveRedis02 redis08833de79be2cf719402b4f4cf42bf06d0f0a84a22e188f2b2f4d03f54ca48c1# 查看映射端口，这里一定一定要注意！！服务器要开安全组！！！不然就是连接失败哎！！！[root@iZbp18qscowpmxk6xpk38iZ redis]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa593c51bc110 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49169-&gt;6379/tcp salveRedis0108833de79be2 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49170-&gt;6379/tcp salveRedis020e9919007f5d redis &quot;docker-entrypoint.s…&quot; 38 minutes ago Up 2 minutes 0.0.0.0:49168-&gt;6379/tcp masterRedis# 查看主节点的基本信息[root@iZbp18qscowpmxk6xpk38iZ ~]# docker exec -it masterRedis redis-cli127.0.0.1:6379&gt; info replication# Replicationrole:master # 当前节点的角色connected_slaves:0 # 当前节点的子节点master_failover_state:no-failovermaster_replid:f37ca91dd3b3578e83031f9ea087d64f9994dd9amaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# 进入子节点1号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis01 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot; #说明连接成功，如果没开安全组的话，这一行会是connecting下一行是-1，表示连接失败5) (integer) 42# 进入子节点2号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis02 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot;5) (integer) 112# 查看父节点的基本信息127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2 # 两个子节点slave0:ip=116.62.151.26,port=6379,state=online,offset=112,lag=0slave1:ip=116.62.151.26,port=6379,state=online,offset=112,lag=1master_failover_state:no-failovermaster_replid:92ee701d04326eb2c74d8de1ea0fc2ec010f97dfmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:112# 在父节点测试是否数据同步127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set k1 v1OK# 子节点1号查询127.0.0.1:6379&gt; get k1&quot;v1&quot;# 子节点2号查询127.0.0.1:6379&gt; get k1&quot;v1&quot; 也可以在配置文件中配置父节点 123456# 配置主节点的ip的端口slaveof 主机ip 端口# 如果主机使用了config set masterauth password，或者主机配置文件中 requirepass password# 则这里配置文件就要加上主机的密码来验证masterauth password 主机可以写入也可以读取，但是从节点是不可以写入的，只可以读取主节点写入的值 12127.0.0.1:6379&gt; set k2 v2(error) READONLY You can&#x27;t write against a read only replica. 主机宕机了之后，从机依旧可以读，但是这样的话，就不能往里面写入数据了。 （这里需要使用哨兵模式，即当主机宕机后，从机中会选举出来一个主机，这样的话就保留了写入操作） 当主机恢复运行，则恢复写入功能 从机宕机的话，对主机没有任何影响 当从机运行后，就恢复主机中的数据 复制原理Slave 启动成功连接到 master 后会发送一个sync命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 主从连接的形式 一对多 链状 哨兵（Sentinel）模式该模式就是为了解决当主机宕机后，从机群无法有写入权限的问题。 该模式下，它会自动监控主机是否故障，当主机宕机后，从机群中会自立一个主机，从而就有了写入的功能 哨兵模式是一种特殊的模式，它是一个独立的进程。 其原理就是哨兵通过发送命令，等待redis服务器响应，从而监控多个Redis实例的功能 这里的哨兵有两个作用 监控服务器的状态 当主机宕机后，会自动选择一个子节点作为主机，然后通过发布订阅模式通知其他子节点，修改配置文件 当然，如果哨兵挂了怎么办？所以需要配置多个哨兵，然后这几个哨兵再互相监视 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行重新选举的过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 配置文件1234567891011121314151617181920212223242526272829303132# 哨兵进程的端口port 26379# 是否以后台运行daemonize no# 绑定的线程pidfile /var/run/redis-sentinel.pid# 日志名称logfile &quot;&quot;# 日志保存目录dir /tmp# 配置监视谁# 2代表至少要有结果哨兵确认主机宕机sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 30000acllog-max-len 128sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yesSENTINEL resolve-hostnames noSENTINEL announce-hostnames no 启动哨兵进程 1[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -d -p 49103:26379 -v /home/redis/sentinel.conf:/etc/redis/sentinel.conf --name=sentinel redis redis-sentinel /etc/redis/sentinel.conf 优点： 主从可以自动切换，可用性会更好 缺点： redis不好在线扩容 实现哨兵模式的配置优点麻烦","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-发布订阅","slug":"Redis-发布订阅","date":"2022-02-25T03:02:40.000Z","updated":"2022-10-04T13:54:19.293Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-发布订阅/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis发布订阅Redis发布订阅是一种消息通信的模式：发布者发送消息，订阅者接收消息 三个角色：消息发布者、消息接收者、订阅的频道 命令 作用 publish channel message 发布消息到指定频道 psubscribe pattern [pattern..] 订阅一个或者多个符合给点pattern的频道 pubsub subcommand [argument [argument..]] 查看订阅和发布系统状态 punsubscribe [pattern [pattern..]] 退订所有符合模式的频道 subscribe channel [channel..] 订阅指定频道 unsubscribe channel [channel..] 退订指定频道 下面直接上案例： 充当订阅者的cli 12345127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 1 充当发布者的cli 12127.0.0.1:6379&gt; PUBLISH study study(integer) 1 订阅者 12345678127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 11) &quot;message&quot;2) &quot;study&quot;3) &quot;designpattern&quot; 原理： Redis订阅发布底层是使用C实现的 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"设计模式-原型模式","slug":"设计模式-原型模式","date":"2022-02-25T01:26:59.000Z","updated":"2022-02-25T02:59:21.994Z","comments":true,"path":"设计模式/2022/02/25/设计模式-原型模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式该设计模式主要用于对象的复制 此设计模式有多种实现： jdk内置cloneable接口 自定义接口 jdk内置cloneable接口我们都知道object中有一个protected方法，叫clone，可以看到这是一个native方法（即该方法是由C++编写的，具体实现是根据操作系统而定） 12@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 我们来自己重写一个这个方法试一试 1234567891011121314151617181920212223242526272829303132333435363738394041public class Video &#123; private String name; private Date gmtCreated; public Video(String name, Date gmtCreated) &#123; this.name = name; this.gmtCreated = gmtCreated; &#125; public Video() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getGmtCreated() &#123; return gmtCreated; &#125; public void setGmtCreated(Date gmtCreated) &#123; this.gmtCreated = gmtCreated; &#125; @Override protected Video clone() throws CloneNotSupportedException &#123; return (Video)super.clone(); &#125; @Override public String toString() &#123; return &quot;Video&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gmtCreated=&quot; + gmtCreated + &#x27;&#125;&#x27;; &#125;&#125; 主程序 1234567891011121314public static void main(String[] args) throws CloneNotSupportedException &#123; Video video = new Video(); video.setName(&quot;视频一号&quot;); video.setGmtCreated(new Date()); System.out.println(video); System.out.println(video.hashCode()); System.out.println(video.getGmtCreated().hashCode()); System.out.println(&quot;=============克隆后================&quot;); Video clone = (Video) video.clone(); System.out.println(clone); System.out.println(clone.hashCode()); System.out.println(clone.getGmtCreated().hashCode()); System.out.println();&#125; 控制台输出 12345678Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:31:04 CST 2022&#125;269468037784235907=============克隆后================Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.lizhi.demo1.Video at java.base/java.lang.Object.clone(Native Method) at com.lizhi.demo1.Video.clone(Video.java:35) at com.lizhi.demo1.CloneApplication.main(CloneApplication.java:13) 可以发现，报错了，这是怎么回事，我不是已经重写了方法吗？ 其实原因就是该类没有一个标记接口Cloneable 123456789101112131415161718192021222324252627/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object&#x27;s clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &#123;@code Object.clone&#125; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;@code clone&#125; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since 1.0 */public interface Cloneable &#123;&#125; 将video实现该接口后，启动程序，控制台输出 1234567Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;269468037784153335=============克隆后================Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;1681595665784153335 我们可以惊奇的发现， 两者的内容打印出来一模一样，两者的对象主体的hashcode是不同的，说明video和clone是货真价实的两个对象。 但是我们也发现他们的gmtCreated变量的hashcode是一样的，这说明两者指向的是同一个gmtCreated，有时候我们会有这样的需求，有时候我们不需要将复制后的对象内部指向的对象还是原来的那个对象，这时候我们就要修改clone方法 1234567@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); Video v = (Video) obj; v.setGmtCreated((Date) v.getGmtCreated().clone()); return obj;&#125; 自定义接口123public interface Copyable &#123; Object copy();&#125; 具体实现就不写啦，本质是一样的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2022-02-25T01:26:35.000Z","updated":"2022-02-25T02:22:49.386Z","comments":true,"path":"设计模式/2022/02/25/设计模式-建造者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式该设计模式解决的问题是在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。 该模式有两种实现方向： 有一个制造者有自己的一套制造方案来制造该对象 自己指定制造计划 制造者制造场景：造汽车 汽车类 12345678910111213141516@Data@NoArgsConstructor@ToString@AllArgsConstructorpublic class Car &#123; private CarBody carBody; private Engine engine; private Lamp lamp; private Window window; public boolean isWhole()&#123; if(carBody!=null&amp;&amp;engine!=null&amp;&amp;lamp!=null&amp;&amp;window!=null)&#123; return true; &#125; return false; &#125;&#125; 组件接口 12public interface Component &#123;&#125; 车身 123public interface CarBody extends Component &#123; void printName();&#125; 引擎 123public interface Engine extends Component &#123; void printName();&#125; 车窗 123public interface Window extends Component &#123; void printName();&#125; 好的车身 123456public class GoodCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;好的车身&quot;); &#125;&#125; 不好的车身 123456public class BadCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;差的车身&quot;); &#125;&#125; 好的引擎 123456public class GoodEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;好的发动机&quot;); &#125;&#125; 不好的引擎 123456public class BadEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;差的发动机&quot;); &#125;&#125; 好的车窗 123456public class GoodWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;好的车窗&quot;); &#125;&#125; 不好的车窗 123456public class BadWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;差的车窗&quot;); &#125;&#125; 车的建造者 1234567public interface CarBuilder &#123; void addCarBody(CarBody carBody); void addWindow(Window window); void addLamp(Lamp lamp); void addEngine(Engine engine); Car getCar();&#125; 具体的建造者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public void addCarBody(CarBody carBody) &#123; if(carBody==null)&#123; car.setCarBody(new GoodCarBody()); return; &#125; car.setCarBody(carBody); &#125; @Override public void addWindow(Window window) &#123; if(window==null)&#123; car.setWindow(new GoodWindow()); return; &#125; car.setWindow(window); &#125; @Override public void addLamp(Lamp lamp) &#123; if(lamp==null)&#123; car.setLamp(new GoodLamp()); return; &#125; car.setLamp(lamp); &#125; @Override public void addEngine(Engine engine) &#123; if(engine==null)&#123; car.setEngine(new GoodEngine()); return; &#125; car.setEngine(engine); &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 指导者 123456789public class Director &#123; public static Car getCar(CarBuilder carBuilder)&#123; carBuilder.addWindow(null); carBuilder.addCarBody(null); carBuilder.addLamp(new BadLamp()); carBuilder.addEngine(null); return carBuilder.getCar(); &#125;&#125; 自定义建造我们发现，有车由四部分组成，这四部分可以是同一个工厂造出来的，所以我们可以结合一个抽象工厂模式，将产品制造交给工厂。 组件工厂接口 123456public interface ComponentFactory &#123; CarBody getCarBody(); Engine getEngine(); Window getWindow(); Lamp getLamp();&#125; 不好的组件工厂 123456789101112131415161718192021public class BadFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new BadCarBody(); &#125; @Override public Engine getEngine() &#123; return new BadEngine(); &#125; @Override public Window getWindow() &#123; return new BadWindow(); &#125; @Override public Lamp getLamp() &#123; return new BadLamp(); &#125;&#125; 好的组件工厂 12345678910111213141516171819202122public class GoodFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new GoodCarBody(); &#125; @Override public Engine getEngine() &#123; return new GoodEngine(); &#125; @Override public Window getWindow() &#123; return new GoodWindow(); &#125; @Override public Lamp getLamp() &#123; return new GoodLamp(); &#125;&#125; 改造CarBuilder 1234567public interface CarBuilder &#123; CarBuilder addCarBody(CarBody carBody); CarBuilder addWindow(Window window); CarBuilder addLamp(Lamp lamp); CarBuilder addEngine(Engine engine); Car getCar();&#125; 具体制造商 12345678910111213141516171819202122232425262728293031323334353637public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public CarBuilder addCarBody(CarBody carBody) &#123; car.setCarBody(carBody); return this; &#125; @Override public CarBuilder addWindow(Window window) &#123; car.setWindow(window); return this; &#125; @Override public CarBuilder addLamp(Lamp lamp) &#123; car.setLamp(lamp); return this; &#125; @Override public CarBuilder addEngine(Engine engine) &#123; car.setEngine(engine); return this; &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 客户端自定义制造 123456789101112131415public class Customer &#123; public static void main(String[] args) &#123; DaZhongCarBulder daZhongCarBulder = new DaZhongCarBulder(); ComponentFactory goodFactory = new GoodFactory(); ComponentFactory badFactory = new BadFactory(); // 这就是链式编程 Car car = daZhongCarBulder .addCarBody(goodFactory.getCarBody()) .addEngine(badFactory.getEngine()) .addLamp(goodFactory.getLamp()) .addWindow(goodFactory.getWindow()) .getCar(); System.out.println(car); &#125;&#125; 加深理解再来个案例：kfc点餐 首先食物接口 12public interface Food &#123;&#125; 饮料接口 123public interface Drink extends Food&#123; void drink();&#125; 薯条接口 123public interface Chip extends Food&#123; void eatChip();&#125; 炸鸡接口 123public interface Chicken extends Food&#123; void eatChicken();&#125; 奥尔良炸鸡 123456public class OrleansFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;奥尔良炸鸡&quot;); &#125;&#125; 孜然炸鸡 123456public class CuminFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;孜然炸鸡&quot;); &#125;&#125; 可乐 123456public class Cola implements Drink&#123; @Override public void drink() &#123; System.out.println(&quot;可口可乐&quot;); &#125;&#125; 大薯条 1234567public class BigChip implements Chip&#123; @Override public void eatChip() &#123; System.out.println(&quot;大份薯条&quot;); &#125;&#125; 百事可乐 123456public class BaiShi implements Drink &#123; @Override public void drink() &#123; System.out.println(&quot;百事可乐&quot;); &#125;&#125; 订单 1234567891011@Data@ToStringpublic class Order &#123; private List&lt;Food&gt; foods; public Order()&#123; foods = new ArrayList&lt;&gt;(); &#125; public void addFood(Food food)&#123; foods.add(food); &#125;&#125; 点单小程序 12345678910111213141516171819public class OrderApplication implements Builder&#123; private Order order; public OrderApplication()&#123; order = new Order(); &#125; @Override public Builder addFood(Food food) &#123; order.addFood(food); return this; &#125; @Override public Order getOrder() &#123; if(order.getFoods().size()==0)&#123; throw new IllegalArgumentException(&quot;您未点单！&quot;); &#125; return order; &#125;&#125; 客户端 123456789public static void main(String[] args) &#123; OrderApplication orderApplication = new OrderApplication(); Order order = orderApplication .addFood(new BigChip()) .addFood(new OrleansFriedChicken()) .addFood(new Cola()) .getOrder(); System.out.println(order);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-概述","slug":"设计模式-概述","date":"2022-02-24T14:36:38.000Z","updated":"2022-02-25T01:43:48.960Z","comments":true,"path":"设计模式/2022/02/24/设计模式-概述/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"什么是设计模式？Design Pattern是前辈们对代码开发经验的总结与归纳，是解决特定问题的一系列解决方案。 1995年，由GoF（Gang of Four）四人帮合作出版了《设计模式：可复用面向对象软件的基础》一书，一共收录了23种设计模式，人称Gof23设计模式 创建型模式： 单例模式 简单工厂模式 抽象工厂模式 建造者模式 原型模式 结构型模式 适配器模式 桥接模式 装饰器模式 组合模式 门面模式 享元模式 代理模式 行为型模式 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【4-Hard】寻找两个正序数组的中位数","slug":"【4-Hard】寻找两个正序数组的中位数","date":"2022-02-24T11:07:44.000Z","updated":"2023-03-06T06:45:35.827Z","comments":true,"path":"算法/刷题篇/2022/02/24/【4-Hard】寻找两个正序数组的中位数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/24/%E3%80%904-Hard%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"寻找两个正序数组的中位数给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 Related Topics 数组 二分查找 分治 合并取中间值这种方法应该是大多数人的第一反应 使用一个list集合存放两个数组的值后排序 判断集合长度的奇偶性 偶数，返回中间两个数的和的平均值 奇数，返回中间那个数 123456789101112131415161718class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int k : nums1) &#123; list.add(k); &#125; for (int j : nums2) &#123; list.add(j); &#125; Collections.sort(list); int size = list.size(); if(size%2==0)&#123; return (list.get(size/2)+list.get(size/2-1))/2.0; &#125;else &#123; return list.get(size/2); &#125; &#125;&#125; 归并再来理一理题目的意思 有两个正序数组num1和nums2 要返回这两个正序数组的中位数 这不就是归并中合并两个有序数组一样的思路吗 但是这里不需要完全合并，只需要合并到中间的位置就可了 说干就干 123456789101112131415161718192021222324252627282930class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; // 总长度 int wholeSize = nums1.length + nums2.length; // 去中间值 int mid = wholeSize / 2; // 新建中间值+1长度的数组 int[] temp = new int[mid + 1]; int index1 = 0; int index2 = 0; for (int i = 0; i &lt; temp.length; i++) &#123; if (index1 == nums1.length) &#123; // num1已经放完了，直接放num2的值即可 temp[i] = nums2[index2++]; &#125; else if (index2 == nums2.length) &#123; // num1已经放完了，直接放num2的值即可 temp[i] = nums1[index1++]; &#125; else if (nums1[index1] &lt;= nums2[index2]) &#123; // num1相对比较小，所以放num1的值 temp[i] = nums1[index1++]; &#125; else &#123; // num2相对比较小，所以放num2的值 temp[i] = nums2[index2++]; &#125; &#125; // 如果总长度是偶数，则返回最后两个数的和的平均数 // 如果总长度是奇数，则直接返回最后一个数即可 return wholeSize % 2 == 0 ? (temp[mid] + temp[mid - 1]) / 2.0 : temp[mid]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-OOP七大原则","slug":"设计模式-OOP七大原则","date":"2022-02-24T10:18:58.000Z","updated":"2022-10-04T13:56:09.005Z","comments":true,"path":"设计模式/2022/02/24/设计模式-OOP七大原则/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"OOP七大原则开闭原则(Open-Closed Principle ，OCP)定义：对拓展开放，对修改关闭 问题的由来：在软件的生命周期的，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧的代码引入错误。 解决办法：当软件需要发生变化的时候，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 为什么要遵循开闭原则 1、只要是面向对象的编程，在开发过程中都会强调开闭原则 2、是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态 3、可以提高代码的复用性 4、可以提高代码的可维护性 单一职责原则（Single Responsibility Principle,SRP）定义：如果一个类具有多个职责，应当将对象解耦，提高内聚，分别创建一些类去一 一完成这些职责， 核心：高内聚、低耦合。 优点： 1、降低类的功能复杂度 2、提高系统的可维护性 3、变更风险低 里氏替换原则（Liskov Substitution Principle ，LSP）定义： 子类对象能够替代程序中父类对象出现的任何地方，并且保证原来的程序的逻辑行为不变及正确性不被破坏 里氏替换至少包含一下两个含义： 1、如果继承是为了实现代码重用，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。 ​ 2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化的，也就不存在子类替换父类实例的现象。 优点：可以大大减少程序的bug以及增强代码的可读性。 依赖倒置原则（Dependency Inversion Principle ，DIP）定义：面向接口编程 本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。 接口隔离原则(Interface Segregation Principle, ISP)定义：要用各个类建立他们需要的专用接口 它包含了2层意思： 接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户使用不到的方法塞进同一个接口里。如果一个接口的有方法没有被用户使用到，则说明该接口已经臃肿了，应该将其分割成几个功能专一的接口。 接口的依赖（继承）原则：如果一个接口a继承另一个接口b，则接口a相当于继承了接口b的方法，那么接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。 迪米特法则（Law of Demeter ，LOD）定义：只与直接朋友交谈，不与陌生人通信 直接朋友的定义： 1）当前对象本身（this） 2）以参量形式传入到当前对象方法中的对象 3）当前对象的实例变量 4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 5）当前对象所创建的对象 合成复用原则（Composite&#x2F;Aggregate Reuse Principle ，CARP）定义：尽量先使用组合或者内聚等关联关系来实现，其次才考虑使用继承来实现，因为java是单继承","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis-配置文件","slug":"Redis-配置文件","date":"2022-02-24T07:13:55.000Z","updated":"2022-10-04T13:56:55.114Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-配置文件/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"配置文件redis.conf基础配置下面为常用的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# 说明单位和不区分大小写# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.################################## INCLUDES #################################### 可以配置多个conf文件组合起来# Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf################################## NETWORK ###################################### 网络模块bind 127.0.0.1# 开启保护模式protected-mode yes# 连接的服务器端口port 6379tcp-backlog 511# 超时时间timeout 0tcp-keepalive 300################################# GENERAL ###################################### When Redis is supervised by upstart or systemd, this parameter has no impact.# 默认为 daemonize no# 需要手动改为yes，我们需要后台启动daemonize yes# 如果以后台方式运行，就需要指定一个pid文件pidfile /var/run/redis_6379.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)生产环境# warning (only very important / critical messages are logged)# 日志级别loglevel notice# 生成的日志文件名logfile &quot;&quot;# 默认有16个数据库databases 16# 是否显示logoalways-show-logo yesset-proc-title yesproc-title-template &quot;&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;&quot;################################## SECURITY #################################### 可以设置Redis的密码# auth# config set requirepass root# 设置密码使用命令requirepass root################################### CLIENTS ##################################### 客户端的一些限# 最大客户端连接数maxclients 10000############################## MEMORY MANAGEMENT ################################# 内存设置# 设置最大内存# maxmemory &lt;bytes&gt;# The default is:# 内存满了，有什么策略，和JUC中的那四种拒绝策略有点类似# 1.volatile-lru:只对设置了过期时间的key进行lru# 2.allkeys-lru:删除lru算法的key# 3.volatile-random:随机删除即将过期的# 4.allkeys-random:随机删除# 5.volatile-ttl:删除即将过期的# 6.noeviction:返回错误maxmemory-policy noeviction############################# LAZY FREEING ####################################lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush nolazyfree-lazy-user-del nolazyfree-lazy-user-flush no 配置RDB（Redis DataBase）持久化Redis是内存性数据库，如果不讲内存中的数据保存到磁盘中，那么一旦服务器退出，服务器中的服务器状态也就消失了，所以需要学会Redis中的持久化操作 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读取到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。 RDB的优点是效率高，对于数据的完整性要求不高 RDB的缺点是最后一次持久化后的数据可能丢失。 rdb文件默认保存为dump.rdb 1234567891011121314151617181920212223242526272829################################ SNAPSHOTTING ################################# 快照：做持久化的时候会用到。# 在规定的时间内执行了多少次操作就会生成一个.rdb文件或者.aof文件# Redis是内存数据库，如果没有持久化，用完数据就没了# 持久化规则# 3600s内至少有一个key进行了修改，则进行持久化操作 save 3600 1# 300s内至少有100个key进行了修改，则进行持久化操作 save 300 100# 60s内至少有10000个key进行了修改，则进行持久化操作 save 60 10000# 持久化出错后，是否还继续工作stop-writes-on-bgsave-error yes# 是否压缩rdb文件，消耗CPU资源rdbcompression yes# 是否校验rdb文件的数目rdbchecksum yes# 持久化生成的文件名字dbfilename dump.rdbrdb-del-sync-files no# 保存的目录，当前目录dir ./ 配置AOF（Append Only File）文件以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 123456789101112131415161718192021############################## APPEND ONLY MODE ################################ 持久化文件aof的配置# 默认关闭aof，默认开启rdb的持久化，大部分情况下，rdb完全够用appendonly no# 持久化文件的名字appendfilename &quot;appendonly.aof&quot;# appendfsync always # 每次修改都同步一下appendfsync everysec # 每1s都同步一下# appendfsync no # 不同步，操作系统自己同步# 是否重写# incrby view 10# incrby view 20# 重写后# incrby 30no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 如果aof中被恶意篡改了，这时候redis是启动不起来的，这时候可以使用redis提供的一个工具redis-check-aof.exe 优点：每一次修改都同步，文件的完整性会更好， 缺点：该文件远远大于rdb，修复速度远远慢于rdb，运行效率比rdb低 小结： RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协自加保存每次写的操作到文件未尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB 文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合 用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1这条规则。 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了 代价一是带来了持续的IO 代价二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF，仅靠Master-Slave Repllcation（主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时断电，会丢失十几分钟的数据，启动脚本也要比较两个Master&#x2F;Slave中的RDB文件，载入较新的那个。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-整合SpringBoot","slug":"Redis-整合SpringBoot","date":"2022-02-24T04:08:56.000Z","updated":"2022-10-04T13:54:55.083Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-整合SpringBoot/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E6%95%B4%E5%90%88SpringBoot/","excerpt":"","text":"SpringBoot整合Redis在SpringBoot2.x之后，底层已经不再使用jedis操作Redis了，而是lettuce jedis：采用的直连，如果有多个线程操作的话，是不安全的，需要使用jedis pool连接池来解决问题（BIO模式） lettcue：采用netty，实例可以在多个实例中共享，不存在线程不安全的问题（Dubbo底层也用到了它）（NIO模式） 如何使用1、导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt;&lt;/dependency&gt; 2、观察RedisAutoConfiguration源码 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean // 这说明我们可以自定义template @ConditionalOnMissingBean( name = &#123;&quot;redisTemplate&quot;&#125; ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean // 因为我们平时使用string会非常多，所以内置了一个StringRedisTemplate @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125;&#125; 3、配置连接，看源码可以发现，就算我们不配置，springboot也默认可以连接本地的redis 4、测试 先打开命令行客户端查看全部的key 12127.0.0.1:6379&gt; keys *(empty list or set) 测试类测试 123456789101112@SpringBootTestclass SpringbootRedisApplicationTests &#123; @Autowired private StringRedisTemplate redisTemplate; @Test void contextLoads() &#123; RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); connection.flushAll(); connection.flushDb(); redisTemplate.opsForValue().set(&quot;springboot integrated Redis&quot;,&quot;success&quot;); &#125;&#125; 命令行客户端查看全部的key，可以发现数据成功插入了 12127.0.0.1:6379&gt; keys *1) &quot;springboot integrated Redis&quot; 序列化器先看下源码 如果我们没有自定义这些序列化，那么他们都会被设置为内置的defaultSerializer，那么这种jdk的序列化会使我们的中文转义，这时候我们需要使用JSON来实现序列化 123if (this.defaultSerializer == null) &#123; this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader());&#125; 下面我们直接上案例： 使用jdk内置序列化器User 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private String name; private int age;&#125; 直接测试将对象写入 12345678@Testvoid testSerialization()&#123; User user = new User(); user.setName(&quot;zhima&quot;); user.setAge(19); redisTemplate.opsForValue().set(&quot;user&quot;, user); System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));&#125; 执行发现报错了，这就想到了我们从源码中看到的JdkSerializationRedisSerializer，如果我们没有配置自己想要的序列化器，那么就默认为此序列化器，所以知道报这个错误的原因是user没有实现序列化接口，那我们来实现以下序列化接口 1org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.lizhi.springbootredis.pojo.User] 这时候再执行，看控制台 1User(name=zhima, age=19) 自定义序列化器 配置自定义redisTemplate 123456789101112131415161718192021@Bean(&quot;myRedisTemplate&quot;)public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectJackson2JsonRedisSerializer.setObjectMapper(om); // hash的value使用JSON序列化 template.setHashValueSerializer(objectJackson2JsonRedisSerializer); // value使用JSON序列化 template.setValueSerializer(objectJackson2JsonRedisSerializer); // hash表的key使用string的序列化器 template.setHashKeySerializer(stringRedisSerializer); // key采用string的序列化器 template.setKeySerializer(stringRedisSerializer); template.afterPropertiesSet(); return template;&#125; 再执行刚刚的测试，就会发现，命令行中的key已经是一个正常的字符串了 工具类RedisUtils这样使用原生的API太麻烦了，我们可以自己编写一个工具类。 12链接:https://pan.baidu.com/s/1CZG5D8QUsz1NnqBjXZf0tg 提取码:24m2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-通过Jredis操作Redis","slug":"Redis-通过Jedis操作Redis","date":"2022-02-24T03:32:22.000Z","updated":"2022-10-04T13:54:48.214Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-通过Jedis操作Redis/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%80%9A%E8%BF%87Jedis%E6%93%8D%E4%BD%9CRedis/","excerpt":"","text":"JedisJedis其实就是java用来操作Redis的一个工具包 如何使用1、导入依赖 12345678910111213&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、使用封装好的对象测试连接Redis 1234567public class TestPing &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379); System.out.println(jedis.ping()); &#125;&#125;// 控制台输出PONG 可以点进源码看一下 我们会发现，这些方法不就是我们当时写的那些吗，只不过都被封装成了方法供我们使用。 实现事务1234567891011121314public class TransactionTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); jedis.set(&quot;money&quot;,&quot;100&quot;); jedis.set(&quot;out&quot;,&quot;0&quot;); jedis.watch(&quot;money&quot;); Transaction multi = jedis.multi(); jedis.decrBy(&quot;mondy&quot;,30); jedis.incrBy(&quot;out&quot;,30); multi.exec(); jedis.close(); &#125;&#125; 实际上和命令行的命令是一模一样的","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-实现乐观锁","slug":"Redis-实现乐观锁","date":"2022-02-24T03:07:07.000Z","updated":"2022-10-04T13:54:41.398Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-实现乐观锁/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/","excerpt":"","text":"浅实现一下乐观锁这里需要使用watch，直接上案例吧 需求：现有存款100元，花出去30元，还剩下70元 12345678910111213141516127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 30QUEUED127.0.0.1:6379&gt; incrby out 30QUEUED127.0.0.1:6379&gt; exec1) (integer) 702) (integer) 30# watch在事务执行结束后就失效了 现在我们开两个客户端cli-1和cli-2，按照以下的命令和顺序执行 cli-1 12345678127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED cli-2 123456127.0.0.1:6379&gt; get money&quot;70&quot;127.0.0.1:6379&gt; incrby money 230(integer) 300127.0.0.1:6379&gt; get money&quot;300&quot; cli-1 1234127.0.0.1:6379&gt; exec # 监视的值发生了改变，所以该事务执行失败，这个时候money上的watch没有解除，可以通过unwactch解除(nil)127.0.0.1:6379&gt; get money&quot;300&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"多并发中的锁","slug":"JUC-多并发中的锁","date":"2022-02-23T07:56:59.000Z","updated":"2023-01-07T07:55:53.613Z","comments":true,"path":"javaEE/JUC/2022/02/23/JUC-多并发中的锁/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/02/23/JUC-%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"为什么需要锁？在单线程环境下，不论怎么操作数据都不会出现什么致命的操作，但是在这个多并发的时代，我们更多的要考虑多并发，并保证多并发环境的安全性。 在并发环境下，多个线程争抢操作同一份数据，这样可能会导致数据异常，这个时候就需要一种机制来保证这一份数据的安全性。 锁是如何实现的？在java中，每一个Object都有一把锁，这把锁放在对象的对象头中，锁中记录了当前对象被哪个线程所占用。 内存中的对象结构 对齐填充字节是为了满足java对象必须是8比特的倍数这一条件所设计的 实例数据是为了保存对象属性和方法的 对象头是为了保存对象的运行时数据，对象头包含了两部分，一个是Mark Word 一个是Class Pointer Class Pointer 指向Class对象 Mark Word (32 bit)存放了很多和当前对象运行时状态有关的数据 hashCode 锁状态 synchronized实现原理synchronized被编译后会生成monitorenter和monitorexit两个字节码指令，依赖这两个指令就可以实现锁的机制，从而实现线程的同步 这是未上锁的代码： 12345678910111213import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125;&#125; 123456789101112131415161718public static void main(String[] args) &#123; TestSync ts = new TestSync(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start();&#125; 我们来加一下synchronized代码块 1234567891011121314151617package com.lizhi;import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; synchronized(this)&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125; &#125;&#125; 可以发现结果十分正确，我们来反编译一下，得到以下字节码文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849javap -c .\\TestSync.classCompiled from &quot;TestSync.java&quot;public class com.lizhi.TestSync &#123; public com.lizhi.TestSync(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void add(); Code: 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/util/concurrent/TimeUnit.MILLISECONDS:Ljava/util/concurrent/TimeUnit; 7: ldc2_w #3 // long 30l 10: invokevirtual #5 // Method java/util/concurrent/TimeUnit.sleep:(J)V 13: goto 21 16: astore_2 17: aload_2 18: invokevirtual #7 // Method java/lang/InterruptedException.printStackTrace:()V 21: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 24: invokestatic #9 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread; 27: invokevirtual #10 // Method java/lang/Thread.getName:()Ljava/lang/String; 30: aload_0 31: dup 32: getfield #11 // Field count:I 35: dup_x1 36: iconst_1 37: iadd 38: putfield #11 // Field count:I 41: invokedynamic #12, 0 // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;I)Ljava/lang/String; 46: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 49: aload_1 50: monitorexit 51: goto 59 54: astore_3 55: aload_1 56: monitorexit 57: aload_3 58: athrow 59: return Exceptio n table: from to target type 4 13 16 Class java/lang/InterruptedException 4 51 54 any 54 57 54 any&#125; 可以看到在第3行和第50行出现了monitorenter和monitorexit Monitor该单词的意思是监视器，可以将其想成一间宾馆的客房，把各个线程想像成客人。如果客人未退房，在这之后的客人则无法入住，只能等待这个客人退房后方可入住。 monitor是依赖于操作系统的mutex lock来实现的 java线程实际上是对操作系统线程的映射，每当挂起或者唤醒一个线程都要切换 操作系统内核态，这种操作是比较重量级的，在一些情况下甚至切换时间会超过任务本身执行的时间，这样的情况下，使用synchronized的会对系统的性能产生很严重的影响，但是从java6开始，synchronized进行了优化，引入了偏向锁和轻量级锁。 锁的四种状态由低到高分别是：无锁、偏向锁、轻量级锁、重量级锁。 这就与Mark Word中的四种状态对应上了 注意：锁只能升级不能降级 无锁 无锁即没有对自身资源上锁，所有线程都可以拿到资源并操作 这就可能出现两种情况 某个对象不会出现在多线程环境下，或者说即使出现在多线程环境下也不会出现竞争的情况 资源会被竞争，但是我不想对资源锁定，不过这样也不行，会导致一些问题，就想通过一种其他机制来控制多线程， 比如说，如果有多个进程想修改同一个值，但是只能有一个线程修改成功，其他失败的线程需要不断尝试，直到修改成功 ，这就是CAS（Compare And Swap）,CAS在操作系统中通过一条指令来实现，所以其就可以保证原子性，有了这种机制，我们就可以实现无锁编程 偏向锁 假如一个对象被加锁了，那么在实际运行过程中只有一个线程会获得这个对象锁，并只有当线程执行完任务，才会将锁释放。 我们设想的是，最好这个对象能够认识这个线程，当这个线程过来，那么这个对象就把自己的锁给他，这可以说这个对象偏爱这个线程，这就是偏向锁的概念 那么这个认识的人，被这个对象记在哪里呢？那就是在对象头中MarkWord的线程ID中，假如情况发生了变化，这个对象发现，不止有一个线程在争抢锁，那么该偏向锁会直接升级成轻量级锁 轻量级锁 那当锁升级为轻量级锁的时候，如何判断线程和所之间的绑定关系呢？可以再看下那张markword的表，这里已经不再使用线程ID这个字段了，而是将30bit变为指向线程栈中的锁记录（Lock Record）的指针 当一个线程想要获得对象的锁的时候，加入看到锁的标志位为00那么就知道它是轻量级锁，这时候线程会在自己的虚拟机栈中开辟一块被称为Lock Record的空间（线程私有的哦），该控件用来存放对象头中的Mark word的副本以及owner指针，线程通过CAS去尝试获得锁，一旦获取那么将会复制该对象头中的markword到本线程的Lock record中并且将Locker record中的owner指针指向该对象，并且对象的前三十位将会生成一个指针，指向线程虚拟机栈中的Lock Record，这样一来就实现了线程和对象锁的绑定。 当线程已经被抢占了，那其他想抢占的线程会自旋等待（可以理解为轮询），不断尝试拿到锁，这种操作区别于被操作系统挂起阻塞，如果对象的锁很快就被释放的话，自旋就不需要进行系统中断和重新恢复，所以它的效率会更高。 自旋相当于CPU空转，如果CPU空转时间过长，性能也会产生损耗，然后就有了一种优化，就是适应性自旋。简单来说，就是自旋的时间会根据上一次在同一个锁上自旋的时间以及锁的状态来决定的 重量级锁 如果同时有多个线程要获得这个对象锁，也就是说一旦自旋等待的线程超过一个，则会升级为重量级锁，那么这个时候，这就需要使用monitor来对线程进行控制，此时将会完全锁定资源，对线程的管控也更为严格 无锁编程java中的synchronized就是悲观锁（Pessimistic Concurrency Control），什么叫悲观锁呢？ 简单来说就是操作系统会悲观地认为，如果不严格同步线程调用，那么一定会产生异常，所以互斥锁会锁定资源，直供一个线程使用，而阻塞其他线程，因此叫悲观锁，但是悲观锁不是万能的，如果大部分操作都是读的操作，那么就没有必要在每次调用的时候都锁定资源。可能会出现同步代码块执行的耗时远远小于线程切换的耗时。使用悲观锁，会导致性能十分不容乐观，比如大量用户需要同时读取同一份资源，如果使用的是悲观锁，则同一时间只能有一个用户可以查看，其他用户都在一直白屏，但是！其实对于读的操作，即使是多个线程同时操作该数据，也不会对该数据造成影响，我们能不能在不锁定资源的情况下，也可以对线程调用进行一些协调呢？这时候就出现了乐观锁这种机制，实现原理就是CAS（Compare And Swap） CAS我们来举个栗子：人就是线程，厕所就是对象，该对象有一个值来表示是否被占用occupy 0表示空闲 1表示有人 很多人要去抢厕所，然后线程A（Old Value &#x3D; 0 ，new Value &#x3D;1）、B（Old Value &#x3D; 0，new Value &#x3D; 1）这两个人冲到了最前面，然后A率先和厕所的occupy比较（Compare）发现和oldValue一致，则将oldValue与厕所的occupy交换（And Swap），这时候B一看自己的oldValue与厕所的occupy（1）不一致，他很不甘心，但也只能在厕所外踱步（自旋），通常在等了一段时间后（设置最大自旋次数），骂出一句国粹后就离去了 这时候可能就出现了问题，因为Compare和Swap是两个操作，没有原子性，这就有可能出现，当A即将将值改为1的那一刹那，B抢到了时间片，将其改为了1，然后A也将其改为1，这就很尴尬了，两个人一起进入了厕所。 那么如何保证CAS的原子性呢？难道还是锁来实现同步吗？这不就是一个鸡生蛋蛋生鸡的问题了吗？ 其实啊，各种不同架构的CPU都提供了指令级别的CAS原子操作， 比如在X86架构下，通过cmpxchg指令可以支持CAS 在ARM下，通过LL&#x2F;SC来实现CS…… 也就是说不通过操作系统的同步原语（比如 mutex），CPU已经实现了CS，上层只需要调用即可，这样我们就可以不依赖锁来进行线程同步，但是这也不意味着无锁可以完全代替有锁 利用CAS特性来进行无锁编程需求：使用三条线程，将一个值，从0累加到1000 1、错误 123456789101112public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125;).start(); &#125; &#125;&#125; 2、使用synchronized 1234567891011121314public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; synchronized (Application2.class)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 3、无锁 123456789101112public class Application2 &#123; static AtomicInteger count =new AtomicInteger(0) ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count.get()&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count.getAndIncrement()); &#125; &#125;).start(); &#125; &#125;&#125; 探究源码 AtomicInteger的getAndIncrement方法 123public final int getAndIncrement() &#123; return U.getAndAddInt(this, VALUE, 1);&#125; U的getAndAddInt方法 1private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe(); U是一个操作底层的类 12345678@HotSpotIntrinsicCandidatepublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v;&#125; 123456@HotSpotIntrinsicCandidatepublic final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) &#123; return compareAndSetInt(o, offset, expected, x);&#125; 1234@HotSpotIntrinsicCandidatepublic final native boolean compareAndSetInt(Object o, long offset, int expected, int x); 启动次数可以通过启动参数来配置，默认是10，所以不会出现死循环 Unsafe","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"}]},{"title":"Redis-事务","slug":"Redis-事务","date":"2022-02-23T07:32:42.000Z","updated":"2022-10-04T13:54:45.002Z","comments":true,"path":"javaEE/Redis/2022/02/23/Redis-事务/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/23/Redis-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务回顾我们在MySQL中学习的事务具有ACID原则 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis中的事务事务的本质即：一组命令一起执行，不允许被插队。 在Redis中，单条命令是原子性的，但是事务不保证原子性 事务没有隔离级别的概念 123456789101112131415161718192021222324# 开启事务127.0.0.1:6379&gt; multiOK# 命令入队127.0.0.1:6379&gt; hset user:1 name zhimaQUEUED127.0.0.1:6379&gt; hset user:1 age 19QUEUED127.0.0.1:6379&gt; hset user:1 address SuzhouQUEUED127.0.0.1:6379&gt; hmget user:1 name age addressQUEUED# 执行事务127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 13) (integer) 14) 1) &quot;zhima&quot; 2) &quot;19&quot; 3) &quot;Suzhou&quot;# 中途放弃事务127.0.0.1:6379&gt; discard 编译时异常：即代码本身又问退，比如127.0.0.1:6379&gt; asdmlk (error) ERR unknown command &#39;asdmlk&#39;命令行会直接报错 12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k2(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k3(nil)127.0.0.1:6379&gt; get k2(nil) 可以发现所有的命令都没有执行。 运行时异常：如果事务队列中存在这种错误，其他语句照常执行，该语句不执行，抛出异常 1234567891011127.0.0.1:6379&gt; set k1 varOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) &quot;var&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"CS和BS架构是什么？","slug":"CS和BS架构是什么？","date":"2022-02-23T03:45:07.000Z","updated":"2022-10-04T13:52:27.206Z","comments":true,"path":"琐碎的知识/2022/02/23/CS和BS架构是什么？/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/23/CS%E5%92%8CBS%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"C&#x2F;S架构和B&#x2F;S架构C&#x2F;S架构 Client&#x2F;Server客户端&#x2F;服务器 客户端是针对某一具体业务专门开发的软件，是需要专门安装的软件。 由于客户端是专用的软件，所以客户端程序一般也具有对具体业务进行处理的能力，可以减轻服务端压力 优点：速度快，安全性较高 致命问题：版本升级成本很高 就比如QQ、微信等应用程序 B&#x2F;S架构 Browser&#x2F;Serve浏览器&#x2F;服务器 它其实也是一种特殊的C&#x2F;S架构，只不过这个Client是浏览器，是一个通用的客户端（浏览器），所以没有对具体业务进行处理的能力，速度降低。 优点：不存在客户端升级的问题 致命问题：速度慢，考虑兼容性的问题，安全性低 就比如，网页版QQ","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"【3-Medium】无重复字符的最长子串","slug":"【3-Medium】无重复字符的最长子串","date":"2022-02-22T09:10:53.000Z","updated":"2023-03-06T06:45:29.740Z","comments":true,"path":"算法/刷题篇/2022/02/22/【3-Medium】无重复字符的最长子串/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/22/%E3%80%903-Medium%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 Related Topics 哈希表 字符串 滑动窗口 暴力解法遍历数组的所有的区间，将满足题意区间长度的最大值返回 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if (len &lt;= 1) &#123; return len; &#125; int maxLength = 1; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; // 如果是无重复的子串才需要和 maxLength 作比较 if (allUnique(s, i, j)) &#123; maxLength = Math.max(maxLength, j - i + 1); &#125; &#125; &#125; return maxLength; &#125; /** * 该函数的作用是返回该区间是否有重复的字符，有则返回false，没有则返回true * * @param s * @param i * @param j * @return */ private boolean allUnique(String s, int i, int j) &#123; // 这里使用ArrayList也是可以的 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); // 看s的[i,j]区间内是否有重复的字符 for (int x = i; x &lt;= j; x++) &#123; if (set.contains(s.charAt(x))) &#123; return false; &#125; set.add(s.charAt(x)); &#125; return true; &#125;&#125; 中间会有重复的比较 导致效率十分低下 当string长度十分大的时候，一定会导致超时 滑动窗口法思路如下组图所示 示例代码 1 123456789101112131415161718192021222324252627282930313233class Solution &#123; // 这是完完全全遵守滑动窗口的思路 public int lengthOfLongestSubstring(String s) &#123; int size = s.length(); if(size &lt;= 1)&#123; return s; &#125; char[] sArray = s.toCharArray(); Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int left = 0; int right = 0; int maxLength = 0; // [left,right)是没有重复元素的区间 while (right &lt; size) &#123; // 如果窗口中没有此元素或者出现次数为0，扩大右边界 while (right &lt; size &amp;&amp; window.getOrDefault(sArray[right], 0) == 0) &#123; window.merge(sArray[right++], 1, Integer::sum); &#125; maxLength = Math.max(right - left, maxLength); // 如果走到了尾部，不需要再缩小窗口了，直接返回最大值即可 if (right == size) &#123; return maxLength; &#125; // 没有到尾部，right所在的位置就是[left,right)中重复的元素 // while (sArray[left] != sArray[right]) &#123; window.merge(sArray[left++], -1, Integer::sum); &#125; window.merge(sArray[left++], -1, Integer::sum); &#125; return maxLength; &#125;&#125; 在这道题目中用set来充当window也是可以的 示例代码 2 1234567891011121314151617181920212223242526272829class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int size = s.length(); if(size &lt;= 1)&#123; return s; &#125; char[] sArray = s.toCharArray(); Set&lt;Character&gt; window = new HashSet&lt;&gt;(); int right = 0; int left = 0; int maxLength = 1; while (right &lt; size) &#123; // 只要窗口中没有sArray[right]，就一直扩大右边界 while (right &lt; size &amp;&amp; !window.contains(sArray[right])) &#123; window.add(sArray[right++]); &#125; maxLength = Math.max(right - left, maxLength); // 说明到了尾部 if (right == size) &#123; return maxLength; &#125; while (sArray[left] != sArray[right]) &#123; window.remove(sArray[left++]); &#125; window.remove(sArray[left++]); &#125; return maxLength; &#125;&#125; 但是这两种都不大好 这两种的window的定义都是s的[legft,right)区间是不重复的子串 下面看window的定义是s的[left,right]区间不是重复的子串的时候该如何写代码 示例代码 3 12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int size = s.length(); if(size &lt;= 1)&#123; return s; &#125; char[] sArray = s.toCharArray(); Set&lt;Character&gt; window = new HashSet&lt;&gt;(); int right = 0; int left = 0; int maxLength = 1; // [left,right]是不重复的子串 while (right &lt; size) &#123; char rightChar = sArray[right]; // 保持窗口中没有和即将加入的右边界一样的字符 while (window.contains(rightChar)) &#123; window.remove(sArray[left++]); &#125; maxLength = Math.max(maxLength, right - left + 1); // 将右边界加入窗口 window.add(sArray[right++]); &#125; return maxLength; &#125;&#125; 使用队列优化12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int size = s.length(); if(size &lt;= 1)&#123; return s; &#125; char[] sArray = s.toCharArray(); int right = 0; int left = 0; int maxLength = 0; LinkedList&lt;Character&gt; window = new LinkedList&lt;&gt;(); while (right &lt; size) &#123; while (window.contains(sArray[right])) &#123; window.removeFirst(); left++; &#125; maxLength = Math.max(maxLength, right - left + 1); window.addLast(sArray[right++]); &#125; return maxLength; &#125;&#125; 使用map优化我们发现对于处理left，需要遍历left往后走 那我们就可以使用map存一下，从而可以快速拿到窗口中重复的字符的那一个索引 12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int size = s.length(); if(size &lt;= 1)&#123; return s; &#125; char[] sArray = s.toCharArray(); int right = 0; int left = 0; int maxLength = 0; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); while (right &lt; size) &#123; // 如果右边界加入就会导致窗口有重复字符了 if (window.containsKey(sArray[right])) &#123; // 更新左边界 left = Math.max(window.get(sArray[right]) + 1, left); &#125; // 更新最大值 maxLength = Math.max(maxLength, right - left + 1); // 覆盖或保存对应的关系 window.put(sArray[right], right++); &#125; return maxLength; &#125;&#125; 对map再次进行优化 因为字符是确定的所以，我们可以new一个128长度的数组来当hashmap，键是字符的ascll码值，值是索引，代码如下 12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; int[] window = new int[128]; while(right &lt; len)&#123; char now = s.charAt(right); // 如果window[now]没有值就是0和原本的left相比较即可 left = Math.max(left, window[now] +1); // 更新最大值 maxLength = Math.max(maxLength, right-left+1); // 覆盖或保存对应的关系 window[now] = right++; &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis-三大特殊类型","slug":"Redis-三大特殊类型","date":"2022-02-22T08:41:55.000Z","updated":"2022-10-04T13:54:37.679Z","comments":true,"path":"javaEE/Redis/2022/02/22/Redis-三大特殊类型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/22/Redis-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"三种特殊类型geospatial该数据类型是用来存储地理空间的 附近的人，发送定位，分享实时位置，打车的时候的距离计算都可以通过这个实现 我们这里使用这几个城市的经纬度作为测试 城市 经度 维度 相城区 120.64239 31.36889 吴江区 120.638317 31.159815 太仓 121.10891 31.4497 常熟市 120.75225 31.65374 昆山市 120.98074 31.38464 这里有六个基本命令，我们来一个个看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# geoadd key longitude latitude member [longitude latitude member..]# 增加一个经纬度的坐标# 两极无法添加，一般我们通过java程序一次性导入127.0.0.1:6379&gt; geoadd Suzhou 120.64239 31.36889 XiangChengDistrict 120.638317 31.159815 WuJiangDistrict 121.10891 31.4497 TaiCang 120.75225 31.65374 ChangShuCity 120.98074 31.38464 KunShanCity(integer) 5# geodist key member1 member2 [unit]# 获取两地之间的距离单位为米127.0.0.1:6379&gt; GEODIST Suzhou TaiCang WuJiangDistrict&quot;55133.1652&quot;127.0.0.1:6379&gt; GEODIST Suzhou TaiCang KunShanCity km&quot;14.1556&quot;# geohash key member [member..]# 获取member的二维的空间经纬度数据编码# 这个可以csdn搜一下具体的算法实现127.0.0.1:6379&gt; geohash Suzhou TaiCang1) &quot;wtw4gvhzf10&quot;# geopos key member [member..]# 查看member的经纬度127.0.0.1:6379&gt; geopos Suzhou TaiCang XiangChengDistrict1) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;120.64238995313644&quot; 2) &quot;31.368889085683811&quot;# georadius key longitude latitude radius m|km|ft|mi [WITHSCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC| ESC]# mi是英里，ft是英尺# 以给定的经纬度为中心，找到某一半径内的元素# WITHCOORD表示显示坐标# WITHDIST表示显示距离该点的位置# WITHHASH表示显示该地址的hash值# COUNT count表示显示几个# ASC| ESC 表示正序还是倒序127.0.0.1:6379&gt; georadius Suzhou 120.98080 31.28460 30 km withdist1) 1) &quot;KunShanCity&quot; 2) &quot;11.1271&quot;2) 1) &quot;TaiCang&quot; 2) &quot;22.0285&quot;# georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]# 以member为中心radius为半径，找到在此范围中的元素127.0.0.1:6379&gt; georadiusbymember Suzhou TaiCang 30 km withcoord withdist withhash asc1) 1) &quot;TaiCang&quot; 2) &quot;0.0000&quot; 3) (integer) 4054798020485654 4) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;KunShanCity&quot; 2) &quot;14.1556&quot; 3) (integer) 4054794184325796 4) 1) &quot;120.98073989152908&quot; 2) &quot;31.38463984296795&quot; geo的底层其实是Zset，我们可以使用Zset的命令去操作geo 1234567127.0.0.1:6379&gt; zrem Suzhou TaiCang(integer) 1127.0.0.1:6379&gt; zrange Suzhou 0 -11) &quot;WuJiangDistrict&quot;2) &quot;XiangChengDistrict&quot;3) &quot;ChangShuCity&quot;4) &quot;KunShanCity&quot; Hyperloglog 先来了解一下基数是什么？ 基数其实就是一个集合中不重复的元素个数，其实就是一个集合去重后的集合长度 业务场景： 网站的访问量（一个人访问一个网站多次，也算一个人） 传统使用set集合的重复无序的特性，可以保存用户的id，以set集合的长度作为标准。但是，专门使用一个set来保存用户id未免优点奢侈，如果id是分布式的会很复杂，导致set集合很庞大，所以需要一个方法来解决这个问题。 Hyperloglog就是用来解决此问题的算法。 优点：占用很小的内存空间存放2^64个数据，也只占用12kb 瑕疵：会有0.81%的错误率 123456789101112131415161718192021222324# pfadd key member [member..]127.0.0.1:6379&gt; pfadd set a b c d e f g h i j k l(integer) 1# pfcount key [key..]# 返回基数127.0.0.1:6379&gt; pfcount set(integer) 12127.0.0.1:6379&gt; pfadd set2 j k l m n(integer) 1127.0.0.1:6379&gt; pfcount set set2(integer) 14# pfmerge destkey sourcekey [sourcekey..]# 将sourcekey合并到destkey127.0.0.1:6379&gt; pfmerge set set2OK# 探究底层：# 我们获取一下此数据的数据类型，可以看到实际上存储的是string127.0.0.1:6379&gt; type setstring127.0.0.1:6379&gt; get set&quot;HYLL\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00Fm\\x80I\\xe8\\x80@\\xc4\\x84K\\\\\\x80D&lt;\\x848\\x80B=\\x80K\\x83\\x80B\\xed\\x84A\\xfc\\x8cG\\x8e\\x80Bm\\x80BZ&quot; Bitmap位存储，一般使用两种状态的区分 比如统计中国的男子和女子的数目 14亿个二进制数，0代表女子，1代表男 0 0 1 1 1 0 1 … 登录，头像是亮着的，未登录，头像是灰色的。 12345678910111213141516171819202122232425# setbit key offset value# 设置offset位是value127.0.0.1:6379&gt; setbit sign 0 0(integer) 0127.0.0.1:6379&gt; setbit sign 1 1(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0# 中国sign可以代表# 星期日未打卡# 星期一已打卡# 星期二未打卡# 星期三已打卡# getbit key offset# 查看该天是否打卡127.0.0.1:6379&gt; getbit sign 3(integer) 1# bitcount key [start end]# 查看sign中为1的个数127.0.0.1:6379&gt; BITCOUNT sign(integer) 2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"【2-Medium】两数相加","slug":"【2-Medium】两数相加","date":"2022-02-21T10:53:00.000Z","updated":"2023-03-06T06:45:23.359Z","comments":true,"path":"算法/刷题篇/2022/02/21/【2-Medium】两数相加/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%902-Medium%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ListNode 12345678//Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 示例1: 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 图示1： 图示2： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 Related Topics 递归 链表 数学 链表转值计算遇到这种链表的题，第一步就是将逻辑图画出来 经过观察可知，链表的第一位表示该数字的个位，第二位代表该数字的十位，以此类推。 我第一个想到的解题思路就是 1、将链表表示的数字算出来 2、将两个数字加起来 3、用该数字构建出来结果链表并返回 示例代码 123456789101112131415161718192021222324252627class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; long sum = compute(l1) + compute(l2); ListNode listNode = new ListNode(); // 这里的listNode是虚拟节点，最后返回的是该节点的下一个节点 ListNode temp = listNode; while (sum != 0) &#123; // 这里需要使用强转 // (sum % 10)的结果是long类型，直接赋值给ListNode的int型的val会报错 temp.next = new ListNode((int) (sum % 10)); temp = temp.next; sum /= 10; &#125; return listNode.next; &#125; /** * 该函数是为了计算链表所表示的值 */ private long compute(ListNode node) &#123; long result = 0; for (long i = 1; node != null; node = node.next, i *= 10L) &#123; result += node.val * i; &#125; return result; &#125;&#125; 来算一下long的最大值是多少 long在Java里面使用8个字节也就是64位，最大值也就是2^64-1，也就是9_223_372_036_854_775_807 此方法乍一看确实没问题 但是题目提示有以下要求 测试的时候可能会出现100位的数字，long类型最大值远远不够 当链表很长的时候，该方法就会超时并且发生溢出错误 递归现在有两个链表，要清楚两点 1、两个链表的长度不一定相同 2、两个链表相加后，长度不一定不变 递归需要先将递归退出条件写出来，即两者都到尾部，先就简单看看我画的思路图 示例代码 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode listNode = new ListNode(); add(l1,l2,listNode); return listNode; &#125; public ListNode add(ListNode a,ListNode b,ListNode temp)&#123; // 当两个链表都到头了，则退出递归 if(a==null&amp;&amp;b==null)&#123; return temp; &#125; // 此变量是用来标注下一次递归的时候两个链表是否是都尾部了 boolean flag=false; // 当a到尾部的时候，将temp的数据域变为自身加上b的数据域的值 if(a==null)&#123; temp.val+=b.val; // 在a已经到尾部的情况下，b的next为null，即b将在下一次递归到尾部了，则将flag变为true if(b.next==null)&#123; flag=true; &#125; // 当b到头的时候，将temp的数据域变为自身加上b的数据域的值 &#125;else if(b==null)&#123; temp.val+=a.val; // 在b已经到尾部的情况下，a的next为null，即a将在下一次递归到尾部了，则将flag变为true if(a.next==null)&#123; flag=true; &#125; &#125;else &#123; temp.val+=a.val+b.val; if(a.next==null&amp;&amp;b.next==null)&#123; flag=true; &#125; &#125; // left用来存储当前这一位的值是否&gt;=10，如果满足，则进1 int left=temp.val&gt;=10?1:0; // 将left作为初始值new出来temp的下一个指针 temp.next = new ListNode(left); // 为了防止超过十，所以这里做了取余的操作， temp.val = temp.val%10; // 如果下一次递归的时候两者都到了尾部，并且没有进1，则不需要new出来temp的next if(flag&amp;&amp;left==0)&#123; temp.next=null; &#125; //递归调用 return add(a==null?null:a.next,b==null?null:b.next,temp.next); &#125;&#125; 其实这种递归就是化简为繁了 下面这种做法才是我觉得比较好的 示例代码 2 1234567891011121314151617181920212223242526272829303132class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return addTwoNumbers(l1, l2, 0); &#125; private ListNode addTwoNumbers(ListNode l1, ListNode l2, int flag) &#123; // 两者都为null才会结束递归 if (l1 == null &amp;&amp; l2 == null) &#123; ListNode tail = null; // 可能最后还需要进位 if (flag == 1) &#123; tail = new ListNode(1); &#125; return tail; &#125; int sum = flag; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; // 新建节点 ListNode node = new ListNode(sum % 10); // 节点的next就递归处理 node.next = addTwoNumbers(l1, l2, sum / 10); // 返回这个新建的节点，最后一层返回的也就是头节点 return node; &#125;&#125; 齐头并进遍历直接两条链表一起遍历 用一个变量存储是否需要进位 这个思路其实和第二种递归的写法思路是一样的 123456789101112131415161718192021222324252627282930313233class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int flag = 0; // 虚拟头节点 ListNode dummy = new ListNode(0); ListNode node = dummy; // 只有有一个没有到尾部，就一直循环 while (l1 != null || l2 != null) &#123; int sum = flag; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; // 记录是否需要进位 flag = sum / 10; // 新建节点并接到node后面 node.next = new ListNode(sum % 10); node = node.next; &#125; // 如果最后一次需要进位，需要修补一下 if (flag == 1) &#123; node.next = new ListNode(1); &#125; // 判断dummy的next是否为空 // 为空的时候就是l1和l2都是null，那么就返回dummy即可 // 不为空的时候就说明l1或者l2有一个不空，那就直接返回dummy的next即可 return dummy.next == null ? dummy : dummy.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1-Easy】两数之和","slug":"【1-Easy】两数之和","date":"2022-02-21T10:52:45.000Z","updated":"2023-03-06T06:45:17.814Z","comments":true,"path":"算法/刷题篇/2022/02/21/【1-Easy】两数之和/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%901-Easy%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ Related Topics 数组 哈希表 暴力枚举法题目意思很明确，就是给一个target和一个数组 目标是在这个数组里面找到 和是 target 的那两个数的索引数组 暴力枚举很简单，代码直接给出 示例代码 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; // 如果找到了，那就保存结果并返回 if (j != i &amp;&amp; nums[j] == target - nums[i]) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; // 没有符合要求的两个数 return new int[]&#123;-1, -1&#125;; &#125;&#125; 哈希表暴力枚举取到target-nums[i]的方法是遍历算法 关键在于如何快速知道i后面有没有等于target-nums[i]的值 那么就可以使用Map结构来解决这个问题 示例代码 12345678910111213141516class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // 键为nums[i] // 值为索引 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; // 找到了target-nums[i] if (map.containsKey(target - nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; // 说明没找到 return new int[]&#123;-1, -1&#125;; &#125;&#125; Tips相信很多同学看到这种方法，第一反应可能不是这样写的 你的代码可能是这样的，差异就在//==========================之间的代码 先遍历一遍数组，目的是将值和其索引先放入map 123456789101112131415161718192021222324class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // 键为nums[i] // 值为索引 // ========================== // 这里手动设置容器初始大小 // 这样指定初始容量的原因是此map肯定不会放超过nums.length数目的元素，所以就设置默认容量为其正好要扩容的数量+1，就不会扩容了 // 这里不懂得话，就不写，走默认的容量然后它自己扩容也是可以的 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;((int)((float) nums.length / 0.75F + 1.0F)); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; // ========================== for (int i = 0; i &lt; nums.length; i++) &#123; // 找到了target-nums[i] if (map.containsKey(target - nums[i])) &#123; return new int[]&#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; // 说明没找到 return new int[]&#123;-1, -1&#125;; &#125;&#125; 为什么不需要提前遍历一遍将值和索引的对应关系放入map中，而是可以边遍历边查map呢？ 案例：nums = [2, 7, 11, 15],target = 13 边遍历边放入map 当条件成立的时候，nums[i]是11，target - nums[i]是2 2是在11之前遍历的，所以2和其索引的对应关系已经在map中了，于是得到了答案 这时候的map是不完整的，只有2、7的对应关系 预填充map 当条件成立的时候，nums[i]是2，target - nums[i]是11 在遍历2的时候，11这个值的对应关系已经在map中了，于是得到了答案 这时候的map是完整的 总结 经过上面案例的分析，应该可以感觉到两者之间的不同了，明显感受到边遍历边放map的方案优于预填充的方案 分析 当然不是每次涉及类似题目都这样的，该预遍历还是要预遍历的，下面分析一下为啥这题可以这样 下面假设答案存在，则target = nums[i] + nums[j] ( i &lt; j ) 预遍历是在当前位置i，向后找target - nums[i]的位置j 先找到那个小的索引，然后再找大的那个索引 边遍历边存是在当前位置j，向前找target - nums[j]的位置i 先找到那个大的索引，然后再找小的那个索引","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"去IOE是什么？","slug":"去IOE是什么？","date":"2022-02-21T07:58:53.000Z","updated":"2022-09-27T13:57:21.326Z","comments":true,"path":"琐碎的知识/2022/02/21/去IOE是什么？/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/21/%E5%8E%BBIOE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"什么去IOE？I是以IBM为代表的小型机小型机与X86服务器的区别： 价格 一台小型机可以买3-4台X86服务器 指令 X86 兼容性好 性能差 小型机 兼容性差 性能好 性能 领域 O是以ORACLE为代表的关系型数据库架构2013年5月17日，最后一台IBM小型机在支付宝下线了，这个是去IOE的一个重要的一个节点。ORACLE数据库告别阿里巴巴是在2013年的7月10日，这一天阿里巴巴的一个重要广告系统的ORACLE数据库也下线了，也是淘宝最后一个ORACLE数据库，这两件事情合在一起啊，也是构成阿里巴巴的一个重要的一个里程碑。 阿里巴巴呢一直是采用的是ORCALE数据库，并利用小型机和高端的存储设备提高性能和数据库的性能，但随着业务的不停的发展，数据量愈发庞大。 传统的移动式ORACLE数据库的扩展，也存在着一些瓶颈。传统的ORACLE软件为代表的关系数据库，大多数呢是以集中式架构为主，这些传统的数据库软件是最大的特点呢，就是将所有的数据集中存储在一个数据库中，依赖大型的高端设备来提高处理的性能和扩展性，集中式数据库的扩展呢，主要是采用向上扩展的那这种方式啊，就是通过增加CPU内存的方式提高处理能力，这种处理的架构就使得数据库成为一个很大的一个系统瓶颈，越来越不适合目前海量数据对计算能力的一个需求。 E是以EMC为代表的高端SAN存储设备SAN：Storage Area Network EMC是一家美国信息存储公司。","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Redis-五大基础数据类型","slug":"Redis-五大基础数据类型","date":"2022-02-21T02:00:54.000Z","updated":"2022-10-04T13:54:51.466Z","comments":true,"path":"javaEE/Redis/2022/02/21/Redis-五大基础数据类型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/21/Redis-%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基础知识redis默认有16个数据库Redis的瓶颈是根据机器的内存和网络带宽。 为什么单线程还可以这么快？redis是c语言写的，官网提供的性能数据 1s 11万读取 1s 8万写入 误区： 高性能的服务器一定是多线程的 多线程一定比单线程效率高 CPU—&gt;内存—&gt;硬盘 核心：redis将所有的数据都放入内存中，所以用单线程去操作效率是很高的，多线程（CPU上下文会切换，十分耗时），对于内存系统，没有上下文切换效率会很高，多次读写都是在一个CPU上的，没有线程调度的耗时 五大数据类型基础命令1234567891011121314151617181920212223242526272829303132333435363738# 切换数据库select index# 查看当前数据库的数据数dbsize# 查看当前所有符合pattern的keykeys pattern# 是否存在该key，存在则返回1，不存在则返回0exists key# 移除keymove key#设置kvset key value# 查看key存储的值get key# 查看类型type key# 设置过期时间为secondssexpire key seconds#查看剩余时间ttl key# 清空当前数据库flushdb# 清空所有的数据库的内容flushall# 随机输出一个keyrandomkey String123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# 追加key存储的value字符串# 如果key不存在，则该命令相当于set# append key valueappend key &quot;appendstring&quot;# 查看key存储的字符串的长度strlen key# 自增1，自减1的操作# incr key # decr key127.0.0.1:6379&gt; set views 1OK127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; incr views(integer) 3127.0.0.1:6379&gt; decr views(integer) 2127.0.0.1:6379&gt; decr views(integer) 1# 一次性加或者减指定数字的操作# incrby key increment# decrby key decrement127.0.0.1:6379&gt; incrby views 10(integer) 11127.0.0.1:6379&gt; decrby views 10(integer) 1# 获取一个范围内的字符串，即substring==&gt;[start,end)# 注意这里的getrange是闭区间，[start,end]# getrange key start end127.0.0.1:6379&gt; set name zhimaOK127.0.0.1:6379&gt; getrange name 0 3&quot;zhim&quot;127.0.0.1:6379&gt; getrange name 0 -1&quot;zhima&quot;# 替换字符串# setrange key offset value127.0.0.1:6379&gt; set key randomstringOK127.0.0.1:6379&gt; setrange key 3 xxx(integer) 12127.0.0.1:6379&gt; get key&quot;ranxxxstring&quot;# setex (set with expire) 设置过期时间# 设置该字段过期时间为30s# setex key seconds valuesetex key 30 &quot;expire&quot;# 如果不存在则设置值，在分布式锁中经常使用# setnx (set if not exist)# setnx key value127.0.0.1:6379&gt; set key1 value1OK127.0.0.1:6379&gt; get key1&quot;value1&quot;127.0.0.1:6379&gt; setnx key1 &quot;setnx&quot;(integer) 0127.0.0.1:6379&gt; set key1 &quot;setnx&quot;OK127.0.0.1:6379&gt; get key1&quot;setnx&quot;# 批量获取和设置值 # mget mset msetnx# mset key value [key value..]# mget key [key..]# msetex key value [key value..]127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; mget k1 k21) &quot;v1&quot;2) &quot;v2&quot;127.0.0.1:6379&gt; msetnx k1 modifiedv1 k4 v4 # 该操作是一个原子性的操作！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 删除# del key127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; keys *1) &quot;k1&quot;127.0.0.1:6379&gt; del k1(integer) 1127.0.0.1:6379&gt; keys *(empty list or set)# 对象set user:1&#123;name:zhangsan,age:3&#125; # 设置一个user:1对象 值为json字符串来保存# 这里的key是一个巧妙的属性：&#123;className&#125;:&#123;id&#125;:&#123;field&#125;，在redis中是可以的127.0.0.1:6379&gt; mset user:1:name zhima user:1:age 19OK127.0.0.1:6379&gt; keys *1) &quot;user:1:age&quot;2) &quot;user:1:name&quot;127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhima&quot;2) &quot;19&quot;# 组合命令# getset先取得当前的值并返回，然后修改当前的值# getset key value127.0.0.1:6379&gt; getset db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db modified&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;modified&quot; List可以给其设置一个使用规则，则可以将其实现栈或者队列的功能 1234567891011# 设置和取值# lrange key start stop [start,stop]127.0.0.1:6379&gt; lpush list1 v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list1 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lrange list1 0 11) &quot;v3&quot;2) &quot;v2&quot; 分析可知这里的lpush是头插入，也就是left插入，那与之对应的肯定还有个尾插入，即right插入，但是啊只有LRANGE操作来取得集合里的数据，没有RRANGE操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131127.0.0.1:6379&gt; rpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;# 删除头部的值并返回# lpop key127.0.0.1:6379&gt; lpop list&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;2) &quot;v3&quot;# 删除尾部的值并返回# rpop key127.0.0.1:6379&gt; rpop list&quot;v3&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 获取索引处的元素# lindex key index127.0.0.1:6379&gt; lpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lindex list 0&quot;v3&quot;# 获取集合长度# llen key 127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; llen list(integer) 3# 移除指定个数的匹配的值# lrem key count value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;4) &quot;v1&quot;127.0.0.1:6379&gt; lrem list 1 v1(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;127.0.0.1:6379&gt; lrem list 2 v3(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 截取指定位置的值# ltrim key start stop127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; ltrim list 0 2OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;# 将集合尾部元素移除，并在另一个集合头部加入一个元素# rpoplpush source destination127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; rpoplpush list otherlist&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lrange otherlist 0 -11) &quot;v1&quot;# 修改指定索引处元素的值127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lset list 0 modifiedOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;modified&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;# lpush key value [value...]# 当该集合不存在的时候会自动创建# lset key index value# 当该集合不存在的时候会报错# 在指定值的前面|后面插入值# linsert key BEFORE|AFTER pivot value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; linsert list before v2 brforev2(integer) 6127.0.0.1:6379&gt; linsert list after v4 afterv4(integer) 7127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;afterv4&quot;4) &quot;v3&quot;5) &quot;brforev2&quot;6) &quot;v2&quot;7) &quot;v1&quot; 该List实质上是使用链表实现的 栈：出栈（Lpop）入栈（Lpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Rpush） 队列：出队（Lpop）入队（Rpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Lpush） Set该集合的特点是：无序不重复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 添加一个元素# sadd key member [member..]# 查看所有的成员# smembers key127.0.0.1:6379&gt; sadd set a b c a(integer) 3127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;# 判断是否包含某个元素127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sismember set c(integer) 1127.0.0.1:6379&gt; sismember set d(integer) 0# 查看集合的长度127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; scard set(integer) 3# 删除某个元素# srem key member [member..]127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srem set a c(integer) 2127.0.0.1:6379&gt; smembers set1) &quot;b&quot;# 随机返回指定个数的元素# srandmember key count127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;b&quot;3) &quot;a# 随机删除指定个数的元素，不写count默认为1# spop key [count] 127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; spop set 31) &quot;c&quot;2) &quot;e&quot;3) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;d&quot;# 将一个指定的值，移到另一个集合中# smove source destination member127.0.0.1:6379&gt; sadd set a b c d e(integer) 5127.0.0.1:6379&gt; smove set set2 a(integer) 1127.0.0.1:6379&gt; smembers set21) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;# 交集 sinter key [key..]# 差集 sdiff key [key..]# 并集 sunion key [key..]127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;127.0.0.1:6379&gt; smembers set21) &quot;b&quot;2) &quot;a&quot;3) &quot;g&quot;127.0.0.1:6379&gt; sinter set set21) &quot;b&quot;127.0.0.1:6379&gt; sdiff set set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sunion set set21) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;a&quot;6) &quot;g&quot; HashMap集合，key-Map集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# hset key field value# 放入一个map# hget key field 127.0.0.1:6379&gt; hset hashmap name zhima(integer) 1127.0.0.1:6379&gt; hget hashmap name&quot;zhima&quot;# 设置和取得多个键值对# hmset key field name [field name..]# hmget key field [field..]127.0.0.1:6379&gt; hmset user:1 name zhim age 10OK127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhim&quot;2) &quot;10&quot;# 使用hset更新键值对127.0.0.1:6379&gt; hset user:1 name zhima(integer) 0127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhima&quot;2) &quot;19&quot;# 取得所有的键值对# hgetall key 127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;19&quot;# 获取键值对个数# hlen key127.0.0.1:6379&gt; hlen user:1(integer) 2# 删除键值对# hdel key field127.0.0.1:6379&gt; hdel user:1 name(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;age&quot;2) &quot;19&quot;# 是否存在该键值对# hexists key field127.0.0.1:6379&gt; hexists user:1 name(integer) 1127.0.0.1:6379&gt; hexists user:1 unknown(integer) 0# 获得所有的键# hkeys key# 获得所有的值# hvals key127.0.0.1:6379&gt; hkeys user:11) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt; hvals user:11) &quot;zhima&quot;2) &quot;19&quot;# 增加值# hincrby key field increment # ！注意：！这里没有自减的方法，但是可以为increment设置负数来实现减127.0.0.1:6379&gt; hincrby user:1 name 1(error) ERR hash value is not an integer127.0.0.1:6379&gt; hincrby user:1 age 2(integer) 21127.0.0.1:6379&gt; hmset user:2 name lizhi age &quot;19&quot;OK127.0.0.1:6379&gt; hgetall user:21) &quot;name&quot;2) &quot;lizhi&quot;3) &quot;age&quot;4) &quot;19&quot;127.0.0.1:6379&gt; hincrby user:2 age 2(integer) 21127.0.0.1:6379&gt; hincrby user:2 age -1(integer) 20# 如果不存在该字段，则添加该字段# 如果存在，则不进行操作# hsetnx key field value127.0.0.1:6379&gt; hsetnx user:1 name modified(integer) 0127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;127.0.0.1:6379&gt; hsetnx user:1 address unknown(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;5) &quot;address&quot;6) &quot;unknown&quot; Hashmap适合存储对象 Zset（有序列表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 添加值 这个score相当于权重，用来排序# zadd key [NX|XX] [CH] [INCR] score member [score member..]127.0.0.1:6379&gt; zadd myzset 1 one(integer) 1127.0.0.1:6379&gt; zadd myzset 2 two 3 three(integer) 2# 正序输出# zrange key start stop [withscores]127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;# 倒叙输出# zrevrange key start stop [withscores]127.0.0.1:6379&gt; zrevrange salary 0 -11) &quot;lizhi&quot;2) &quot;xiaozhang&quot;3) &quot;zhima&quot;# 携带权重输出127.0.0.1:6379&gt; zrange salary 0 -1 withscores1) &quot;zhima&quot;2) &quot;1000&quot;3) &quot;xiaozhang&quot;4) &quot;1500&quot;5) &quot;lizhi&quot;6) &quot;2000&quot;# zrangebyscore key min max [withscores] [limit offset count]# 获取score在min到max之间的元素，闭区间127.0.0.1:6379&gt; zrangebyscore salary 1000 16001) &quot;zhima&quot;2) &quot;xiaozhang&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf1) &quot;zhima&quot;2) &quot;xiaozhang&quot;3) &quot;lizhi&quot;# zrevrangebyscore key max min [withscores] [limit offset count]# 倒叙输出score在max到min之间的，闭区间，# [limit offset count]是指定显示从offset开始的count个数据，包括offset所在的元素127.0.0.1:6379&gt; zrevrangebyscore salary 1600 10001) &quot;xiaozhang&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zadd salary 10 xiaoming 27 ziaohzhyang 19 zhima 25 lizhi(integer) 4127.0.0.1:6379&gt; zrangebyscore salary 10 191) &quot;xiaoming&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 withscores1) &quot;xiaoming&quot;2) &quot;10&quot;3) &quot;zhima&quot;4) &quot;19&quot;5) &quot;lizhi&quot;6) &quot;25&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 limit 0 21) &quot;xiaoming&quot;2) &quot;zhima&quot;# 删除元素127.0.0.1:6379&gt; zrem salary xiaoming(integer) 1# 查看该集合的长度# zcard key127.0.0.1:6379&gt; zcard salary(integer) 3# 查看符合[min,max]区间的元素个数# zcount key min max127.0.0.1:6379&gt; zcount salary 10 19(integer) 2 注：以上命令只是常用命令，更多命令可以在官网查看 英文官网地址：https://redis.io/ 中文官网地址：http://www.redis.cn/","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-前期准备","slug":"Redis-前期准备","date":"2022-02-19T09:36:09.000Z","updated":"2022-10-04T13:54:33.955Z","comments":true,"path":"javaEE/Redis/2022/02/19/Redis-前期准备/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/19/Redis-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","excerpt":"","text":"Nosql我们先前学的都是mysql，它是关系型数据库，表与表之间有联系。 NoSql即非关系型数据库。 MySql MySql的瓶颈 数据太大了，一个机器就放不下了 30万以上的数据，需要使用索引（B+Tree） 访问量大的话，服务器压力大 解决方案：读写分离（垂直拆分） 因为80%网站对于数据的操作都是读取，不会产生并发问题，所以为了提升效率，当我们第一次读取完数据后，将数据放入缓存中，下一次查询如果是同样的业务，则直接从缓存中读取数据，会大大提升性能，解决了读的压力 解决方案：分库分表，MySql集群（水平拆分）每一个集群放一些表和数据库，这样的操作解决了写的压力 如今的数据数据量大，变化快，导致mysql无法很好的解决问题。 有的人使用mysql来存储一些比较大的文件，博客推文，图片等，数据库非常庞大，效率十分低下。 如果有一种数据库来专门处理这种数据，mysql的压力就变小了。这时候就需要使用Nosql了 特点 方便拓展（数据之间联系低，很好拓展） 大数据高性能（Redis1s读11万次，写8万次，Nosql的缓存记录，是一种细粒度的缓存，性能比较高） 数据多样，不需要事先设计数据库 大数据时代的3V：出现的一些问题 Volume 海量 Variety 多样 Velocity 实时 大数据时代的3高：对程序的要求 高性能 高可用（扩） 高并发 Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis+Tair 阿里+百度：Redis+MemeCache 应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于些日志系统等等。 数据模型：Key 指向的键值对Value，通常用hash table来实现 优点：查找速度快 缺点：数据无结构，通常只被当做字符串或者二进制存储 文档型数据库（BSON格式） MongoDB 基于分布式文件存储的数据库，C++编写的，主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中间的产物，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的 ConthDB 应用场景：web应用 数据模型：key-value键值对（Value为结构化数据） 优点：数据结构要求不严格表结构可不需要像关系型数据库那样需要预先定义表结构 缺点：查询效率不高，而且缺乏统一的查询语句 列存储数据库 HBase 应用场景：分布式文件系统 数据模型：以列簇式存储，将同一列数据存储在一起 优点：查找速度快，可拓展性强，容易实现分布式文件系统 缺点：功能相对局限 图形关系数据库 存的是关系，不是存图形的 Neo4j InfoGrid 应用场景：社交网络、相关推荐 数据模型：图架构 优点：利用图结构相关算法，比如最短路径寻址N度关系查找等 缺点：很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方式 Redis简介概述 Redis全名是Remote Dictionary Server ，即远程字典调用 默认端口是6379 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 它使用ANSI、C语言编写的、支持网络、可以基于内存亦可持久化的日志型、Key-value数据库、并提供多种语言的API，亦被称为结构化数据库 下载下载后直接解压即可12链接：https://pan.baidu.com/s/12ozkQkUss8GH70lf7qrinQ 提取码：nv5z 点击redis-server.exe即可启动服务 备注Redis推荐我们使用Linux使用redis，所以接下来使用阿里云服务器来学习redis 12链接:https://pan.baidu.com/s/1Hy1eFwcSqfftXrWv92-zug 提取码:u1ff 将压缩文件解压到服务器的opt目录下即可，进入解压后的目录，然后安装gcc-c++ 12yum install gcc-c++make 也可以使用docker创建redis容器 1234# 开启一个redis容器并设置密码docker run -it --name studyredis -p6379:6379 --requirepass lizhi9275 redis# 查看运行的容器docker ps","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Springboot-shiro","slug":"SpringBoot-Shiro","date":"2022-02-17T03:56:42.000Z","updated":"2022-10-04T13:55:11.308Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","excerpt":"","text":"Shiro简介其实这个就是一个关于做安全管理的框架，他不仅可以和javaEE结合也可以和javaSE结合 提供的功能 Authentication：身份认证，登录，验证用户的身份 Authorization：授权， Session Management： Shiro内置的session，对其进行管理 Cryptography：加密，保证数据的安全性 Web Support： web支持，可以很好的集成到web环境 Caching： 缓存， Concurrency： 多并发 Testing：测试 Remember Me：”记住我”的功能 Shiro结构我们来观察一下Shiro的结构 解释一下出现的名词 subject：与当前应用交互的任何东西都可以是Subject，与Subject的所有交互都会委托给SecurityManager，Subject其实只是一个门面，SecurityManager 才是实际的执行者 SecurityManager：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，并且它管理着所有的Subject，它是Shiro的核心，它负责与Shiro的其他组件进行交互 Realm： Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager 要验证用户身份，那么它需要从Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行 快速开始（看一下直接过）导入依赖 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/jcl-over-slf4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置文件 log4j.properties 123456789101112131415161718log4j.rootLogger=INF0,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# GeneraL Apache Librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Defautt Shiro Logginglog4j.logger.org.apache.shiro=INF0# DisabLe verbose Logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini 12345678910111213141516171819202122232425[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27;（&quot;That&#x27;s the same combination on# my Luggage!!!&quot; ;)), and rote &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhe met&#x27; with password &#x27;Ludicrousspeed’and rotes &#x27;darklord’and &#x27;schwartzdarkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;tonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# RoLes with assigned permissions# Each Line conforms to the format defined in the# org.apache.shiro.reatm.text.TextConfigurationReatm#setRoleDefinitions JavaDoc# -[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard&#x27;* &#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is aLlowed to &#x27;drive&#x27; (action) the winnebago (type) with# ticense plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5 ShiroQuickStart.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ShiroQuickStart &#123; private static final Logger LOG = LoggerFactory.getLogger(ShiroQuickStart.class); public static void main(String[] args) &#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;,&quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if(&quot;aValue&quot;.equals(value))&#123; LOG.info(&quot;Retrieved the correct value&quot;); &#125; if(!currentUser.isAuthenticated())&#123; UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestar&quot;, &quot;vespa&quot;); token.setRememberMe(true); try&#123; currentUser.login(token); &#125;catch (UnknownAccountException uae)&#123; LOG.info(&quot;There is no user with username whith &quot;+ token.getPrincipal()); &#125;catch (IncorrectCredentialsException ice)&#123; LOG.info(&quot;Password for account&quot;+ token.getPrincipal()+&quot;was incorrect&quot;); &#125;catch (LockedAccountException lae)&#123; LOG.info(&quot;The Account for userName&quot;+ token.getPrincipal()+&quot;is locked. &quot; + &quot;Please contact your administrator to unlocked it&quot;); &#125;catch (AuthenticationException ae)&#123; //unexpected exception &#125; &#125; LOG.info(&quot;USER[&quot;+ currentUser.getPrincipal()+&quot;] logged in successfully&quot;); if(currentUser.hasRole(&quot;schwartz&quot;))&#123; LOG.info(&quot;May the Schwartz be with you&quot;); &#125;else &#123; LOG.info(&quot;Hello,Mere mortal&quot;); &#125; if(currentUser.isPermitted(&quot;lightsaber:wield&quot;))&#123; LOG.info(&quot;You may use a lightsaber ring use it wisely&quot;); &#125;else &#123; LOG.info(&quot;Sorry, light rings are for schwartz masters only&quot;); &#125; if(currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;))&#123; LOG.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate(id) &#x27;eagle5&#x27;. &quot; + &quot;Here are the keys-have fun!&quot;); &#125;else &#123; LOG.info(&quot;Sorry,you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago&quot;); &#125; currentUser.logout(); System.exit(0); &#125;&#125; 运行输出 123456789101112131415161718192021222324252627282930313233342022-02-17 14:33:37,982 DEBUG [org.apache.shiro.io.ResourceUtils] - Opening resource from class path [shiro.ini] 2022-02-17 14:33:38,021 DEBUG [org.apache.shiro.config.Ini] - Parsing [users] 2022-02-17 14:33:38,026 DEBUG [org.apache.shiro.config.Ini] - Parsing [roles] 2022-02-17 14:33:38,523 DEBUG [org.apache.shiro.config.IniFactorySupport] - Creating instance from Ini [sections=users,roles] 2022-02-17 14:33:38,571 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [roles] section. Processing... 2022-02-17 14:33:38,575 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [users] section. Processing... 2022-02-17 14:33:38,594 DEBUG [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - No sessionValidationScheduler set. Attempting to create default instance. 2022-02-17 14:33:38,595 INFO [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - Enabling session validation scheduler... 2022-02-17 14:33:38,625 DEBUG [org.apache.shiro.session.mgt.DefaultSessionManager] - Creating new EIS record for new session instance [org.apache.shiro.session.mgt.SimpleSession,id=null] 2022-02-17 14:33:39,022 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - Retrieved the correct value 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - Looked up AuthenticationInfo [null] from doGetAuthenticationInfo 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - No AuthenticationInfo found for submitted AuthenticationToken [org.apache.shiro.authc.UsernamePasswordToken - lonestar, rememberMe=true]. Returning null. 2022-02-17 14:33:39,030 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - There is no user with username whith lonestar SpringBoot整合Shiro先按照以下步骤把基本的环境搭好 导入依赖，这里只显示shiro的相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt; 实体类User.java 12345678910@Data@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User &#123; private int id; private String userName; private String password; private String perms;&#125; 配置类ShiroConfig.java 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); return shiroFilterFactoryBean; &#125; //DefaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Autowired UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; &#125; //realm,需要自定义，用来做授权和认证的 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; UserRealm.java 1234567891011121314151617public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserMapper userMapper; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); return null; &#125;&#125; index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;ul&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; user的add页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的add&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的del页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的delete&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的update页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的update&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; MyController.java 1234567891011121314151617181920212223242526272829package com.lizhi.springbootshiro.contoller;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MyController &#123; @GetMapping(&quot;/index&quot;) public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,shiro&quot;); return &quot;index&quot;; &#125; //这里是restful风格 @GetMapping(&quot;/user/&#123;method&#125;&quot;) public String operateUser(@PathVariable(&quot;method&quot;) String method)&#123; return &quot;user/&quot;+method; &#125;&#125; UserMapper.java user表中就三个字段。id,user_name,password,perms 12345@Mapperpublic interface UserMapper &#123; List&lt;User&gt; listAllUsers(); User getUserByName(String userName);&#125; UserMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.springbootshiro.mapper.UserMapper&quot;&gt; &lt;select id=&quot;listAllUsers&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` &lt;/select&gt; &lt;select id=&quot;getUserByName&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` where user_name = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt; 登录拦截登录拦截指的是，未登录的用户不得进入用户的增删改页面 下面是集中拦截规则，一般authc和perms用的比较多 1234567/** * anno： 无需认证即可访问 * authc：必须认证了才可以访问 * perms：必须拥有权限才可以访问 * roles：必须拥有某种角色才可以访问 * user：必须拥有记住我的功能的时候才可以访问（一般很少用） */ 这是在ShiroFilterFactoryBean中配置的 1234567891011121314151617@Beanpublic ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //设置该路径只有user:add才可以访问 filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //设置该路径只有user:update才可以访问 filterMap.put(&quot;/user/del&quot;,&quot;perms[user:del]&quot;); //设置该路径只有user:del才可以访问 filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;); //设置登录的路径 shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;); //设置登录成功的路径 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauth&quot;); //设置未授权的用户被访问后跳转的路径 return shiroFilterFactoryBean;&#125; login.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;p style=&quot;color: red&quot;&gt;[[$&#123;error&#125;]]&lt;/p&gt; &lt;form th:action=&quot;@&#123;/login.do&#125;&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; MyController中配置路径 123456789101112131415161718192021222324252627282930@GetMapping(&quot;/login&quot;)public String login()&#123; return &quot;login&quot;;&#125;@GetMapping(&quot;/unauth&quot;)@ResponseBody //这里偷懒没写页面了，而是直接将消息返回到页面中public String unauthorized()&#123; return &quot;未经授权无法访问此页面&quot;;&#125;@GetMapping(&quot;/login.do&quot;)public String doLogin(String userName, String password, Model model) &#123; //获取当前用户 Subject currentUser = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(userName, password); try&#123; currentUser.login(token);//这里下一步是到userRealm的认证方法 //如果没有抛出异常，则说明登录成功 Subject currentUser = SecurityUtils.getSubject(); //拿到shiro内部的session保存数据， currentUser.getSession().setAttribute(&quot;loginInfo&quot;,user); return &quot;index&quot;; &#125;catch (UnknownAccountException uae)&#123; model.addAttribute(&quot;error&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException ice)&#123; model.addAttribute(&quot;error&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125;&#125; 用户认证案例走到这里，你会发现无论怎么登录都是错的，那是因为我们还没有对用户进行认证。 用户认证指的是，当用户登录的时候，对其进行验证 1234567891011121314151617@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); /** * 数据库中读取数据 */ UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; User user = userMapper.getUserByName(token.getUsername()); if(user==null)&#123; //这里如果返回null的话，会自动抛出异常到下图处 return null; &#125; //这里的第一个参数user会设置给当前登录对象的Principal中。 //可以通过SecurityUtils.getSubject().getPrincipal()获取 //第二个参数传入正确的密码，即数据库中的密码，交给shiro来做密码的校验，如果密码错误，也会抛出异常到下图的地方 return new SimpleAuthenticationInfo(user, user.getPassword(),&quot;&quot;);&#125; 这里插上一嘴，在web环境中，通过subject拿到的session即web框架中的那个session。 但是如果shiro没有使用在web环境的话，内部也是有一个session的，但是那个就不是web中的session了。 用户授权好啦，现在案例已经可以跑起来了，并且如果账号密码正确的话是可以登录的，并且返回到主页 还记得我们在下图配置的这一串让人一头雾水的配置吗？ 这里就只是配置了一个规则，但是具体登录的用户的授权还没有做，我们现在去完成它吧 1234567891011121314@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //这里需要根据用户表的数据进行增加权限 Subject subject = SecurityUtils.getSubject(); //拿到用户认证的时候传入的user User currentUser = (User) subject.getPrincipal(); System.out.println(&quot;权限为：&quot;+ currentUser.getPerms()); //数据库中perms字段是以这样的形式存储的 user:add,user:update //所以需要将其用，分割然后使用工具类将其转换为集合传入addStringPermissions info.addStringPermissions(Arrays.asList(currentUser.getPerms().split(&quot;,&quot;))); return info;&#125; 现在就完成了所有的配置啦！大家可以尝试一下 这里再多完成一个需求，就是首页只显示用户具有权限的链接 首先需要导入thymeleaf的依赖，然后再导入命名空间xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 配置一个bean 12345//整合thymeleaf@Beanpublic ShiroDialect shiroDialect()&#123; return new ShiroDialect();&#125; index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;p&gt;[[$&#123;msg&#125;]]&lt;/p&gt; &lt;!--当session中没有登录信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo==null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;!--当session有信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo!=null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;!--或者像这样写，不用将用户信息存入session &lt;p shiro:notAuthenticated&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;p shiro:authenticated&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; --&gt; &lt;ul&gt; &lt;li shiro:hasPermission=&quot;user:add&quot;&gt;&lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:del&quot;&gt;&lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:update&quot;&gt;&lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 注销大家都应该注意到了，上面的页面中多了一个注销的链接，接下来我们来完成一下注销的功能 12345@GetMapping(&quot;/logout&quot;)public String logout()&#123; SecurityUtils.getSubject().logout(); return &quot;index&quot;;&#125; 是的，你没有看错，就是这么简单，shiro已经将其完美得封装好了 以上","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"swagger","slug":"SpringBoot-Swagger","date":"2022-02-17T02:11:19.000Z","updated":"2022-10-04T13:55:14.714Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","excerpt":"","text":"Swagger 号称世界上最流行的API框架 RestFul风格的API展示可以实现API文档和API定义同步更新 SpringBoot整合Swagger 导入相关依赖 1234567891011121314151617&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要web的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 写一个简单的Controller 1234567@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 开启Swagger功能 1234@Configuration@EnableSwagger2public class SwaggerConfig &#123; &#125; 访问swagger-ui.html 我们在ui的jar包中可以知道我们可以访问该页面 这是访问的页面 配置SwaggerSwagger中用来配置的bean是Docket 配置文档信息123456789101112131415161718@Beanpublic Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo());&#125;//配置swagger信息public ApiInfo apiInfo()&#123; return new ApiInfo( &quot;swagger测试&quot;,//文档名称 &quot;初次测试swagger&quot;,//文档描述 &quot;1.0&quot;,//版本号 &quot;http://li-zhi.net.cn/&quot;,//作者个人博客 new Contact(&quot;李智&quot;,&quot;http://li-zhi.net.cn/&quot;,&quot;1158778689@qq.com&quot;),//作者联系方式 &quot;Apache 2.0&quot;,//开源协议 &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() );&#125; 配置模型1234567@Controllerpublic class SwaggerModelConfig &#123; @GetMapping(&quot;/user&quot;) public User user()&#123; return new User(); &#125;&#125; 我是专门建了一个SwaggerModelConfig来放置所有的模型类 配置分组因为项目一般是分组协同开发，每个组各自开发的接口，那接口文档应该各自分开，所以就有了分组的需要 分组只需要配置一个groupName(“groupName”)即可 12345678910@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;);&#125; 配置扫描的接口这里主要讲两种方式，第一种是按路径扫描，第二种是按包名扫描 按路径扫描123456789@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .select() .paths(PathSelectors.ant(&quot;/user/**&quot;)) // 该配置下，该组会扫描所有的/user/下的所有的API .build();&#125; 按包名扫描123456789@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.lizhiswaggertest.controller&quot;)) //该配置下，该组会扫描所有此包下的API接口 .build();&#125; 在类RequestHandlerSelectors中还有其他的扫描机制，可自行研究 根据环境控制是否能访问swagger一般产品的开发都会有开发、测试、运维、上线等多套环境，根据不同的环境，控制是否可以访问swagger的ui界面 配置文件application.yml 1234567891011121314151617181920212223---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: test---server: port: 8083spring: profiles: pro---spring: profiles: active: dev 配置dev环境和test环境可以使用swagger 12345678@Beanpublic Docket docket1(Environment environment)&#123; Profiles devProfile = Profiles.of(&quot;dev&quot;,&quot;test&quot;); boolean dev = environment.acceptsProfiles(devProfile); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .enable(dev);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"单例设计模式","slug":"设计模式-单例设计模式","date":"2022-02-16T11:02:56.000Z","updated":"2022-02-25T01:43:38.836Z","comments":true,"path":"设计模式/2022/02/16/设计模式-单例设计模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式该设计模式解决的问题是，一个环境中只会存在一个该类的对象 该模式有五种实现方式 恶汉模式 懒汉模式 静态内部类模式 枚举模式 该设计模式的核心是构造方法私有化 饿汉模式恶汉模式：见名知意，就是在类被加载的时候就创建。 案例：Runtime类 缺点：浪费内存空间 我查了资料，查到了这个缺点，但是这个缺点我不时很能理解 123456789public class Hungry &#123; private final static Hungry HUNGRY = new Hungry(); private Hungry()&#123; &#125; public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 懒汉模式这种实现方式，我们从分几个版本从简单到复杂 Version 0112345678910111213public class LazyMan &#123; private static LazyMan lAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(lAZYMAN==null)&#123; //A lAZYMAN = new LazyMan(); &#125; return lAZYMAN; &#125;&#125; 缺点：只能在单线程中安全，多线程中是不安全的 现在有线程A和线程B，线程A走到了注解A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全 Version 02123456789101112public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public synchronized static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; LAZYMAN = new LazyMan(); &#125; return LAZYMAN; &#125;&#125; 缺点：为方法加锁，确实保证了单例模式，但是我们都知道同步方法，锁的是LazyMan的Class类，所以我们得知这种方式可以保证单例模式的线程安全。但是我们好好想想，当我们创建了第一个单例对象之后，还需要锁来保证同步吗？答案显而易见，肯定是不需要的，所以这种方式效率低下，需要改进，我们来看下一个版本 Version 03123456789101112131415public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; LAZYMAN = new LazyMan(); &#125; &#125; return LAZYMAN; &#125;&#125; 我们不使用同步方法来保证所有的线程同步，我们只对LAZYMAN对象还为null的线程同步，这时候又出现了问题。我们来分析一下 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全，我们发现这和我们没有加锁的时候的情形几乎一模一样。我们来看下一个版本，双重锁机制 Version 04public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125; &#125; 我个人的理解是第一重锁是为了过滤LAZYMAN为NULL的线程，第二重锁是为了保证只能有一个线程去创建对象，这时候我们似乎找不到什么破绽了，我们来继续往下看 Version 05123456789101112131415161718public class LazyMan &#123; private volatile static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125;&#125; 乍一看，好像和上一个版本没什么区别，仔细一看，其实区别是在这个单例变量的修饰符多了一个volatile。 volatile三大作用 保证可见性 不保证原子性 禁止该变量出现的地方发生指令重排 这里的话，我们使用到的特性是第三点，我们来分析一下 LAZYMAN = new LazyMan(); 这一句话其实执行了三个步骤 开辟一个内存空间 初始化对象 将该内存空间的地址指向变量 JVM内部会有一种叫指令重排的代码优化机制，这时候，这三者的顺序就有可能会改变。 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，开始执行LAZYMAN = new LazyMan();开辟内存空间后，没有先初始化对象，而是先将该内存空间的地址指向变量，这时候线程A抢回了CPU，这时候的LAZYMAN已经不是NULL了，直接将其返回了出去，但是这个对象其实还没有初始化，还是个空架子，这就出现了问题。 当然这种情况十分十分少，但是为了严谨性，最好还是加上volatile关键词禁止指令重排 静态内部类模式1234567891011public class StaticWay &#123; private StaticWay()&#123; &#125; public static class InnerClass&#123; private static final StaticWay STATICWAY = new StaticWay(); &#125; public static StaticWay getInstance()&#123; return InnerClass.STATICWAY; &#125;&#125; 该实现方式其实就是利用的JVM的一些特性 类的加载分为以下过程 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中生成一个代表该类的Class对象，作为方法区类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程，当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 ，JVM会保证类构造器在多线程环境下被正确加锁 其实最开始的饿汉单例模式也是也是这个原理 颠覆其实一路到了这里，以上方法都是不安全的。因为java有一个很牛X的包。 java.lang.reflect 我们在最开始说过，单例模式的本质就是构造器私有化，但是java的反射机制，它不讲武德，它可以直接修改权限修饰符。我们来看看代码。 12345678public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;Hungry&gt; constructor = Hungry.class.getDeclaredConstructor(null); constructor.setAccessible(true); Hungry hungry1 = Hungry.getInstance();; Hungry hungry2 = constructor.newInstance(); System.out.println(hungry1==hungry2);&#125;//可想而知最后的结果是 false 可不可以对其作出防御呢？ 1234567891011121314private Hungry()&#123; if(HUNGRY!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;&#125;Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) at com.lizhi.hungry.Hungry.main(Hungry.java:26)Caused by: java.lang.IllegalArgumentException: 请不要尝试使用反射破坏单例模式 at com.lizhi.hungry.Hungry.&lt;init&gt;(Hungry.java:15) ... 5 more 上述方法对饿汉已经作出了合适的防御，那对于懒汉模式，如果两个对象都是使用反射创建的呢？这时候这个防御就是形同虚设了，因为我们肯定是禁止反射去创建对象，所以这种肯定是不行的 123456789101112131415161718192021222324252627282930public class LazyMan &#123; private static LazyMan LazyMan; private LazyMan()&#123; if(LAZYMAN!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; synchronized (LazyMan.class)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 我们引入一个布尔值来完成这个任务 12345678910111213141516171819202122232425262728293031public class LazyMan &#123; private volatile static LazyMan LazyMan; private volatile static boolean flag ; private LazyMan()&#123; if(flag)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; flag=true; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance();// LazyMan lazyMan2 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance();// LazyMan lazyMan1 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 这样反射就无法控制我们的单例了！ 枚举类这时候有没有想起来我们在学javaSE的时候就学到了一个自带单例模式的类型，那就是枚举类Enum！ 我们来尝试攻击一下枚举类！ 1234567891011public enum SingleEnum &#123; SINGLETON; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;SingleEnum&gt; constructor = SingleEnum.class.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); SingleEnum single1 = constructor.newInstance(&quot;single&quot;, 2); SingleEnum single2 = constructor.newInstance(&quot;single&quot;, 2); System.out.println(single1==single2); &#125;&#125; 这时候发现报错了！！ 123Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:484) at com.lizhi.SingleEnum.main(SingleEnum.java:12) 我们点进newInstance方法看下源码， 1234567891011121314151617181920@CallerSensitive@ForceInline // to ensure Reflection.getCallerClass optimizationpublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, clazz, modifiers); &#125; if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125; 我们发现了这句话throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); 这就解释通了，原来是java的反射已经处理好了枚举类，使其真正的实现了安全的单例！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂设计模式","slug":"设计模式-工厂设计模式","date":"2022-02-16T11:01:20.000Z","updated":"2022-02-25T01:45:08.928Z","comments":true,"path":"设计模式/2022/02/16/设计模式-工厂设计模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂设计模式该设计模式解决的问题是：将类实例化的操作与使用对象的操作分开，让使用者不用知道具体参数就可以实例化出所需要的产品类，从而避免了在客户端代码中显式指定，实现了解耦。 该设计模式分为三种实现 简单工厂设计模式 工厂方法实现模式 抽象工厂实现模式 简单工厂设计模式一个汽车工厂生产汽车。有特斯拉、大众、五菱 车的接口 123public interface Car &#123; void printName();&#125; 大众 123456public class DaZhong implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;大众&quot;); &#125;&#125; 特斯拉 123456public class TeSiLa implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;特斯拉&quot;); &#125;&#125; 五菱 123456public class WuLin implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;五菱宏光&quot;); &#125;&#125; 工厂 12345678910111213public class CarFactory &#123; public static Car getCar(String carName)&#123; if(&quot;大众&quot;.equals(carName))&#123; return new DaZhong(); &#125;else if(&quot;五菱宏光&quot;.equals(carName))&#123; return new WuLin(); &#125;else if(&quot;特斯拉&quot;.equals(carName))&#123; return new TeSiLa(); &#125;else &#123; return null; &#125; &#125;&#125; 缺点：很难横向拓展，如果我后期需要加新的车型，需要改变原来的代码，不符合开闭原则（OOP七大原则） 优点：简单易懂 可以简单优化 1234567891011public class CarFactory &#123; public static Car getWuLin()&#123; return new WuLin(); &#125; public static Car getDaZhong()&#123; return new DaZhong(); &#125; public static Car getTeSiLa()&#123; return new TeSiLa(); &#125;&#125; 工厂方法实现模式还是简单工厂的模型，我们来换个工厂 这一次我们定义一个汽车工厂的接口 123public interface CarFactory &#123; Car getCar();&#125; 特斯拉工厂 123456public class TeSiLaCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new TeSiLa(); &#125;&#125; 大众工厂 123456public class DaZhongCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new DaZhong(); &#125;&#125; 五菱工厂 123456public class WuLinCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new WuLin(); &#125;&#125; 缺点：当汽车类型很多的时候，会有很多很多很多各自的工厂，没有必要 抽象工厂实现模式这次我们换一个场景：小米和华为都有路由器和手机的产品 路由器接口 1234public interface Router &#123; void doConfig(); void printInfo();&#125; 手机接口 1234public interface MobilePhone &#123; void sendMsg(); void callUp();&#125; 厂家接口 1234public interface ProductFactory &#123; MobilePhone getMobilePhone(); Router getRouter();&#125; 华为手机 1234567891011public class HuaWeiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;华为手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;华为手机打电话&quot;); &#125;&#125; 华为路由器 1234567891011public class HuaWeiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;华为路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;华为路由器打印详细信息&quot;); &#125;&#125; 小米路由器 1234567891011public class XiaoMiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;小米路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;小米路由器打印详细信息&quot;); &#125;&#125; 小米手机 1234567891011public class XiaoMiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;小米手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;小米手机打电话&quot;); &#125;&#125; 华为厂商 1234567891011public class HuaWeiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new HuaWeiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new HuaWeiRouter(); &#125;&#125; 小米厂商 1234567891011public class XiaoMiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new XiaoMiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new XiaoMiRouter(); &#125;&#125; 两个维度，第一个维度是产品族（路由器、手机），第二个维度是具体厂商（华为，小米）。 根据这两种维度分别设计了接口，抽象的工厂定义生产哪些产品族，具体的工厂具体实现自己的产品族","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot-Security","slug":"SpringBoot-Security","date":"2022-02-16T08:20:46.000Z","updated":"2022-10-04T13:55:07.490Z","comments":true,"path":"javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","excerpt":"","text":"简介Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理! Spring Security的两个主要目标是“认证”和“授权”（访问控制） “认证”(Authentication) “授权” (Authorization) 这个概念是通用的，而不是只在Spring Security 中存在。 基本使用 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 继承WebSecurityConfigurerAdapter 123@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 重写以下方法做出权限设置 1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //首页都可以访问，但是各个级别下的页面设置成只能各自的级别才可以访问 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/vip1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/vip2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/vip3/**&quot;).hasRole(&quot;vip3&quot;); //没有权限默认回到登录页面，loginPage设置登录页面，loginProcessingUrl设置登录提交的api //如果只写 http.formLogin();会有一个默认登录页面和默认的登录提交的api http.formLogin().loginPage(&quot;/login&quot;).loginProcessingUrl(&quot;/user/api/login&quot;); //设置退出时候使session失效，logoutSuccessUrl设置退出成功的页面 http.logout().invalidateHttpSession(true).logoutSuccessUrl(&quot;/index&quot;); //设置’记住我‘的功能 //remember-me为默认提交的参数 http.rememberMe().rememberMeParameter(&quot;remember&quot;);&#125; 重写以下方法做出授权处理 123456789101112@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; /** * 这里要从数据库读 */ //BCryptPasswordEncoder为密码设置加密，如果不设置会报错，也可以使用其他加密的类 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); auth.inMemoryAuthentication().passwordEncoder(encoder) .withUser(&quot;zhima&quot;).password(encoder.encode(&quot;a&quot;)).roles(&quot;vip1&quot;,&quot;vip3&quot;) .and() .withUser(&quot;lizhi&quot;).password(encoder.encode((&quot;123456&quot;))).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;);&#125; 测试 thymeleaf模板结合SpringSecurity导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 观察这个页面的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;!isAuthenticated()&quot;当用户没登录的时候--&gt; &lt;p&gt;首页&lt;/p&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;isAuthenticated()&quot;当用户登录的时候--&gt; 用户名：&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;name&quot;取出用户的用户名--&gt; 授权：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;principal.authorities&quot;取出用户的roles--&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;如果当前登录用户有vip1权限则显示此div--&gt; &lt;span&gt;vip1&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/1&#125;&quot;&gt;vip1-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/2&#125;&quot;&gt;vip1-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/3&#125;&quot;&gt;vip1-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;如果当前登录用户有vip2权限则显示此div--&gt; &lt;span&gt;vip2&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/1&#125;&quot;&gt;vip2-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/2&#125;&quot;&gt;vip2-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/3&#125;&quot;&gt;vip2-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;如果当前登录用户有vip3权限则显示此div--&gt; &lt;span&gt;vip3&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/1&#125;&quot;&gt;vip3-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/2&#125;&quot;&gt;vip3-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/3&#125;&quot;&gt;vip3-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"ForkJoin","slug":"ForkJoin","date":"2022-02-11T08:48:02.000Z","updated":"2022-10-04T13:52:53.878Z","comments":true,"path":"javaEE/JUC/2022/02/11/ForkJoin/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/02/11/ForkJoin/","excerpt":"","text":"ForkJoin什么是ForkJoin？并行执行任务，提交效率，大数据量的时候使用！ 把大任务拆分成小任务 ForkJoin特点：工作窃取内部维护的双端队列，两端都可以出 如何使用 创建ForkJoinPool对象 新建一个计算任务ForkJoinTask放入池子中计算 1234567891011121314151617181920212223242526272829303132package com.lizhi;import java.util.concurrent.RecursiveTask;public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private long start; private long end; private long temp = 10000L; public ForkJoinDemo(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override public Long compute()&#123; long result = 0; if(end-start&lt;temp)&#123; for (long i = start; i &lt;= end; i++) &#123; result+=i; &#125; &#125;else &#123; long middle = (start + end) / 2; ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start,middle); forkJoinDemo1.fork(); ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle,end); forkJoinDemo2.fork();//把任务压入线程队列 result = forkJoinDemo1.join()+ forkJoinDemo2.join(); &#125; return result; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"}]},{"title":"函数式接口","slug":"函数式接口","date":"2022-02-11T07:13:29.000Z","updated":"2022-10-04T13:56:05.902Z","comments":true,"path":"琐碎的知识/2022/02/11/函数式接口/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"函数式接口函数式接口，即只有一个抽象方法的接口即为函数式接口，可以使用lambda表达式简化使用。 函数式接口一般接口上都会有@FunctionInterface注解做标记，作用是检查该接口是否只有一个抽象方法，如果不写，但是接口中确实只有一个抽象方法，也不会影响lambda的使用，下面我们来看一下一些常见的函数式接口 Function&lt; T , R &gt;函数型接口 T为传入参数的类型 R为返回值类型 123Function&lt;String, String&gt; f = s -&gt; s.substring(2,4);String apply = f.apply(&quot;asdas asd &quot;);System.out.println(apply); Predicate&lt; T &gt;断言型接口 T为传入参数的类型 返回值为Boolean 123Predicate&lt;String&gt; p = t-&gt;t.length()&gt;5;System.out.println(p.test(&quot;3223&quot;));System.out.println(p.test(&quot;saf223&quot;)); Consumer&lt; T &gt;消费者型接口 T为传入的参数 无返回值 123Consumer&lt;String&gt; consumer = c-&gt; System.out.println(&quot;我使用了&quot;+c);consumer.accept(&quot;123&quot;);consumer.accept(&quot;456&quot;); Supplier&lt; T &gt;生产者型接口 T为返回值类型 12Supplier&lt;String&gt; supplier = ()-&gt; UUID.randomUUID().toString();System.out.println(supplier.get());","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"线程池","slug":"JUC-线程池","date":"2022-02-11T06:31:26.000Z","updated":"2022-10-04T13:53:09.177Z","comments":true,"path":"javaEE/多线程/2022/02/11/JUC-线程池/","link":"","permalink":"https://li-zhi.net.cn/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022/02/11/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"线程池三大方法我们先看使用Executors创建的三种线程池 123Executors.newSingleThreadExecutor();//创建一个只有一个线程的线程池Executors.newFixedThreadPool();//创建一个固定数目的线程的线程池Executors.newCachedThreadPool();//缓存池，会复用之前使用过的线程 执行线程 12345678public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); &#125;&#125; 七大参数阿里巴巴规范中有这么一条 12345线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下：1）FixedThreadPool和SingleThreadPool: 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。2）CachedThreadPool: 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 我们来看看创建这三种线程池的构造方法 1234567891011121314151617public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以发现，这三个构造方法创建的对象其实都是ThreadPoolExecutor对象，只不过就是构造参数不一样。 参数 作用 int corePoolSize 核心线程池的大小 int maximumPoolSize 最大线程池的大小 long keepAliveTime 超时时间过后就释放 TimeUnit unit 超时时间单位 BlockingQueue&lt; Runnable&gt; workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂，创建线程的，一般不用动 RejectedExecutionHandler handler 拒绝策略 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize为一直开着的线程数，当workQueue已经满了，则继续开启线程直到maximumPoolSize，当线程数到了maximumPoolSize，然后workQueue也满了，如果还有新的任务，则使用handler拒绝策略对其进行处理。 当corePoolSize-maximumPoolSize区间的线程等待了workQueue时间后，还是没任务来，则关闭该区间的线程 123456789ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); CPU密集型和IO密集型最大线程数到底如何定义？ CPU密集型几核CPU就是几，可以保证效率最高 1Runtime.getRuntime().availableProcessors()//动态获取cpu核数 IO密集型程序里面有多少个非常消耗IO的线程，一般最大线程数设置为该数字的两倍 四大拒绝策略 AbortPolicy不处理此任务，并且抛出异常 CallerRunsPolicy不处理此任务，往上传递此任务，哪来的回哪里去 DiscardOldestPolicy不处理此任务，不会抛出异常 DiscardPolicy尝试和最老的那一个线程竞争，不会抛出异常","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"https://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JVM-简介","slug":"JVM-简介","date":"2022-02-10T04:24:26.000Z","updated":"2022-10-04T13:53:05.830Z","comments":true,"path":"javaEE/JVM/2022/02/10/JVM-简介/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/02/10/JVM-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"JVM的体系结构下面是简易的结构图 栈中不会有垃圾回收 大部分JVM调优都是在堆内存上进行调优 详细的结构图如下 沙箱安全机制​ java安全模型的核心就是java沙箱（sandbox）。沙箱是一个限制程序运行的环境。沙箱机制就是将java代码限定在JVM特定的运行范围内，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源（CPU，内存，文件系统，网络）访问。不同级别的沙箱对这些资源的限制就不一样 ​ 所有的java程序运行都可以指定沙箱，可以指定安全策略。 ​ 在java中，将执行过程分为本地代码和远程代码两部分，本地代码是默认可信任的，而远程代码则被看做是不受信任的。对于授予信任的本地代码，可以访问一切本地资源。而对于非授予信任的远程代码在早期的java实现中，完全依赖于java沙箱机制。下图是jdk1.0的安全模型 ​ 但是如此严格的安全机制也给程序的功能拓展带来了障碍，比如用户希望远程代码访问本地资源的时候，就会被沙箱机制所拒绝。所以在后来的jdk1.1版本中，针对安全机制做出了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。下图是jdk1.1的安全模型 ​ 在jdk1.2的版本中，再次引进安全机制，增加了代码签名，不论是本地代码还是远程代码，都会按照用户的安全策略设定，由类加载器加载到JVM中权限不同的运行空间，来实现差异化的代码执行权限控制。下图是jdk1.2的安全模型 ​ 当前最新的安全机制实现，则引入了域（domain）的概念。JVM会把所有的代码加载到不同的系统和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。下图是jdk1.6的安全模型 ​ 组成沙箱的基本组件: 字节码校验器(bytecode verifier):确保java类文件遭循java语言规范。这样可以帮助ava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器(classloader):其中类装载器在3个方面对java沙箱起作用 它防止恶意代码去干涉善意的代码; 它守护了被信任的类库边界; 它将代码归入保护域，确定了代码可以进行哪些操作。 ​ 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由ava虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 从最内层IVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用; 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 存取控制器(access controller):存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包(security package):javasecurity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括: 安全提供者 消息摘要 数字签名 加密 鉴别 native凡是带了native关键词的方法，说明这个方法java语言实现不了，此方法会被放入本地方法栈中，该栈通过JNI（Java Native Interface）去调用底层的C或者C++语言写的方法。 方法区Method Area 方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单来说，所有定义的方法的信息都会被保存在该区域 静态变量、常量、类信息（构造方法，接口定义），运行时的常量池存放在方法区中，但是实例变量存在于内存区中，与方法区无关 PC寄存器程序计数器：Program Counter Register ​ 每个线程都有一个程序计数器，实现程序私有的，就是一个指针，指向方法区中的方法字节码 堆（Heap）一个JVM只有一个堆内存，堆内存的大小是可以调节的，里面一般放实例对象 堆内存细分为三个区域： 新生区 Young&#x2F;New 养老区 old 永久区 perm GC垃圾回收主要在伊甸园区和养老区 堆内存满了就会爆OOM（OutOfMemoryError）错误 所有的对象都是在伊甸园区产生的 伊甸园满了会触发轻GC，有的就直接死了，然后留下来的去往幸存区 如果幸存区满了，就去往老年区 如果老年区满了，触发一次重GC（伊甸园区和幸存者区都清一遍，活下来的去老年区） 垃圾处理器GCGC的作用区域只有堆 两种回收：轻GC 、Full GC GC的算法 标记清除法 标记整理法 标记复制算法 引用计数法（给每一个对象分配一个计数器，将计数器为0的对象清除） 标记复制法谁空谁是to幸存区 新生区主要使用复制算法 好处：没有内存碎片 坏处：浪费了内存空间 复制算法使用最佳场景：对象存活度较低的时候 标记清除法扫描这些活着的对象，清除没有标记的对象进行清除 缺点：两次扫描，浪费时间，会产生内存碎片 优点：不需要额外空间 标记整理法再次扫描，向一端移动存活的对象 分代收集算法 年轻代： 存活率低 复制算法 老年代 存活率高 标记清除+标记压缩混合实现 这五道面试题可以试着做一做 请你谈谈你对JVM的理解？java8虚拟机和之前的有什么不同？ 什么是OOM，什么是栈溢出？怎么分析？ JVM的常用调优参数有哪些？ 内存快照如何抓取？怎么分析Dump文件？ 谈谈你对类加载器的认识？","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"if语句减少嵌套","slug":"if语句减少嵌套","date":"2022-02-07T12:32:09.000Z","updated":"2022-10-04T13:52:57.435Z","comments":true,"path":"琐碎的知识/2022/02/07/if语句减少嵌套/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/if%E8%AF%AD%E5%8F%A5%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97/","excerpt":"","text":"if的多重嵌套直接举栗子：有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 可以看到这里的if语句可能不是那么繁琐，但是当业务十分复杂或者当策略会经常变动的时候，需要经常修改源代码，这就严重违反了开闭原则，但是我可不可减少if的出现甚至不出现呢？ 下面我们结合以下两种解决方案来一步一步尝试解决问题 卫语句 策略模式 Version 1.1卫语句，就是将不符合的情况直接返回 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.0策略模式就是将各个会员的优惠方式提出一个接口，分别实现 策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2022-02-07T10:04:34.000Z","updated":"2022-09-27T14:17:58.259Z","comments":true,"path":"琐碎的知识/2022/02/07/Cookie和Session/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Cookie%E5%92%8CSession/","excerpt":"","text":"情景在线我们在登录完一个网站后，很长一段时间都不需要输入用户名和密码。大家有没有好奇这是为什么呢？ 学过HTTP的都知道，HTTP访问是无状态的，也就是说，服务器是不知道你这是第几次访问该网站的。 那么Cookie，Session就是来做到让服务器预先知道一些信息，其核心其实就是存储。 Cookie是存储在客户端的，Session是存储在服务器端的 下面我们来说说Cookie CookieCookie翻译为小饼干 该技术可以实现每次HTTP请求都自动带数据给服务器，从而实现服务器可以在请求的时候就预先知道一些信息。 流程图如下 我们可以在浏览器中查看Cookie 如果使用Cookie保存账号密码，那只要别人盗到你的Cookie，那么你的账号密码就泄露了！所以就出现了Session的技术 SessionSession翻译为会话 当我们打开一个浏览器进去网站，则开始一个会话，但是会话的结束比较模糊，可以自动设置session过期时间，也可以设置永不过期。 Session保存在服务器，当产生了一次会话，则服务器返回的时候携带存储session相关信息的Cookie，并保存在客户端，而这个session对象的信息则保存在服务器的数据库中。 下面是流程图","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Token","slug":"Token","date":"2022-02-07T10:01:03.000Z","updated":"2023-01-11T08:08:38.418Z","comments":true,"path":"琐碎的知识/2022/02/07/Token/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Token/","excerpt":"","text":"为什么会出现Token相信大家都知道Cookie和Session（不知道这两者的在我另外两篇博客里面有写，附上链接，Cookie和Session） 随着技术的发展，用户群体变的越来越大，如果服务器依旧使用基于Cookie的Session，在某一时间段有大量用户访问的话，服务器就会将大量的Session保存在数据库中，导致服务器性能降低，为了处理这种问题，就出现了一种技术，也就是JWT(JSON Web Token) Token JWT是由三部分组成的，分别是header、payload、signature header部分申明用什么算法生成签名 payload部分保存一些数据 signature部分保存header申明的算法生成的签名 小结Session、Cookie、Token都是是在服务器产生的 Cookie是保存SessionID的载体，但是Session对象是保存在服务器数据库中的 Token在服务器端生成，保存服务器端的密文，将token放入cookie发送诶客户端并交由客户端保存","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Ngrok","slug":"Ngrok","date":"2022-02-07T09:30:02.000Z","updated":"2022-10-04T13:54:15.986Z","comments":true,"path":"琐碎的知识/2022/02/07/Ngrok/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Ngrok/","excerpt":"","text":"使用Ngrok快速部署项目 打开https://ngrok.cc/ 注册一个账户 支付2块钱进行支付宝实名认证 点击开通隧道并翻到最后 开通隧道选项 说明： 隧道协议，两者即可 HTTP HTTPS（HTTPS需要绑定自己的域名，并且已经申请了SSL证书，才能有效，否则无法使用https。） 隧道名称 随便写即可 前置域名 写自己喜欢的 http验证用户名和密码 这里可以不写 确认信息，开通 进入隧道管理页面 ps：这里和我之前写的配置不一样，是因为一个用户只能免费开通一个http隧道 下载客户端 下载对应系统的软件，并解压 启动批处理命令 ps：我第一次使用的不是乱码，我也不理解这次使用为什么会乱码，这里不影响使用 输入隧道id，回车 如果之前配置了账号密码，则在此处需要输入账号密码 启动本地项目 注：本地项目启动的端口一定要和之前写的端口映射一致 打开网址测试 本地 Ngrok提供的网站访问","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"关于路径","slug":"关于路径","date":"2022-02-07T08:57:28.000Z","updated":"2022-10-04T13:56:00.923Z","comments":true,"path":"琐碎的知识/2022/02/07/关于路径/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84/","excerpt":"","text":"访问路径URL统一资源定位符，用于定位资源的一种方式。 通常的URL资源访问路径由两部分构成:资源路径与资源名称。 资源名称指的是要访问资源的直接名称，如show.html,或与要访问资源存在映射关系的间接名称，如show.do 资源路径，则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。 根据“资源路径是否可以独立完成资源准确定位”的判别标准,可以将访问路径分为绝对路径与相对路径 绝对路径绝对路径，是指根据给出的访问路径可以精确的定位到这个资源的路径 对于计算机中Web应用的绝对路径，则是指带访问协议的路径。即URL 相对路径相对路径,是指仅根据访问路径无法准确定位资源的路径。 相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。 参照路径的不同，所形成的可以准确定位资源的绝对路径也是不同的。 在进行资源访问时,必须要将相对路径转换为绝对路径才可完成资源的精确定位 绝对路径 &#x3D; 参照路径 + 相对路径 根据相对路径是否以斜杠开头，且路径指向的文件不同，其默认的参照路径是不一样的 以斜杠开头的相对路径前台路径所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。 例如，html、 css、 js中的路径，及jsp文件中静态部分的路径(HTML标签中的路径)。html 及jsp文件中的&lt; img src-&#x3D;*&#x2F;&gt;、&lt; a href&#x3D;””&gt;. &lt; form action&#x3D;””&gt;等标签中的以斜杠开头的路径都属于前台路径 前台路径的参照路径是Web服务器的根路径,即http://127.0.0.1:8080 将前台路径转换为绝对路径的工作,是由浏览器自动完成的。 该路径的作用是要为用户提交对某种资源的请求,是要查找并定位服务器中的某资源。 简单来说,前台路径的作用是“查找” 后台路径所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。 例如，java 代码中的路径、jsp文件动态部分java代码块)中的路径、xml等配置文件中的路径(配置文件是要被java代码解析后加载到内存的，其中的路径会出现在Java 代码中) 后台路径的参照路径是Web应用的根路径。http://127.0.0.1:8080/projectName 将后台路径转换为绝对路径的工作,是由服务器自动完成的。该路径的作用是标识出该资源在服务器中的路径，以便客户端能够按照这个设定路径来查找相应资源。简单来说,后台路径的作用是“标识” 以路径开头的相对路径以路径名称开头的相对路径，无论是出现在前台页面,还是出现在后台Java代码或配置文件中，其参照路径都是当前访问路径的资源路径。 即使是response 的sendRedirect()方法的参数路径,若不以斜杠开头，其也属于“以斜杠开头的相对路径”类的路径，参照路径为当前服务器的根路径 总结 相对路径类型 参照路径 相对路径转绝对路径的完成者 前台路径 当前Web服务器的根路径 浏览器 后台路径 当前Web应用的根路径 Web服务器 以路径名称开头的路径 当前访问路径的资源路径 浏览器&#x2F;Web服务器 PS： 对于response的sendRedirect( )方法完成的重定向 若其参数路径为“以斜杠开头的相对路径”这个后台路径是个特例。是由sendRedirect( )方法的本质决定的。这个方法不仅可以完成在当前项目中资源的跳转,还可以跳转到其它项目中的资源。所以这个后台路径的参照路径为“当前Web服务器的根”。所以要加resquest.getContextPath(); 注意，只有这一种重定向是特例,将来我们还会学习到其它方式实现的重定向，但那里的重定向就不是特例,而是遵循我们之前的路径转换理论 如果加斜杠和不加斜杠都可以完成跳转，就加上斜杠","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"SpringMVC-文件下载","slug":"SpringMVC-文件下载","date":"2022-01-31T06:57:54.000Z","updated":"2022-10-04T13:55:44.776Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件下载/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"文件下载文件下载很简单，只要设置一下响应头即可 页面： 123456789101112131415161718192021&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; ul li &#123; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;javascript:&quot;&gt;点击文字下载&lt;/a&gt;&lt;ul id=&quot;ul&quot;&gt; &lt;c:forEach items=&quot;$&#123;fileList&#125;&quot; var=&quot;file&quot;&gt; &lt;li&gt;&lt;a href=&quot;/fileDownLoad.do?fileName=$&#123;file&#125;&quot;&gt;$&#123;file&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Controller： 123456789101112131415161718@GetMapping(&quot;/fileDownLoad.do&quot;)public String fileDownLoad(String fileName,HttpServletRequest req,HttpServletResponse resp) throws IOException &#123; String realPath = req.getServletContext().getRealPath(&quot;\\\\download&quot;)+&quot;\\\\&quot;; File file = new File(realPath.concat(fileName)); resp.setHeader(&quot;Content-disposition&quot;,&quot;attachment; filename=&quot;+ URLEncoder.encode(file.getName(),&quot;UTF-8&quot;)); ServletOutputStream outputStream = resp.getOutputStream(); FileInputStream fis = new FileInputStream(file); byte[] buffer = new byte[1024]; int len=0; while((len=fis.read(buffer))&gt;0)&#123; outputStream.write(buffer,0,len); &#125; outputStream.flush(); fis.close(); outputStream.close(); return &quot;filedownload&quot;;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-文件上传","slug":"SpringMVC-文件上传","date":"2022-01-31T06:55:40.000Z","updated":"2022-10-04T13:55:41.444Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件上传/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"准备工作首先对于表单中的enctype属性做一个了解 application&#x2F;x-www&#x3D;form-urlencoded:默认方式，只处理表单中的value的属性值，采用这种编码方式的表单会将表单域中的值处理成URL编码方式 multipart&#x2F;form-data:这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会将文件域中的文件夜风撞到请求参数中 text&#x2F;plain:除了把空格改为“+”号外，其他字符不做编码处理，这种方式适合直接通过表单来发送邮件 文件上传是一个web项目中很常见的功能，在springmvc中有着很好的支持，但是springmvc默认上下文没有配置MultipartResolver，所以在做文件上传和下载前，需要配置MultipartResolver， 在原有包的基础上导入此包 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt; 注册MultipartResolver实例，id必须为multipartResolver，id必须为multipartResolver，id必须为multipartResolver，不然报错 12345&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; 以下就不赘述springMVC的配置文件了 上传单个文件页面： 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; controller： 12345678910111213141516171819202122@PostMapping(&quot;/singleFileUpload.do&quot;)public String singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false) CommonsMultipartFile avatar,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); return &quot;singleFileUpload&quot;;&#125; 上传多个文件其实和上传单个文件很像，只要input控件的name属性是一样的，那它们就是一组，下面来看看代码 controller：（两法，个人偏向于第二种） 12345678910111213141516171819202122232425@PostMapping(&quot;/multiFileUpload.do&quot;)public String multiFileUploadDo(@RequestParam(value = &quot;file&quot;,required = false) CommonsMultipartFile[] files,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload/multipart&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; for (int i = 0; i &lt; files.length; i++) &#123; //文件的全称，包括后缀 String avatarWholeName = files[i].getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 files[i].transferTo(new File(realSavePath)); &#125; return &quot;multiFileUpload&quot;;&#125; 1234567891011121314151617181920212223@PostMapping(&quot;/multiFileUpload.do&quot;)public Map multiFileUploadDo(HttpServletRequest request) throws IOException &#123; String realPath = request.getServletContext().getRealPath(&quot;\\\\multipartUpload&quot;)+&quot;\\\\&quot;; CommonsMultipartResolver cmr = new CommonsMultipartResolver(request.getServletContext()); if(cmr.isMultipart(request))&#123; MultipartHttpServletRequest req = (MultipartHttpServletRequest) request; MultiValueMap&lt;String, MultipartFile&gt; multiFileMap = req.getMultiFileMap(); for (String fieldName : multiFileMap.keySet()) &#123; String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); //创建存放文件的文件夹 File dir = new File(realPath + uuidPath + fieldName); dir.mkdirs(); List&lt;MultipartFile&gt; multipartFiles = multiFileMap.get(fieldName); for (MultipartFile f : multipartFiles) &#123; //如果文件为空，则忽略，不然会报错 if(!f.isEmpty())&#123; f.transferTo(new File(dir.getPath()+&quot;\\\\&quot;+f.getOriginalFilename())); &#125; &#125; &#125; &#125; return &quot;multiFileUpload&quot;;&#125; 页面： 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/multiFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 以上都是同步提交，下面我们使用异步提交并且将图片预览出来，这次只演示单个文件上传，多个文件上传同理。 异步提交并提供预览Controller： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@PostMapping(&quot;/reg.do&quot;)@ResponseBodypublic Map reg(User user,String relativePath)&#123; user.setAvatarUrl(&quot;\\\\upload\\\\&quot;.concat(relativePath)); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); System.out.println(user); map.put(&quot;result&quot;,&quot;success&quot;); return map;&#125;@PostMapping(&quot;/singleFileUpload.do&quot;)@ResponseBodypublic Map singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false)CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); if(avatar==null||avatar.isEmpty())&#123; map.put(&quot;result&quot;,&quot;fail&quot;); return map; &#125; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); map.put(&quot;result&quot;,&quot;success&quot;); //用来给页面显示图片 map.put(&quot;relativePath&quot;,&quot;\\\\upload\\\\&quot;.concat(realFileName)); //用来给前端判断是否需要再次上传 map.put(&quot;fileName&quot;,avatarWholeName); return map;&#125; 页面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;userName&quot; id=&quot;userName&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;number&quot; placeholder=&quot;请输入年龄&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;div style=&quot;display: none&quot; id=&quot;showimgcontainer&quot;&gt; &lt;img id=&quot;showimg&quot; width=&quot;400px&quot; height=&quot;400px&quot; style=&quot;border: solid 1px black&quot;/&gt; &lt;/div&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;submitBtn&quot; value=&quot;注册&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.form.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; let fileName; let relativePath; $(&#x27;#avatar&#x27;).change(()=&gt;&#123; if(fileName===$(&#x27;#avatar&#x27;)[0].files[0].name)&#123; return; &#125; let options = &#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&#x27;, dataType:&#x27;text&#x27;, success(data)&#123; data = JSON.parse(data); if(data.result===&#x27;fail&#x27;)&#123; alert(&quot;文件为空或者不存在&quot;); return; &#125; relativePath = data.relativePath; fileName = data.fileName; $(&#x27;#showimgcontainer&#x27;).show(); $(&#x27;#showimg&#x27;).attr(&#x27;src&#x27;,relativePath); &#125; &#125; $(&#x27;#form&#x27;).ajaxSubmit(options); &#125;) $(&#x27;#submitBtn&#x27;).click(()=&gt;&#123; $.ajax(&#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/reg.do&#x27;, method:&#x27;post&#x27;, data: &#123;relativePath:relativePath,userName:$(&#x27;#userName&#x27;).val(),age:$(&#x27;#age&#x27;).val()&#125;, success(data) &#123; if(data.result===&#x27;success&#x27;)&#123; alert(&quot;注册成功&quot;); window.location = &#x27;$&#123;pageContext.request.contextPath&#125;/login&#x27;; &#125;else &#123; alert(&quot;出错！请重试！&quot;); &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"Linux-其他命令","slug":"Linux-其他命令","date":"2022-01-31T06:10:26.000Z","updated":"2023-01-10T14:32:41.773Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-其他命令/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/","excerpt":"","text":"df作用查看磁盘使用情况 使用说明12345678910# 格式：df [参数] [对象磁盘/分区]# 常用参数 # 显示所有系统文件 -a, --all include pseudo, duplicate, inaccessible file system # 以容易阅读的方式展示 -h, --human-readable print sizes in human readable format (e.g., 1K 234M 2G # 显示索引节点的信息 -i, --inodes list inode information instead of block usage # 只显示本地的文件系统 -l, --local limit listing to local file systems","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"SpringMVC-JSON","slug":"SpringMVC-JSON","date":"2022-01-29T02:05:17.000Z","updated":"2022-10-04T13:55:22.980Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","excerpt":"","text":"JSON(JavaScript Object Notation)JSON是一种十分轻量级的数据交换的格式，我们来讲一下处理JSON字符串的两个库 Jackson 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.1&lt;/version&gt;&lt;/dependency&gt; 将对象转为JSON字符串 12ObjectMapper mapper = new ObjectMapper();String json = mapper.writeValueAsString(user); 这时候，页面再次出现乱码问题 第一种原生的解决方案是 1@GetMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 第二种使用springmvc的配置文件，这段配置只针对jackson库 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 那我们怎么处理时间对象呢？ 12345678@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; Date date = new Date(); ObjectMapping objectMapping = new ObjectMapper(); return objectMapping.writeValueAsString(date);&#125;//返回的是当时的时间戳 下面是第一种方法 123456@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); return new ObjectMapper().writeValueAsString(sdf.format(new Date()));&#125; 这是第二种方法 123456789@GetMapping(&quot;/datejson2&quot;)@ResponseBodypublic String jsonDate2() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); mapper.setDateFormat(sdf); return mapper.writeValueAsString(new Date());&#125; FastJson 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt;&lt;/dependency&gt; 主要的三个类 JSONObject 对应JSON对象，可以使用get方法获取JSON对象的值 JSONArray 代表JSON数据 JSON代表JSONarray和JSONObject的转化 主要用这个类的静态方法去转化JSON字符串和对象","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-Controller","slug":"SpringMVC-Controller","date":"2022-01-29T02:02:36.000Z","updated":"2022-10-04T13:55:19.525Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","excerpt":"","text":"Controller控制器和mybatis不同，在springmvc中，注解开发才是主流，所以接下来都会使用注解来开发。 被@Controller标注的类是一个控制器类，其中的每一个方法都是一个控制器，都各自映射一个url地址 在spring中我们说过，使用注解的时候需要在spring的配置文件中开启注解扫描 12&lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt;&lt;!--这里最好写到controller包，因为该配置文件专注于处理Controller层的事情，不要将包扫描的范围扩大--&gt; 回顾spring中的常用注册bean的注解 12345@Component 普通组件@Service 服务层@Repository 持久层@Mapper mybatis的接口层@Controller 控制器层 因为我们配置的DispatcherServlet会拦截所有的请求，但是对于静态资源，我们不需要拦截对他做出处理，所以有了以下配置 12&lt;!-- Springmvc不处理静态文件--&gt;&lt;mvc:default-servlet-handler/&gt; @RequestMapping该注解可以作用于类上面或者方法上面 方法上面 该方法映射的url地址即为注解中的值 类上面 当其作用在类上面的时候，该控制器类中所有的方法的映射路径的前面都会加上该注解中的值 @GetMapping 该注解代表请求是get请求 @PostMapping 该注解代表请求是post请求 @PutMapping 该注解代表请求是put请求 @DeleteMapping该注解代表请求是delete请求 @RestController当类上不是@Controller注解而是@RestController时候，该类中所有的方法返回的值，不会跳转视图，而是返回JSON字符串 如果不想让类中所有的方法都返回字符串 则类上面使用@Controller注解，方法上使用@ResponseBody标注此方法返回的结果是一个JSON字符串不要被视图解析器解析 RestFul风格概念：RestFul就是一个资源定位及资源操作的风格。 它不是标准也不是协议，它就只是一个style。基于这种风格设计的软件可以更加简洁，更有层次，并且安全，更易于实现缓存等机制 传统方式操作资源通过不用的参数来实现不同的功能，方法单一，post和get http:&#x2F;locoalhost:8080&#x2F;item&#x2F;insertItem post提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;deleteitem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;queryItem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;updateitem post提交 使用RestFul风格操作资源 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;add&#x2F;参数&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;query&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… 本质其实就是通过不同的提交方式走不同的方法 结果跳转方式控制器最后直接return字符串的话默认请求转发 如果想要重定向字符串前面加“**redirect:**”即可 处理前端数据 如果提交参数的名称和方法的参数名一致的话， 提交数据：http://localhost:8080/user/add?name=lizhi&amp;age=20 1234@GetMapping(&quot;user/add&quot;)public String test01(String name,int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交参数和方法参数不一致的话 提交数据：http://localhost:8080/user/add?username=lizhi&amp;userage=20 1234@GetMapping(&quot;user/add&quot;)public String add(@RequestParam(&quot;username&quot;) String name,@RequestParam(&quot;userage&quot;)int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交的是一个对象 提交数据：http://localhost:8080/user/add 要求提交的表单要和属性的属性名一致，方法参数即可直接使用对象 1234@PostMapping(&quot;user/add&quot;)public String add(User user,Model model)&#123; return &quot;user&quot;;&#125; 返回前端数据 ModelAndView 该对象在初识mvc的时候已经见过，不再赘述 Model（这是一个接口） 该对象在使用注解开发的时候也已经见过，这里也不再赘述 ModelMap ModelMap实现了Model接口，继承了LinkedHashMap，所以它更强大，但是大部分情况下Model会更常用","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-简述","slug":"SpringMVC-简述","date":"2022-01-29T02:01:23.000Z","updated":"2022-10-04T13:55:30.676Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-简述/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-%E7%AE%80%E8%BF%B0/","excerpt":"","text":"Spring MVCModel 1时代所有请求直接转发到jsp然后在jsp编写业务代码，然后根据不同的结果跳转不同的页面 Model 2时代Controller 取得表单数据 处理业务逻辑 根据不同的情况跳转不同的页面 View 展示数据 Model 业务逻辑 保存数据 简介SpringMVC的特点： 轻量级，简单易学 与spring无缝结合，可以将mvc中所有需要的类注册到ioc容器中 高效，基于请求和响应的mvc框架 功能强大，RESTFUL风格，格式化，数据验证 约定大于配置 说白了学它就一个原因，因为它让我们开发变得简单了 原理 回顾servlet我们都学过java web，那时候我们对于前端的请求都是通过一个servlet来处理的，然后在servlet里面，处理前端传来的数据，调用业务逻辑，返回处理之后的数据，然后servlet根据这些数据，进行重定向或者请求转发 一个请求对应一个servlet，这就会导致我们在开发中写了大量的servlet，而且每次都需要在web.xml中注册，十分繁琐。 没有什么是加一层解决不了的，所以，springmvc在servlet之前加了一层来简化我们的开发 SpringMVC的web框架是以围绕DispatcherServlet（前端控制器，调度器，请求分发器）设计的。它的作用就是将请求分发到不同的处理器（方法或者类，下面的初识mvc是以类级作为处理器，但是一般都会使用方法级去做处理器） 下图是DispatcherServlet的结构图，我们可以看到一些在javaweb阶段比较眼熟的类，比如Servlet，GenericServlet，HttpServlet。因此我们可以得出，DispatcherServlet本质就是一个和我们当时写的servlet是一样的，只是他帮我们做了很多事情。 人到中年有三大件，枸杞大枣保温杯。 SpringMVC中也有三大件，分别是 处理器映射器（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 我们来看看这三大件是如何在springmvc中发挥作用的，原理图如下： 核心类图 简要分析 DispatcherServlet就可以简单理解为前端控制器，他会将所有客户端的请求拦截 将该请求发送给HandlerMapping实现类，该实现类根据url查找到对应的控制器，将结果返回给DispatcherServlet DispatcherServlet根据HandlerMapping解析的结果，适配并执行对应的控制器的逻辑， 控制器返回信息，HandlerAdapter实现类接收该信息并将其解析成ModelAndView对象返回到DispatcherServlet DispatcherServlet调用ViewResolver实现类将HandlerAdapter实现类传回来的视图逻辑和模型解析 视图解析器将解析后的逻辑视图名传回DispatcherServlet DispatcherServlet根据解析后的视图名称找到该视图 渲染视图，返回页面，作出响应","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-拦截器","slug":"SpringMVC-拦截器","date":"2022-01-28T14:48:50.000Z","updated":"2022-10-04T13:55:34.517Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-拦截器/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"SpringMVC中的拦截器其实此拦截器就是我们在javaweb阶段使用的过滤器，只不过是换了一个名字而已，换汤不换药，本质是一样的。 只不过拦截器是AOP思想的具体应用 过滤器： Servlet规范中的一部分，任何javaweb工程都可以使用 在url-pattern中配置了&#x2F;*后，会拦截所有的请求 拦截器： 拦截器是SpringMVC中才会有的，只有使用了此框架的工程才可以使用 拦截器只会拦截访问的控制器方法，如果访问的是静态资源是不会进行拦截的 自定义拦截器实现HandlerInterceptor接口 1234567891011121314151617181920212223242526272829package com.lizhi.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; /** * return true才会执行下一个拦截器 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;===处理前===&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;===处理后===&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;===清理===&quot;); &#125;&#125; 在Spring核心文件中注册拦截器 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/**会拦截这个请求下面的所有请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.lizhi.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-乱码","slug":"SpringMVC-乱码","date":"2022-01-28T14:48:01.000Z","updated":"2022-10-04T13:55:37.492Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-乱码/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E4%B9%B1%E7%A0%81/","excerpt":"","text":"乱码！一生之敌！！！UserController 123456789101112131415161718package com.lizhi.controller;import com.lizhi.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping(&quot;/login.do&quot;) public String login(User user, Model model)&#123; model.addAttribute(&quot;user&quot;,user); return &quot;index&quot;; &#125;&#125; login.jsp 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/user/login.do&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;name:$&#123;user.name&#125;age:$&#123;user.age&#125;&lt;/body&gt;&lt;/html&gt; 结果如下： 我们先尝试一下配置一个过滤器，这是第一种方案 1234567891011121314151617181920212223package com.lizhi.filter;import javax.servlet.*;import java.io.IOException;public class CharsetFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 记得去web.xml中注册 12345678&lt;filter&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.CharsetFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 我们尝试后发现，没有任何效果，那既然我们写的过滤器不行 那springmvc给我们写了一个专门处理乱码的过滤器，我们来配置一下，这是第二种方案，很稳妥 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 测试后发现，还是乱码！！这时候我们可以去看一下tomcat的config目录下的server.xml，找到connector标签并修改属性 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 发现还是不行，我们去找一个其他大佬自己写的过滤器试一试，这是第三种方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.lizhi.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.util.Map;public class EncodeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse resp = (HttpServletResponse) servletResponse; resp.setContentType(&quot;text/html;utf-8&quot;); HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletRequest myreq = new MyRequest(req); filterChain.doFilter(myreq, resp); &#125; @Override public void destroy() &#123; &#125;&#125;class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; private boolean hasEncode; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public Map getParameterMap() &#123; String method = request.getMethod(); if(&quot;post&quot;.equalsIgnoreCase(method))&#123; try&#123; request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;else if(&quot;get&quot;.equalsIgnoreCase(method))&#123; Map&lt;String,String[]&gt; parameterMap = request.getParameterMap(); if(!hasEncode)&#123; for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if(values!=null)&#123; for (int i = 0; i &lt; values.length; i++) &#123; try&#123; values[i] = new String(values[i].getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; @Override public String getParameter(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if(values==null)&#123; return null; &#125; return values[0]; &#125; @Override public String[] getParameterValues(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); return parameterMap.get(name); &#125;&#125; 结果测试发现，还是不对！其实乱码的问题到这里一般都会解决了，但是为什么还是不行呢？ 其实是在注册filter的时候就出错了，接下来看下面的正确配置，大家可以看一下有什么区别， 12345678&lt;filter&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.EncodeFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 有的小伙伴可能在一开始就看出来了，没错，就是&lt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&gt;这里的拦截路径我们应该使用/*而不是/ 两者有什么区别呢？ 前者是拦截一切请求，包括jsp 而后者会拦截除了jsp的所有资源 相信吃了这次亏，大家之后就再也不会忘记这个坑了！而且也了解了大部分乱码问题的解决方案！","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-第一个SpringMVC工程","slug":"SpringMVC-第一个SpringMVC工程","date":"2022-01-28T14:26:57.000Z","updated":"2022-10-04T13:55:26.774Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-第一个SpringMVC工程/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E7%AC%AC%E4%B8%80%E4%B8%AASpringMVC%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"初识SpringMVC第一步：创建普通maven工程 第二步：导入所需依赖 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 第三步：添加web支持 第四步：在web.xml中配置DispatcherServlet 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第五步：在资源路径下创建springmvc-servlet.xml配置文件，配置处理器映射器，处理器适配器，视图解析器 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.lizhi.controller.HelloServlet&quot;/&gt;&lt;/beans&gt; 第六步：创建HelloController实现Controller接口，并注册，id为路径 12345678910111213141516171819package com.lizhi.controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloServlet implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;msg&quot;,&quot;HelloSpringMVC&quot;); modelAndView.setViewName(&quot;hello&quot;); return modelAndView; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 第八步：启动tomcat测试 使用注解开发前四步如上 第五步：在springmvc-servlet中开启注解支持 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt; &lt;!-- Springmvc不处理静态文件--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--支持springmvc注解驱动在spring中一般采用@RequestMapping来完成映射关系要想让注解生效，则必须要向上下文注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerMapping实例这两个处理器分别是类级别和方法级别的而annotation-driven则帮助我们自动完成了这两个类的配置--&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第六步：创建Controller 123456789101112131415package com.lizhi.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class UserController &#123; @GetMapping(&quot;login&quot;) public String login(Model model)&#123; //model对象是页面模型，可以在此对象中放入业务返回的前端需要的数据 model.addAttribute(&quot;msg&quot;,&quot;请登录&quot;); return &quot;login&quot;; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建login.jsp 第八步：启动tomcat测试 如果出现404或者500错误可，尝试以下两种解决方案 在pom.xml中加入此段配置 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在artifact中加入lib目录，并将所需jar包导入其中","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"MyBatis映射器文件","slug":"MyBatis映射器文件","date":"2022-01-27T10:59:36.000Z","updated":"2022-10-04T13:54:12.745Z","comments":true,"path":"javaEE/MyBatis/2022/01/27/MyBatis映射器文件/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/27/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8%E6%96%87%E4%BB%B6/","excerpt":"","text":"映射器文件mybatis的真正强大之处就在于它的语句映射。 正是因为此映射器文件，才使我们减少了将近95%的JDBC代码，使我们更专注于书写SQL语句 映射器文件只有这些顶级元素 cache cache-ref delete insert resultMap select sql update select该标签对标SQL语句的DQL语句，也就是select语句 123&lt;select id=&quot;getStudentById&quot; resultType=&quot;student&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 这个select语句映射namespace绑定的接口中的listTeachers方法 resultType定义返回值类型 #{id}是取到方法传入的参数 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 insert，update和delete这三个标签对标SQL语句的DML语句 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 sql该标签用来定义sql片段，一般用来定义一些可复用的SQL语句片段，使用include标签以在其他语句中使用 12345678910111213&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt; &lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt; &lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 参数如果传入一个复杂的对象，行为就会有点不一样了。比如： 1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; JDBC 要求，如果一个列允许使用 null 值，并且可能会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType) 字符串替换默认情况下，使用#{}获取参数的值的时候，mybatis会创建一个PreparedStatement对象，通过预编译，生成与#{}出现次数相同的占位符（即 ? ）这样更安全并且更迅速。 但是有时候想直接在SQL语句中插入一个字符串，不需要转义此字符串（即不需要占位符），比如ORDER BY语句，这时候可以使用${}语句，这样的话，mybatis就不会转义该字符串了 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个栗子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 而是可以只写这样一个方法： 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 结果集映射可以自定义一些复杂的返回值对象 简单结果集映射123456789@Data@NoArgsConstructor@AllArgsConstructor@Alias(&quot;aliasStudent&quot;)public class Student &#123; private Integer id; private String name; private Integer tid;&#125; 12345678&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select student_id,student_name,student_tid from student where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;studentMap&quot;&gt; &lt;id column=&quot;student_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;student_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;student_tid&quot; property=&quot;tid&quot;/&gt;&lt;/resultMap&gt; 高级结果集映射1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class Teacher &#123; private int id; private String name;&#125; 123456789101112&lt;resultMap id=&quot;teacherMap&quot; type=&quot;com.lizhi.pojo.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap的子标签 constructor 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association 一个复杂类型的关联,许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 constructor有些情况下，你会使用一个不可变类，即那些很少改变或者基本不变的类，即可以使用构造方法注入 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;&lt;/constructor&gt; id &amp; result12&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; 这些元素是结果映射的基础。 id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。 这两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 两个元素都有一些属性： 属性 描述 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 column 数据库中的列名，或者是列的别名。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 jdbcType支持的 JDBC 类型 为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY association该标签处理一个对象聚合另一个对象的关系。 mybatis有两种不同方式去加载关联 嵌套select查询：通过另一个SQL语句去加载复杂对象 嵌套结果查询：通过连接查询直接将所有的结果查询出来，放在一张表里面 嵌套select查询（不推荐）12345678910111213&lt;resultMap id=&quot;StudentMap&quot; type=&quot;student&quot;&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacherById&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;StudentMap&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 优点：SQL语句写起来方便 缺点：多层SQL嵌套，不易于维护，使用了mybatis的相关插件会导致select语句爆红，看起来不舒服 对于大型数据上，这里有一个“N+1查询问题”，问题描述如下 执行了一个单独的SQL语句去加载每一条记录的详细信息（就是+1） 对返回的列表的每一条记录，都需要执行这样的一个单独的SQL语句去加载详细信息（就是N） 这样会导致运行成千上万条sql语句，大大增加系统开销，这是我们不希望看到的 嵌套结果查询（推荐）123456789101112131415&lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; javaType=&quot;string&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot; javaType=&quot;string&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select s.id sid, s.name sname, tid, t.name tname from student s inner join teacher t on s.id = #&#123;id&#125; and tid = t.id&lt;/select&gt; 优点：配置resultMap十分方便，逻辑十分清楚，方便查错和维护 缺点：连接查询的SQL语句写起来难度大， collectioncollection可以说是多个类型的关联，所以与association的处理十分相似 嵌套select查询123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;student&quot; select=&quot;getStudentsByTid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTid&quot; resultType=&quot;student&quot;&gt; select * from student where tid = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt; 注意：这里需要使用ofType来指定集合的泛型 嵌套结果查询1234567891011121314&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT t.name tname,t.id tid,s.id sid, s.name sname FROM teacher t inner join student s on t.id=#&#123;id&#125; and s.tid=#&#123;id&#125;&lt;/select&gt; 缓存首先我们先来看一下到底什么是缓存？ 缓存这个词，相信大家对其不会陌生，因为我们在b站，腾讯视频这一类视频APP中都会缓存过一些视频。 那我们可以从中归纳出，缓存就是程序以某种形式将数据保存下来，方便下一次的使用。 那我们为什么需要使用缓存呢？ 我们都知道，我们程序员要追求三高，当然不会是高血脂，高血糖，高血压。我们所说的三高是高并发，高可用，高性能。众所周知，对于数据库的操作是比较消耗资源的。因此，多次连接数据库不利于我们达到三高，那么缓存就是会帮助我们达到三高的一种技术。 我们将用户经常查询，并且很少发生改变的数据放入缓存中，当用户下一次查询同样的数据时，就不用再去连接数据库查询数据了，减少了访问数据库的次数，减少了系统开销，从而提高了性能。 在mybatis中，存在着两种缓存机制：一级缓存和二级缓存 一级缓存该级别的缓存，mybatis是默认开启的，并且无法关闭。 该缓存是sqlSession级别的，也就是说作用域和我们之前谈过的sqlSession的作用域一致 因为用户大部分操作都是查询，但是如果出现了DML语句（即增删改）的时候，可能会对缓存中的数据造成了修改，为了安全起见，当发生增删改操作的时候，一级缓存即刻失效。 当然我们也可以手动清理缓存 二级缓存该级别的缓存，是默认关闭的，需手动打开 在mapper映射器文件中，添加以下一行代码 1234567&lt;cache/&gt;//或者加一些配置&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 在mybatis-config.xml文件中 123//可能有的小伙伴会说，该设置默认就是true，不需要写这一行代码//但是，为了显式说明我们开启了二级缓存，最好还是标注出来&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 注：如果在cache标签中没有加入readOnly&#x3D;“true”，则需要将模型类实现序列化接口（Serializable） 该缓存是namespace级别的，也就是和应用程序的生命周期一致 附上一张关于mybatis的原理图，仅供参考","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Spring-aop","slug":"Spring-aop","date":"2022-01-27T08:25:19.000Z","updated":"2022-10-04T13:55:04.331Z","comments":true,"path":"javaEE/Spring/2022/01/27/Spring-aop/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Spring/2022/01/27/Spring-aop/","excerpt":"","text":"AOPAOP为Aspect Oriented Programming的缩写，意思是面向切面编程，是通过预编译和运行期动态代理实现程序功能的统一维护的一种技术。 Spring框架两大重点，AOP和IOC(Inversion Of Control)控制反转 AOP是OOP的延续,是软件开发中的一个热点, 也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行解耦合,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性，同时提高了开发的效率。 作用及优势 作用：在程序运行期间，在不修改源码的情况下进行功能增强 优势：减少代码重复性，提高开发效率，并且便于维护 底层原理实际上，AOP的底层是通过Spring提供的的动态代理技术实现的。 在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 常用代理技术 JDK代理：基于接口的动态代理技术 Adivce.java 12345678public class Advice &#123; public void before()&#123; System.out.println(&quot;前置增强&quot;); &#125; public void after()&#123; System.out.println(&quot;后置增强&quot;); &#125;&#125; TargetInterface.java 123public interface TargetInterface &#123; void save();&#125; Target.java 123456public class Target implements TargetInterface &#123; @Override public void save()&#123; System.out.println(&quot;saving running......&quot;); &#125;&#125; ProxyTest.java 1234567891011121314151617181920public class ProxyTest &#123; public static void main(String[] args) &#123; final Target = new Target(); final Adivice = new Advice(); TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandle()&#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable &#123; advice.before(); Object invoke = method.invoke(target,args); advice.after(); return invoke; &#125; &#125; ); proxy.save(); &#125;&#125; cglib代理：基于父类的动态代理技术 ProxyTest.java 123456789101112131415161718192021222324public class ProxyTest &#123; public static void main(String[] args) &#123; Target target = new Target(); Enhance enhance = new Enhance(); //创建增强其 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(Target.class); //设置回调 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; enhance.before(); Object invoke = method.invoke(target, args); enhance.after(); return invoke; &#125; &#125;); //创建代理对象 Target proxy = (Target) enhancer.create(); proxy.save(); &#125;&#125; AOP相关术语Spring的AOP实现底层就是对上面的动态代理的代码进行了封装,封装后我们只需要对需要关注的部分进行代码编写,并通过配置的方式完成指定目标的方法增强。 Target (目标对象) :代理的目标对象 Proxy (代理) :一个类被AOP织入增强后,就产生一 个结果代理类 Joinpoint (连接点) :所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut (切入点) :所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice (通知&#x2F;增強) :所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect (切面) :是切入点和通知(引介)的结合 Weaving (织入) :是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect采用编译期织入和类装载期织入 开发明确事项 需要编写的内容 编写核心业务代码(目标类的目标方法) 编写切面类,切面类中有通知(增强功能方法) 在配置文件中，配置织入关系,即将哪些通知与哪些连接点进行结合 AOP技术实现的内容 Spring框架监控切入点方法的执行。 一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置,将通知对应的功能织入，完成完整的代码逻辑运行。 基于XML的AOP开发 步骤 导入AOP坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8.M1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建目标类和目标接口 创建切面类（内部有增强方法） 将目标类和切面类的对象的创建权交给Spring 在applicationContext.xml中配置中织入关系 测试 切点表达式1execution([修饰符]返回值类型 包名.类名.方法名(参数列表)) 访问修饰符可以省略 返回值类型、 包名、类名、方法名可以使用星号*代表任意 包名与类名之间一 个点.代表当前包下的类,两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数,任意类型的参数列表 1234567891011121314//代表切口是com.lizhi.aop.Target类的返回void的method的无参数方法execution (public void com.itheima.aop.Target.method() )//代表切口是com.lizhi.aop.Target类的返回void的所有方法，参数个数为任意execution (void com.itheima.aop.Target.*(.. ))//代表切口是com.lizhi.aop包下的所有类的所有方法，参数个数为任意execution(* com.lizhi.aop.*.*(..))//代表切口是com.lizhi.aop包及其子包下的所有类所有方法，参数个数为任意execution(* com.lizhi.aop..*.* (..) )//代表切口是项目下的所有包的所有方法，参数为任意参数execution(* *..*.*(..) ) 通知类型 名称 通知类型 说明 前置通知 aop:before 指定增强的方法在切入点之前执行 后置通知 aop:after-returning 指定增强的方法在切入点之后执行 环绕通知 aop:around 指定增强的方法在切入点之前和之后都会执行 异常抛出通知 aop:throwing 指定增强的方法在出现切点异常时执行 最终通知 aop:after 无论增强方式执行是否有异常都会执行 around 1234567//ProceedingJoinPoint指的是正在执行的连接点==切点public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕前增强。。。。。&quot;); Object obj = pjp.proceed();//切点方法 System.out.println(&quot;环绕后增强。。。。。&quot;); return obj;&#125; 切点表达式的抽取 123456&lt;apo:config&gt; &lt;aop:aspect&gt; &lt;apo:pointcut id=&quot;myPointcut&quot; expression=&quot;excution( * com.lizhi.apo.*.*(..))&quot;&gt;&lt;/apo:pointcut&gt; &lt;apo:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/apo:before&gt; &lt;/aop:aspect&gt;&lt;/apo:config&gt; 基于注解的AOP开发 创建目标接口和目标类(内部有切点) 创建切面类(内部有增强方法) 将目标类和切面类的对象创建权交给spring 在切面类中使用注解配置织入关系 在配置文件中开启组件扫描和AOP的自动代理 测试","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"https://li-zhi.net.cn/categories/javaEE/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://li-zhi.net.cn/tags/Spring/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2022-01-27T08:21:11.000Z","updated":"2022-09-27T13:57:24.767Z","comments":true,"path":"琐碎的知识/2022/01/27/面向接口编程/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/01/27/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"面向接口编程是什么大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因:解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了: 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解接口从更深层次的理解，应是定义(规范，约束)与实现(名实分离的原则)的分离。 接口的本身反映了系统设计人员对系统的抽象理解。接口应有两类: 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class) 第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface) 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向的区别面向对象编程指的是，我们考虑问题的时候，以对象为单位，考虑它的属性和方法 面向过程编程指的是，我们考虑问题的时候，以一个具体的流程（事务过程）为单位，考虑它的实现 接口设计与非接口设计是针对复用技术层面的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"MyBatis的xml配置","slug":"MyBatis配置","date":"2022-01-26T15:44:33.000Z","updated":"2022-10-04T13:54:05.280Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis配置/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置Configuration在MyBatis中，配置文件的顶层结构如下 Configuration properties settings typeAliases typeHandlers objectFactory plugins environments environment dataSource transactionManager databaseIdProvider mappers 属性properties123&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; resource属性可以导入在外部properties配置文件中的属性到properties标签中 property标签可以定义一些属性 配置好的属性可以在该文件中使用${}来替换需要动态配置的属性值 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 比如上方的driver的值会由db.properties文件中对应的值来替换 如果在多个地方进行了配置Java代码，外部文件，properties标签，则按照以下顺序加载 先加载properties标签中的属性 再加载外部文件中配置的属性，如果有重复的属性，则覆盖旧的属性 最后加载Java代码中的属性，如果有重复的属性，覆盖旧的属性 因此，通过java方法传入的属性具有最高的优先级，外部文件优先级次之，properties标签中的属性优先级最为低 设置settings以下为重要的几个配置，需要掌握 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 类型别名typeAliases在映射器XML文件中，resultType属性在配置了类型别名后，可以不需要写全限定名，可以写在这里起的别名 在此包下的所有类都被默认起别名为类名开头小写，该默认值被注解@Alias()覆盖 123&lt;typeAliases&gt; &lt;package name=&quot;com.lizhi.pojo&quot;/&gt;&lt;/typeAliases&gt; 可以单独为一个类起别名， 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.lizhi.pojo.Teacher&quot; alias=&quot;teacher&quot;/&gt;&lt;/typeAliases&gt; 下面为一些常见的java类型内建的类型别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date map Map 环境配置Environmentsmybatis可以配置多套环境，这种机制有利于将SQL映射应用于多种数据库之中。开发，测试，生成环境需要有不同的配置。 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意一些关键点 environment的id属性，该属性是唯一性标识环境的值 在environments的default属性中通过id指定环境配置 事务管理器transactionManagertype指定事务管理器 mybatis中有两种事务管理器（也就是type &#x3D; “JDBC|MANAGED”） JDBC-这个配置直接使用了JDBC的提交和回滚机制，依赖于数据源的连接来管理事务管理作用域 MANAGED-这个配置几乎什么都不做，一般不选用 如果使用mybatis+Spring 则没有必要配置事务管理器，因为Spring模块会使用自带的事务管理器来覆盖此配置 数据源dataSourcetype指定数据源类型 dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源 有三种内置的数据源格式 UNPOOLED这个数据源的实现每次连接会打开和关闭连接会有点慢，但是对于一些小型应用已经足够了， 此类型的数据源只需要配置以下几种属性 driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒） POOLED这个数据源的实现利用了池的概念将JDBC的连接对象组织起来，避免了创建新的连接实例的时候所必需的初始化和认证时间，可以使web应用响应速度变快，该类型的数据源除了以上UNPOOLED的属性外还有以下常用配置 poolMaximumActiveConnections – 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。 JNDI(用得少，略)","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"MyBatis入门","slug":"MyBatis入门","date":"2022-01-26T15:43:33.000Z","updated":"2022-10-04T13:54:08.504Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis入门/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"MyBatis回顾JDBC 注册驱动 获取连接 获取数据库操作对象 执行SQL，操作数据库 处理结果集 关闭连接 Connection可以获得PreparedStatement或者Statement ResultSet是SQL语句执行后返回的对象 PreparedStatement和Statement是用来执行SQL语句的对象 两者的区别： PreparedStatement对SQL语句做了预编译，很好的解决了SQL注入的问题。 Statement是单纯的对字符串进行拼接，会产生SQL注入的问题 简介Def： MyBatis是一个优秀的持久层的框架，支持定制化SQL语句，存储过程以及高级映射，大大简化了JDBC的笨重的代码。 MyBatis可以使用XML配置文件或者注解的方式来配置和映射原生类型、接口和pojo（Plain Object Java Object） 持久层是什么？持久层是一个将应用中产生的数据保存到数据库的过程 思路：导入依赖—》编写代码—》测试 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 入门MyBatis中最重要的三个类 SqlSessionFactoryBuilder SqlSessionFactory SqlSession 每个基于MyBatis的应用都是以一个SqlSessionFactory实例为核心的。这个实例需要通过SqlSessionFactoryBuilder加载配置文件获得。这个配置文件可以通过两种方式获得，第一种是以XML文件的形式存在，第二种是在java代码对象的形式存在 构建SqlSessionFactory mybatis-config.xml配置构建SqlSessionFactory所需要的参数 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 在java中加载配置文件，通过SqlSessionFactoryBuilder构建SqlSessionFactory实例 123String resource=&quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 通过java代码配置不推荐，略 构建SqlSessionSqlSession，通过此对象获得接口的映射器实例，该映射对象对标JDBC中接口的实现类 123456//开启一个sqlSession对象，默认关闭自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession();//开启自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession(true);TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); 映射SQL语句 通过XML配置文件的方式和接口做绑定，实现接口方法 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.mapper.TeacherMapper&quot;&gt; &lt;select id=&quot;listTeachers&quot; resultType=&quot;com.lizhi.pojo.Teacher&quot;&gt; SELECT * FROM teacher &lt;/select&gt;&lt;/mapper&gt; mapper标签的namespace属性指向被绑定的接口 标签内书写SQL语句，id为接口中的方法名 select标签实现select方法 insert标签实现insert方法 update标签实现update方法 delete标签实现delete方法 通过注解的方式实现SQL映射 12@Select(&quot;SELECT * FROM teacher WHERE id = #&#123;id&#125;&quot;)Teacher getTeacherById(int id); 选择何种方式实现SQL映射，取决于自身。 但是如果SQL复杂的情况下，尽量不要使用注解开发，使用XML的方式去做SQL映射 三个对象的作用域（Scope） SqlSessionFactoryBuilder 该对象就一个作用，通过读取一些配置获取SqlSessionFactory实例对象。 我们没有理由一直保留它，因为SqlSessionFactory将被保存在全局作用域中，以保证所有的XML解析资源可以被释放给做其他事情，所以它的作用域应该是局部变量 SqlSession 该对象就一个作用，通过getMapper方法获取映射器实例。 每个线程都应该有它自己的SqlSession对象，因为该对象不是线程安全的，因此它是不能被共享的，所以它的最佳作用域是局部变量。 在web框架中，可以将其放到request的作用域中，返回一个响应前，关闭SqlSession对象，这个关闭操作很重要 SqlSessionFactory 该对象就一个作用，通过openSession方法获取SqlSession对象。 因为SqlSession对象是线程不安全的，所以每次查询数据库都需要一个新的SqlSession对象，既然SqlSessionFactoryBuilder的作用域为局部变量，那么在我们第一次创建出来SqlSessionFactory对象的时候，就可以将其保存在全局作用域中，下次就不需要再创建SqlSessionFactoryBuilder对象了，所以SqlSessionFactory的最佳作用域是全局唯一变量。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Maven","slug":"Maven","date":"2022-01-26T15:36:37.000Z","updated":"2022-10-04T13:54:01.800Z","comments":true,"path":"javaEE/Maven/2022/01/26/Maven/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Maven/2022/01/26/Maven/","excerpt":"","text":"MavenMaven简介学maven首先记住一句话，约定大于配置 Maven是什么 本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（pom） POM(Project Object Model)：项目对象模型 pom.xml—&gt;项目管理模型——&gt;依赖管理（Dependency）—&gt;本地仓库—&gt;私服仓库—&gt;中央 Maven有什么用 项目构建：提供标准化，跨平台的自动化项目构建方式 依赖管理：方便快捷的管理项目依赖的资源包，避免资源间的版本冲突问题 统一开发结构：提供标准的，统一的项目结构 下载与安装 官网：http://maven.apache.org/ 下载地址：http://maven.apache.org/download.cgi Maven环境配置 依赖java，所以需要JAVA_HOME 设置Maven自身的运行环境，需要配置MAVEN_HOME Maven基础概要仓库仓库：用于存储资源，包含各种jar包 仓库分类 本地仓库：自己电脑上的存储资源的仓库，连接远程仓库获取资源 远程仓库：非本机上的仓库，为本地仓库提供资源 中央仓库：由Maven团队维护，存储所有开源资源的仓库 私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库中获取资源 私服的作用 保护具有版权的资源，包含购买或者自主研发的jar 中央仓库中的jar都是开源的，不能存储具有版权的资源 一定范围内共享资源，就对内开放，不对外开放 坐标GAV 坐标：Maven中的坐标主要用于描述仓库中资源的位置，记住这个网站 https://mvnrepository.com/ Maven主要组成部分 groupId：定义当前项目隶属的组织名称（通常是域名反写 org.mybatis） artifactId：定义该项目的项目名称（通常是模块名称） version：定义当前项目的版本号 packaging：定义该项目的打包方式 作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成 本地仓库配置maven默认的本地仓库目录在c盘用户文件夹下的.m2文件夹中，如有需要，可在配置文件中自行配置。 在这里举个例子，我需要将D:\\APP\\Maven\\mvn-repo该目录作为我的maven本地仓库的路径。 创建mvn-repo文件夹，在此文件夹中创建repository目录 在maven安装根目录下的config文件夹下找到settings.xml找到以下配置所在，照着以下配置修改 12345678910//这里改成自己需要配置的仓库目录&lt;localRepository&gt;D:\\APP\\Maven\\mvn-repo\\repository&lt;/localRepository&gt;//阿里云的镜像服务器，会加快jar包的下载速度，直接复制即可&lt;mirrors&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirrors&gt; 将此份配置文件保存并复制到mvn-repo文件夹中 全局setting（maven的config中的setting文件）和用户setting（尽量和全局setting一样）区别 全局setting定义了当前计算机中Maven的公共配置 用户setting定义了当前用户的配置 创建maven项目手工普通maven工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-quickstart -Dversion = 0.0.1-snapshot -DinteractiveMode = false web工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-webapp -Dversion = 0.0.1-snapshot -DinteractiveMode = false 依赖管理依赖配置123456789101112&lt;!--设置当前项目所需要的依赖--&gt;&lt;dependencies&gt; &lt;!--设置具体的依赖--&gt; &lt;dependency&gt; &lt;!--依赖所属的群组id--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!--依赖所属的项目id--&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--依赖的版本号--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖传递依赖具有传递性 直接传递：在当前项目中，通过依赖配置建立的依赖关系 间接关系：被依赖的资源如果依赖其他的资源，当前项目间接依赖其他项目 依赖冲突 路径优先：当依赖中出现相同的资源时，层次越深，优先级越低，层次越浅，优先级越高 声明优先：当资源在相同层次被依赖时，配置顺序靠前的覆盖顺序靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖（主动表示断开）123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;!--不透明--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 排除依赖（主动断开） 排除依赖指的是主动断开依赖的资源，被排除的资源无需指定版本—不需要 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖范围12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies 依赖的jar包默认情况下可以在任何地方使用，可以通过scope标签设定起作用范围 作用范围 主程序范围有效（main文件范围内） 测试范围有效（test文件夹范围） 是否参与打包（package指令范围内） scope 主代码 测试代码 打包 示例 compile Y Y Y log4j test Y junit provided Y Y servlet-api runtime Y jdbc 依赖范围的传递性 带有依赖范围的资源在进行传递的时候，作用范围将会受到影响 行是直接依赖，列是间接依赖 compile test provided runtime compile compile test provided runtime test provided runtime runtime test provided runtime 生命周期以及插件生命周期 Maven对项目构建的生命周期划分为3套 clean：清理工作 default：核心工作，例如编译、测试、打包、部署等 site：产生报告，发布站点等 clean生命周期 pre-clean 执行一些需要在clean之前立即完成的工作 clean 移除所有上一次构件生成的文件 post-clean 执行一些需要在clean之后立即完成的工作 default生命周期 site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备工作 site-deploy 将生成的站点文档部署到特定服务器上面去 插件 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能 默认maven在各个生命周期上绑定有预设的功能 通过插件可以自定义其他功能","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"https://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://li-zhi.net.cn/tags/Maven/"}]},{"title":"first","slug":"first","date":"2022-01-16T10:39:26.000Z","updated":"2022-10-04T13:52:45.460Z","comments":true,"path":"uncategorized/2022/01/16/first/","link":"","permalink":"https://li-zhi.net.cn/uncategorized/2022/01/16/first/","excerpt":"","text":"测试博客的发布","categories":[],"tags":[]}],"categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"},{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"https://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"https://li-zhi.net.cn/categories/javaEE/Spring/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"https://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"},{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"并发","slug":"并发","permalink":"https://li-zhi.net.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"},{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"},{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"},{"name":"多线程","slug":"多线程","permalink":"https://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://li-zhi.net.cn/tags/Spring/"},{"name":"Maven","slug":"Maven","permalink":"https://li-zhi.net.cn/tags/Maven/"}]}