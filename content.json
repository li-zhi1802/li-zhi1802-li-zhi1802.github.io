{"meta":{"title":"芝麻的blog","subtitle":"百 事 可 乐","description":"芝麻的blog","author":"芝麻","url":"http://li-zhi.net.cn","root":"/"},"pages":[{"title":"about","date":"2022-01-26T14:34:59.000Z","updated":"2022-01-26T14:35:42.811Z","comments":true,"path":"about/index.html","permalink":"http://li-zhi.net.cn/about/index.html","excerpt":"","text":"这个是about页面"},{"title":"分类","date":"2022-01-27T03:28:29.000Z","updated":"2022-06-11T06:16:15.381Z","comments":false,"path":"categories/index.html","permalink":"http://li-zhi.net.cn/categories/index.html","excerpt":"","text":""},{"title":"有料","date":"2022-01-26T14:36:13.000Z","updated":"2022-06-11T06:16:04.478Z","comments":true,"path":"sometips/index.html","permalink":"http://li-zhi.net.cn/sometips/index.html","excerpt":"","text":"Spring核心配置文件的模板1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; SpringMVC的web.xml模板123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 数据库模板配置文件123spring.datasource.url=jdbc:mysql://locoalhost:3306/dbname?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 MyBatis配置文件的模板核心配置文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;/configuration&gt; 映射器xml文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.youkeda.comment.dao.UserDAO&quot;&gt;&lt;/mapper&gt; druid连接池配置文件maven坐标12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 一部分核心配置文件12345678910111213141516171819202122232425262728293031323334spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC&amp;useUnicodestrue&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid druid特有配置 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxwait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计栏截的filters，stat: 监控统计、Log4j: 日志记录、wall: 防御sqL注入 #如果允许时报借 java.Lang.CLassNotFoundException: org.apache.Log4j.Priority filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourcestat: true connectionProperties: druid.stat.mergesqletrue;druid.stat.slowSq1Millis=500 stat-view-servlet: enabled: true url-pattern: /druid/* login-password: admin login-username: 123456 allow: deny: 后台监控页面也可以通过以下方式配置 12345678910@Beanpublic ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;Servlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(&quot;loginUserName&quot;,&quot;admin&quot;); params.put(&quot;loginPassword&quot;,&quot;123456&quot;); params.put(&quot;allow&quot;,&quot;localhost&quot;); bean.setInitParameters(params); return bean;&#125; 去除druid的广告1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.lizhi.springbootdata;import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure;import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;import com.alibaba.druid.util.Utils;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.*;import java.io.IOException;@Configuration@ConditionalOnWebApplication@AutoConfigureAfter(DruidDataSourceAutoConfigure.class)@ConditionalOnProperty(name = &quot;spring.datasource.druid.stat-view-servlet.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)public class RemoveDruidAdConfig &#123; /** * 方法名: removeDruidAdFilterRegistrationBean * 方法描述: 除去页面底部的广告 * @param properties * @return org.springframework.boot.web.servlet.FilterRegistrationBean * @throws */ @Bean public FilterRegistrationBean removeDruidAdFilterRegistrationBean(DruidStatProperties properties) &#123; // 获取web监控页面的参数 DruidStatProperties.StatViewServlet config = properties.getStatViewServlet(); // 提取common.js的配置路径 String pattern = config.getUrlPattern() != null ? config.getUrlPattern() : &quot;/druid/*&quot;; String commonJsPattern = pattern.replaceAll(&quot;\\\\*&quot;, &quot;js/common.js&quot;); final String filePath = &quot;support/http/resources/js/common.js&quot;; //创建filter进行过滤 Filter filter = new Filter() &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(request, response); // 重置缓冲区，响应头不会被重置 response.resetBuffer(); // 获取common.js String text = Utils.readFromResource(filePath); // 正则替换banner, 除去底部的广告信息 text = text.replaceAll(&quot;&lt;a.*?banner\\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;, &quot;&quot;); text = text.replaceAll(&quot;powered.*?shrek.wang&lt;/a&gt;&quot;, &quot;&quot;); response.getWriter().write(text); &#125; @Override public void destroy() &#123; &#125; &#125;; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(filter); registrationBean.addUrlPatterns(commonJsPattern); return registrationBean; &#125;&#125; GitHub加速https://gitee.com/docmirror/dev-sidecar?_from=gitee_search 高质量项目https://github.com/kon9chunkit/Github-Chinese-Top-Charts#%E7%9B%AE%E5%BD%95 官方文档https://docs.github.com/cn maven中资源导出出现问题123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; CORS跨域请求的配置1234567891011121314151617import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowCredentials(true) .allowedOriginPatterns(&quot;*&quot;) .maxAge(2000); &#125;&#125; 12345678910111213141516171819202122232425import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig1 &#123; private static final long MAX_AGE=24*60*60; private CorsConfiguration buildConfig()&#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.setMaxAge(MAX_AGE); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter()&#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;,buildConfig()); return new CorsFilter(source); &#125;&#125; SpringSession的配置123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.session.MapSessionRepository;import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;import org.springframework.session.web.http.CookieSerializer;import org.springframework.session.web.http.DefaultCookieSerializer;import java.util.concurrent.ConcurrentHashMap;@Configuration@EnableSpringHttpSessionpublic class SpringHttpSessionConfig &#123; @Bean public CookieSerializer cookieSerializer() &#123; DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(&quot;JSESSIONID&quot;); // 用正则表达式配置匹配的域名，可以兼容 localhost、127.0.0.1 等各种场景 serializer.setDomainNamePattern(&quot;^.+?\\\\.(\\\\w+\\\\.[a-z]+)$&quot;); serializer.setCookiePath(&quot;/&quot;); serializer.setUseHttpOnlyCookie(false); // 最大生命周期的单位是秒 serializer.setCookieMaxAge(48 * 60 * 60); return serializer; &#125; @Bean public MapSessionRepository sessionRepository() &#123; return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); &#125;&#125; Log4j 核心配置文件12345678910111213141516171819202122232425#将等级为DEBUG的志信息输出到console和file这两个目的地。console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#范制台偷出的相关设置log4j.appender.console =org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.Threshold=DEBUglog4j.appender.console.layout =org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file =org.apache.log4j.RollingFileAppender#日志文件输出的磁盘路径log4j.appender.file.File=./log/lizhi.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日去输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.Preparedstatement=DEBUG 字体图标的使用使用字体图标前，添加字体申明，参考如下或者直接在style.css文件中复制 1234567891011@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?suef9x&#x27;); src: url(&#x27;fonts/icomoon.eot?suef9x#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?suef9x&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?suef9x&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?suef9x#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block;&#125; 记得修改字体（font-family）为icomoon"},{"title":"标签","date":"2022-01-27T03:32:41.000Z","updated":"2022-06-11T06:15:58.150Z","comments":false,"path":"tags/index.html","permalink":"http://li-zhi.net.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法-二叉树（纲领）","slug":"算法-二叉树（纲领）","date":"2022-05-07T00:24:28.000Z","updated":"2022-05-07T02:32:15.981Z","comments":true,"path":"算法/2022/05/07/算法-二叉树（纲领）/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/05/07/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%BA%B2%E9%A2%86%EF%BC%89/","excerpt":"","text":"二叉树（纲领）12345678910111213141516171819202122int depth = 0;int res = 0;public int maxDepth(TreeNode root)&#123; traverse(root); return res;&#125;public void traverse(TreeNode root) &#123; if(root==null)&#123; res = Math.max(depth,res); return; &#125; // 前序位置 // 刚刚进入这个节点 depth++; traverse(root.left); // 中序位置 // 左子树遍历完了，开始遍历右子树 traverse(root.right); // 后序位置 // 离开该二叉树节点 depth--;&#125; 123456789public int maxDepth(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); int max = Math.max(left,right)+1; return max;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【19-Medium】删除链表的倒数第N个节点","slug":"【19-Medium】删除链表的倒数第N个节点","date":"2022-05-01T05:16:28.000Z","updated":"2022-06-11T04:48:02.482Z","comments":true,"path":"算法/2022/05/01/【19-Medium】删除链表的倒数第N个节点/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/05/01/%E3%80%9019-Medium%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ Related Topics 链表 双指针 分析这道题目暴力解法就是，先进行一个循环用一个数字将总长度size算出来，然后取size-n-1个节点，进行删除操作 这里我们不使用这种方法，我们使用快慢指针法。 先将fast指针往后走n步 然后两者齐头并进，当fast.next为null的时候，slow已经在倒数第n-1个节点的位置了，此时进行删除操作。 该方法的原理是利用步长，fast先走的那几步，在fast到了链表末尾的null的时候，slow则表示的是倒数第n个节点， 因为这里需要执行删除操作，所以需要将fast走到链表末尾即可 代码： 123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; for (int i = 0; i &lt; n; i++) &#123; fast = fast.next; &#125; if(fast == null)&#123; return head.next; &#125; while(fast.next != null)&#123; slow = slow.next; fast = fast.next; &#125; slow.next = slow.next.next; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-递归算法","slug":"算法-递归算法","date":"2022-04-30T04:12:07.000Z","updated":"2022-05-02T08:09:23.643Z","comments":true,"path":"算法/2022/04/30/算法-递归算法/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/04/30/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"","text":"Chapter 2单项递归循环与递归对比回顾1、参数传递 值传递 引用传递 2、递归三要素 递归定义 递归拆解s 递归出口 3、尾递归 ​ 特点： * 函数中所有的递归形式的调用都出现在函数的末尾 * 递归调用不属于表达式的一部分 ​ 作用： * 不会在栈中创建一个新的栈 * 覆盖当前活动记录 例题例一：二阶阶乘 题目：给定一个数n，返回该数的二阶阶乘。在数学中，正整数的二阶阶乘表示不超过这个正整数且与它有相同奇偶性的所有正整数乘积。 1234输入: n = 5输出: 15解释:5!! = 5 * 3 * 1 = 15 普通递归123456789101112131415// 普通递归 @Testpublic void example1OrdinaryWay()&#123; System.out.println(example1_ordinaryWay(5));&#125;public long example1_ordinaryWay(int n)&#123; return example1_recursion(n);&#125;public long example1_recursion(int n)&#123; if(n==2||n==1)&#123; return n; &#125; return n * example1_recursion(n-2);&#125; 尾递归123456789101112131415// 尾递归 @Testpublic void example1TailRecursion()&#123; System.out.println(example1_tailRecursion(5));&#125;private long example1_tailRecursion(int n)&#123; return example1_tailRecursion(n, 1);&#125;private long example1_tailRecursion(int n,int res)&#123; res*=n; if(n==1||n==2)&#123; return res; &#125; return example1_tailRecursion(n-2,res);&#125; 迭代12345678910111213// 迭代@Testpublic void example2Iterate()&#123; System.out.println(example1_iterate(5));&#125;private long example1_iterate(int n)&#123; long res =1; while(n!=1&amp;&amp;n!=2)&#123; res*=n; n-=2; &#125; return res;&#125; 模板 1234567private returnType function(parameters)&#123; while(true)&#123; dosomething... get new parameters parameters = new parameters &#125;&#125; 按照模板 1234567891011121314151617// 迭代@Testpublic void example2Iterate()&#123; System.out.println(example1_iterate(5));&#125;private long example1_iterate(int n)&#123; return example1_iterate(n,1);&#125;private long example1_iterate(int n,int res)&#123; while(true)&#123; res*=n; if(n==1||n==2)&#123; return res; &#125; n-=2; &#125;&#125; 例一：2. 两数相加 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return add(l1,l2,0); &#125; public ListNode add(ListNode l1, ListNode l2, int bit) &#123; if (l1 == null &amp;&amp; l2 == null &amp;&amp; bit == 0) &#123; return null; &#125; int val = bit; // bit就是表示每次是否进位 if (l1 != null) &#123; val += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; val += l2.val; l2 = l2.next; &#125; ListNode node = new ListNode(val % 10); node.next = add(l1, l2, val / 10); return node; &#125;&#125; 例二：21. 合并两个有序链表 12345678910111213public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; if(list1==null)&#123; return list2; &#125;else if(list2==null)&#123; return list1; &#125;else if(list1.val &lt;= list2.val)&#123; list1.next=mergeTwoLists(list1.next,list2); return list1; &#125;else &#123; list2.next = mergeTwoLists(list1, list2.next); return list2; &#125;&#125; 例三：两两交换节点 12345678910public ListNode swapTwoAsGroup(ListNode head)&#123; if(head==null||head.next==null)&#123; return head; &#125; ListNode newHead = head.next; ListNode tail=head.next.next; head.next.next=head; head.next=swapTwoAsGroup(tail); return newHead;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux-常用命令","slug":"Linux-常用命令","date":"2022-04-24T07:57:17.000Z","updated":"2022-04-26T02:59:39.732Z","comments":true,"path":"uncategorized/2022/04/24/Linux-常用命令/","link":"","permalink":"http://li-zhi.net.cn/uncategorized/2022/04/24/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令查看文件内容123cat fileName# -n 显示行号cat -n fileName 分配查看器1more fileName 操作 功能 空白键 向下翻一页 enter 向下翻一页 q 离开 Ctrl+F 向下滚动一屏 Ctrl+B 返回上一屏 &#x3D; 输出当前行号 :f 输出文件名和当前行的行号 less指令用来分屏查看文件内容，他的功能和more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容的时候，不会一次加载整个文件，而是根据显示需要加载内容，对于显示大型文件具有较高的效率 1less fileName 操作 功能说明 空白键、pagedown 向下翻动一页 pageup 向上翻动一页 &#x2F;字符串 向下搜寻字符串的功能 ?字符串 向上搜寻字符串的功能 q 退出 输出内容123echo &quot;hello\\tworld&quot;# -e 支持控制字符echo -e &quot;hello\\tworld&quot; 控制字符 作用 \\ \\ 输出\\本身 \\n 换行符 \\t 制表符 显示头部文件1234head fileName# -n 显示前多少行，不写的话默认10行head -n 5 fileName 显示尾部文件1234tail fileName# -n 显示尾部前多少行，不写的话默认10行# -f 实时更新 输出重定向&gt;和&gt;&gt;追加&gt;是覆盖 &gt;&gt;是追加 12ls -ll &gt; fileName cat fileName &gt; fileName2 查看历史操作记录1history 查看用户是否存在1id userName 查找文件和目录12345find [搜索范围] [选项] -name 按照指定的文件名查找文件 -user 查找指定用户名查找文件 -size 按照指定的文件大小查找文件 (+大于，-小于，) 快速定位路径locate命令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查找速度较快，为了保证查询结果的准确度，管理员需要定时使用updatedb命令更新db 1locate 压缩和解压gzip&#x2F;gunzip压缩gzip只能将文件压缩为.gz文件 特点： 1、只能压缩文件，不能压缩目录 2、不能保留原来的文件 3、同时多个文件会产生多个压缩包 zip&#x2F;unzip压缩 zip可选项 作用 -r 压缩目录 unzip可选项 作用 -d 指定解压后文件的存放位置 tar 可选项 功能 -c 产生tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包 -C 解压到指定目录 12345# 常用解压缩命令tar -zxvf# 常用压缩命令tar -zcvf 查看当前系统进程状态12345# 查看系统中的所有进程ps aux# 查看子父进程之间的关系ps -ef 特点： 1、查看进程的CPU占用率和内存占用率，可以使用aux 2、想查看进程的父进程ID可以使用-ef 显示网络状态和端口占用信息123netstat -anp |grep 进程号netstat -anp |grep 进程号 选项 功能 -a 显示所有正在监听和未监听的套接字 -n 拒绝显示别名，能显示数字的就显示数字 -l 仅列出在监听的服务状态 -p 表示显示哪个进程在调用 设置定时任务1crontab [选项] 选项 功能 -e 编辑crontab任务 -l 查询crontab任务 -r 删除当前用户所有的crontab任务","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"},{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/tags/javaEE/"}]},{"title":"Linux-系统管理","slug":"Linux-系统管理","date":"2022-04-24T03:02:23.000Z","updated":"2022-04-24T05:40:07.586Z","comments":true,"path":"uncategorized/2022/04/24/Linux-系统管理/","link":"","permalink":"http://li-zhi.net.cn/uncategorized/2022/04/24/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","excerpt":"","text":"系统服务管理开启服务 1systemctl start servieName 重启服务 1systemctl restart servieName 关闭服务 1systemctl stop servieName 查看服务状态 1systemctl status servieName 查看所有后台服务状态 1systemctl list-units --type service --all 关闭后台服务自启动 1systemctl disable name.service 开启后台服务自启动 1systemctl enable name.service","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"},{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/tags/javaEE/"}]},{"title":"JVM-内存分区","slug":"JVM-内存分区","date":"2022-03-18T09:27:35.000Z","updated":"2022-04-03T08:57:11.608Z","comments":true,"path":"javaEE/JVM/2022/03/18/JVM-内存分区/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JVM/2022/03/18/JVM-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"JVM内存分区内存分区和内存模型是两个概念 操作系统内存分区 栈（Stack） 堆（Heap） 未初始化数据段（BSS） 数据段（Data Segment） 文本段（Literal Segment） 代码段（Code Segment） JVM内存分区 程序计数器（PC） 虚拟机栈（JVM Stack） 本地方法栈（Native Method Stack） 堆（Heap） 方法区（Method Area） 橙色虚线包裹的就是线程共享的，被红色实现包裹的是线程隔离的 程序计数器在硬件层面，程序计数器是寄存器，是用来存储指令地址给处理器执行， 在JVM中，它的作用就是用来存储字节码指令的地址，提供给执行引擎去执行 这里我们从侧面去查看该特新 1234567public class Demo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); &#125; &#125;&#125; 然后先编译javac Demo.java反编译javap -l -c Demo.class 得到以下字节码 123456789101112131415161718192021222324252627282930313233Compiled from &quot;Demo.java&quot;public class com.lizhi.Demo &#123; public com.lizhi.Demo(); descriptor: ()V Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V Code: // 这里的数字就是字节码指令的偏移量 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 21 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: iload_1 12: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 15: iinc 1, 1 18: goto 2 21: return // 这里可以解释断点的原理，将源码行数和字节码行数进行映射 LineNumberTable: line 5: 0 line 6: 8 line 5: 15 line 8: 21&#125; 虚拟机栈也叫java方法栈，java方法的调用对应着栈帧的入栈与出栈。 3个重点： 栈帧 栈帧出现时机 栈帧的构成 栈帧栈帧主要有四部分组成：局部变量表、操作数栈、动态连接、返回地址 局部变量表 主要存储方法的参数、定义在方法内的局部变量，包括基本数据类型（8大）对象的引用地址，返回值地址。 局部变量表中存储的基本单元为变量槽（Slot），32位（4字节）以内的数据类型占一个slot，64位（long，double）的占两个slot。 局部变量表是一个数字数组，byte、short、char都会被转化为int,boolean类型也会被转化为int，O代表false、非0代表true。局部变量表的大小是在编译期间决定下来的，所以在运行时它的大小是不会变的。 局部变量表中含有直接或者间接指向的引用类型变量时，不会被垃圾回收处理。 操作数栈 就是用来存储操作数的栈，这里的操作数大部分就是方法内的变量 作用： 存储操作数 操作数栈可以方便指令顺序读取操作数 指令 含义 iload int型变量入栈 istore 栈顶数值存入局部变量 iadd 弹出栈顶两个操作数，并将求和的int值压入栈中 动态连接 java中的多态就是通过动态连接实现的 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用都是为了支持方法调用过程中的动态连接 连接是将部分符号引用替换为直接引用，对于有些方法，JVM并不能判断它们的具体实现，只有在真正运行的时候，才可以根据实际类型进行连接，这就是动态连接 本地方法栈本地方法是由非java语言实现的函数，一般是一些和操作系统底层相关的函数","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"http://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://li-zhi.net.cn/tags/JVM/"}]},{"title":"JavaScript-模块化开发","slug":"JavaScript-模块化开发","date":"2022-03-16T12:34:07.000Z","updated":"2022-06-11T06:49:13.733Z","comments":true,"path":"javaEE/JavaScript/2022/03/16/JavaScript-模块化开发/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JavaScript/2022/03/16/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"javaScript模块化 什么是模块化？ 即将一个复杂的程序依据一定的规则(规范)封装成几个块(文件)，并用规定语法将其组合在一起，块的内部数据&#x2F;实现是私有的,只是向外部暴露一些接口(方法)与外部其他模块通信 以前的代码 全局模式 123456function foo()&#123; &#125;function abc()&#123; &#125; 问题：所有的函数都被绑定在了window上，容易产生命名冲突和产生对window的污染 namespace模式 将函数或者数据绑定在对象上 123456789let obj = &#123; k: &#x27;asd&#x27;, foo()&#123; console.log(this.k) &#125;, abc()&#123; &#125;&#125; 问题：对象中的数据可以随意被修改，所以数据不安全 IIFE(Immedicately-invoked-function-expression) 该方法就是利用函数的作用域和即使函数的特性 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=&#123;foo&#125;&#125;)(window);-----------------------------module.foo(); 或者 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=foo&#125;)(window);-----------------------------module(); IIFE就是现代化模块化的基石 模块化的好处 避免命名冲突 根据功能点进行更好的分离 更高的复用性 高可维护性 但是以此同时就出现了问题 一个页面需要引入多个js文件，如果多个文件之间有依赖关系，先后顺序的错误就会导致报错 请求过多 依赖模糊 难以维护 这时候我们就需要引入一种模块化的规范来避免这种问题，下面我们来看看有哪些模块化规范 模块化的规范 CommonJS（nodejs就是基于这种规范） AMD （用的少） CMD（阿里的人写的。用的少） ES6 CommonJS说明： 每一个文件都是一个模块 服务器端：模块的加载是运行时同步加载的 浏览器端：需要自己编译打包将所有的模块js合并到一个js中 定义模块： 123456module.exports=&#123;&#125;---expoets.foo = function()&#123; &#125;exports.n = 2 引入模块： 1234let module1 = require(..)// 这里的..// 引入第三方的包 直接写包名// 引入自己写的js 写路径 服务器端例子： 先创建项目结构 123456-modules --module1.js --module2.js --module3.js-app.js-package.json module1.js 12345module.exports = &#123; foo()&#123; console.log(`&#x27;module1&#x27;s foo()`) &#125;&#125; module2.js 123456exports.foo = function()&#123; console.log(`&#x27;module2&#x27;s foo()`)&#125;exports.abc = function()&#123; console.log(`&#x27;module2&#x27;s abc()`)&#125; module3.js 123module.exports = function()&#123; console.log(`&#x27;module3&#x27;s foo()`)&#125; app.js 12345678let module1 = require(&#x27;./modules/module1.js&#x27;)let module2 = require(&#x27;./modules/module2.js&#x27;)let module3 = require(&#x27;./modules/module3.js&#x27;)module1.foo()module2.foo()module2.abc()module3() package.json 1234&#123; name: &#x27;applicationname&#x27;,// 这里写项目名字，不能有大写字母，不能有中文 version: &#x27;1.0.0&#x27;&#125; 可以使用npm init生成该文件 客户端例子： 结构树如下 123456789-test --dist --src ---module1.js ---module2.js ---module3.js ---app.js --index.html --package.json js代码如上 下载编译工具 12npm install browserify -g # 全局安装npm install browserify --save-dev # 开发依赖，在上线阶段不需要此工具了 使用该工具 1browserify src/app.js -o dist/budle.js index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&#x27;./dist/budle.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; AMD说明：AMD(（Asynchronous Module Definition）)专门用户浏览器端，模块的加载是异步的 此规范依赖于一个Require.js 基本语法： 定义模块： 12345678// 没有依赖其他模块define(function()&#123; return 模块&#125;)// 定义有依赖的模块define([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; return 模块&#125;) 引入模块 123456require([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;)requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;) 例子： 目录结构 12345678910-test --js ---libs ----require.js//这是引入的第三方js ---modules ----module1.js ----module2.js ----modlue3.js ---main.js --index.html mudule1.js 1234567define(function()&#123; lett msg = &#x27;module1&#x27;; function foo()&#123; console.log(msg) &#125; return &#123;foo&#125;&#125;) module2.js 1234567define([&#x27;module1&#x27;],function(m1)&#123; let msg = &#x27;module2.js&#x27; function foo()&#123; console.lopg(msg,m1.foo()) &#125; return &#123;foo&#125;&#125;) main.js 12345678910111213(function()&#123; require.config(&#123; baseUrl: &#x27;js/&#x27;, path: &#123; module1: &#x27;./modules/module1.js&#x27;, module2: &#x27;./modules/module2.js&#x27; jquery: &#x27;./libs/jquery.js&#x27;//引入第三方库，不是所有的第三方库都支持AMD语法 &#125; &#125;) requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; m1.foo(); &#125;)&#125;)() 页面中只要引入该标签即可 1&lt;script data-main=&quot;js/main.js&quot; src=js/libs/require.js&gt;&lt;/script&gt; ES6规范说明：该规范也需要编译打包处理，先使用babel将ES6转化为ES5，然后使用browserify将其并为一个js文件 基本语法： 导出模板： 1234567891011121314151617181920212223export function foo()&#123; &#125;export function abc()&#123; &#125;------------------------------------------------------------------------------------------------------function foo()&#123; &#125;function abc()&#123; &#125;export &#123;foo,abc&#125;------------------------------------------------------------------------------------------------------export default &#123; function foo()&#123; &#125; function abc()&#123; &#125;&#125; 引入模块： 12345// 常规导出，这边用对象接import &#123;&#125; from &#x27;路径&#x27; //自己的js// 默认导出，这边用变量来接impoet module from &#x27;路径&#x27; 例子： 项目结构 123456789101112-test --js ---dist ---build ---src ----module1.js ----module2.js ----module3.js ----main.js --index.html --.babelrc --package.json 安装依赖 12345npm install browserify --save-devnpm install babel-cli -gnpm install babel-preset-es2015 --save-dev 创建.babelrc rc就是run control运行时控制文件 123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; module1.js 123456export function foo()&#123; &#125;export function abc()&#123; &#125; module2.js 1234567function f1()&#123; &#125;function f2()&#123; &#125;export &#123;f1,f2&#125; module3.js 12345678export default &#123; function d1()&#123; &#125; function d2()&#123; &#125;&#125; main.js 123456789import &#123;foo,abc&#125; from &#x27;./module1.js&#x27;import &#123;f1,f2&#125; from &#x27;./module2.js&#x27;import module3 from &#x27;./module3.js&#x27;foo();abc();f1();module3.d1();module3.d2(); es6转es5 1babel js/src -d js/build 这里如果出现这个错误： 1babel : 无法加载文件 C:\\Users\\win\\AppData\\Roaming\\npm\\babel.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/ go.micros 那么你输入以下命令一定是这样的 12get-ExecutionPolicy# restricted 这时候，先使用管理员身份打开Windows Powershell然后输入以下命令 12set-ExecutionPolicy RemoteSigned然后输入y回车 合并文件 1browserify js/build/main.js -o js/dist/bundle.js index.html导入js 1&lt;script src=&quot;js/src/dist/bundle.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JavaScript","slug":"javaEE/JavaScript","permalink":"http://li-zhi.net.cn/categories/javaEE/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"JVM-内存模型","slug":"JVM-内存模型","date":"2022-03-12T02:41:34.000Z","updated":"2022-04-08T12:23:37.059Z","comments":true,"path":"javaEE/JVM/2022/03/12/JVM-内存模型/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JVM/2022/03/12/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"内存模型硬件的内存模型在讲java内存模型之前，先来看看硬件的内存模型 CPU的处理速度和内存的读写不是一个数量级的，所以在CPU和主存之间加上了一层缓存 这种结构在单CPU的时候，处理的很好 但是当多CPU的时候， 这时候就会出现缓存一致性问题 当CPUA读取主存中的数据之后，对其进行修改，在将其刷新回主存的之前，CPUB读取主存中的数据，对其进行修改，将其刷新回主存，这时候CPUA也同时将其修改后的数据刷新回主存，那么这个数据到底以哪一个为准，这个就是缓存一致性问题 针对这个问题，就出现了缓存一致性协议 1、窥探性 2、目录型 有了这一层协议，在硬件层面，就解决了缓存一致性问题，即汇编语言能够运行在一个具有缓存一致性的内存视图中 Java的内存模型设计编程语言的内存模型是为了能够该语言也可以拥有一个内存一致性的视图，于是在硬件内存模型之上，就有了高级语言的内存模型 Java内存模型就屏蔽了各种硬件的操作系统的内存差异，使得java可以正常的运行在各大操作系统上 虚拟机栈也可以叫做java方法栈，该栈中存放8大基础类型的数据和对象的引用 堆中存放着所有的java对象 内存读写指令 作用于主存 作用于工作内存 lock：锁定 load：加载数据 unlock：解锁 store：存储数据 read：读取 use：使用数据 write：写入 assign：赋值 上面的图只是一种理想状态，会出现以下两种问题 1、可见性 当线程A将本地内存中的数据修改后，刷新回主存后，线程B直接使用本地内存中的数据，没有使用刷新后的数据，这就是可见性问题 2、原子性 当线程A修改了数据，还没刷新回主存，线程B也修改了数据，也要刷新回主存，那么这时候主存中应该刷新成哪个线程修改后的值呢 线程通信之间的同步问题，当多个线程在并发操作同一个数据的时候，会引发很多的问题，这些问题被总结为并发三要素 1、可见性 2、原子性 3、有序性 可见性当一个线程修改了共享变量的值之后，其他所有使用该变量的线程都应该立刻得知此修改 两层含义 第一种含义 线程A修改了数据X，线程B需要使用到最新的数据X（这是线程B没有重新读取主存导致的） 12345678910111213141516public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 控制台不会返回响应码，而是一直死循环。 当thread1开始循环的时候，本地内存中a=1，当thread2修改了a为0的时候，thread1并不知道，而是一直使用着a=1，所以会一直循环 两种解决方法 1、将a变量加一个修饰词volatile 如果一个共享变量被volatile修饰，那么该共享变量被修改后，将会直接写入主存，当其他线程读取该共享变量的时候，也会直接从主存中读取 2、使用synchronized包裹，并使用该数据 synchronized块中读写变量会隐式调用lock和unlock指令 123456789101112131415161718public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; synchronized(this)&#123; int b = a + 1; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 第二层含义 线程B需要读取到线程A修改后的数据x，但是因为指令重排，在线程A未修改数据x之前，线程B读到了数据x 123456789101112131415161718public class Demo2 &#123; static int a =0; static boolean b =false; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; a = 1;//1 b = true;//2 &#125;); Thread thread2 = new Thread(() -&gt; &#123; if (b) &#123;//3 int x = a;// 4 // 这个x一定是1吗? System.out.println(x); // 5 &#125; &#125;); thread1.start(); thread2.start(); &#125;&#125; 在硬件内存模型的时候就说过，在底层会存在指令重排的情况， 我们觉得的顺序应该是 1-&gt;2-&gt;3-&gt;4 但是在编译后顺序有可能就变成了 2-&gt;3-&gt;4-&gt;1 这也是一种可见性的问题 同样的这里我们也可以使用上述两种方法来解决这种问题 volatile是禁止了当前变量与之前的代码语句进行指令重排 synchronized就是将两段代码分别捆绑在一起，那么无论在thread1中怎么指令重排，都不会影响thread2对于变量的读取 Happens-Before原则我们平时很少遇到可见性问题，因为我们站在了前人的肩膀上，设计内存模型的前辈已经帮我们解决了此问题，这就是Happens-Before原则 定义：对于两个操作A和操作B，这两个操作可以在不同的线程中执行，如果A Happens-Before B（即A先于B执行），那么可以保证当A操作执行完后，A操作的执行结果对B操作是可见的 程序顺序原则 锁定原则 volatile原则 线程启动原则 线程结束原则 中断规则 终结器规则 传递性原则 原子性一个操作要么全部执行成功，要么全部执行失败 1、单指令原子操作 2、利用锁的组合指令原子操作 有序性指令重排在单线程环境下不会出现什么问题，但是在多线程环境下，可能导致有的代码执行顺序修改后可能会导致与顺序执行的结果不同 这里可以使用Happens-Before原则来解决问题","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"http://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://li-zhi.net.cn/tags/JVM/"}]},{"title":"JVM-类加载器","slug":"JVM-类加载器","date":"2022-03-11T14:47:01.000Z","updated":"2022-03-18T10:13:35.202Z","comments":true,"path":"javaEE/JVM/2022/03/11/JVM-类加载器/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JVM/2022/03/11/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"类的加载过程类的加载过程分三个阶段 类的加载 &#x3D;&#x3D;》类的链接 &#x3D;&#x3D;》类的初始化 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中（方法区）生成一个代表该类的Class对象，作为类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程 类构造器方法是由编译期按顺序收集类中所有类变量的赋值动作和静态代码块中的语句合并而成的（类构造器是构造类信息的，不是对象构造器） 当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 JVM会保证类构造器在多线程环境下被正确加锁 类的链接为黑盒实现 类的主动引用（一定会发生类的初始化） 当JVM启动的时候，先初始化main方法所在的类 new 一个类的对象 调用该类的静态成员（除了final）和静态方法 使用反射对其类进行反射调用 当初始化一个类时，其父类若没有初始化，则先初始化其父类 类的被动引用（不会发生类的初始化） 当访问一个静态域的时候，只有真正声明该域的类才会被初始化。举个栗子：当通过子类调用父类的静态变量，该子类是不会被初始化的 通过数组定义类引用，不会导致初始化 引用常量不会导致初始化 类加载器市面上有三种JVM，不同的JVM对类加载器的实现是不同的，我们主要学习的并且使用的是Sun公司的HotSpot 类加载器的作用就是将类（class）装进内存的 JVM规定了以下类型的加载器 引导类加载器：用C++编写的，是JVM自带的类加载器，负责java平台的核心库，用来装载核心类库，该加载器无法直接获取（获取的时候会是null） 扩展类加载器（ExtClassLoader）：负责**&#x2F;lib&#x2F;etc**目录下的jar包户或者 -d java.ext.dirs指定目录下的jar包装入工作库 系统类加载器（AppClassLoader）：负责java -classpath或者java.class.path指定目录下的类与jar包 用户加载器（User ClassLoader）：用户自定义的加载器 扩展类加载器、系统类加载器、用户加载器都是继承自java.lang.ClassLoader JVM规范：每个类加载器都有属于自己的命名空间 双亲委派机制检查顺序从下至上，加载顺序从顶至下 举个栗子：我写了一个Student类，我要加载它需要经过以下过程 先将该任务委托给AppClassLoader AppClassLoader很懒，它不想加载，将任务向上委托给ExtClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，但是在自己管理的lib目录下并没有找到该类，只能将任务再次交给ExtClassLoader去加载 那ExtClassLoader没法偷懒了，只能在自己管理的ext目录下找该类，但是也没有找到，只能将任务继续向下转交给AppClassLoader AppClassLoader不得不自己去尝试加载该类，于是加载成功 既然最后还是AppClassLoader去加载Student类何必绕一个大圈子呢？ 这是为了防止原始类被用户写的类所覆盖。 再举个栗子：我自己写了一个String类，我要加载它会经历以下过程 先将该任务委托给AppClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，于是在自己管理的lib目录下找到该类并加载，将加载结果向下一直传递到用户 对双亲委派模型的破坏1、自定义类加载器 我们写一个类继承java.lang.ClassLoader，重写loadClass方法，双亲委派的逻辑就在这个方法中，但是我自定义的类加载器可以不这么写，也就破坏了双亲委派。在jdk1.2之后，jdk增加了一个findClass方法提供给上层重写，也就有效地防止了双亲委派被破坏 1234567891011121314151617181920212223public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader myClassLoader = new ClassLoader()&#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try&#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if(is==null)&#123; return super.loadClass(name); &#125; byte[] buffer = new byte[is.available()]; is.read(buffer); return defineClass(name,buffer,0, buffer.length); &#125;catch (Exception e)&#123; e.printStackTrace(); throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object o = myClassLoader.loadClass(&quot;com.test.A&quot;).newInstance(); System.out.println(o.getClass()); System.out.println(o instanceof com.test.A);&#125; 控制台输出 12class com.test.Afalse 这不仅破坏了双亲委派，并且证明了每个类加载器都有自己的命名空间 2、SPI（Service Provider Interface）服务发现机制 JDK中定义了JDBC的接口，规范各大厂家。对于JDK中的接口，使用的是BootstrapClassLoader但是对于各大厂家的实现类，使用的是ApplClassLoader 1234567891011121314151617181920212223242526272829303132333435@CallerSensitivepublic static Driver getDriver(String url) throws SQLException &#123; println(&quot;DriverManager.getDriver(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); ensureDriversInitialized(); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); // Walk through the loaded registeredDrivers attempting to locate someone // who understands the given URL. for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if (isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if (aDriver.driver.acceptsURL(url)) &#123; // Success! println(&quot;getDriver returning &quot; + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.driver.getClass().getName()); &#125; &#125; println(&quot;getDriver: no suitable driver&quot;); throw new SQLException(&quot;No suitable driver&quot;, &quot;08001&quot;);&#125; 123456@CallerSensitivepublic static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 当前线程的ClassLoader默认为AppClassLoader ClassLoader cl = Thread.currentThread().getContextClassLoader(); return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);&#125; 3、热部署","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"http://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://li-zhi.net.cn/tags/JVM/"}]},{"title":"算法-差分数组","slug":"算法-差分数组","date":"2022-03-11T04:45:24.000Z","updated":"2022-06-11T04:51:29.296Z","comments":true,"path":"算法/2022/03/11/算法-差分数组/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/11/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"","text":"差分数组该技巧和前缀和数组一样都是用在数组上的， 前缀和数组是用来简化 任意区间的元素之和的， 差分数组是用来简化 频繁在任意区间减去某个值或者在任意区间加上某个值，最后输出最后的数组结果的 比如，给你一个数组nums[2,4,1,45,21,54,12,43]，我需要先将[2,4]都加3，再将[3,6]都减1，再…..，最后输出最后的数组结果 如果没学过差分数组，那么应该是使用for循环将范围内的数都进行操作，最后输出数组， 对nums的操作十分频繁，这样的效率十分低下 这里我们就使用差分数组来提高我们的效率 12345int[] diff = new int[nums.length];diff[0] = nums[0];for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i] - nums[i-1];&#125; 当i!=0的时候diff[i]代表nums[i]-nums[i-1]的值，即当前值与前一个值的差 那有了这个差分数组，我们怎么将数组还原呢？ 12345int[] res = new int[diff.length];res[0] = diff[0];for (int i = 1; i &lt; diff.length; i++) &#123; res[i] = res[i-1] + diff[i];&#125; diff的还原是先new一个新的数组来存放最后的结果，对于0之后的元素，res[i]等于前一个元素加上当前索引的diff 如果我要将[i,j]区间加2，那么就将diff[i]+=2;diff[j+1]-=2即可 我将diff[i]+=2，即达到res[i]到最后都会被加上2的效果 我将diff[j+1]-=2，即达到res[j+1]之后，会将前面的加2抵消，所以j之后的元素就不会被影响了 我们来和之前的那道前缀和数组一样，抽象出来一个类来处理数组 123456789101112class Diff&#123; private int[] diff; public Diff(int[] nums)&#123; &#125; public void increase(int left, int right, int step)&#123; &#125; public int[] getResult()&#123; &#125;&#125; 大家可以先自己写一下 这是实现： 123456789101112131415161718192021222324class Diff&#123; private int[] diff; public Diff(int[] nums)&#123; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i]-nums[i-1]; &#125; &#125; public void increase(int left, int right, int step)&#123; diff[left]+=step; if(right&lt;diff.length-1)&#123; diff[right+1]-=step; &#125; &#125; public int[] getResult()&#123; int[] result = new int[diff.length]; result[0]=diff[0]; for (int i = 1; i &lt; diff.length; i++) &#123; result[i] = result[i-1]+diff[i]; &#125; return result; &#125;&#125; 接下来就要实践出真知，来看一下这道力扣题，这道题在力扣上是plus会员才可以查看，这里直接将题目简述给大家 力扣370：区间加法 12345678910111213141516# 370.区间加法假设你有一个长度为 n 的数组nums，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[left,right,step]，你需要该区间[left,right] (包括left和right)增加step。请你返回 k 次操作后的数组。# 示例len=5,updates=[[1,3,3],[2,4,-5],[0,3,4]]原数组变为 [0,0,0,0,0]原数组变为 [0,3,3,3,0]原数组变为 [0,3,-2,-2,-5]原数组变为 [4,7,2,2,-5]result: [4,7,2,2,-5]# 方法签名public int[] getModifiedArray(int[] nums, int[][] updates) &#123; &#125; 只要懂了上面的Diff类的写法，这题轻轻松松拿下！ 代码： 12345678910111213141516171819public int[] getModifiedArray(int[] nums, int[][] updates) &#123; int[] diff = new int[nums.length]; diff[0]=nums[0]; for (int i = 1; i &lt; diff.length; i++) &#123; diff[i] = nums[i]-nums[i-1]; &#125; for (int[] update : updates) &#123; diff[update[0]]+=update[2]; if(update[1]+1&lt;diff.length)&#123; diff[update[1]+1]-=update[2]; &#125; &#125; int[] result = new int[diff.length]; result[0]=diff[0]; for (int i = 1; i &lt; result.length; i++) &#123; result[i] = result[i-1]+diff[i]; &#125; return result;&#125; 既然我们之前写了Diff那么我们就可以使用它 1234567public int[] getModifiedArray1(int[] nums, int[][] updates) &#123; Diff diff = new Diff(nums); for (int[] update : updates) &#123; diff.increase(update[0],update[1],update[2]); &#125; return diff.getResult();&#125; 接下来我们来尝试一下这道实际应用题力扣1109：航班预订统计 本质是一样的，只不过这边需要注意一下索引和编号的对应关系， 1234567891011121314151617class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; int[] diff = new int[n]; for (int[] booking : bookings) &#123; diff[booking[0]-1]+=booking[2]; if(booking[1]&lt;n)&#123; diff[booking[1]]-=booking[2]; &#125; &#125; int[] answer = new int[diff.length]; answer[0]= diff[0]; for (int i = 1; i &lt; answer.length; i++) &#123; answer[i] = answer[i-1]+ diff[i]; &#125; return answer; &#125;&#125; 相信学完这些，你对差分数组的理解也比较深刻了","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-前缀和数组","slug":"算法-前缀和数组","date":"2022-03-10T10:01:29.000Z","updated":"2022-03-11T07:22:36.237Z","comments":true,"path":"算法/2022/03/10/算法-前缀和数组/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/10/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"前缀和数组力扣303：区域和检索 - 数组不可变 这是一道很典型的使用前缀和数组的题目。 对于频繁计算数组的一个范围的和，学没过前缀和数组的会这样做， 1234567public int sumRange(int[] sums, int left, int right) &#123; int sum = 0; for(int i = left ;i &lt;= right;i++)&#123; sum += nums[i]; &#125; return sum;&#125; 这样确实可以达到效果，但是频繁这样操作，效率不是很高。 所以学过前缀和的会这么写从而提高效率 1234567public int sumRange(int[] sums, int left, int right) &#123; int[] preSum = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length ; i++) &#123; preSum[i] = preSum[i-1] + nums[i-1]; &#125; return preSum[right+1] - preSum[left];&#125; 我们来分析一下这个preSum 它的长度是原数组的长度加一 preSum[0]置为nums数组前0个的和 preSum[1]置为nums数组前1个的和 preSum[2]置为nums数组前2个的和 所以我如果需要[0,1]区间的和，则返回preSum[2]-preSum[0]（前2个数的和减去前0个数的和） 所以我如果需要[3,5]区间的和，则返回preSum[6]-preSum[3]（前6个数的和减去前3个数的和） 所以这道力扣303题的代码为： 1234567891011121314class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length+1]; for (int i = 1; i &lt;= nums.length; i++) &#123; preSum[i]=preSum[i-1]+nums[i-1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right+1]-preSum[left]; &#125;&#125; 小试身手：初三一班的数学期末成绩(满分120分)出来了，现将成绩乱序列表发于你，请你统计在[min,max]范围内的学生人数 方法签名：public int scoreRange(List&lt;Integer&gt; scores, int fullMarks, int min, int max) 在学前缀和数组之前 先将scores按升序排序 然后使用二分搜索两个端点，将长度返回 这样的思路确实没毛病，但是如果频繁需要查询， 就算是强如二分查找，也会消耗很多资源 学了前缀和数组之后 既然学了前缀和数组，我们就使用该技巧去优化 1234567891011121314151617181920/** * 返回成绩范围内的学生数 * @param scores 学生成绩列表 * @param fullMarks 这门成绩的满分 * @param min 最小值 * @param max 最大值 * @return 满足成绩区间的个数 */public int scoreRange(List&lt;Integer&gt; scores, int fullMarks, int min, int max)&#123; int[] counts = new int[fullMarks+1]; int[] preSums = new int[fullMarks+2]; for (Integer score : scores) &#123; counts[score]++; &#125; preSums[0]=0; for (int i = 1; i &lt;= counts.length; i++) &#123; preSums[i] = preSums[i-1]+counts[i-1]; &#125; return preSums[max+1]-preSums[min];&#125; 现在我们来解决力扣304：二维区域和检索 - 矩阵不可变 本质和一维的时候是一样的只不过变成了二维，需要预处理一个二维前缀和数组而已 1234567891011121314151617181920class NumMatrix &#123; private int[][] preSums; public NumMatrix(int[][] matrix) &#123; preSums = new int[matrix.length][matrix[0].length+1]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt;= matrix[i].length; j++) &#123; preSums[i][j] = preSums[i][j-1] + matrix[i][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int sum = 0; for (int i = row1; i &lt;= row2; i++) &#123; sum+=preSums[i][col2+1]-preSums[i][col1]; &#125; return sum; &#125;&#125; 这是大佬的解法 1234567891011121314151617181920212223class NumMatrix &#123; // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 private int[][] preSum; public NumMatrix(int[][] matrix) &#123; int m = matrix.length, n = matrix[0].length; if (m == 0 || n == 0) return; // 构造前缀和矩阵 preSum = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1]; &#125; &#125; &#125; // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int x1, int y1, int x2, int y2) &#123; // 目标矩阵之和由四个相邻矩阵运算获得 return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]; &#125;&#125; 再来看看这道题力扣560： 和为 K 的子数组 只要前x总和之差为k，则说明存在一个子数组的和为k 代码： 1234567891011121314151617class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int[] preSums = new int[nums.length+1]; for (int i = 1; i &lt;= nums.length; i++) &#123; preSums[i]=preSums[i-1]+nums[i-1]; &#125; int counter = 0; for (int i = 1; i &lt; preSums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if(preSums[i]- preSums[j]==k)&#123; counter++; &#125; &#125; &#125; return counter; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-以k个节点为一组逆转单链表","slug":"算法-以k个节点为一组逆转单链表","date":"2022-03-08T07:00:11.000Z","updated":"2022-05-01T04:41:01.275Z","comments":true,"path":"算法/2022/03/08/算法-以k个节点为一组逆转单链表/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/08/%E7%AE%97%E6%B3%95-%E4%BB%A5k%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%BA%E4%B8%80%E7%BB%84%E9%80%86%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"以k个节点为一组逆转单链表力扣25：K 个一组翻转链表 首先我们来分析一下这道题目，题目不难理解，就是以k个节点为一组逆转单链表，我们使用递归的思想来思考一下这道题 首先需要一个逆转前n个节点的方法 方法签名：public ListNode reverseKNode(ListNode head,int k) 迭代实现： 123456789101112public ListNode reverseKNode(ListNode head,int k)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur!=null &amp;&amp; k--!=0)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; 递归实现： 123456789101112ListNode processor;// 这里的k要保证不超过链表长度public ListNode reverseKNode(ListNode head,int k)&#123; if(k == 1)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode1(head.next, k-1); head.next.next = head; head.next = processor; return node;&#125; 方法签名：public ListNode reverseKNode(ListNode head,ListNode end) 递归实现： 123456789101112ListNode processor;// [head,end)public ListNode reverseKNode(ListNode head,ListNode end)&#123; if(head.next == end)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode(head.next, end); head.next.next = head; head.next = processor; return node;&#125; 迭代实现： 12345678910111213public ListNode reverseKNode(ListNode head,ListNode end)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur != end)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; k个一组逆转单链表123456789101112131415161718192021222324252627class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode end = head; for (int i = 0; i &lt; k; i++) &#123; // 如果长度不足k，则直接返回头部，不用逆转 if(end==null)&#123; return head; &#125; end = end.next; &#125; ListNode newHead = reverseKNode(head, k); head.next = reverseKGroup(end, k); return newHead; &#125; public ListNode reverseKNode(ListNode head, int k)&#123; ListNode prev=null; ListNode cur=head; ListNode suffix; while(cur!=null&amp;&amp;k--!=0)&#123; suffix=cur.next; cur.next=prev; prev=cur; cur=suffix; &#125; return prev; &#125;&#125; 第二次写 12345678910111213141516171819202122public ListNode reverseKGroup(ListNode head, int k)&#123; ListNode node = head; for (int i = 0; i &lt; k; i++) &#123; if(node==null)&#123; return head; &#125; node=node.next; &#125; ListNode newHead = reverseKNode(head,k,node); head.next=reverseKGroup(node,k); return newHead;&#125;private ListNode reverseKNode(ListNode head,int k,ListNode tail)&#123; if(k==1)&#123; return head; &#125; ListNode newHead=reverseKNode(head.next,k-1,tail); head.next.next=head; head.next=tail; return newHead;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-逆转单链表","slug":"算法-逆转单链表","date":"2022-03-08T01:31:19.000Z","updated":"2022-03-10T12:53:22.956Z","comments":true,"path":"算法/2022/03/08/算法-逆转单链表/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/08/%E7%AE%97%E6%B3%95-%E9%80%86%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"逆转单链表逆转单链表，这是一个经典的单链表问题 本节不仅讲如何迭代去逆转单链表 还讲如何使用递归去逆转一部分单链表或者整个单链表 1234567public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 反转链表力扣206：反转链表 迭代实现 1、初始化三个节点prev = null（作为前置节点）、cur = head（作为当前节点）、suffix（作为后置节点） 2、开始循环条件为cur!=null的循环，cur将一直走到最后一个节点的下一个节点为null的地方 3、先将suffix指向cur的next，然后将cur的next指向前一个指针prev，然后prev变为cur，cur变为suffix 4、返回prev节点 初始化 开始循环 1234567891011121314151617class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return head; &#125; ListNode prev=null; ListNode cur=head; ListNode suffix; while(cur!=null)&#123; suffix=cur.next; cur.next=prev; prev = cur; cur=suffix; &#125; return prev; &#125;&#125; 递归实现 我们的 reverseList 函数定义是这样的： 输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。 先递归到源链表的最后一个节点 然后当前的head节点就是需要加入到反转好的链表中， head的next指针是逆转后的链表的最后一个节点 1234567891011class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null)&#123; return head; &#125; ListNode cur = reverseList(head.next); head.next.next=head; head.next=null; return cur; &#125;&#125; 反转前n个节点n&lt;&#x3D;链表长度 12345678910111213class Solution &#123; ListNode end = null; public ListNode reverseList(ListNode head,int n) &#123; if(n==1)&#123; end = head.next; return head; &#125; ListNode node = reverseList(head.next,n-1); head.next.next=head; head.next=end; return node; &#125;&#125; 反转指定索引范围的链表力扣92：反转链表 II 反转left到right部分的链表 如果当left为1，那不就回到上面的那个问题了 所以只需要在reverseBetween中不断递归直到left的时候，right也就变成了区间长度 1234567891011121314151617181920class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; if(left==1)&#123; return reverseList(head,right); &#125; head.next=reverseBetween(head.next,left-1,right-1); return head; &#125; ListNode end = null; public ListNode reverseList(ListNode head, int n) &#123; if(n==1)&#123; end = head.next; return head; &#125; ListNode node = reverseList(head.next,n-1); head.next.next=head; head.next=end; return node; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-解决单链表问题","slug":"算法-解决单链表问题","date":"2022-03-07T09:05:29.000Z","updated":"2022-03-08T01:30:57.834Z","comments":true,"path":"算法/2022/03/07/算法-解决单链表问题/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/07/%E7%AE%97%E6%B3%95-%E8%A7%A3%E5%86%B3%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"单链表对于单链表的操作，有很多技巧性的东西。 下面我们使用六道题来以题明技巧 合并两个有序链表力扣21：合并两个有序链表 123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; // 这里使用了一个虚节点来充当头部存放节点 ListNode virtual = new ListNode(-1); ListNode temp=virtual; ListNode l1 = list1; ListNode l2 = list2; // 这里循环退出条件是两者都不为null，因为其中只要有一者为null，A处代码就会爆空指针异常 while(l1!=null&amp;&amp;l2!=null)&#123; // 将较小的那一个放入virtual链表中 if(l1.val&gt;l2.val)&#123;// A temp.next=l2; l2=l2.next; &#125;else&#123; temp.next=l1; l1=l1.next; &#125; temp = temp.next; &#125; // 这里是为了防止出现两者长度不一致的情况，这里不需要遍历，直接将temp.next指向还不为空的那个指针 if(l1!=null)&#123; temp.next=l1; &#125; if(l2!=null)&#123; temp.next=l2; &#125; // 最后返回虚节点的next return virtual.next; &#125;&#125; 合并 k 个有序链表力扣23：合并k个有序链表 使用一个动态数组存储所有的链表的头结点 1234567891011121314151617181920212223class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode virtual = new ListNode(-1); ListNode temp = virtual; List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;(); for (ListNode list : lists) &#123; if(list!=null)&#123; nodes.add(list); &#125; &#125; while(!nodes.isEmpty())&#123; nodes.sort((a,b)-&gt; a.val-b.val); temp.next = nodes.get(0); temp=temp.next; if(nodes.get(0).next==null)&#123; nodes.remove(0); &#125;else &#123; nodes.set(0,nodes.get(0).next); &#125; &#125; return virtual.next; &#125;&#125; 寻找单链表的倒数第 k 个节点力扣19：删除倒数第k个节点 123456789101112131415161718192021class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; // fast指针先走n步 while(n--&gt;0)&#123; fast=fast.next; &#125; // 如果fast变为了null说明是走到了尾部，则说明倒数第n个节点就是头结点 // 删除头结点，那就是直接返回头结点的下一个节点作为头结点 if(fast==null)&#123; return head.next; &#125; while(fast.next!=null)&#123; slow=slow.next; fast=fast.next; &#125; slow.next=slow.next.next; return head; &#125;&#125; 寻找单链表的中点力扣876：寻找单链表的中点 使用快慢指针法，slow走一步，fast走两步，当fast走到最后的时候，slow自然就在中间了 1234567891011class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode slow=head; ListNode fast=head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; &#125; return slow; &#125;&#125; 当单链表节点个数为奇数的时候，slow指向的是正中间的位置 当单链表节点个数为偶数的时候，slow指向的是中间靠右的位置 判断单链表是否包含环力扣141：判断单链表是否成环 1234567891011121314151617public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; if(fast==null)&#123; return false; &#125; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; return true; &#125; &#125; return false; &#125;&#125; 进阶：找到成环的起点 12345678910111213141516171819202122public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 判断两个单链表是否相交并找出交点1、将第一条链表的尾部的next指向第二条链表的头部，然后返回成环的那个起点 注意：此法只是一个思路，但是力扣中这道题的校验是不允许修改原来的链表的 123456789101112131415161718192021222324252627282930public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode ha=headA; while(ha.next!=null)&#123; ha=ha.next; &#125; ha.next=headB; return detectCycle(headA); &#125; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 2、使用技巧直接找到相交点 12345678910111213141516171819public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode ha = headA; ListNode hb = headB; while(ha!=hb)&#123; if(ha==null)&#123; ha=headB; &#125;else&#123; ha=ha.next; &#125; if(hb==null)&#123; hb=headA; &#125;else&#123; hb=hb.next; &#125; &#125; return ha; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript-原型和原型链","slug":"JavaScript-原型和原型链","date":"2022-03-05T12:18:26.000Z","updated":"2022-03-05T13:01:09.564Z","comments":true,"path":"javaEE/JavaScript/2022/03/05/JavaScript-原型和原型链/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JavaScript/2022/03/05/JavaScript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链prototype在JavaScript中，所有的函数都有一个prototype属性，该属性指向该函数的原型对象 12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.name = &#x27;kerwin&#x27;;let p1 = new Person();let p2 = new Person();console.log(p1.name);// kerwinconsole.log(p2.name);// kerwin 函数的prototype指向的就是对象原型，这个对象是调用构造函数时创建实例的原型对象，就是说p1和p2的原型对象是同一个 _proto_每个对象都会有一个属性，叫做_proto_，该属性指向该对象的原型对象，也就是构造函数的原型属性指向的对象 constructor每个原型都有一个constructor属性，指向该对象的构造函数 12345678910function Person()&#123; &#125;let person = new Person();console.log(Person.prototype._proto_ ==== Person);// trueconsole.log(person._proto_ === Person.prototype);// true// 在person中找不到constructor属性，所以向上在原型中找到该属性console.log(person.constructor === Person);// trueconsole.log(person.constructor === Person.prototype.constructor);console.log(person.constructor === person._proto_.constructor) 实例与原型当读取实例中的属性的时候，如果不存在该属性，则会去查找该对象的原型对象中是否存在该属性，如果不存在，则一直向上查找，一直找到最顶部为止 12345678910function Person(age)&#123; this.age = age;&#125;Person.prototype.name = &#x27;zhima&#x27;;let p1 = new Person();person.name = &#x27;kerwin&#x27;console.log(p1.name);// kerwin// 删除person对象中的name属性delete person.nameconsole.log(p1.name);// zhima 可以看到p1的name属性 显示输出了自身的属性值kerwin 当删除了对象中name属性之后，输出的是原型中的数据 原因是当对象内部不存在该属性的时候，会向上在原型中找属性，所以会输出kerwin 原型的原型原型是随着使用构造函数创建对象时，生成的一个对象。 那么原型也是一个对象，既然是一个对象，那么它一定也有原型 它的原型其实是通过Object对象的构造函数创建的 原型链简单回顾一下之前的知识点， prototype是每个函数的一个属性，指向原型对象 _proto_是每一个对象的一个属性，指向原型对象 constructor是每一个原型对象的一个属性，指向其绑定的构造函数 1每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎么样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层次递进，就构成了原型和实例的链条，这就是所谓的原型链的概念 ----------《摘自JavaScript高级程序设计》 那Object.prototype的原型是什么呢？是null 图中蓝色的线就是原型链","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JavaScript","slug":"javaEE/JavaScript","permalink":"http://li-zhi.net.cn/categories/javaEE/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"算法-滑动窗口","slug":"算法-滑动窗口","date":"2022-03-05T12:13:46.000Z","updated":"2022-03-07T09:04:15.961Z","comments":true,"path":"算法/2022/03/05/算法-滑动窗口/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/05/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口滑动窗口的思路非常简单， 就是维护一个窗口， 不断滑动， 然后更新答案 滑动窗口的骨架1234567891011121314151617181920public void slidingWindow(String s1, String s2) &#123; int left = 0; int right = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : s1.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); // 当前符合needs条件的条数 int valid=0; while(right &lt; s2.length())&#123; now = s2.charAt(right++); // 窗口内的数据更新 while(// 左窗口收缩条件)&#123; // 收缩左窗口 &#125; &#125;&#125; 看完了骨架，直接上四个题目 最小覆盖子串力扣76：最小覆盖子串 1、我们先初始化 left = right = 0，把索引区间 [left, right) 中的内容称为窗口。 2、不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（即窗口中的内容包含了 t 中的所有字符）。 3、此时，我们停止增加 right，开始不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新结果。 4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public String minWindow(String s, String t) &#123; if(t.length()&gt;s.length())&#123; return &quot;&quot;; &#125; int len = s.length(); int left = 0; int right = 0; char now; char[] chars = s.toCharArray(); Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); // valid指的是need中的所有条件的满足个数 int valid = 0; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) &#123; // 这个是java8的map新特性，当map中不存在该值，自动创建值并赋值为1，当该值存在的时候，将其加1 needs.merge(c, 1, Integer::sum); &#125; int start=0; int minLength = Integer.MAX_VALUE; while(right&lt;len)&#123; now = chars[right++]; // 只有当前这个字符是t里面的，我再去将其放入窗口中 // 如果这时候窗口中的该字符数量达到了needs中的，则valid自增 if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; // 如果needs中的条件都满足了，则left要自增 while(valid==needs.size())&#123; // 这里使用right-left充当字符串长度，因为now = chars[right++];这里right已经自增了 if(right-left&lt;minLength)&#123; start=left; minLength = right-left; &#125; now = chars[left++]; if(window.get(now)!=null)&#123; // 这个是java8的map新特性，当map中存在该值，则将其加上-1 window.merge(now,-1,Integer::sum); if(window.get(now)&lt;needs.get(now))&#123; valid--; &#125; &#125; &#125; &#125; return minLength==Integer.MAX_VALUE?&quot;&quot;:s.substring(start,start+minLength); &#125;&#125; 字符串排序力扣567：字符串排序 1、先初始化left和right为0，把[left,right)范围的数据叫做窗口 2、将需要符合的字符串条件初始化到needs中 3、不断扩大right，使窗口逐渐变大 4、直到窗口长度等于s1的长度，如果这时候已经出现了符合条件的字符串直接返回true，反之，将left向右走，缩小窗口 5、重复3、4，直到right走到最后 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int left = 0; int right = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : s1.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int valid=0; while(right &lt; s2.length())&#123; now = s2.charAt(right++); if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; if(right-left == s1.length())&#123; now = s2.charAt(left++); if(valid == needs.size())&#123; return true; &#125; if(window.get(now)!=null)&#123; if(window.get(now).equals(needs.get(now)))&#123; valid--; &#125; window.merge(now,-1, Integer::sum); &#125; &#125; &#125; return false; &#125;&#125; 找到字符串中所有字母异位词力扣438：找到字符串中所有字母异位词 其实本题就是上面那一题，只不过这一题需要将所有的异位词出现的地方都放到一个List中 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int left = 0; int right = 0; int valid = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); char[] chars = s.toCharArray(); while(right&lt;s.length())&#123; now = chars[right++]; if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; if(right-left == p.length())&#123; if(valid==needs.size())&#123; result.add(left); &#125; now = chars[left++]; if(window.get(now)!=null)&#123; if(window.get(now).equals(needs.get(now)))&#123; valid--; &#125; window.merge(now,-1, Integer::sum); &#125; &#125; &#125; return result; &#125;&#125; 无重复最长子串力扣3：无重复字符的最长子串 1、初始化left和right为0，window作为窗口 2、将当前right处的字符在window中的数目加一 3、如果当前right处的字符在window中的数目已经大于1了。说明有了重复元素，需要将left不断左移，直到当前right处的字符在window中的数目不大于1 4、重复2、3操作 代码： 12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len&lt;2)&#123; return len; &#125; int left = 0; int right = 0; int maxLength=1; char now; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); while(right&lt;len)&#123; now = s.charAt(right++); window.merge(now,1, Integer::sum); while(window.get(now)&gt;1)&#123; window.merge(s.charAt(left++),-1, Integer::sum); &#125; maxLength = Math.max(right-left,maxLength); &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-双指针技巧","slug":"算法-双指针技巧","date":"2022-03-04T23:49:11.000Z","updated":"2022-03-07T08:58:09.285Z","comments":true,"path":"算法/2022/03/05/算法-双指针技巧/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/05/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/","excerpt":"","text":"双指针技巧对于双指针，一般分为快慢指针和前后指针 前者一般使用在链表中，后者一般使用在数组中。 123456789101112class ListNode &#123; int val; ListNode next; ListNode(int val) &#123; this.val = val; this.next = null; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 快慢指针快慢指针一般初始化两个指针分别指向链表的头结点 head 前进时快指针 fast 在前 慢指针 slow 在后 这就是快慢指针的核心 判断链表是否成环力扣141题：环形链表 单链表的特点是每一个节点只知道后置节点，不知道前置节点。如果我使用单指针想去解决这个判断成环 123456789public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode temp = head; while(temp!=null)&#123; temp = temp.next; &#125; return false; &#125;&#125; 当链表成环的时候，因为没有一个节点的后置节点为null，所以该方法一定是死循环，无法退出。 经典解法就是使用两个指针，fast指针跑得快，slow指针跑得慢。 如果链表没有环，跑得快的那个指针最终会遇到 null，说明链表不含环； 如果链表有环，快指针最终会超慢指针一圈，和慢指针相等，说明链表含有环。 以下是解法 1234567891011121314public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; return true; &#125; &#125; return false; &#125;&#125; 已知链表有环，返回环开始的地方力扣142题：环形链表 II 5就是那个环开始的地方 假设快指针走了2k步，则慢指针就一定走了k步，那么k其实就是环节点个数的整数倍 黄色的线就是快指针比慢指针多走的步数，即k,图上只画了一圈，但是实际可能不止一圈 设慢指针在环中走了m个节点。 则说明在环节点之前，一共有k-m个节点，就是说我可以从头结点往后走k-m次就可以找到该环开始的地方了。 但是如果想着如何把k-m求出来的话是有点困难的，所以我们来看看关于快指针的路径中可不可以出现k-m 我们现在来看看快指针走的2k长度的路径，它在环里面走过的路径长度是k+m，从相遇点到相遇点的距离是k 那么就是说快指针从相遇点在环中走k-m步就可以走到环开始的节点， 所以我们可以将slow置于head，与fast同步前进，当两个指针相同时，返回该值 代码： 12345678910111213141516171819202122public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 寻找链表的中点力扣876：链表的中心节点 给出一个无环的链表，要求返回该链表的中点 使用快慢指针，当fast指针走到尾部的时候，slow就在链表中间位置了 以下是节点个数为奇数的情况 以下是节点个数为偶数的结果 可以发现，当个数为奇数的时候，慢指针正好在中心位置， 当个数为偶数的时候，慢指针在中心偏右的位置 这个算法在链表的归并算法中常常被用到 代码： 123456789public ListNode middleNode(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; 这是hash实现 12345678910public ListNode middleNode(ListNode head) &#123; Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode curr = head; int i = 0; while(curr != null)&#123; map.put(i++,curr); curr = curr.next; &#125; return map.get(i/2);&#125; 删除倒数第n个节点力扣19题：删除倒数第n个节点 思路就是快指针先走n步，然后慢指针和快指针同步向前，当快指针的next是null的时候，慢指针的下一个就是倒数第n个节点 123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; while(n--&gt;0)&#123; fast=fast.next; &#125; if(fast==null)&#123; return head.next; &#125; while(fast.next!=null)&#123; slow=slow.next; fast=fast.next; &#125; slow.next=slow.next.next; return head; &#125;&#125; 左右指针左右指针一般初始化left right两个变量来表示左边界和右边界 二分查找这里就不赘述二分查找的细节了，之前有写，这里就写一种最常见的 查找target找到则返回索引，没有找到则返回-1 123456789101112131415161718int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = (right + left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; return -1;&#125; 两数之和 题目中说，该数组是递增的， 通过left和right来调整大小从而判断是否存在两个数使得和为target 12345678910111213141516171819202122class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length-1; int mid; int sum; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;1; sum=numbers[left]+ numbers[right]; if(sum==target)&#123; return new int[]&#123;left+1,right+1&#125;; &#125;else if(sum&gt;target)&#123; // 使大的值变小 right--; &#125;else &#123; // 使小的值变大 left++; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 反转数组这个就很简单了，直接上代码 12345678910void reverseString(int[] arr) &#123; int left = 0; int right = arr.length - 1; while (left &lt; right) &#123; // 交换 arr[left] 和 arr[right] int temp = arr[left]; arr[left++] = arr[right]; arr[right--] = temp; &#125;&#125; 滑动窗口这个就是左右指针的重头戏了，掌握了这个方法后，可以解决一大类子字符串匹配的问题！ 这个放在下一篇文章中详解","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2022-03-02T10:06:48.000Z","updated":"2022-03-02T10:41:36.988Z","comments":true,"path":"设计模式/2022/03/02/设计模式-观察者模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式定义：定义了对象之间的一对多依赖，让多个观察者监听同一个对象的行为，当该行为发生的时候，则做出一定的动作 天气变化了，发出提示 天气模型 1234567891011121314151617181920@Data@NoArgsConstructor@AllArgsConstructorpublic class Weather &#123; private String address; private Integer temperature; private List&lt;Observer&gt; observers; public void addObserver(Observer observer)&#123; observers.add(observer); &#125; public void removeObserver(Observer observer)&#123; observers.remove(observer); &#125; public void changeTemperature(int temperature)&#123; this.temperature=temperature; for (Observer observer : observers) &#123; observer.update(temperature); &#125; &#125;&#125; 观察者的接口 123public interface Observer &#123; void update(Integer temperature);&#125; 邮件的观察者 1234567public class EmailObserver implements Observer &#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发邮件告诉用户天气改变了，变为了&quot;+temperature); &#125;&#125; 短信观察者 123456public class MsgObserver implements Observer&#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发短信告诉用户气温改变了，变为了&quot;+temperature); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模板方法模式","slug":"设计模式-模板方法模式","date":"2022-03-02T09:24:31.000Z","updated":"2022-03-02T10:06:27.982Z","comments":true,"path":"设计模式/2022/03/02/设计模式-模板方法模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法模式定义：定义一个操作的算法骨架，将一些操作延迟到子类实现。Template Method使得子类可以在不改变算法结构的基础上即可重新定义算法的某些特定步骤 其实该模式很简单，就是定义一个抽象类，然后定义一个抽象方法给子类去实现。 处理器 12345678910public abstract class Handler &#123; public void operation()&#123; System.out.println(&quot;做前期准备&quot;); System.out.println(&quot;准备就绪，开始处理&quot;); doHandler(); System.out.println(&quot;处理完毕&quot;); &#125; abstract void doHandler();&#125; 字符处理器 123456public class CharHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;将字符串转化&quot;); &#125;&#125; 字符串处理器 123456public class StringHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;字符串转化&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式-策略模式","date":"2022-03-02T04:11:02.000Z","updated":"2022-03-02T10:19:04.792Z","comments":true,"path":"设计模式/2022/03/02/设计模式-策略模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式的变化独立于算法的使用者 有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 下面使用策略模式来优化 Version 1.2策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"算法-二分查找的多种写法","slug":"算法-二分查找的魔鬼细节探究","date":"2022-03-02T01:07:03.000Z","updated":"2022-03-07T08:58:25.708Z","comments":true,"path":"算法/2022/03/02/算法-二分查找的魔鬼细节探究/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/02/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"二分查找二分查找作为数组的基操，肯定是要牢牢掌握的，其思想十分简单，但是对于细节的处理，就可以看出你对二分算法的理解深刻与否。 如果没有真正的理解细节处的内涵，二分查找算法的编写就是玄学编写，这里加不加等号呢？这里是+1还是不变呢？最后该返回啥呢？ 接下来我们就来看看这些细节该如何处理 下面使用三个二分查找使用的场景做出分析：寻找一个数、寻找左侧边界、寻找右侧边界 二分查找的骨架12345678910111213141516public int binarySearch(int[] nums, int target) &#123; int left=0; int right=..;// nums.length-1还是nums.length int mid; while(left..right)&#123;// &lt;=还是&lt; mid = (left+right)&gt;&gt;1;// (right-left)/2+left还是(left+right)&gt;&gt;1还是(right+left)/2 if(nums[mid]==target)&#123; ..=..; // right还是left mid-1还是mid &#125;else if(target&lt;nums[mid])&#123; right=..; // mid-1还是mid &#125;else &#123; left=..;// mid+1 &#125; &#125; return ..;// left或者要做什么处理&#125; 或许你经常看见一些代码不会将等于的情况单独列出来，但是我觉得对于二分查找的分析，将等于的情况单独分离出来，会更有利于理解，等到彻底理解后，随便怎么写都不会少搜索区间的时候，那就随便合并语句了。 上述骨架中..出现的地方就是我们需要去琢磨的细节之处了，乍一看，全是细节，所以叫魔鬼细节探究。 先解决最好解决的一个细节，很多人都在LeetCode官网中看到有时候官网对于中间值的取值会使用(right-left)/2+left有时候会使用(left+right)&gt;&gt;1有时候看见别人写的代码中又是(right+left)/2，肯定会很迷糊，这三者的计算到底有什么不同之处呢？ (right-left)/2+left这种写法是为了防止(left+right)因为数据过大导致溢出，导致mid计算错误， (left+right)&gt;&gt;1这是位运算，可能处理效率会高一点 (right+left)/2这就是正常写法，一般也不会出错 接下来按照二分查找的常见使用场景来逐个做出分析 查找一个数场景1：查找一个数，存在返回索引，不存在返回-1 123456789101112131415161718int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; return -1;&#125; 循环条件是left &lt;= right而不是left &lt; right？ 这里我们要说一下什么时候应该退出循环，就是当我所有的元素都搜索完成之后（即搜索区间里面没有元素的时候），或者是找到了目标值的时候可以直接终止，返回结果。 当right赋值为nums.length - 1，则搜索区间为[left,right]，所有元素搜索完成的条件应该是left==right+1，即搜索区间为[right+1,right]，符合要求。如果循环退出条件改为 left&lt;right，则退出循环的时候，搜索区间为[left,right]，会缺少搜索第left个元素。，不符合要求。 如果**right赋值为nums.length**，则搜索区间为[left,right)，所有元素搜索完成的条件应该是left==right，即搜索区间为[left,right) 当nums[mid] &gt; target的时候，为什么是right = mid - 1; 而不是right = mid; ？ 还是回到搜索区间的问题上，当我发现当前这个元素与target不等而是大于target，那么我只需要搜索左边区间，即将[left,right]分割为左边区间[left,mid-1]和右边区间[mid+1,right]，所以下一步应该将mid-1赋值给right 此算法的用途 这种方法只可以在找到目标值的情况下返回索引，但是当nums为[1,2,2,2,4]的时候，返回的值是2，没错，但是这样可能就无法满足我们的需求了，只能在数组是严格递增的情况下使用。 如果场景变为：查找一个数，如果找到则返回索引位置，如果找不到，则返回目标值插入数组的位置。 这个时候其实只要最后返回left即可。 返回左边界123456789101112131415161718192021int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; right= mid - 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; if(left&gt;=nums.length||nums[left]!=target)&#123; return -1; &#125; return left;&#125; 为什么最后返回的时候要做出判断？ 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid - 1，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，也要做出判断 为什么找到的一定是左边界？ 因为这一段代码， 123if(nums[mid] == target)&#123; right= mid - 1;&#125; 当数组元素等于目标元素的时候，不着急返回，而是缩小查找范围。因为需要查找左边界，所以需要向左边收缩区间 这里面while的循环条件可以改为left &lt; right吗？ 当然可以，只要理解了搜索区间，只要能够保证所有的元素都被查找了，怎么写都可以。 123456789101112131415161718192021222324int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length; int mid; while(left &lt; right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; right= mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid; &#125; &#125; if(left==nums.length)&#123; return -1; &#125; if(nums[left]!=target)&#123; return -1; &#125; return left;&#125; 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，需要单独做出判断 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid ，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 返回右边界123456789101112131415161718192021222324int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; left = mid + 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; if(left==nums.length)&#123; return -1; &#125; if(nums[left]!=target)&#123; return -1; &#125; return left;&#125; 为什么最后返回的时候要做出判断？ 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，也要做出判断 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid - 1，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 为什么找到的一定是右边界？ 因为这一段代码， 123if(nums[mid] == target)&#123; left = mid + 1;&#125; 当数组元素等于目标元素的时候，不着急返回，而是缩小查找范围。因为需要查找右边界，所以需要向右边收缩区间 如何修改循环条件为left &lt; right？ 12345678910111213141516171819202122232425262728int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length; int mid; while(left &lt; right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; left = mid + 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid; &#125; &#125; // 当target比数组所有元素都大的时候，right和left都走到了数组长度的位置， // 如果数组最后一个元素不是这说明数组中没有target元素 if(nums[left-1]!=target)&#123; return -1; &#125; // 当target比数组中所有元素都小的时候，right和left都走到了-1的位置， // 这时候这说明，数组中不存在target元素，直接返回-1 if(left&lt;0)&#123; return -1; &#125; return left - 1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【704-Easy】二分查找","slug":"【704-Easy】二分查找","date":"2022-03-02T00:40:52.000Z","updated":"2022-03-02T14:07:21.630Z","comments":true,"path":"算法/2022/03/02/【704-Easy】二分查找/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/02/%E3%80%90704-Easy%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 Related Topics 数组 二分查找 法一：二分查找123456789101112131415161718class Solution &#123; public int search(int[] nums, int target) &#123; int left=0; int right=nums.length-1; int mid; while(left&lt;=right)&#123; mid=(left+right)&gt;&gt;1; if(target&lt;nums[mid])&#123; right=mid-1; &#125;else if(target&gt;nums[mid])&#123; left=mid+1; &#125;else &#123; return mid; &#125; &#125; return -1; &#125;&#125; 官方代码中 left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【74-Medium】搜索二维矩阵","slug":"【74-Medium】搜索二维矩阵","date":"2022-03-01T10:49:43.000Z","updated":"2022-03-02T04:00:39.375Z","comments":true,"path":"算法/2022/03/01/【74-Medium】搜索二维矩阵/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/01/%E3%80%9074-Medium%E3%80%91%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/","excerpt":"","text":"搜索二维矩阵编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例 2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 100 -104 &lt;= matrix[i][j], target &lt;= 104 Related Topics 数组 二分查找 矩阵 法一：二维看成一维根据题目所给的矩阵性质， 可以得知该二维数组的每一行顺次排下来就是一个一维的升序数组， 那我们可以依赖下标和一维索引的关系来进行二分查找 12345678910111213141516171819202122class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m=matrix.length; int n=matrix[0].length; int left=0; int right=m*n-1; int mid; int value; while(left&lt;=right)&#123; mid=(right+left)&gt;&gt;1; value=matrix[mid/n][mid%n]; if(value&gt;target)&#123; right=mid-1; &#125;else if(value&lt;target)&#123; left=mid+1; &#125;else &#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【240-Medium】搜索二维矩阵II","slug":"【240-Medium】搜索二维矩阵II","date":"2022-03-01T08:51:22.000Z","updated":"2022-03-01T10:54:05.281Z","comments":true,"path":"算法/2022/03/01/【240-Medium】搜索二维矩阵II/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/01/%E3%80%90240-Medium%E3%80%91%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/","excerpt":"","text":"搜索二维矩阵II编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 示例 2： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= n, m &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -109 &lt;= target &lt;= 109 Related Topics 数组 二分查找 分治 矩阵 法一：二分查找12345678910111213141516public boolean searchMatrix(int[][] matrix, int target) &#123; int m=matrix.length; int n=matrix[0].length; int i=m-1; int j=0; while(i&gt;=0&amp;&amp;j&lt;n)&#123; if(matrix[i][j]==target)&#123; return true; &#125;else if(matrix[i][j]&gt;target)&#123; i--; &#125;else &#123; j++; &#125; &#125; return false;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","slug":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","date":"2022-03-01T08:49:22.000Z","updated":"2022-03-02T13:57:44.328Z","comments":true,"path":"算法/2022/03/01/【34-Medium】在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/01/%E3%80%9034-Medium%E3%80%91%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 Related Topics 数组 二分查找 法一：二分查找123456789101112131415161718192021222324252627282930class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int first = binarySearch(nums,target); if(first==-1)&#123; return new int[]&#123;-1,-1&#125;; &#125; int end=binarySearch(nums,target+1); if(end&lt;=first)&#123; return new int[]&#123;-1,-1&#125;; &#125; return new int[]&#123;first,end-1&#125;; &#125; private int binarySearch(int[] nums, int target) &#123; int left=0; int right=nums.length-1; int mid; while(left&lt;=right)&#123; mid = (left+right)&gt;&gt;1; if(nums[mid]==target)&#123; right=mid-1; &#125;else if(target&lt;nums[mid])&#123; right=mid-1; &#125;else &#123; left=mid+1; &#125; &#125; return left; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【378】有序矩阵中第k小的元素","slug":"【378-Medium】有序矩阵中第k小的元素","date":"2022-03-01T04:57:57.000Z","updated":"2022-03-01T10:49:47.152Z","comments":true,"path":"算法/2022/03/01/【378-Medium】有序矩阵中第k小的元素/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/01/%E3%80%90378-Medium%E3%80%91%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"有序矩阵中第k小的元素 在做这道题之前最好把这几题做了 【74-Medium】搜索二维矩阵 【240-Medium】搜索二维矩阵II 给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。 你必须找到一个内存复杂度优于 O(n2) 的解决方案。 示例 1： 123输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8输出：13解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13 示例 2： 12输入：matrix = [[-5]], k = 1输出：-5 提示： n == matrix.length n == matrix[i].length 1 &lt;= n &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列 1 &lt;= k &lt;= n^2 进阶： 你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题? 你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。 Related Topics 数组 二分查找 矩阵 排序 堆（优先队列） 法一：暴力枚举先将所有的数据放到一个集合中，然后直接排序，取出要求的元素 123456789101112class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; List&lt;Integer&gt; list=new ArrayList(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; list.add(matrix[i][j]); &#125; &#125; list.sort((a,b)-&gt;a-b); return list.get(k-1); &#125;&#125; 法二：二分查找该矩阵是一个行是递增的，列是递增的，则说明左上角matrix[0][0]是最小值右下角matrix[len-1][len-1]是最大值 当mid为15的时候可以将其划分为这样的两个区域，左上部分和右下部分， 左上部分为小于等于mid的所有元素 右下部分为大于mid的所有元素 如果左上部分元素的个数比k大， 这说明mid不是第k个最小元素 将区域减半，继续以上的过程 流程图：粉色代表left元素，绿色代表right元素，橙色代表当前要检查的元素 这次示例是k等于8的情况 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; int len=matrix.length; int left=matrix[0][0]; int right = matrix[len-1][len-1]; int mid; while(left&lt;right)&#123; // 就是自己除以2，只是这样写的话更装B一点 mid=(left+right)&gt;&gt;1; if(check(matrix,mid,k))&#123; right = mid; &#125;else &#123; // 这个加一是因为check中将小于和等于mid的元素都划分到左上部分了，所以left必须要加一 left = mid+1; &#125; &#125; return left; &#125; private boolean check(int[][] matrix, int mid, int k) &#123; int i=0; int j=matrix.length-1; int nums=0; while(i&lt;matrix.length&amp;&amp;j&gt;=0)&#123; if(matrix[i][j]&lt;=mid)&#123; nums+=j+1; i++; &#125;else &#123; j--; &#125; &#125; return nums&gt;=k; &#125;&#125; 关于这个left+1一定在矩阵中的论证 可以先把这一题做了 【34-Medium】在排序数组中查找元素的第一个和最后一个位置 我找了官网评论区的几个评论 1234我们先看check函数.check函数的目的是统计矩阵里小等于mid的元素数目count. 再判断count和k的关系.因为mid = (l + r) / 2这种划分方法是把矩阵划分成了[left , mid] 与[mid + 1, right]两部分. 当 count &lt; k 时, 说明mid太小了, 我们应该在[mid + 1, right] 这个范围里查找. 否则在[left, mid]范围里查找.如果存在一个不在矩阵中的数a满足条件, 因为a不在矩阵中,那count统计的元素肯定都是小于a的, 那一定存在一个比a小且在矩阵中的数b满足条件,即从小于a的数变成了小于等于b的数 .等用题目中的例子,x = 13 和x = 14 都满足小于等于x的元素数目等于8, 对14来说统计的都是小于它的数, 而对13来说统计的都是小于等于它的数. 问题来了, 那为何取到的不是14而是13呢?因为我们取mid的取法是 mid = (left + right) / 2, 当left &lt; right时, mid 永远 取不到right, 想要mid取到right ,只有left == right. 但循环条件是 while(left &lt; right),当 left == right时循环已经终止. 所以我们得到会是一个左边界. 还是用题目中的例子, 假设left = 13, right = 14 则 mid = (13 + 14) / 2 = 13 1二分法的精髓是，不断排除错误答案，最后剩下的就是正确答案。先记住这句话，我们再来看题目，如果 我们从 二分取出来的 mid，恰好不在矩阵中，那么这个数字，是无法 左右两个条件都满足的，否则矩阵就少一个数了。所以在左右排除的过程中，一定会将其排除掉的。 举例说明， 一个 3*3 的矩阵，取第 3 小的元素a，那么在矩阵中，一定是有 2个 小于等于 a的元素，以及6个大于等于a的元素。如果元素b不在矩阵中，且满足这两个条件，那么矩阵一共，只能有 2+6 = 8个元素了，所以是不可能的。 1综合前几位大佬的思路，谈谈如何证明解法三中的left必出现在矩阵中。解法三中二分查找后退出循环后，left为min&#123;x|矩阵中小于等于x的元素个数大于等于k&#125;。假设left不出现在矩阵中，那么矩阵中小于等于left的元素集合实则为矩阵中小于left的元素集合。从矩阵中小于left的元素集合中选择最大值，记为b。那么矩阵中小于等于b的元素个数大于等于k，但b&lt;left与left=min&#123;x|矩阵中小于等于x的元素个数大于等于k&#125;矛盾，所以left必出现在矩阵中。 1之前考虑怎么保证算出值一定在矩阵里呢，我是这么想的，假设答案应该是m为第k个元素，s为第（k+1）个元素，那么使得矩阵中有k个比mid小于等于的元素，mid一定会在m与s之间，而算法中找到的是left，仔细想，其实就是第一个满足有k个比自身小于等于的元素，无疑m是第一个，所以找到的left一定是在矩阵中的","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-装饰者模式","slug":"设计模式-装饰者模式","date":"2022-03-01T03:31:14.000Z","updated":"2022-03-01T03:48:31.941Z","comments":true,"path":"设计模式/2022/03/01/设计模式-装饰者模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰者模式定义：在不改变原有对象的基础上，将功能附加到对象上 这个其实大家在平时写代码的时候就已经用过了，只是不知道这是一个模式 下面看一个案例 有一个组件的接口，然后我有一个具体的实现类，现在我需要在这个具体实现类的基础上进行功能拓展 组件接口 123public interface Component &#123; void operation();&#125; 具体接口实现 123456public class ConcreteComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;实现组件功能&quot;); &#125;&#125; 拓展功能抽象类 12345678public abstract class EnhanceComponent implements Component&#123; protected Component component; public EnhanceComponent(Component component) &#123; this.component = component; &#125;&#125; 具体增强类 1234567891011public class ConcreteEnhanceComponent extends EnhanceComponent&#123; public ConcreteEnhanceComponent(Component component) &#123; super(component); &#125; @Override public void operation() &#123; component.operation(); System.out.println(&quot;拓展功能一&quot;); &#125;&#125; 优点： 不改变原有代码的情况下，对原来的类进行增强 使用不同的组合可以实现不同的人效果 符合开闭原则","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-适配器模式","slug":"设计模式-适配器模式","date":"2022-03-01T03:10:43.000Z","updated":"2022-03-01T03:30:45.584Z","comments":true,"path":"设计模式/2022/03/01/设计模式-适配器模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式定义：将一个类的接口转换为用户希望的另一个接口。这使得原本由于接口不兼容而不能一起工作的那些类就可以一起工作了 接下来我们来模拟USB转接网线口，从而使电脑上网的案例 网线接口 123public interface NetWorkThread &#123; void connectNetWork();&#125; 华为的网线 123456public class HuaWeiNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;华为网线连接网络，可以上网了&quot;); &#125;&#125; 自制的网线 123456public class CustomerNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;自制网线，可以上网了&quot;); &#125;&#125; 适配器（网线口变为USB口） 123public interface Adapter &#123; void netWorkToUSB();&#125; 华为的适配器（转接口） 1234567891011121314151617public class HuaWeiAdapter implements Adapter&#123; private NetWorkThread netWorkThread; public void setNetWorkThread(NetWorkThread netWorkThread) &#123; this.netWorkThread = netWorkThread; &#125; @Override public void netWorkToUSB() &#123; if(netWorkThread==null)&#123; System.out.println(&quot;适配器没有网线插入！&quot;); return; &#125; System.out.println(&quot;华为适配器适配了网线&quot;); netWorkThread.connectNetWork(); &#125;&#125; 电脑 123456789101112131415public class Computer &#123; private Adapter adapter; public void setAdapter(Adapter adapter) &#123; this.adapter = adapter; &#125; public void connectToNetWork()&#123; if(adapter!=null)&#123; adapter.netWorkToUSB(); &#125;else &#123; System.out.println(&quot;没有插网线！&quot;); &#125; &#125;&#125; 客户端 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); HuaWeiAdapter huaWeiAdapter = new HuaWeiAdapter(); computer.setAdapter(huaWeiAdapter); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); huaWeiAdapter.setNetWorkThread(new HuaWeiNetWorkThread()); computer.connectToNetWork(); &#125;&#125; 控制台输出 123456没有插网线！===================适配器没有网线插入！===================华为适配器适配了网线华为网线连接网络，可以上网了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【5-Medium】最长回文数","slug":"【5-Medium】最长回文数","date":"2022-02-28T13:24:51.000Z","updated":"2022-03-09T07:45:13.643Z","comments":true,"path":"算法/2022/02/28/【5-Medium】最长回文数/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/28/%E3%80%905-Medium%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"最长回文数给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 Related Topics 字符串 动态规划 法一：暴力枚举123456789101112131415161718192021222324252627282930class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)&#123; return s; &#125; char[] chars = s.toCharArray(); int begin = 0; int end = 0; for (int i = 0; i &lt; s.length() - 1; i++) &#123; for (int j = i+1 ; j &lt; s.length(); j++) &#123; if((j - i + 1) &gt; (end - begin + 1) &amp;&amp; isValid(chars,i,j))&#123; begin = i; end = j; &#125; &#125; &#125; return s.substring(begin, end+1); &#125; private boolean isValid(char[] chars, int left, int right) &#123; while(left &lt; right)&#123; if(chars[left] != chars[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125; 法二：中心扩散将每”一位”作为中心向两边扩撒， 每次扩散分两种情况， 第一种情况是以当前那一位为中心向两边扩散 第二种情况是以当前那一位和下一位为中心向两边扩散 取这两种情况的最值max 如果max比maxLen大的话，计算得出begin‘ 最后直接返回截取的字符串 这是我的解法 12345678910111213141516171819202122232425class Solution &#123; public String longestPalindrome(String s)&#123; if (s.length() &lt; 2) &#123; return s; &#125; int begin = 0; int maxLen = 1; for (int i = 0; i &lt; s.length(); i++) &#123; int max = Math.max(expand(s,i,i),expand(s,i,i+1)); if(max &gt; maxLen)&#123; maxLen = max; begin = i - (max - 1)/2; &#125; &#125; return s.substring(begin, maxLen+begin); &#125; public int expand(String s, int left, int right) &#123; while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; return right - left - 1; &#125;&#125; 这是官方的解法 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) &#123; return &quot;&quot;; &#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 法三：动态规划对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。 例如对于字符串 “ababa’”，如果我们已经知道 “bab” 是回文串这层关系，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是a 使用dp[][]二位数组来存储这层关系 即使用dp[i][j]来表示s字符串的i到j是否是回文数 如果当前要判断的范围是dp[left][right]，字符串长度为x 第一步先看首尾是否一致， 如果不一致，则dp[left][right]直接为false， 如果一致，则进入下一步判断 如果当前判断的字符串长度小于3 为什么是3呢？ 如果长度为1，则本身就是字符串，形成自回文 如果长度为2，则首尾一致的情况下，可以直接判断为回文 如果长度为3，则首尾一致的情况下，也可以直接判断回文 这三组数据是后面做判断的支撑 则直接将dp[left][right]赋值为true 反之将dp[left+1][right-1]（即去掉首尾的时候是否为回文数）的回文结构赋值给dp[i][j] 这些结束后，当dp[left][right]是true时， 则将当前循环长度和存储的maxLen进行比较， 如果当前循环长度较大，则将其赋值给maxLen，将left赋值给begin 反之，直接进行下一次循环 官方代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) &#123; // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) &#123; // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) &#123; break; &#125; if (charArray[i] != charArray[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125;&#125; 下面是我理解思路后写的 对于变量的命名更贴近其本身的含义 可能会更好理解一点 1234567891011121314151617181920212223242526272829303132333435363738public String longestPalindrome1(String s) &#123; int len = s.length(); if(len &lt; 2)&#123; return s; &#125; int begin = 0; int maxLen = 1; char[] chars = s.toCharArray(); boolean[][] dp = new boolean[len][len]; // dp[i][j]即表示s[i..j]是否为回文数 // 对角线即为每个字符本身那就可以直接初始化为true // 也可以不初始化这个，但是为了语义完整，最好还是加上 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; //x表示长度，从长度为2开始，因为长度为1的情况可以直接判断 for (int x = 2 ; x &lt;= len; x++) &#123; //循环次数为总长度减当前循环的长度再加一 for (int left = 0; left &lt; len - x + 1; left++) &#123; //x=right-left+1 int right = x + left - 1; if(chars[left] != chars[right])&#123; dp[left][right] = false; &#125;else &#123; if(x &lt; 4)&#123; dp[left][right] = true; &#125;else &#123; dp[left][right] = dp[left+1][right-1]; &#125; &#125; if(dp[left][right] &amp;&amp; x &gt; maxLen)&#123; begin = left; maxLen = x; &#125; &#125; &#125; return s.substring(begin, maxLen+begin);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于权限修饰符protected","slug":"关于权限修饰符protected","date":"2022-02-28T10:05:05.000Z","updated":"2022-02-28T13:14:09.160Z","comments":true,"path":"琐碎的知识/2022/02/28/关于权限修饰符protected/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/28/%E5%85%B3%E4%BA%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6protected/","excerpt":"","text":"权限修饰符我们先回顾一下java中的权限修饰符 权限修饰符 同类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 对于public和private大家都很了解了，但是对于protected，大家可能对它的概念可能就一句话：被protected修饰的成员对于本包和其子类可见。 该权限修饰符的关键是 基类的protected成员属性是包内可见的，并且对所有子类可见 若子类与基类不在同一包下，则在子类中，子类实例可以访问从基类继承来的protected方法，而不能访问基类实例的protected方法 遇到protected 首先思考这个protected来自何方 接着看其和这个地方是不是同包 最后看其是否有父子类关系 可以通过以下几个Test来掌握protected的用法 注意：观察包限定名 模型 12345678910package com.lizhi.protect.p1;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 1234package com.lizhi.protect.p1;public class Son1 extends Feather1&#123;&#125; 123456package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;public class Son11 extends Feather1 &#123;&#125; 测试 1234567891011121314151617package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译通过，因为该测试类与Feather1处于同一包下 son1.clone();//编译通过，因为该测试类与Feather1处于同一包下 son2.f();//编译通过，因为该测试类与Feather1处于同一包下 son2.clone();//编译通过，因为该测试类与Feather1处于同一包下 feather1.f();//编译通过，因为该测试类与Feather1处于同一包下 feather1.clone();//编译通过，因为该测试类与Feather1处于同一包下 &#125;&#125; 测试 12345678910111213141516171819package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 &#125;&#125; 测试 123456789101112131415161718package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;public class Son11 extends Feather1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类所在的地方是Feather1的子类 son2.clone();//编译通过，因为该测试类所在的地方是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 &#125;&#125; 测试 1234567891011121314151617181920212223package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类是Son1和Son11的父类 son2.clone();//编译通过，因为该测试类是Son1和Son11的父类 feather1.f();//编译通过，因为该测试类是Son1和Son11的父类 feather1.clone();//编译通过，因为该测试类是Son1和Son11的父类 son1.f();//编译通过，因为该测试类是Son1和Son11的父类 son1.clone();//编译通过，因为该测试类是Son1和Son11的父类 &#125;&#125; 测试 12345678910package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译不通过 &#125;&#125; 说明：myobject4的clone直接来自MyObject4类本身 其范围是MyObjcet4的子类与其同包的类 Test4都不满足 所以编译不通过 测试 1234567package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; &#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译通过 &#125;&#125; 说明：myobject4的clone直接来源于Test4 范围是Test4子类及其同包的类 满足与其同包 编译通过","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"算法-旋转的数字","slug":"算法-旋转的数字","date":"2022-02-28T07:58:54.000Z","updated":"2022-05-07T02:32:22.768Z","comments":true,"path":"算法/2022/02/28/算法-旋转的数字/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/28/%E7%AE%97%E6%B3%95-%E6%97%8B%E8%BD%AC%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"旋转的数字 这是自己起的题目名 直接上5阶旋转数字的示例图 分析这道题一看就知道是不可能一行一行输出的 我们需要通过一个二位数组先来计算出来这个矩阵的数据 再遍历输出这个矩阵 那么如何操作这个二位矩阵呢？ 通过一个大循环限制循环次数 有四个小循环 第一个循环用来写入这一次循环中水平向左的数据 第二个循环用来写入这一次循环中水平向下的数据 第三个循环用来写入这一次循环中水平向右的数据 第四个循环用来写入这一次循环中水平向上的数据 流程图粉红色的是标注为每次大循环的开始处 PS：图片很多，过程很详细 代码1234567891011121314151617181920212223242526272829public int[][] rotateNumber(int n)&#123; int[][] matrix = new int[n][n]; int counter=1; int timer; for (int i = 0; i &lt; n / 2; i++) &#123; timer = n - i - 1; //-&gt; for (int j = i; j &lt; timer; j++) &#123; matrix[i][j]=counter++; &#125; //↓ for (int j = i ; j &lt; timer; j++) &#123; matrix[j][timer]=counter++; &#125; //&lt;- for (int j = timer; j &gt; i ; j--) &#123; matrix[timer][j]=counter++; &#125; //↑ for (int j =timer; j &gt; i ; j--) &#123; matrix[j][i]=counter++; &#125; &#125; // 如果是奇数，单独处理中间那一格数据 if(n%2!=0)&#123; matrix[n/2][n/2]=n*n; &#125; return matrix;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-螺旋数字","slug":"算法-螺旋数字","date":"2022-02-28T01:03:17.000Z","updated":"2022-02-28T09:04:59.885Z","comments":true,"path":"算法/2022/02/28/算法-螺旋数字/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/28/%E7%AE%97%E6%B3%95-%E8%9E%BA%E6%97%8B%E6%95%B0%E5%AD%97/","excerpt":"","text":"螺旋数字 这是自己起的题目名字 直接上6阶螺旋数字的示例图 传入数字n，最后输出n阶的螺旋数字 123public void spiralNumber(int n)&#123; &#125; 控制台输出 1234561 2 6 7 15 16 3 5 8 14 17 4 9 13 18 10 12 19 11 20 21 分析这道题目的话，循环写的稍微多点的都知道，我不可能直接输出1 2 6 7 15 16这一行数据的 而是应该通过一个二维数组来先将数据计算好，然后将此二维数组输出，这样才可以达到目的 那么如何通过二维数组来达到目的呢？ 我是用一个大循环中套两个小循环来做的 外面大循环用来限制循环次数的 内层第一个循环是用来向右上方走的 内层第二个循环是用来向左下方走的 流程图粉红色的是标注为每次大循环的开始处 标注内层循环初始化的是该循环刚要开始时候的数据 PS：图片很多，过程很详细 这是代码 123456789101112131415161718192021public int[][] spiralNumber(int n)&#123; int[][] matrix = new int[n][n]; int counter = 1; int j; int end; for (int i = 0; i &lt; n; i+=2) &#123; j=0; for (int k = i; k &gt;= 0; k--) &#123; matrix[k][j++]=counter++; &#125; end=j; // 如果n是奇数，在最后一次大循环中就不会有这个小循环了 if(j &gt;= n)&#123; break; &#125; for (int k = 0; k &lt;= end; k++) &#123; matrix[k][j--]=counter++; &#125; &#125; return matrix;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-门面模式","slug":"设计模式-门面模式","date":"2022-02-28T00:38:22.000Z","updated":"2022-02-28T00:59:19.367Z","comments":true,"path":"设计模式/2022/02/28/设计模式-门面模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式定义：为子系统中的一组接口提供一个一致的高层接口，使得这一子系统更加容易使用 实现子系统1 12345public class System1 &#123; public void operateA()&#123; System.out.println(&quot;子系统1的A操作&quot;); &#125;&#125; 子系统2 12345public class System2 &#123; public void operateB()&#123; System.out.println(&quot;子系统2的B操作&quot;); &#125;&#125; 子系统3 12345public class System3 &#123; public void operateC()&#123; System.out.println(&quot;子系统3的C操作&quot;); &#125;&#125; 系统门面 1234567891011public class SystemFacade &#123; private System1 system1 = new System1(); private System2 system2 = new System2(); private System3 system3 = new System3(); public void operateABC()&#123; system1.operateA(); system2.operateB(); system3.operateC(); &#125;&#125; 客户端调用 12345public class Client &#123; public static void main(String[] args) &#123; new SystemFacade().operateABC(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【981-Medium】基于时间的键值存储","slug":"【981-Medium】基于时间的键值存储","date":"2022-02-27T04:15:00.000Z","updated":"2022-02-27T07:06:50.714Z","comments":true,"path":"算法/2022/02/27/【981-Medium】基于时间的键值存储/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/27/%E3%80%90981-Medium%E3%80%91%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/","excerpt":"","text":"基于时间的键值存储设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。 实现 TimeMap 类： TimeMap() 初始化数据结构对象 void set(String key, String value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 &#96;&#96;&#96;String get(String key, int timestamp) 1234567 - 返回先前调用 `set(key, value, timestamp_prev)` 所存储的值，其中 `timestamp_prev &lt;= timestamp` 。 - 如果有多个这样的值，则返回对应最大的 `timestamp_prev` 的那个值。 - 如果没有值，则返回空字符串（`&quot;&quot;`）。**示例：** 输入：[“TimeMap”, “set”, “get”, “get”, “set”, “get”, “get”][[], [“foo”, “bar”, 1], [“foo”, 1], [“foo”, 3], [“foo”, “bar2”, 4], [“foo”, 4], [“foo”, 5]]输出：[null, null, “bar”, “bar”, null, “bar2”, “bar2”] 解释：TimeMap timeMap &#x3D; new TimeMap();timeMap.set(“foo”, “bar”, 1); &#x2F;&#x2F; 存储键 “foo” 和值 “bar” ，时间戳 timestamp &#x3D; 1timeMap.get(“foo”, 1); &#x2F;&#x2F; 返回 “bar”timeMap.get(“foo”, 3); &#x2F;&#x2F; 返回 “bar”, 因为在时间戳 3 和时间戳 2 处没有对应 “foo” 的值，所以唯一的值位于时间戳 1 处（即 “bar”） 。timeMap.set(“foo”, “bar2”, 4); &#x2F;&#x2F; 存储键 “foo” 和值 “bar2” ，时间戳 timestamp &#x3D; 4timeMap.get(“foo”, 4); &#x2F;&#x2F; 返回 “bar2”timeMap.get(“foo”, 5); &#x2F;&#x2F; 返回 “bar2” 12345678```java/** * Your TimeMap object will be instantiated and called as such: * TimeMap obj = new TimeMap(); * obj.set(key,value,timestamp); * String param_2 = obj.get(key,timestamp); */ 提示： 1 &lt;= key.length, value.length &lt;= 100 key 和 value 由小写英文字母和数字组成 1 &lt;= timestamp &lt;= 107 set 操作中的时间戳 timestamp 都是严格递增的 最多调用 set 和 get 操作 2 * 105 次 Related Topics 设计 哈希表 字符串 二分查找 法一：内置结构Map&lt;Integer,TreeMap&lt;Integer,String&gt;&gt;这是自己写的，但是超时了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TimeMap &#123; private Map&lt;String, TreeMap&lt;Integer,String&gt;&gt; map ; public TimeMap() &#123; map = new HashMap(); &#125; public void set(String key, String value, int timestamp) &#123; TreeMap&lt;Integer, String&gt; sm = map.get(key); if(sm==null) &#123; TreeMap&lt;Integer, String&gt; v = new TreeMap&lt;&gt;(); v.put(timestamp, value); map.put(key, v); &#125;else &#123; sm.put(timestamp,value); &#125; &#125; public String get(String key, int timestamp) &#123; TreeMap&lt;Integer, String&gt; sm = map.get(key); if(sm==null)&#123; return null; &#125; int find = binarySearch(sm.keySet().toArray(new Integer[]&#123;&#125;), timestamp); if(find==-1)&#123; return &quot;&quot;; &#125;else &#123; return sm.get(find); &#125; &#125; private int binarySearch(Integer[] nums, int target) &#123; int left = 0; int right = nums.length-1; int mid; while (left&lt;=right) &#123; mid = (left+right)/2; if(nums[mid]==target)&#123; return target; &#125;else if(nums[mid]&gt;target)&#123; right = mid - 1; &#125;else &#123; left = mid + 1; &#125; &#125; if(left==0)&#123; return -1; &#125; return nums[left-1]; &#125;&#125; 这是我看到评论区写的 123456789101112131415161718192021222324class TimeMap &#123; /** Initialize your data structure here. */ HashMap&lt;String, TreeMap&lt;Integer, String&gt;&gt; map; public TimeMap() &#123; map = new HashMap(); &#125; public void set(String key, String value, int timestamp) &#123; map.computeIfAbsent(key, k-&gt; new TreeMap()).put(timestamp, value); &#125; public String get(String key, int timestamp) &#123; if(!map.containsKey(key)) &#123; return &quot;&quot;; &#125; // 这是在对应的TreeMap中找到以timeStamp为天花板的数字 Integer time = map.get(key).floorKey(timestamp); if(time == null) &#123; return &quot;&quot;; &#125; return map.get(key).get(time); &#125;&#125; computeIfAbsent这是java8中的操作，关于java8新特性，我后面会专门写一个专栏的","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指OfferII68-Easy】查找插入位置","slug":"【剑指OfferII68-Easy】查找插入位置","date":"2022-02-27T03:19:03.000Z","updated":"2022-02-27T04:13:26.935Z","comments":true,"path":"uncategorized/2022/02/27/【剑指OfferII68-Easy】查找插入位置/","link":"","permalink":"http://li-zhi.net.cn/uncategorized/2022/02/27/%E3%80%90%E5%89%91%E6%8C%87OfferII68-Easy%E3%80%91%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"查找插入位置给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 示例 4: 12输入: nums = [1,3,5,6], target = 0输出: 0 示例 5: 12输入: nums = [1], target = 0输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 注意：本题与主站 35 题相同： https://leetcode-cn.com/problems/search-insert-position/ Related Topics 数组 二分查找 法一：二分查找先设定左侧下标 left 和右侧下标 right，再计算中间下标 middle nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标 nums[mid] &lt; target 则 left右移 nums[mid] &gt; target 则 right 左移 查找结束如果没有相等值则返回left，该值为插入位置 123456789101112131415161718class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; int mid; while (left&lt;=right) &#123; mid = (left+right)/2; if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&gt;target)&#123; right = mid - 1; &#125;else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 拓展：以下这种递归查找只能找到目标值并返回索引，找不到则返回-1，并不能达到本题要求 12345678910111213141516public int binarySearch(int[] nums, int target) &#123; return binarySearch(nums,target,nums.length/2);&#125;public int binarySearch(int[] nums, int target,int binary)&#123; if(binary==0||binary==nums.length)&#123; return -1; &#125; if(nums[binary]==target)&#123; return binary; &#125; if(target&gt;nums[binary])&#123; return binarySearch(nums,target,(binary+nums.length)/2+1); &#125;else&#123; return binarySearch(nums,target,binary/2); &#125;&#125;","categories":[],"tags":[]},{"title":"【2016-Easy】增量元素之间的最大差值","slug":"【2016-Easy】增量元素之间的最大差值","date":"2022-02-27T03:04:08.000Z","updated":"2022-02-27T03:20:06.986Z","comments":true,"path":"算法/2022/02/27/【2016-Easy】增量元素之间的最大差值/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/27/%E3%80%902016-Easy%E3%80%91%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","excerpt":"","text":"增量元素之间的最大差值给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。 返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。 示例 1： 12345输入：nums = [7,1,5,4]输出：4解释：最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。 示例 2： 1234输入：nums = [9,4,3,2]输出：-1解释：不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。 示例 3： 1234输入：nums = [1,5,2,10]输出：9解释：最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。 提示： n == nums.length 2 &lt;= n &lt;= 1000 1 &lt;= nums[i] &lt;= 109 Related Topics 数组 法一：暴力枚举直接遍历，然后比较最值 12345678910111213class Solution &#123; public int maximumDifference(int[] nums) &#123; int max = -1; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if(nums[i]&lt;nums[j])&#123; max = Math.max(nums[j]-nums[i],max); &#125; &#125; &#125; return max; &#125;&#125; 法二：最小前缀法0 &lt;= i &lt; j &lt; n，所以j是从1开始走 将premin作为j之前的数组内最小的那个元素 如果nums[j]大于该数字，则将其减去并比较与max的大小关系 反之该数字替代premin的地位成为j之前的最小值 上代码： 1234567891011121314class Solution &#123; public int maximumDifference(int[] nums) &#123; int max=-1; int premin = nums[0]; for (int j = 1; j &lt; nums.length; j++) &#123; if(nums[j]&gt;premin)&#123; max=Math.max(nums[j]-premin,max); &#125;else &#123; premin = nums[j]; &#125; &#125; return max; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【206-Easy】反转链表","slug":"【206-Easy】反转链表","date":"2022-02-26T15:42:36.000Z","updated":"2022-02-27T01:03:10.601Z","comments":true,"path":"算法/2022/02/26/【206-Easy】反转链表/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/26/%E3%80%90206-Easy%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ Related Topics 递归 链表 法一：迭代使用三个节点分别存储当前节点（now），前置节点（prev），后置节点（suffix） 将now的next指向前置节点， 将prev指向now， 将now指向suffix， 然后suffix向后走一位。 这样一次循环就走完了。 12345678910111213141516171819202122class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode prev = null; ListNode now = head; if(head.next==null)&#123; return head; &#125; ListNode suffix = now.next; while(now.next!=null)&#123; now.next=prev; prev = now; now = suffix; suffix = suffix.next; &#125; now.next=prev; head = now; return head; &#125;&#125; 优化：将获取suffix的步骤放到了每次循环的最前面，根据now来拿到，而不是自己往后走。 1234567891011121314151617class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode prev = null; ListNode now = head; ListNode suffix; while(now!=null)&#123; suffix = now.next; now.next=prev; prev = now; now = suffix; &#125; return prev; &#125;&#125; 法二：递归使用递归的，有一个缺点，就是如果链表过于长，那么就会报异常StackOverFlowException 思路和之前是一模一样的，直接上代码。 12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; return reverse(null,head); &#125; public ListNode reverse(ListNode prev, ListNode curr)&#123; if(curr==null)&#123; return prev; &#125; ListNode suffix=curr.next; curr.next = prev; return reverse(curr,suffix); &#125;&#125; 或者不想在外面定义一个递归也可以这样写 1234567891011class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; &#125;&#125; 这种递归写的就比较烂了，看看就过去了 12345678910111213141516171819public ListNode reverseList3(ListNode head) &#123; ListNode temp= head; ListNode tail; while(temp.next!=null)&#123; temp = temp.next; &#125; tail = temp; reverse3(head); return tail;&#125;public ListNode reverse3(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode suffix = reverse3(head.next); suffix.next = head; head.next = null; return head;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【876-Easy】链表的中间节点","slug":"【876-Easy】链表的中间节点","date":"2022-02-26T15:41:52.000Z","updated":"2022-02-27T03:01:35.452Z","comments":true,"path":"算法/2022/02/26/【876-Easy】链表的中间节点/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/26/%E3%80%90876-Easy%E3%80%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","excerpt":"","text":"链表的中间节点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 Related Topics 链表 双指针 法一：hash映射遍历链表 将索引当做key ListNode当做value 最后返回索引为长度减1的那个节点 上代码： 123456789101112class Solution &#123; public ListNode middleNode(ListNode head) &#123; Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode curr=head; int i=0; while(curr!=null)&#123; map.put(i++,curr); curr = curr.next; &#125; return map.get(i/2); &#125;&#125; 法二：快慢指针法使用两个指针，slow，fast slow一次走一步 fast一次走两步 当fasf走到底的时候slow就在中间 节点数目为奇数 节点数目为偶数 上代码： 123456789public ListNode middleNode1(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指offerII26-Medium】重排链表","slug":"【剑指offerII26-Medium】重排链表","date":"2022-02-26T14:04:54.000Z","updated":"2022-02-27T13:41:48.326Z","comments":true,"path":"算法/2022/02/26/【剑指offerII26-Medium】重排链表/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/26/%E3%80%90%E5%89%91%E6%8C%87offerII26-Medium%E3%80%91%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","excerpt":"","text":"重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： 1L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 12输入: head = [1,2,3,4]输出: [1,4,2,3] 示例 2: 12输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 提示： 链表的长度范围为 [1, 5 * 104] 1 &lt;= node.val &lt;= 1000 注意：本题与主站 143 题相同：https://leetcode-cn.com/problems/reorder-list/ Related Topics 栈 递归 链表 双指针 1234567public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 法一：暴力分析：使用笨办法，可以先遍历链表将所有的节点都放入队列中，用len递增来得到链表的长度。 当长度为偶数时，我需要保留半数加一个节点。 当长度为奇数时，我需要保留半数加一个节点，将这个数字赋给len（这个可以自行推演一下） 然后出队len个元素，将最后一个出队的元素的next置空 这时候需要插入的节点就按顺序保存在队列中了 接着按队列出队顺序间隔插入到原链表中 对于实例二的流程图： 12345678910111213141516171819202122232425class Solution &#123; public void reorderList(ListNode head) &#123; LinkedList&lt;ListNode&gt; nodes = new LinkedList&lt;&gt;(); ListNode temp = head; int len = 0; while(temp!=null)&#123; nodes.add(temp); temp = temp.next; len++; &#125; len = len/2+1; for (int i = 0; i &lt; len; i++) &#123; temp = nodes.poll(); &#125; temp.next=null; temp = head; ListNode now; while(!nodes.isEmpty())&#123; now = nodes.pollLast(); now.next = temp.next; temp.next = now; temp = now.next; &#125; &#125;&#125; 使用栈也是可以的，代码如下： 12345678910111213141516171819202122class Solution &#123; public void reorderList(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); int len = 0; ListNode temp = head; while(temp!=null)&#123; len++; stack.push(temp); temp = temp.next; &#125; len = (int) (len/2.0-0.5); temp = head; ListNode now; for (int i = 0; i &lt; len; i++) &#123; now = stack.pop(); now.next = temp.next ; temp.next = now; temp = now.next; &#125; stack.pop().next = null; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-享元模式","slug":"设计模式-享元模式","date":"2022-02-26T05:05:48.000Z","updated":"2022-02-28T00:36:16.964Z","comments":true,"path":"设计模式/2022/02/26/设计模式-享元模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式定义：运用共享技术有效地支持大量细粒度的对象 优点：如果系统有大量类似的对象，可以节省大量的内存和CPU资源 实现场景：假如我要开发一款游戏，然后游戏里面的地图有很多树木 这个时候，我们不可能创建几万个树的对象 Tree 123456@Data@AllArgsConstructor@ToStringpublic class Tree &#123; private final String name;&#125; TreeNode 1234567@Data@AllArgsConstructorpublic class TreeNode &#123; private final Tree tree; private int x; private int y;&#125; TreeFactory 12345678910111213public class TreeFactory &#123; private static ConcurrentHashMap&lt;String, Tree&gt; map = new ConcurrentHashMap&lt;&gt;(); public static Tree getTree(String name)&#123; if(map.containsKey(name))&#123; return map.get(name); &#125; return null; &#125; public static void addTree(String name)&#123; map.put(name,new Tree(name)); &#125;&#125; 主函数 123456789public static void main(String[] args) &#123; TreeFactory.addTree(&quot;梧桐树&quot;); TreeFactory.addTree(&quot;香樟树&quot;); TreeFactory.addTree(&quot;银杏树&quot;); TreeFactory.addTree(&quot;面包树&quot;); TreeNode treeNode1 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,1); TreeNode treeNode2 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,2); TreeNode treeNode3 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,3);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【64-Medium】最小路径和","slug":"【64-Medium】最小路径和","date":"2022-02-25T15:03:19.000Z","updated":"2022-02-26T04:03:46.005Z","comments":true,"path":"算法/2022/02/25/【64-Medium】最小路径和/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/25/%E3%80%9064-Medium%E3%80%91%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"最小路径和给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 123输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 12输入：grid = [[1,2,3],[4,5,6]]输出：12 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 分析：一般来说，遇到这种统计可行路径的数量，或者求最小路径的时候，使用动态规划和搜索这两种方法，但是搜索更适用于数据规模较小的题目 法一：动态规划动态规划算法，我们主要关注以下两点。 状态的设置。在这个题目里，由于要求最小路径和，我们可以令 dp[ i ] [ j ] 代表从（i，j）点走到右下角点的最小路径和。 状态转移方程。我们考虑如何来求出 dp [ i] [j]。由于每次只能往右或者下走，所以从（i，j）只能走到（i+1，j）或者（i，j+1)。换言之，dp[ i ] [ j ] 的前继状态只有dp[ i+1 ] [ j ], dp[ i ] [ j+1 ], 所以我们在两者取最小，然后加上这个格子内的数即可 dp(i,j) &#x3D; grid(i,j) + min(dp(i + 1,j),dp(i,j + 1)) 是需要特殊处理的，当然还有终点元素也是要做个排除，下面先看流程图 就以案例一的矩阵为例子： 123输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。 正向思维从终点考虑问题，思考下一点在哪 只有最后一列是只能向下走 只有最后一行是只能向右走 终点不做处理 上代码： 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; int height = grid.length; int width = grid[0].length; for (int i = height - 1 ; i &gt;= 0; i--) &#123; for (int j = width - 1 ; j &gt;= 0; j--) &#123; if(i==height-1&amp;&amp;j!=width-1)&#123; grid[i][j]+=grid[i][j+1]; &#125;else if(i!=height-1&amp;&amp;j==width-1)&#123; grid[i][j]+=grid[i+1][j]; &#125;else if(i!=height-1&amp;&amp;j!=width-1)&#123; grid[i][j]+=Math.min(grid[i+1][j],grid[i][j+1]); &#125; &#125; &#125; return grid[0][0]; &#125;&#125; 逆向思维即我从起点出发，思考上一点在哪 只有第一行是可以向左 只有第一列是可以向上 第一个元素不做处理 上代码： 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; int rows = grid.length; int columns = grid[0].length; for (int i = 0; i &lt; rows ; i++) &#123; for (int j = 0; j &lt; columns ; j++) &#123; if(i==0&amp;&amp;j!=0)&#123; grid[i][j]+=grid[i][j-1]; &#125;else if(j==0&amp;&amp;i!=0)&#123; grid[i][j]+=grid[i-1][j]; &#125;else if(i!=0) &#123; grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); &#125; &#125; &#125; return grid[rows-1][columns-1]; &#125;&#125; 优化这是官方的优化说明： 12345我们可以用一个一维数组dp来代替二维数组，dp 数组的大小和grid的行大小相同。这是因为对于某个固定状态，只需要考虑下方和右方的节点。我们就可以一行一行计算，来节省空间复杂度。 这是我个人的解读（对于逆向思维） 123想要得到最后的结果，就需要从第一行开始计算，然后该行的数据为下一行的计算提供数据。这一行计算完成后，上一行就失去了作用，而且我们需要的就只是计算完成后的最后一行数据返回的也就是这最后一行的最后一个数据也就是dp[rows-1][colums-1] 这里就不画流程图了，直接上代码 12345678910111213141516class Solution &#123; public int minPathSum(int[][] grid) &#123; int rows = grid.length; int columns = grid[0].length; int[] dp = new int[columns]; Arrays.fill(dp,Integer.MAX_VALUE); dp[0]=0; for (int i = 0; i &lt; rows; i++) &#123; dp[0]=dp[0]+grid[i][0]; for (int j = 1; j &lt; columns; j++) &#123; dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j]; &#125; &#125; return dp[columns-1]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【537-Easy】复数乘法","slug":"【537-Easy】复数乘法","date":"2022-02-25T14:41:15.000Z","updated":"2022-02-25T15:06:52.718Z","comments":true,"path":"算法/2022/02/25/【537-Easy】复数乘法/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/25/%E3%80%90537-Easy%E3%80%91%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/","excerpt":"","text":"复数乘法复数 可以用字符串表示，遵循 &quot;**实部**+**虚部**i&quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 示例 1： 123输入：num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;输出：&quot;0+2i&quot;解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。 示例 2： 123输入：num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;输出：&quot;0+-2i&quot;解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 提示： num1 和 num2 都是有效的复数表示。 Related Topics 数学 字符串 模拟 法一：分解数字法分析：这题直接看这个提示↑有效的复数表示，就说明测试使用的字符串都是类似这样的，”21+-21i”,”12+1i”,”0+1i”,”12+0i” 所以这就很简单了 123456789public String complexNumberMultiply(String num1, String num2) &#123; String[] complex1 = num1.split(&quot;\\\\+&quot;); String[] complex2 = num2.split(&quot;\\\\+&quot;); int x1 = Integer.parseInt(complex1[0]); int y1 = Integer.parseInt(complex1[1].split(&quot;i&quot;)[0]); int x2 = Integer.parseInt(complex2[0]); int y2 = Integer.parseInt(complex2[1].split(&quot;i&quot;)[0]); return String.format(&quot;%d+%di&quot;,(x1*x2-y1*y2),(x1*y2+x2*y1));&#125; 进阶：题目给出的复数没有固定的规范未完待续","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis-缓存穿透和雪崩","slug":"Redis-缓存穿透和雪崩","date":"2022-02-25T13:37:11.000Z","updated":"2022-02-25T14:10:06.283Z","comments":true,"path":"Redis/2022/02/25/Redis-缓存穿透和雪崩/","link":"","permalink":"http://li-zhi.net.cn/Redis/2022/02/25/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"缓存穿透和雪崩缓存的时候，大大提高了应用程序的性能和效率，特别是数据查询方面。但同时，它带来好处的同时，也带来了问题。 缓存穿透和雪崩就是两个经典的问题，当然业界也已经有了比较流行的解决方案 缓存穿透（查不到）概念：缓存穿透的概念很简单，用户想要查询一个数据，发现Redis内存数据库中没有，也就是缓存没有命中，于是去持久层数据库查询。发现也没有，于是本次查询失败。当这种查询情况很多的时候，缓存都没有命中，都时去请求了持久层数据库。就是意味着该缓存无用，也就是缓存穿透。 解决方案： 布隆过滤器 布隆过滤器是一种数据结构，对所有能查询到的参数以hash的形式存储，在控制层先进行校验，不符合则该请求直接丢弃，从而解决问题 置空缓存 当存储层未命中的时候，及时返回的是null对象，缓存也将其存储起来同时设置一个过期时间，之后再从数据库中查询，保护了mysql 问题： 有可能会存放很多很多值为空的键值对，浪费文件 及时设置了过期时间，但是如果mysql在这个过期时间还没到的时候，已经有查询结果了，但是因为过期时间没到，却还是访问不了mysql，从而查询到数据 缓存击穿（查得太多了）概述：这里需要注意和缓存击穿的区别，缓存击穿，是指一个key在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。解决方案： 设置热点数据永不过期，从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 加互斥锁分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限 雪崩概念：指的是在某一时间段，缓存集中过期失效或者集中宕机 正常： 雪崩： 如果是自然key过期，倒是影响不大，但是如果是节点宕机或者断电，这就很有可能会将数据库冲垮 解决方案： redis集群 限流降级：在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程个数 数据预热：在正式部署前，先把可能的数据预先访问一遍，这样的话可能大量访问的数据就会加载到缓存中去，在即将发生高并发访问前，手动触发加载器缓存不同的key，设置不同的过期时间，让缓存过期时间点比较均匀","categories":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-主从复制","slug":"Redis-主从复制","date":"2022-02-25T03:40:53.000Z","updated":"2022-02-25T13:36:13.180Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-主从复制/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"主从复制主从复制，是指将一台Redis服务器中的数据，复制到其他的Redis服务器上。 前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower) 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。 且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 作用主从复制的作用主要包括： 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。4、高可用（集群）基石：主从复制还是哨兵模式和部署集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，最少三台（一主二从） ​ 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大​ 2、从容量上，不能将一台服务所有内存用作Redis存储内存，单台Redis最大使用内存不应该超过20G。 配置子节点我们这里使用docker来做 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 复制两份配置文件给从节点镜像使用[root@iZbp18qscowpmxk6xpk38iZ redis]# lsredis-01.conf redis-02.conf redis.conf# 需要修改这三份文件，将绑定本地的配置注释掉，关闭安全模式# 分别以后台方式启动两个从节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-01.conf:/etc/redis/redis.conf --name=salveRedis01 redisa593c51bc1100e892f5d18c34ba5a05f637d1b3a4a29e5840cfeb18a633355f5[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-02.conf:/etc/redis/redis.conf --name=salveRedis02 redis08833de79be2cf719402b4f4cf42bf06d0f0a84a22e188f2b2f4d03f54ca48c1# 查看映射端口，这里一定一定要注意！！服务器要开安全组！！！不然就是连接失败哎！！！[root@iZbp18qscowpmxk6xpk38iZ redis]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa593c51bc110 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49169-&gt;6379/tcp salveRedis0108833de79be2 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49170-&gt;6379/tcp salveRedis020e9919007f5d redis &quot;docker-entrypoint.s…&quot; 38 minutes ago Up 2 minutes 0.0.0.0:49168-&gt;6379/tcp masterRedis# 查看主节点的基本信息[root@iZbp18qscowpmxk6xpk38iZ ~]# docker exec -it masterRedis redis-cli127.0.0.1:6379&gt; info replication# Replicationrole:master # 当前节点的角色connected_slaves:0 # 当前节点的子节点master_failover_state:no-failovermaster_replid:f37ca91dd3b3578e83031f9ea087d64f9994dd9amaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# 进入子节点1号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis01 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot; #说明连接成功，如果没开安全组的话，这一行会是connecting下一行是-1，表示连接失败5) (integer) 42# 进入子节点2号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis02 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot;5) (integer) 112# 查看父节点的基本信息127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2 # 两个子节点slave0:ip=116.62.151.26,port=6379,state=online,offset=112,lag=0slave1:ip=116.62.151.26,port=6379,state=online,offset=112,lag=1master_failover_state:no-failovermaster_replid:92ee701d04326eb2c74d8de1ea0fc2ec010f97dfmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:112# 在父节点测试是否数据同步127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set k1 v1OK# 子节点1号查询127.0.0.1:6379&gt; get k1&quot;v1&quot;# 子节点2号查询127.0.0.1:6379&gt; get k1&quot;v1&quot; 也可以在配置文件中配置父节点 123456# 配置主节点的ip的端口slaveof 主机ip 端口# 如果主机使用了config set masterauth password，或者主机配置文件中 requirepass password# 则这里配置文件就要加上主机的密码来验证masterauth password 主机可以写入也可以读取，但是从节点是不可以写入的，只可以读取主节点写入的值 12127.0.0.1:6379&gt; set k2 v2(error) READONLY You can&#x27;t write against a read only replica. 主机宕机了之后，从机依旧可以读，但是这样的话，就不能往里面写入数据了。 （这里需要使用哨兵模式，即当主机宕机后，从机中会选举出来一个主机，这样的话就保留了写入操作） 当主机恢复运行，则恢复写入功能 从机宕机的话，对主机没有任何影响 当从机运行后，就恢复主机中的数据 复制原理Slave 启动成功连接到 master 后会发送一个sync命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 主从连接的形式 一对多 链状 哨兵（Sentinel）模式该模式就是为了解决当主机宕机后，从机群无法有写入权限的问题。 该模式下，它会自动监控主机是否故障，当主机宕机后，从机群中会自立一个主机，从而就有了写入的功能 哨兵模式是一种特殊的模式，它是一个独立的进程。 其原理就是哨兵通过发送命令，等待redis服务器响应，从而监控多个Redis实例的功能 这里的哨兵有两个作用 监控服务器的状态 当主机宕机后，会自动选择一个子节点作为主机，然后通过发布订阅模式通知其他子节点，修改配置文件 当然，如果哨兵挂了怎么办？所以需要配置多个哨兵，然后这几个哨兵再互相监视 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行重新选举的过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 配置文件1234567891011121314151617181920212223242526272829303132# 哨兵进程的端口port 26379# 是否以后台运行daemonize no# 绑定的线程pidfile /var/run/redis-sentinel.pid# 日志名称logfile &quot;&quot;# 日志保存目录dir /tmp# 配置监视谁# 2代表至少要有结果哨兵确认主机宕机sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 30000acllog-max-len 128sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yesSENTINEL resolve-hostnames noSENTINEL announce-hostnames no 启动哨兵进程 1[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -d -p 49103:26379 -v /home/redis/sentinel.conf:/etc/redis/sentinel.conf --name=sentinel redis redis-sentinel /etc/redis/sentinel.conf 优点： 主从可以自动切换，可用性会更好 缺点： redis不好在线扩容 实现哨兵模式的配置优点麻烦","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-02-25T03:19:07.000Z","updated":"2022-04-07T01:43:32.807Z","comments":true,"path":"琐碎的知识/2022/02/25/正则表达式/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式正则表达式是由普通字符（如英文字母）以及特殊字符（也称为元字符）组成的文字模式，该模式对文本查找时需要匹配的一个或多个字符串描述，给出一个匹配模板。它可以大大简化文本识别工作，现已超出了某种语言或某个系统的局限，成为被人们广为使用的工具。 正则表达式基础书写符号 符号 名称 示例 解释 匹配输入 \\ 转义符 \\* 符号“*” * [ ] 可接收的字符列表 [efgh] e、f、g、h中的任意1个字符 e、f、g、h [^] 不接收的字符列表 [^abc] 除a、b、c之外的任意1个字符，包括数字和特殊符号 m、q、5、* | 匹配“|”之前或之后的表达式 ab|cd ab或者cd ab、cd ( ) 将子表达式分组 (abc) 将字符串abc作为一组 abc - 连字符（只在[ ]中使用） A-Z 任意单个大写字母 大写字母 正则表达式限定符 符号 名称 示例 解释 匹配输入 不匹配输入 * 指定字符重复0次或n次相当于&#123;0,&#125; (abc)* 仅包含任意个abc的字符串 abc、abcabcabc a、abcabcabca + 指定字符重复1次或n次，相当于&#123;1,&#125; m+(abc)* 以至少1个m开头，后接任意个abc的字符串 m、mabc、mabcabc ma、abc ? 指定字符重复0次或1次 m+abc? 以至少1个m开头，后接ab或abc的字符串 mab、mabc、mmmab、mmabc ab、abc、mabcc {n} 只能输入n个字符 [abcd]{3} 由abcd中字母组成的任意长度为3的字符串 abc、dbc、adc a、aa、dcbd {n,} 指定至少 n 个匹配 [abcd]{3,} 由abcd中字母组成的任意长度不小于3的字符串 aab、dbc、aaabdc a、cd、bb {n,m} 指定至少 n 个但不多于 m 个匹配 [abcd]{3,5} 由abcd中字母组成的任意长度不小于3，不大于5的字符串 abc、abcd、aaaaa、bcdab ab、ababab、a ^ 指定起始字符，用于&#123;&#125;内 ^[0-9]+[a-z]* 以至少1个数字开头，后接任意个小写字母的字符串 123、6aa、555edf abc、aaa、a33 $ 指定结束字符，用于&#123;&#125;内 ^[0-9]-[a-z]+$ 以1个数字开头后接连字符“–”，并以至少1个小写字母结尾的字符串 2-a、3-ddd、5-efg 33a、8-、7-Ab 匹配字符集 符号 名称 示例 解释 匹配输入 不匹配输入 . 匹配除 \\n 以外的任何字符 a..b 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 aaab、aefb、a35b、a#*b ab、aaaa、a123447b \\d 匹配单个数字字符，相当于[0-9] \\d{3}(\\d)? 包含3个或4个数字的字符串 123、9876 123、9876 \\D 匹配单个非数字字符，相当于[^0-9] \\D(\\d)* 以单个非数字字符开头，后接任意个数字字符串 a、A342 aa、AA78、1234 \\w 匹配单个数字、大小写字母字符，相当于[0-9a-zA-Z] ^^^^^ 以3个数字字符开头的长度为7的数字字母字符串 234abcd、12345Pe 58a、Ra46 \\W 匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z] \\W+\\d{2} 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 #29、#?@10 23、#?@10 \\s 匹配空格字符，比如tab \\s[0-9]\\s 匹配所有的空白 空格12空格 asdfa \\b 匹配每一个字母的前后 \\b 匹配所有字母的前后 正则-PatternJAVA中的正则java.util.regex 是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包，它包括两个类：Pattern 和 Matcher 。 Pattern： 一个 Pattern 是一个正则表达式经编译后的表现模式。 Matcher：一个 Matcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 首先一个 Pattern 实例订制了一个所用语法与 PERL 类似的正则表达式经编译后的模式，然后一个 Matcher 实例在这个给定的 Pattern 实例的模式控制下进行字符串的匹配工作。 以下我们就分别来看看这两个类： 1.1、PatternPattern 的方法如下表： 方法名称 解释 static Pattern compile(String regex) 将给定的正则表达式编译并赋予给 Pattern 类 static Pattern compile(String regex, int flags) 对指定字符串的截取，参数配置如下 int flags() 返回当前 Pattern 的匹配 flag 参数 Matcher matcher(CharSequence input) 生成一个给定命名的 Matcher 对象 static boolean matches(String regex, CharSequence input) 编译给定的正则表达式并对输入的字串以该正则表达式为模开展匹配 String pattern() 返回该Patter对象所编译的正则表达式 对于 static Pattern compile(String regex, int flags) 方法中的参数 flags 取值如下： Pattern.CASE_INSENSITIVE：默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。让表达式忽略大小写进行匹配。 Pattern.COMMENTS：此种模式下，匹配时会忽略表达式中空格字符(表达式里的空格，tab，回车)。 Pattern.UNIX_LINES：此种模式下，只有 \\n才被认作一行的中止，并且与 .，^，以及 $ 进行匹配。 Pattern.MULTILINE：此种模式下，上箭头和单引号分别匹配一行的开始和结束。 Pattern.DOTALL：此种模式下，表达式 . 可以匹配任意字符，包括表示一行的结束符。 一个正则表达式，也就是一串有特定意义的字符，必须首先要编译成为一个 Pattern 类的实例，这个 Pattern 对象将会使用 matcher() 方法来生成一个 Matcher 实例，接着便可以使用该 Matcher 实例以编译的正则表达式为基础对目标字符串进行匹配工作，多个 Matcher 是可以共用一个 Pattern 对象的。 现在我们先来看一个简单的例子，再通过分析它来了解怎样生成一个 Pattern 对象并且编译一个正则表达式，最后根据这个正则表达式将目标字符串进行分割： 123456789101112// 生成一个 Pattern，同时编译一个正则表达式Pattern p = Pattern.compile(&quot;[/]+&quot;);//用 Pattern 的 split() 方法把字符串按 &quot;/&quot; 分割String[] result = p.split( &quot;Kevin has seen《LEON》seveal times,because it is a good film.&quot; +&quot;/ 凯文已经看过《这个杀手不太冷》几次了，因为它是一部&quot; +&quot;好电影。/名词:凯文。&quot;);for (int i = 0; i &lt; result.length; i++)&#123; System.out.println(result[i]);&#125; 上述代码的运行结果为： Kevin has seen《LEON》seveal times,because it is a good film.凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。名词:凯文。 正则 - Matcher 1、MatcherMatcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 我们来学习一下 Matcher 常用的方法： 索引方法：索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配。 名称 简介 public int start() 返回以前匹配的初始索引 public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引 public int end() 返回最后匹配字符之后的偏移量 public int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量 查找方法：查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式。 名称 简介 public boolean lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配 public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列 public boolean find(int start） 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列 public boolean matches() 尝试将整个区域与模式匹配 例：下面是一个对单词 cat 出现在输入字符串中出现次数进行计数的例子： 123456789101112String regex = &quot;dog&quot;;String input = &quot;dog dog dogtie&quot;;Pattern p = Pattern.compile(regex);Matcher m = p.matcher(input); // 获取 matcher 对象int count = 0;while (m.find()) &#123; count++; System.out.println(&quot;Match number &quot; + count); System.out.println(&quot;start(): &quot; + m.start()); System.out.println(&quot;end(): &quot; + m.end());&#125; 上述代码的执行结果为： Match number 1 &#x2F;&#x2F; 第一次出现 （下标 0-2）start(): 0 &#x2F;&#x2F; 开始下标 0end(): 3 &#x2F;&#x2F; 结束下标 3Match number 2 &#x2F;&#x2F; 第二次出现（下标 4-6）start(): 4 &#x2F;&#x2F; 开始下标 4end(): 7 &#x2F;&#x2F; 结束下标 7Match number 3 &#x2F;&#x2F; 第三次出现（下标 8-10）start(): 8 &#x2F;&#x2F; 开始下标 8end(): 11 &#x2F;&#x2F; 结束下标 11 matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而 lookingAt 不要求。 lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。 这两个方法经常在输入字符串的开始使用。 我们通过下面这个例子，来解释这个功能： 1234567891011String regex = &quot;foo&quot;;String input = &quot;fooooooooooooooooo&quot;;String input2 = &quot;ooooofoooooooooooo&quot;;Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(input);Matcher matcher2 = pattern.matcher(input2);System.out.println(&quot;lookingAt(): &quot; + matcher.lookingAt());System.out.println(&quot;matches(): &quot; + matcher.matches());System.out.println(&quot;lookingAt(): &quot; + matcher2.lookingAt()); 上述代码的执行结果为： lookingAt(): truematches(): falselookingAt(): false 替换方法：替换方法是替换输入字符串里文本的方法。 名称 简介 public Matcher appendReplacement(StringBuffer sb, String replacement) 实现非终端添加和替换步骤。 public StringBuffer appendTail(StringBuffer sb) 实现终端添加和替换步骤。 public String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。 public String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。 public static String quoteReplacement(String s) 返回指定字符串的字面替换字符串。 replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。 下面的例子来解释这个功能： 123456789101112131415String regex = &quot;dog&quot;;String input1 = &quot;The dog says meow. All dogs say meow.&quot;;String input2 = &quot;The dog says meow. All dogs say meow.&quot;;String replace = &quot;cat&quot;;Pattern p = Pattern.compile(regex);// get a matcher objectMatcher m1 = p.matcher(input1);Matcher m2 = p.matcher(input2);input1 = m1.replaceAll(replace);input2 = m2.replaceFirst(replace);System.out.println(input1);System.out.println(input2); 上述代码的执行结果为： The cat says meow. All cats say meow.The cat says meow. All dogs say meow. 从上面的结果，我们可以发现，replaceFirst 方法只将第一个 dog 替换成了 cat。而 replaceAll 方法却将两个 dog 都替换成了 cat。 下面看一些案例： 回溯 123456789101112131415161718# 实例一# pattern:前后标签名一致&lt;(\\w+)&gt;(.+)&lt;\\/\\1&gt;# 匹配：&lt;font&gt;asdasdas&lt;/font&gt;&lt;head&gt;as&lt;/head&gt;# 不匹配：&lt;font&gt;sad&lt;/asd&gt;===============================# 实例二 # pattern:(\\w)(\\w)\\1\\2# 匹配：abbadffd# 不匹配asasd=============================== 正向先行断言、反向先行断言、正向后行断言、反向后行断言 1234567891011121314151617181920212223242526272829303132# 括号内的不会被提取出来===============================# 正向先行断言，从左往右看，有才继续匹配后面的# pattern：至少有一个大小和一个小写字母(?=.*?[a-z])(?=.*?[A-Z]).+# 匹配asdojCsdsvdZjsdzsaJN12# 不匹配assafasf123r32# 密码强度验证# 1.至少有一个数字# 2.至少有一个小写字母# 3.至少有一个大写字母# 4.至少有8个字符# pattern：(?=.*?[a-zA-z0-9])\\w&#123;8,&#125;================================# 反向先行断言，从左往右看，没有才继续匹配后面的# pattern：匹配不是qq.com结尾的邮箱(\\d&#123;6,10&#125;)@(?!qq\\.com)# 匹配233325425@163.com# 不匹配233325425@qq.com# pattern：匹配不是&lt;font&gt;&lt;/font&gt;包裹的标签&lt;(?!font)&gt;(\\w+)&lt;/(\\1)&gt;============================# 后行断言是从右向左来看的# 正向后行断言(?&lt;=)# 反向后行断言(?&lt;!) 或者 12345678# 提取图片格式是jpg或者png的图片名字# pattern.+(png|jpg)# 匹配asdfsa.jpgasfsabiu.png# 不匹配asfsas.webp 分组 12345678910111213141516171819# 使用分组功能但是不捕获数据# pattern：China:开头的才获取城市数据(?:China:)(.+)# 匹配China:SuzhouChina:BeiJing# 不匹配America:Los Angeles==================================# 分组实用技巧#pattern：对于不同格式的数据获取年月日(\\d&#123;4&#125;)[-\\\\\\.\\/\\s]?(\\d&#123;2&#125;)[-\\\\\\.\\/\\s]?(\\d&#123;2&#125;)# 匹配201909082019-09-082019 09 082019/09/082019\\09\\082019.09.08","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Redis-发布订阅","slug":"Redis-发布订阅","date":"2022-02-25T03:02:40.000Z","updated":"2022-02-25T03:40:30.989Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-发布订阅/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis发布订阅Redis发布订阅是一种消息通信的模式：发布者发送消息，订阅者接收消息 三个角色：消息发布者、消息接收者、订阅的频道 命令 作用 publish channel message 发布消息到指定频道 psubscribe pattern [pattern..] 订阅一个或者多个符合给点pattern的频道 pubsub subcommand [argument [argument..]] 查看订阅和发布系统状态 punsubscribe [pattern [pattern..]] 退订所有符合模式的频道 subscribe channel [channel..] 订阅指定频道 unsubscribe channel [channel..] 退订指定频道 下面直接上案例： 充当订阅者的cli 12345127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 1 充当发布者的cli 12127.0.0.1:6379&gt; PUBLISH study study(integer) 1 订阅者 12345678127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 11) &quot;message&quot;2) &quot;study&quot;3) &quot;designpattern&quot; 原理： Redis订阅发布底层是使用C实现的 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"设计模式-原型模式","slug":"设计模式-原型模式","date":"2022-02-25T01:26:59.000Z","updated":"2022-02-25T02:59:21.994Z","comments":true,"path":"设计模式/2022/02/25/设计模式-原型模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式该设计模式主要用于对象的复制 此设计模式有多种实现： jdk内置cloneable接口 自定义接口 jdk内置cloneable接口我们都知道object中有一个protected方法，叫clone，可以看到这是一个native方法（即该方法是由C++编写的，具体实现是根据操作系统而定） 12@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 我们来自己重写一个这个方法试一试 1234567891011121314151617181920212223242526272829303132333435363738394041public class Video &#123; private String name; private Date gmtCreated; public Video(String name, Date gmtCreated) &#123; this.name = name; this.gmtCreated = gmtCreated; &#125; public Video() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getGmtCreated() &#123; return gmtCreated; &#125; public void setGmtCreated(Date gmtCreated) &#123; this.gmtCreated = gmtCreated; &#125; @Override protected Video clone() throws CloneNotSupportedException &#123; return (Video)super.clone(); &#125; @Override public String toString() &#123; return &quot;Video&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gmtCreated=&quot; + gmtCreated + &#x27;&#125;&#x27;; &#125;&#125; 主程序 1234567891011121314public static void main(String[] args) throws CloneNotSupportedException &#123; Video video = new Video(); video.setName(&quot;视频一号&quot;); video.setGmtCreated(new Date()); System.out.println(video); System.out.println(video.hashCode()); System.out.println(video.getGmtCreated().hashCode()); System.out.println(&quot;=============克隆后================&quot;); Video clone = (Video) video.clone(); System.out.println(clone); System.out.println(clone.hashCode()); System.out.println(clone.getGmtCreated().hashCode()); System.out.println();&#125; 控制台输出 12345678Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:31:04 CST 2022&#125;269468037784235907=============克隆后================Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.lizhi.demo1.Video at java.base/java.lang.Object.clone(Native Method) at com.lizhi.demo1.Video.clone(Video.java:35) at com.lizhi.demo1.CloneApplication.main(CloneApplication.java:13) 可以发现，报错了，这是怎么回事，我不是已经重写了方法吗？ 其实原因就是该类没有一个标记接口Cloneable 123456789101112131415161718192021222324252627/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object&#x27;s clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &#123;@code Object.clone&#125; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;@code clone&#125; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since 1.0 */public interface Cloneable &#123;&#125; 将video实现该接口后，启动程序，控制台输出 1234567Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;269468037784153335=============克隆后================Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;1681595665784153335 我们可以惊奇的发现， 两者的内容打印出来一模一样，两者的对象主体的hashcode是不同的，说明video和clone是货真价实的两个对象。 但是我们也发现他们的gmtCreated变量的hashcode是一样的，这说明两者指向的是同一个gmtCreated，有时候我们会有这样的需求，有时候我们不需要将复制后的对象内部指向的对象还是原来的那个对象，这时候我们就要修改clone方法 1234567@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); Video v = (Video) obj; v.setGmtCreated((Date) v.getGmtCreated().clone()); return obj;&#125; 自定义接口123public interface Copyable &#123; Object copy();&#125; 具体实现就不写啦，本质是一样的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2022-02-25T01:26:35.000Z","updated":"2022-02-25T02:22:49.386Z","comments":true,"path":"设计模式/2022/02/25/设计模式-建造者模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式该设计模式解决的问题是在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。 该模式有两种实现方向： 有一个制造者有自己的一套制造方案来制造该对象 自己指定制造计划 制造者制造场景：造汽车 汽车类 12345678910111213141516@Data@NoArgsConstructor@ToString@AllArgsConstructorpublic class Car &#123; private CarBody carBody; private Engine engine; private Lamp lamp; private Window window; public boolean isWhole()&#123; if(carBody!=null&amp;&amp;engine!=null&amp;&amp;lamp!=null&amp;&amp;window!=null)&#123; return true; &#125; return false; &#125;&#125; 组件接口 12public interface Component &#123;&#125; 车身 123public interface CarBody extends Component &#123; void printName();&#125; 引擎 123public interface Engine extends Component &#123; void printName();&#125; 车窗 123public interface Window extends Component &#123; void printName();&#125; 好的车身 123456public class GoodCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;好的车身&quot;); &#125;&#125; 不好的车身 123456public class BadCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;差的车身&quot;); &#125;&#125; 好的引擎 123456public class GoodEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;好的发动机&quot;); &#125;&#125; 不好的引擎 123456public class BadEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;差的发动机&quot;); &#125;&#125; 好的车窗 123456public class GoodWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;好的车窗&quot;); &#125;&#125; 不好的车窗 123456public class BadWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;差的车窗&quot;); &#125;&#125; 车的建造者 1234567public interface CarBuilder &#123; void addCarBody(CarBody carBody); void addWindow(Window window); void addLamp(Lamp lamp); void addEngine(Engine engine); Car getCar();&#125; 具体的建造者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public void addCarBody(CarBody carBody) &#123; if(carBody==null)&#123; car.setCarBody(new GoodCarBody()); return; &#125; car.setCarBody(carBody); &#125; @Override public void addWindow(Window window) &#123; if(window==null)&#123; car.setWindow(new GoodWindow()); return; &#125; car.setWindow(window); &#125; @Override public void addLamp(Lamp lamp) &#123; if(lamp==null)&#123; car.setLamp(new GoodLamp()); return; &#125; car.setLamp(lamp); &#125; @Override public void addEngine(Engine engine) &#123; if(engine==null)&#123; car.setEngine(new GoodEngine()); return; &#125; car.setEngine(engine); &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 指导者 123456789public class Director &#123; public static Car getCar(CarBuilder carBuilder)&#123; carBuilder.addWindow(null); carBuilder.addCarBody(null); carBuilder.addLamp(new BadLamp()); carBuilder.addEngine(null); return carBuilder.getCar(); &#125;&#125; 自定义建造我们发现，有车由四部分组成，这四部分可以是同一个工厂造出来的，所以我们可以结合一个抽象工厂模式，将产品制造交给工厂。 组件工厂接口 123456public interface ComponentFactory &#123; CarBody getCarBody(); Engine getEngine(); Window getWindow(); Lamp getLamp();&#125; 不好的组件工厂 123456789101112131415161718192021public class BadFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new BadCarBody(); &#125; @Override public Engine getEngine() &#123; return new BadEngine(); &#125; @Override public Window getWindow() &#123; return new BadWindow(); &#125; @Override public Lamp getLamp() &#123; return new BadLamp(); &#125;&#125; 好的组件工厂 12345678910111213141516171819202122public class GoodFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new GoodCarBody(); &#125; @Override public Engine getEngine() &#123; return new GoodEngine(); &#125; @Override public Window getWindow() &#123; return new GoodWindow(); &#125; @Override public Lamp getLamp() &#123; return new GoodLamp(); &#125;&#125; 改造CarBuilder 1234567public interface CarBuilder &#123; CarBuilder addCarBody(CarBody carBody); CarBuilder addWindow(Window window); CarBuilder addLamp(Lamp lamp); CarBuilder addEngine(Engine engine); Car getCar();&#125; 具体制造商 12345678910111213141516171819202122232425262728293031323334353637public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public CarBuilder addCarBody(CarBody carBody) &#123; car.setCarBody(carBody); return this; &#125; @Override public CarBuilder addWindow(Window window) &#123; car.setWindow(window); return this; &#125; @Override public CarBuilder addLamp(Lamp lamp) &#123; car.setLamp(lamp); return this; &#125; @Override public CarBuilder addEngine(Engine engine) &#123; car.setEngine(engine); return this; &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 客户端自定义制造 123456789101112131415public class Customer &#123; public static void main(String[] args) &#123; DaZhongCarBulder daZhongCarBulder = new DaZhongCarBulder(); ComponentFactory goodFactory = new GoodFactory(); ComponentFactory badFactory = new BadFactory(); // 这就是链式编程 Car car = daZhongCarBulder .addCarBody(goodFactory.getCarBody()) .addEngine(badFactory.getEngine()) .addLamp(goodFactory.getLamp()) .addWindow(goodFactory.getWindow()) .getCar(); System.out.println(car); &#125;&#125; 加深理解再来个案例：kfc点餐 首先食物接口 12public interface Food &#123;&#125; 饮料接口 123public interface Drink extends Food&#123; void drink();&#125; 薯条接口 123public interface Chip extends Food&#123; void eatChip();&#125; 炸鸡接口 123public interface Chicken extends Food&#123; void eatChicken();&#125; 奥尔良炸鸡 123456public class OrleansFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;奥尔良炸鸡&quot;); &#125;&#125; 孜然炸鸡 123456public class CuminFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;孜然炸鸡&quot;); &#125;&#125; 可乐 123456public class Cola implements Drink&#123; @Override public void drink() &#123; System.out.println(&quot;可口可乐&quot;); &#125;&#125; 大薯条 1234567public class BigChip implements Chip&#123; @Override public void eatChip() &#123; System.out.println(&quot;大份薯条&quot;); &#125;&#125; 百事可乐 123456public class BaiShi implements Drink &#123; @Override public void drink() &#123; System.out.println(&quot;百事可乐&quot;); &#125;&#125; 订单 1234567891011@Data@ToStringpublic class Order &#123; private List&lt;Food&gt; foods; public Order()&#123; foods = new ArrayList&lt;&gt;(); &#125; public void addFood(Food food)&#123; foods.add(food); &#125;&#125; 点单小程序 12345678910111213141516171819public class OrderApplication implements Builder&#123; private Order order; public OrderApplication()&#123; order = new Order(); &#125; @Override public Builder addFood(Food food) &#123; order.addFood(food); return this; &#125; @Override public Order getOrder() &#123; if(order.getFoods().size()==0)&#123; throw new IllegalArgumentException(&quot;您未点单！&quot;); &#125; return order; &#125;&#125; 客户端 123456789public static void main(String[] args) &#123; OrderApplication orderApplication = new OrderApplication(); Order order = orderApplication .addFood(new BigChip()) .addFood(new OrleansFriedChicken()) .addFood(new Cola()) .getOrder(); System.out.println(order);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-概述","slug":"设计模式-概述","date":"2022-02-24T14:36:38.000Z","updated":"2022-02-25T01:43:48.960Z","comments":true,"path":"设计模式/2022/02/24/设计模式-概述/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"什么是设计模式？Design Pattern是前辈们对代码开发经验的总结与归纳，是解决特定问题的一系列解决方案。 1995年，由GoF（Gang of Four）四人帮合作出版了《设计模式：可复用面向对象软件的基础》一书，一共收录了23种设计模式，人称Gof23设计模式 创建型模式： 单例模式 简单工厂模式 抽象工厂模式 建造者模式 原型模式 结构型模式 适配器模式 桥接模式 装饰器模式 组合模式 门面模式 享元模式 代理模式 行为型模式 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【350-Easy】两个数组的交集","slug":"【350-Easy】两个数组的交集","date":"2022-02-24T13:17:21.000Z","updated":"2022-02-25T15:06:26.487Z","comments":true,"path":"算法/2022/02/24/【350-Easy】两个数组的交集/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/24/%E3%80%90350-Easy%E3%80%91%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"","text":"两个数组的交集给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 Related Topics 数组 哈希表 双指针 二分查找 排序 ***进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 法一：暴力先将其中一个数组放到map中key存储值，value先存为0。遍历另一个数组，从map中拿值，如果有，则说明这是相交的元素，将value自增1，然后遍历map，如果value为1，说明该元素在两数组中都存在，并且只存在一次，直接将其放入list中。如果大于等于2，则说明第两个数组中相同的该元素大于了2不能确定最小出现的次数，所以只能分别遍历两个数组找最小出现次数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums1) &#123; map.put(num, 0); &#125; for (int v : nums2) &#123; if(map.get(v)!=null)&#123; map.put(v,map.get(v)+1); &#125; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (Integer v : map.keySet()) &#123; if(map.get(v)==1)&#123; list.add(v); continue; &#125; for (int i = 0; i &lt; Math.min(showTimes(nums1,v),showTimes(nums2,v)); i++) &#123; list.add(v); &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result; &#125; public int showTimes(int[] nums,int value)&#123; int time=0; for (int num : nums) &#123; if(num==value)&#123; time++; &#125; &#125; return time; &#125;&#125; 优化： 一开始的map就用来存储最小的那一个数组的k（数组元素）-v（出现次数） 遍历另一个数组，从map中取值，如果该值不为空且大于0则将其放入list，并自减1 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; //key存储值，value存出现次数 if(nums1.length&gt; nums2.length)&#123; int[] temp = nums1; nums1=nums2; nums2=temp; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums1) &#123; map.merge(num, 1, Integer::sum); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Integer temp; for (int t : nums2) &#123; temp = map.get(t); if(temp!=null&amp;&amp;temp&gt;0)&#123; list.add(t); map.put(t,temp-1); &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result; &#125;&#125; 同一思路的官方代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; if (nums1.length &gt; nums2.length) &#123; // 保证我是给最短的数组进行哈希映射 return intersect(nums2, nums1); &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); // 将nums数组放入map中key为元素，value为出现次数 for (int num : nums1) &#123; int count = map.getOrDefault(num, 0) + 1; map.put(num, count); &#125; // new一个最大的数组用来存放值 int[] intersection = new int[nums1.length]; // 充当索引，也是最后该返回的数组长度 int index = 0; // 遍历nums2 for (int num : nums2) &#123; // 在map中拿值 int count = map.getOrDefault(num, 0); // 如果大于0，说明该元素是重合的 // 个人觉得这里的移除元素没有必要 // 这一段可以改为 /** if(count&gt;0)&#123; intersection[index++] = num; map.put(num,--count); &#125; **/ if (count &gt; 0) &#123; // 将该元素放入intersection中 intersection[index++] = num; // 出现次数减一 count--; // 如果出现次数还是大于0的，则更新，如果已经等于0了，则移除该元素 if (count &gt; 0) &#123; map.put(num, count); &#125; else &#123; map.remove(num); &#125; &#125; &#125; return Arrays.copyOfRange(intersection, 0, index); &#125;&#125; 进阶：如果是已经排序好的。 i作为短数组nums1的索引，j作为长数组nums2的索引 挑选一个长度小的遍历，遇到一样的则放入list，如果不一样，则比大小，如果nums[j]比nums[i]大，则i往后走，然则j往后走 123456789101112131415161718192021222324252627public int[] intersect2(int[] nums1, int[] nums2) &#123; if(nums1.length&gt; nums2.length)&#123; int[] temp = nums1; nums1=nums2; nums2=temp; &#125; Arrays.sort(nums1); Arrays.sort(nums2); int j=0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums1.length; ) &#123; if(nums1[i]==nums2[j])&#123; list.add(nums1[i]); i++; j++; &#125;else if(nums1[i]&gt;nums2[j])&#123; j++; &#125;else &#123; i++; &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指Offer21-Easy】奇前偶后","slug":"【剑指Offer21-Easy】奇前偶后","date":"2022-02-24T12:05:31.000Z","updated":"2022-02-25T15:08:30.008Z","comments":true,"path":"算法/2022/02/24/【剑指Offer21-Easy】奇前偶后/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/24/%E3%80%90%E5%89%91%E6%8C%87Offer21-Easy%E3%80%91%E5%A5%87%E5%89%8D%E5%81%B6%E5%90%8E/","excerpt":"","text":"奇前偶后输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 0 &lt;= nums.length &lt;= 50000 0 &lt;= nums[i] &lt;= 10000 Related Topics 数组 双指针 排序 法一：分析：先new一个相同长度的数组result，接着用odd&#x3D;0标记从头开始，用even&#x3D;nums.length-1标记从尾开始，然后遍历nums，将数字放入result中 12345678910111213141516class Solution &#123; public int[] exchange(int[] nums) &#123; int len = nums.length; int[] result = new int[len]; int odd=0; int even= len -1; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]%2==0)&#123; result[even--]=nums[i]; &#125;else &#123; result[odd++]=nums[i]; &#125; &#125; return result; &#125;&#125; 进阶在原有题目基础上加一个条件：奇数和偶数部分必须是排好序的。 其实只要我们在每次插入数据之后，循环判断是否需要交换 1234567891011121314151617181920212223242526272829public int[] sortExchange(int[] nums) &#123; int len = nums.length; int[] result = new int[len]; int odd=0; int even= len -1; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]%2==0)&#123; result[even--]=nums[i]; for (int j = even+1; j &lt; len-1; j++) &#123; if(result[j]&gt;result[j+1])&#123; swap(result,j,j+1); &#125; &#125; &#125;else &#123; result[odd++]=nums[i]; for (int j = odd - 1; j &gt; 0 ; j--) &#123; if(result[j]&lt;result[j-1])&#123; swap(result,j,j-1); &#125; &#125; &#125; &#125; return result;&#125;public void swap(int[] arr,int i,int j)&#123; int temp=arr[j]; arr[j]=arr[i]; arr[i]=temp;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【4-Hard】寻找两个正序数组的中位数","slug":"【4-Hard】寻找两个正序数组的中位数","date":"2022-02-24T11:07:44.000Z","updated":"2022-02-25T15:06:01.419Z","comments":true,"path":"算法/2022/02/24/【4-Hard】寻找两个正序数组的中位数/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/24/%E3%80%904-Hard%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"寻找两个正序数组的中位数给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 Related Topics 数组 二分查找 分治 法一：合并取中间值我使用一个list集合存放两个数组的值后排序，判断集合长度是否为偶数，返回对应的结果 123456789101112131415161718class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int k : nums1) &#123; list.add(k); &#125; for (int j : nums2) &#123; list.add(j); &#125; Collections.sort(list); int size = list.size(); if(size%2==0)&#123; return (list.get(size/2)+list.get(size/2-1))/2.0; &#125;else &#123; return list.get(size/2); &#125; &#125;&#125; 显然，这肯定不是题目真正想让我们写的，不然可就愧对这hard级的难度了 更高阶的解答请去力扣官网查看","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-OOP七大原则","slug":"设计模式-OOP七大原则","date":"2022-02-24T10:18:58.000Z","updated":"2022-02-28T07:37:10.536Z","comments":true,"path":"设计模式/2022/02/24/设计模式-OOP七大原则/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"OOP七大原则开闭原则(Open-Closed Principle ，OCP)定义：对拓展开放，对修改关闭 问题的由来：在软件的生命周期的，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧的代码引入错误。 解决办法：当软件需要发生变化的时候，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 为什么要遵循开闭原则 1、只要是面向对象的编程，在开发过程中都会强调开闭原则 2、是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态 3、可以提高代码的复用性 4、可以提高代码的可维护性 单一职责原则（Single Responsibility Principle,SRP）定义：如果一个类具有多个职责，应当将对象解耦，提高内聚，分别创建一些类去一 一完成这些职责， 核心：高内聚、低耦合。 优点： 1、降低类的功能复杂度 2、提高系统的可维护性 3、变更风险低 里氏替换原则（Liskov Substitution Principle ，LSP）定义： 子类对象能够替代程序中父类对象出现的任何地方，并且保证原来的程序的逻辑行为不变及正确性不被破坏 里氏替换至少包含一下两个含义： 1、如果继承是为了实现代码重用，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。 ​ 2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化的，也就不存在子类替换父类实例的现象。 优点：可以大大减少程序的bug以及增强代码的可读性。 依赖倒置原则（Dependency Inversion Principle ，DIP）定义：面向接口编程 本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。 接口隔离原则(Interface Segregation Principle, ISP)定义：要用各个类建立他们需要的专用接口 它包含了2层意思： 接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户使用不到的方法塞进同一个接口里。如果一个接口的有方法没有被用户使用到，则说明该接口已经臃肿了，应该将其分割成几个功能专一的接口。 接口的依赖（继承）原则：如果一个接口a继承另一个接口b，则接口a相当于继承了接口b的方法，那么接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。 迪米特法则（Law of Demeter ，LOD）定义：只与直接朋友交谈，不与陌生人通信 直接朋友的定义： 1）当前对象本身（this） 2）以参量形式传入到当前对象方法中的对象 3）当前对象的实例变量 4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 5）当前对象所创建的对象 合成复用原则（Composite&#x2F;Aggregate Reuse Principle ，CARP）定义：尽量先使用组合或者内聚等关联关系来实现，其次才考虑使用继承来实现，因为java是单继承","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis-配置文件","slug":"Redis-配置文件","date":"2022-02-24T07:13:55.000Z","updated":"2022-02-24T10:00:29.148Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-配置文件/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"配置文件redis.conf基础配置下面为常用的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# 说明单位和不区分大小写# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.################################## INCLUDES #################################### 可以配置多个conf文件组合起来# Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf################################## NETWORK ###################################### 网络模块bind 127.0.0.1# 开启保护模式protected-mode yes# 连接的服务器端口port 6379tcp-backlog 511# 超时时间timeout 0tcp-keepalive 300################################# GENERAL ###################################### When Redis is supervised by upstart or systemd, this parameter has no impact.# 默认为 daemonize no# 需要手动改为yes，我们需要后台启动daemonize yes# 如果以后台方式运行，就需要指定一个pid文件pidfile /var/run/redis_6379.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)生产环境# warning (only very important / critical messages are logged)# 日志级别loglevel notice# 生成的日志文件名logfile &quot;&quot;# 默认有16个数据库databases 16# 是否显示logoalways-show-logo yesset-proc-title yesproc-title-template &quot;&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;&quot;################################## SECURITY #################################### 可以设置Redis的密码# auth# config set requirepass root# 设置密码使用命令requirepass root################################### CLIENTS ##################################### 客户端的一些限# 最大客户端连接数maxclients 10000############################## MEMORY MANAGEMENT ################################# 内存设置# 设置最大内存# maxmemory &lt;bytes&gt;# The default is:# 内存满了，有什么策略，和JUC中的那四种拒绝策略有点类似# 1.volatile-lru:只对设置了过期时间的key进行lru# 2.allkeys-lru:删除lru算法的key# 3.volatile-random:随机删除即将过期的# 4.allkeys-random:随机删除# 5.volatile-ttl:删除即将过期的# 6.noeviction:返回错误maxmemory-policy noeviction############################# LAZY FREEING ####################################lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush nolazyfree-lazy-user-del nolazyfree-lazy-user-flush no 配置RDB（Redis DataBase）持久化Redis是内存性数据库，如果不讲内存中的数据保存到磁盘中，那么一旦服务器退出，服务器中的服务器状态也就消失了，所以需要学会Redis中的持久化操作 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读取到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。 RDB的优点是效率高，对于数据的完整性要求不高 RDB的缺点是最后一次持久化后的数据可能丢失。 rdb文件默认保存为dump.rdb 1234567891011121314151617181920212223242526272829################################ SNAPSHOTTING ################################# 快照：做持久化的时候会用到。# 在规定的时间内执行了多少次操作就会生成一个.rdb文件或者.aof文件# Redis是内存数据库，如果没有持久化，用完数据就没了# 持久化规则# 3600s内至少有一个key进行了修改，则进行持久化操作 save 3600 1# 300s内至少有100个key进行了修改，则进行持久化操作 save 300 100# 60s内至少有10000个key进行了修改，则进行持久化操作 save 60 10000# 持久化出错后，是否还继续工作stop-writes-on-bgsave-error yes# 是否压缩rdb文件，消耗CPU资源rdbcompression yes# 是否校验rdb文件的数目rdbchecksum yes# 持久化生成的文件名字dbfilename dump.rdbrdb-del-sync-files no# 保存的目录，当前目录dir ./ 配置AOF（Append Only File）文件以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 123456789101112131415161718192021############################## APPEND ONLY MODE ################################ 持久化文件aof的配置# 默认关闭aof，默认开启rdb的持久化，大部分情况下，rdb完全够用appendonly no# 持久化文件的名字appendfilename &quot;appendonly.aof&quot;# appendfsync always # 每次修改都同步一下appendfsync everysec # 每1s都同步一下# appendfsync no # 不同步，操作系统自己同步# 是否重写# incrby view 10# incrby view 20# 重写后# incrby 30no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 如果aof中被恶意篡改了，这时候redis是启动不起来的，这时候可以使用redis提供的一个工具redis-check-aof.exe 优点：每一次修改都同步，文件的完整性会更好， 缺点：该文件远远大于rdb，修复速度远远慢于rdb，运行效率比rdb低 小结： RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协自加保存每次写的操作到文件未尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB 文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合 用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1这条规则。 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了 代价一是带来了持续的IO 代价二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF，仅靠Master-Slave Repllcation（主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时断电，会丢失十几分钟的数据，启动脚本也要比较两个Master&#x2F;Slave中的RDB文件，载入较新的那个。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-整合SpringBoot","slug":"Redis-整合SpringBoot","date":"2022-02-24T04:08:56.000Z","updated":"2022-02-24T07:13:41.530Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-整合SpringBoot/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E6%95%B4%E5%90%88SpringBoot/","excerpt":"","text":"SpringBoot整合Redis在SpringBoot2.x之后，底层已经不再使用jedis操作Redis了，而是lettuce jedis：采用的直连，如果有多个线程操作的话，是不安全的，需要使用jedis pool连接池来解决问题（BIO模式） lettcue：采用netty，实例可以在多个实例中共享，不存在线程不安全的问题（Dubbo底层也用到了它）（NIO模式） 如何使用1、导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt;&lt;/dependency&gt; 2、观察RedisAutoConfiguration源码 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean // 这说明我们可以自定义template @ConditionalOnMissingBean( name = &#123;&quot;redisTemplate&quot;&#125; ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean // 因为我们平时使用string会非常多，所以内置了一个StringRedisTemplate @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125;&#125; 3、配置连接，看源码可以发现，就算我们不配置，springboot也默认可以连接本地的redis 4、测试 先打开命令行客户端查看全部的key 12127.0.0.1:6379&gt; keys *(empty list or set) 测试类测试 123456789101112@SpringBootTestclass SpringbootRedisApplicationTests &#123; @Autowired private StringRedisTemplate redisTemplate; @Test void contextLoads() &#123; RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); connection.flushAll(); connection.flushDb(); redisTemplate.opsForValue().set(&quot;springboot integrated Redis&quot;,&quot;success&quot;); &#125;&#125; 命令行客户端查看全部的key，可以发现数据成功插入了 12127.0.0.1:6379&gt; keys *1) &quot;springboot integrated Redis&quot; 序列化器先看下源码 如果我们没有自定义这些序列化，那么他们都会被设置为内置的defaultSerializer，那么这种jdk的序列化会使我们的中文转义，这时候我们需要使用JSON来实现序列化 123if (this.defaultSerializer == null) &#123; this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader());&#125; 下面我们直接上案例： 使用jdk内置序列化器User 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private String name; private int age;&#125; 直接测试将对象写入 12345678@Testvoid testSerialization()&#123; User user = new User(); user.setName(&quot;zhima&quot;); user.setAge(19); redisTemplate.opsForValue().set(&quot;user&quot;, user); System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));&#125; 执行发现报错了，这就想到了我们从源码中看到的JdkSerializationRedisSerializer，如果我们没有配置自己想要的序列化器，那么就默认为此序列化器，所以知道报这个错误的原因是user没有实现序列化接口，那我们来实现以下序列化接口 1org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.lizhi.springbootredis.pojo.User] 这时候再执行，看控制台 1User(name=zhima, age=19) 自定义序列化器 配置自定义redisTemplate 123456789101112131415161718192021@Bean(&quot;myRedisTemplate&quot;)public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectJackson2JsonRedisSerializer.setObjectMapper(om); // hash的value使用JSON序列化 template.setHashValueSerializer(objectJackson2JsonRedisSerializer); // value使用JSON序列化 template.setValueSerializer(objectJackson2JsonRedisSerializer); // hash表的key使用string的序列化器 template.setHashKeySerializer(stringRedisSerializer); // key采用string的序列化器 template.setKeySerializer(stringRedisSerializer); template.afterPropertiesSet(); return template;&#125; 再执行刚刚的测试，就会发现，命令行中的key已经是一个正常的字符串了 工具类RedisUtils这样使用原生的API太麻烦了，我们可以自己编写一个工具类。 12链接:https://pan.baidu.com/s/1CZG5D8QUsz1NnqBjXZf0tg 提取码:24m2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-通过Jredis操作Redis","slug":"Redis-通过Jedis操作Redis","date":"2022-02-24T03:32:22.000Z","updated":"2022-02-24T04:05:50.360Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-通过Jedis操作Redis/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%80%9A%E8%BF%87Jedis%E6%93%8D%E4%BD%9CRedis/","excerpt":"","text":"JedisJedis其实就是java用来操作Redis的一个工具包 如何使用1、导入依赖 12345678910111213&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、使用封装好的对象测试连接Redis 1234567public class TestPing &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379); System.out.println(jedis.ping()); &#125;&#125;// 控制台输出PONG 可以点进源码看一下 我们会发现，这些方法不就是我们当时写的那些吗，只不过都被封装成了方法供我们使用。 实现事务1234567891011121314public class TransactionTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); jedis.set(&quot;money&quot;,&quot;100&quot;); jedis.set(&quot;out&quot;,&quot;0&quot;); jedis.watch(&quot;money&quot;); Transaction multi = jedis.multi(); jedis.decrBy(&quot;mondy&quot;,30); jedis.incrBy(&quot;out&quot;,30); multi.exec(); jedis.close(); &#125;&#125; 实际上和命令行的命令是一模一样的","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-实现乐观锁","slug":"Redis-实现乐观锁","date":"2022-02-24T03:07:07.000Z","updated":"2022-02-24T03:31:06.877Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-实现乐观锁/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/","excerpt":"","text":"浅实现一下乐观锁这里需要使用watch，直接上案例吧 需求：现有存款100元，花出去30元，还剩下70元 12345678910111213141516127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 30QUEUED127.0.0.1:6379&gt; incrby out 30QUEUED127.0.0.1:6379&gt; exec1) (integer) 702) (integer) 30# watch在事务执行结束后就失效了 现在我们开两个客户端cli-1和cli-2，按照以下的命令和顺序执行 cli-1 12345678127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED cli-2 123456127.0.0.1:6379&gt; get money&quot;70&quot;127.0.0.1:6379&gt; incrby money 230(integer) 300127.0.0.1:6379&gt; get money&quot;300&quot; cli-1 1234127.0.0.1:6379&gt; exec # 监视的值发生了改变，所以该事务执行失败，这个时候money上的watch没有解除，可以通过unwactch解除(nil)127.0.0.1:6379&gt; get money&quot;300&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"多并发中的锁","slug":"JUC-多并发中的锁","date":"2022-02-23T07:56:59.000Z","updated":"2022-02-24T02:29:10.098Z","comments":true,"path":"javaEE/JUC/2022/02/23/JUC-多并发中的锁/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JUC/2022/02/23/JUC-%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"为什么需要锁？在单线程环境下，不论怎么操作数据都不会出现什么致命的操作，但是在这个多并发的时代，我们更多的要考虑多并发，并保证多并发环境的安全性。 在并发环境下，多个线程争抢操作同一份数据，这样可能会导致数据异常，这个时候就需要一种机制来保证这一份数据的安全性。 锁是如何实现的？在java中，每一个Object都有一把锁，这把锁放在对象的对象头中，锁中记录了当前对象被哪个线程所占用。 内存中的对象结构 对齐填充字节是为了满足java对象必须是8比特的倍数这一条件所设计的 实例数据是为了保存对象属性和方法的 对象头是为了保存对象的运行时数据，对象头包含了两部分，一个是Mark Word 一个是Class Pointer Class Pointer 指向Class对象 Mark Word (32 bit)存放了很多和当前对象运行时状态有关的数据 hashCode 锁状态 synchronized实现原理synchronized被编译后会生成monitorenter和monitorexit两个字节码指令，依赖这两个指令就可以实现锁的机制，从而实现线程的同步 这是未上锁的代码： 12345678910111213import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125;&#125; 123456789101112131415161718public static void main(String[] args) &#123; TestSync ts = new TestSync(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start();&#125; 我们来加一下synchronized代码块 1234567891011121314151617package com.lizhi;import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; synchronized(this)&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125; &#125;&#125; 可以发现结果十分正确，我们来反编译一下，得到以下字节码文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849javap -c .\\TestSync.classCompiled from &quot;TestSync.java&quot;public class com.lizhi.TestSync &#123; public com.lizhi.TestSync(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void add(); Code: 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/util/concurrent/TimeUnit.MILLISECONDS:Ljava/util/concurrent/TimeUnit; 7: ldc2_w #3 // long 30l 10: invokevirtual #5 // Method java/util/concurrent/TimeUnit.sleep:(J)V 13: goto 21 16: astore_2 17: aload_2 18: invokevirtual #7 // Method java/lang/InterruptedException.printStackTrace:()V 21: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 24: invokestatic #9 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread; 27: invokevirtual #10 // Method java/lang/Thread.getName:()Ljava/lang/String; 30: aload_0 31: dup 32: getfield #11 // Field count:I 35: dup_x1 36: iconst_1 37: iadd 38: putfield #11 // Field count:I 41: invokedynamic #12, 0 // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;I)Ljava/lang/String; 46: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 49: aload_1 50: monitorexit 51: goto 59 54: astore_3 55: aload_1 56: monitorexit 57: aload_3 58: athrow 59: return Exceptio n table: from to target type 4 13 16 Class java/lang/InterruptedException 4 51 54 any 54 57 54 any&#125; 可以看到在第3行和第50行出现了monitorenter和monitorexit Monitor该单词的意思是监视器，可以将其想成一间宾馆的客房，把各个线程想像成客人。如果客人未退房，在这之后的客人则无法入住，只能等待这个客人退房后方可入住。 monitor是依赖于操作系统的mutex lock来实现的 java线程实际上是对操作系统线程的映射，每当挂起或者唤醒一个线程都要切换 操作系统内核态，这种操作是比较重量级的，在一些情况下甚至切换时间会超过任务本身执行的时间，这样的情况下，使用synchronized的会对系统的性能产生很严重的影响，但是从java6开始，synchronized进行了优化，引入了偏向锁和轻量级锁。 锁的四种状态由低到高分别是：无锁、偏向锁、轻量级锁、重量级锁。 这就与Mark Word中的四种状态对应上了 注意：锁只能升级不能降级 无锁 无锁即没有对自身资源上锁，所有线程都可以拿到资源并操作 这就可能出现两种情况 某个对象不会出现在多线程环境下，或者说即使出现在多线程环境下也不会出现竞争的情况 资源会被竞争，但是我不想对资源锁定，不过这样也不行，会导致一些问题，就想通过一种其他机制来控制多线程， 比如说，如果有多个进程想修改同一个值，但是只能有一个线程修改成功，其他失败的线程需要不断尝试，直到修改成功 ，这就是CAS（Compare And Swap）,CAS在操作系统中通过一条指令来实现，所以其就可以保证原子性，有了这种机制，我们就可以实现无锁编程 偏向锁 假如一个对象被加锁了，那么在实际运行过程中只有一个线程会获得这个对象锁，并只有当线程执行完任务，才会将锁释放。 我们设想的是，最好这个对象能够认识这个线程，当这个线程过来，那么这个对象就把自己的锁给他，这可以说这个对象偏爱这个线程，这就是偏向锁的概念 那么这个认识的人，被这个对象记在哪里呢？那就是在对象头中MarkWord的线程ID中，假如情况发生了变化，这个对象发现，不止有一个线程在争抢锁，那么该偏向锁会直接升级成轻量级锁 轻量级锁 那当锁升级为轻量级锁的时候，如何判断线程和所之间的绑定关系呢？可以再看下那张markword的表，这里已经不再使用线程ID这个字段了，而是将30bit变为指向线程栈中的锁记录（Lock Record）的指针 当一个线程想要获得对象的锁的时候，加入看到锁的标志位为00那么就知道它是轻量级锁，这时候线程会在自己的虚拟机栈中开辟一块被称为Lock Record的空间（线程私有的哦），该控件用来存放对象头中的Mark word的副本以及owner指针，线程通过CAS去尝试获得锁，一旦获取那么将会复制该对象头中的markword到本线程的Lock record中并且将Locker record中的owner指针指向该对象，并且对象的前三十位将会生成一个指针，指向线程虚拟机栈中的Lock Record，这样一来就实现了线程和对象锁的绑定。 当线程已经被抢占了，那其他想抢占的线程会自旋等待（可以理解为轮询），不断尝试拿到锁，这种操作区别于被操作系统挂起阻塞，如果对象的锁很快就被释放的话，自旋就不需要进行系统中断和重新恢复，所以它的效率会更高。 自旋相当于CPU空转，如果CPU空转时间过长，性能也会产生损耗，然后就有了一种优化，就是适应性自旋。简单来说，就是自旋的时间会根据上一次在同一个锁上自旋的时间以及锁的状态来决定的 重量级锁 如果同时有多个线程要获得这个对象锁，也就是说一旦自旋等待的线程超过一个，则会升级为重量级锁，那么这个时候，这就需要使用monitor来对线程进行控制，此时将会完全锁定资源，对线程的管控也更为严格 无锁编程java中的synchronized就是悲观锁（Pessimistic Concurrency Control），什么叫悲观锁呢？ 简单来说就是操作系统会悲观地认为，如果不严格同步线程调用，那么一定会产生异常，所以互斥锁会锁定资源，直供一个线程使用，而阻塞其他线程，因此叫悲观锁，但是悲观锁不是万能的，如果大部分操作都是读的操作，那么就没有必要在每次调用的时候都锁定资源。可能会出现同步代码块执行的耗时远远小于线程切换的耗时。使用悲观锁，会导致性能十分不容乐观，比如大量用户需要同时读取同一份资源，如果使用的是悲观锁，则同一时间只能有一个用户可以查看，其他用户都在一直白屏，但是！其实对于读的操作，即使是多个线程同时操作该数据，也不会对该数据造成影响，我们能不能在不锁定资源的情况下，也可以对线程调用进行一些协调呢？这时候就出现了乐观锁这种机制，实现原理就是CAS（Compare And Swap） CAS我们来举个栗子：人就是线程，厕所就是对象，该对象有一个值来表示是否被占用occupy 0表示空闲 1表示有人 很多人要去抢厕所，然后线程A（Old Value &#x3D; 0 ，new Value &#x3D;1）、B（Old Value &#x3D; 0，new Value &#x3D; 1）这两个人冲到了最前面，然后A率先和厕所的occupy比较（Compare）发现和oldValue一致，则将oldValue与厕所的occupy交换（And Swap），这时候B一看自己的oldValue与厕所的occupy（1）不一致，他很不甘心，但也只能在厕所外踱步（自旋），通常在等了一段时间后（设置最大自旋次数），骂出一句国粹后就离去了 这时候可能就出现了问题，因为Compare和Swap是两个操作，没有原子性，这就有可能出现，当A即将将值改为1的那一刹那，B抢到了时间片，将其改为了1，然后A也将其改为1，这就很尴尬了，两个人一起进入了厕所。 那么如何保证CS的原子性呢？难道还是锁来实现同步吗？这不就是一个鸡生蛋蛋生鸡的问题了吗？ 其实啊，各种不同架构的CPU都提供了指令级别的CAS原子操作， 比如在X86架构下，通过cmpxchg指令可以支持CAS 在ARM下，通过LL&#x2F;SC来实现CS…… 也就是说不通过操作系统的同步原语（比如 mutex），CPU已经实现了CS，上层只需要调用即可，这样我们就可以不依赖锁来进行线程同步，但是这也不意味着无锁可以完全代替有锁 利用CAS特性来进行无锁编程需求：使用三条线程，将一个值，从0累加到1000 1、错误 123456789101112public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125;).start(); &#125; &#125;&#125; 2、使用synchronized 1234567891011121314public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; synchronized (Application2.class)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 3、无锁 123456789101112public class Application2 &#123; static AtomicInteger count =new AtomicInteger(0) ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count.get()&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count.getAndIncrement()); &#125; &#125;).start(); &#125; &#125;&#125; 探究源码 AtomicInteger的getAndIncrement方法 123public final int getAndIncrement() &#123; return U.getAndAddInt(this, VALUE, 1);&#125; U的getAndAddInt方法 1private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe(); U是一个操作底层的类 12345678@HotSpotIntrinsicCandidatepublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v;&#125; 123456@HotSpotIntrinsicCandidatepublic final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) &#123; return compareAndSetInt(o, offset, expected, x);&#125; 1234@HotSpotIntrinsicCandidatepublic final native boolean compareAndSetInt(Object o, long offset, int expected, int x); 启动次数可以通过启动参数来配置，默认是10，所以不会出现死循环 Unsafe","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"http://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://li-zhi.net.cn/tags/JUC/"}]},{"title":"Redis-事务","slug":"Redis-事务","date":"2022-02-23T07:32:42.000Z","updated":"2022-02-23T07:56:26.132Z","comments":true,"path":"javaEE/Redis/2022/02/23/Redis-事务/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/23/Redis-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务回顾我们在MySQL中学习的事务具有ACID原则 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis中的事务事务的本质即：一组命令一起执行，不允许被插队。 在Redis中，单条命令是原子性的，但是事务不保证原子性 事务没有隔离级别的概念 123456789101112131415161718192021222324# 开启事务127.0.0.1:6379&gt; multiOK# 命令入队127.0.0.1:6379&gt; hset user:1 name zhimaQUEUED127.0.0.1:6379&gt; hset user:1 age 19QUEUED127.0.0.1:6379&gt; hset user:1 address SuzhouQUEUED127.0.0.1:6379&gt; hmget user:1 name age addressQUEUED# 执行事务127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 13) (integer) 14) 1) &quot;zhima&quot; 2) &quot;19&quot; 3) &quot;Suzhou&quot;# 中途放弃事务127.0.0.1:6379&gt; discard 编译时异常：即代码本身又问退，比如127.0.0.1:6379&gt; asdmlk (error) ERR unknown command &#39;asdmlk&#39;命令行会直接报错 12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k2(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k3(nil)127.0.0.1:6379&gt; get k2(nil) 可以发现所有的命令都没有执行。 运行时异常：如果事务队列中存在这种错误，其他语句照常执行，该语句不执行，抛出异常 1234567891011127.0.0.1:6379&gt; set k1 varOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) &quot;var&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"CS和BS架构是什么？","slug":"CS和BS架构是什么？","date":"2022-02-23T03:45:07.000Z","updated":"2022-02-23T04:03:49.550Z","comments":true,"path":"琐碎的知识/2022/02/23/CS和BS架构是什么？/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/23/CS%E5%92%8CBS%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"C&#x2F;S架构和B&#x2F;S架构C&#x2F;S架构 Client&#x2F;Server客户端&#x2F;服务器 客户端是针对某一具体业务专门开发的软件，是需要专门安装的软件。 由于客户端是专用的软件，所以客户端程序一般也具有对具体业务进行处理的能力，可以减轻服务端压力 优点：速度快，安全性较高 致命问题：版本升级成本很高 就比如QQ、微信等应用程序 B&#x2F;S架构 Browser&#x2F;Serve浏览器&#x2F;服务器 它其实也是一种特殊的C&#x2F;S架构，只不过这个Client是浏览器，是一个通用的客户端（浏览器），所以没有对具体业务进行处理的能力，速度降低。 优点：不存在客户端升级的问题 致命问题：速度慢，考虑兼容性的问题，安全性低 就比如，网页版QQ","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"【3-Medium】无重复字符的最长子串","slug":"【3-Medium】无重复字符的最长子串","date":"2022-02-22T09:10:53.000Z","updated":"2022-02-25T15:05:37.566Z","comments":true,"path":"算法/2022/02/22/【3-Medium】无重复字符的最长子串/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/22/%E3%80%903-Medium%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 Related Topics 哈希表 字符串 滑动窗口 法一：暴力解法分析：遍历数组的所有的区间，将满足题意区间长度的最大值返回 123456789101112131415161718192021222324252627public int lengthOfLongestSubstring(String s) &#123; int len=s.length(); if(len&lt;=1)&#123; return len; &#125; int maxLength = 1; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if(allUnique(s, i, j))&#123; maxLength = Math.max(maxLength, j-i+1); &#125; &#125; &#125; return maxLength;&#125;// 该函数的作用是返回该区间是否有重复的字符，有则返回false，没有则返回trueprivate boolean allUnique(String s, int i, int j) &#123; // 这里使用ArrayList也是可以的 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int x = i; x &lt;= j; x++) &#123; if(set.contains(s.charAt(x)))&#123; return false; &#125; set.add(s.charAt(x)); &#125; return true;&#125; 缺点：中间会有重复的比较，导致其效率十分低下，当string长度十分大的时候，就会超时。所以我们可以优化一个这个算法 法二：暴力优化123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; len; i++) &#123; set.add(s.charAt(i)); int j = i; while(j&lt;len-1 &amp;&amp; !set.contains(s.charAt(j+1)))&#123; j++; set.add(s.charAt(j)); &#125; maxLength = Math.max(set.size(), maxLength); set.clear(); &#125; return maxLength; &#125;&#125; 法三：滑动窗口法此方法从力扣官网解题得知： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/jian-dan-yi-dong-javac-pythonjshua-dong-bff20/ 我按照此思路画了图 这是我知道此方法后写的代码： 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); while(right &lt; len)&#123; while(right &lt; len &amp;&amp; !list.contains(s.charAt(right)))&#123; maxLength = Math.max(maxLength, right-left+1); list.add(s.charAt(right++)); &#125; left++; while(right &lt; len &amp;&amp; list.pop()!=s.charAt(right))&#123; left++; &#125; &#125; return maxLength; &#125;&#125; 这是力扣官网给出的同一方法的代码：两者本质是一样的，但是显然这一种更为简便！ 12345678910111213141516171819public int lengthOfLongestSubstring2(String s) &#123; int n = s.length(); if (n &lt;= 1) return n; int maxLen = 1; int left = 0, right = 0; Set&lt;Character&gt; window = new HashSet&lt;&gt;(); while (right &lt; n) &#123; char rightChar = s.charAt(right); while (window.contains(rightChar)) &#123; window.remove(s.charAt(left)); left++; &#125; maxLen = Math.max(maxLen, right - left + 1); window.add(rightChar); right++; &#125; return maxLen;&#125; 这是我看完后，对自己代码的优化： 123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123;return len;&#125; int maxLength = 1; int left = 0; int right = 0; LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); while(right &lt; len)&#123; char now = s.charAt(right); if(list.contains(now))&#123; left++; while(list.pop()!=now)&#123; left++; &#125; &#125; maxLength = Math.max(maxLength, right-left+1); list.add(now); right++; &#125; return maxLength; &#125;&#125; 我们发现对于处理left，我们需要遍历，那我们有什么办法可以直接拿到窗口中重复的字符的后一个索引呢？没错，就是hashmap 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(right &lt; len)&#123; char now = s.charAt(right); if(map.get(now)!=null)&#123; // 如果拿到的索引+1比left大再赋值 left = Math.max(map.get(now)+1,left); &#125; maxLength = Math.max(maxLength, right-left+1); map.put(now,right); right++; &#125; return maxLength; &#125;&#125; 接下来，我们追求一下极致，先看下题目要求 因为字符是确定的所以，我们可以new一个128长度的数组来当hashmap，键是字符的ascll码值，值是索引，代码如下 1234567891011121314151617181920class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; int[] window = new int[128]; while(right &lt; len)&#123; char now = s.charAt(right); left = Math.max(left, window[now] +1); maxLength = Math.max(maxLength, right-left+1); window[now] = right; right++; &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"大O表示法","slug":"算法-大O表示法","date":"2022-02-22T08:52:02.000Z","updated":"2022-02-22T14:31:40.400Z","comments":true,"path":"算法/2022/02/22/算法-大O表示法/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/22/%E7%AE%97%E6%B3%95-%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"如何去评判一个算法的好坏呢？我们可以从两个维度分别是时间和空间去评判，所以我们也可以根据这两点去优化我们的代码，从而使自己的算法的复杂度降低，效率提高。 那这样说的话，是不是我拿着不同的算法在不同的电脑上跑然后比较时间，谁的时间短，谁的算法更牛逼。那如果两台电脑的性能本就有着很大的差距呢？这样就不公平了，导致了比较的偏差。 大O表示法那么我们可以使用一种表示法也就是大O表示法来具体表示时间复杂度和空间复杂度。它将代码的所有步骤转换为关于数据规模n的公式项，然后排除不会对问题的整体复杂度产生较大影响的低阶、系数项和常数项。 时间复杂度其实该值表示的是，当数据的量级增加的时候，时间增长的一个趋势。 公式：T(n) &#x3D; O(f(n)) O(1)的例子： 123int x = 0;int y = 1;int temp = x + y; O(n)的例子： 12345678910111213for (int i = 1; i &lt; n; i++)&#123; System.out.println(i);&#125;/*** 该循环实际会执行多少行代码呢？* int i = 1; * 1* i &lt; n * n* i++ * n* sout(i) * n* 所以是O(1+3n)* 我们在开始就说过了需要排除不会对问题的整体复杂度产生较大影响的低阶、系数项和常数项。* 所以复杂度是O(n)*/ 再来看一个O(n^2)的案例： 12345678910111213141516for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.println(i+j); &#125;&#125;/** 一样的我们来看一下这个循环实际会执行多少次* int i = 0; * 1* int j = 0; * 1* i &lt; n * n* i++ * n* j &lt; n * n*n* j++ * n*n* sout(i+j); * 1* 也就是O(n^2+2n+3) = O(n^2)*/ O(logn)的例子： 12345678910int i=1;while(i &lt; n)&#123; i = i * 2; &#125;/** int i = 1; * 1* i &lt; n * (log2)n* i = i * 2 * (log2)n* 也就是O(2(log2)n)==(log2)n*/ O(nlogn)的例子： 1234567for (int i = 1; i &lt; n; i++)&#123; int j = 1; while(j &lt; n)&#123; j = j * 2; &#125;&#125;//这个很简单，和之前的分析是一样的 空间复杂度该复杂度表示的是内存空间随着数据的增加增长的趋势。 常用的空间复杂度O(1),O(n),O(n^2) O(1)的例子： 123int x = 0;int y = 1;int temp = x + y; O(n)的例子： 1234int[] arr = new int[n];for (int i = 0; i &lt; n; i++)&#123; arr[i] = i;&#125; O(n^2)的例子： 123456int[][] arr = new int[n][n];for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; arr[i][j] = i+j; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis-三大特殊类型","slug":"Redis-三大特殊类型","date":"2022-02-22T08:41:55.000Z","updated":"2022-02-24T05:30:53.475Z","comments":true,"path":"javaEE/Redis/2022/02/22/Redis-三大特殊类型/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/22/Redis-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"三种特殊类型geospatial该数据类型是用来存储地理空间的 附近的人，发送定位，分享实时位置，打车的时候的距离计算都可以通过这个实现 我们这里使用这几个城市的经纬度作为测试 城市 经度 维度 相城区 120.64239 31.36889 吴江区 120.638317 31.159815 太仓 121.10891 31.4497 常熟市 120.75225 31.65374 昆山市 120.98074 31.38464 这里有六个基本命令，我们来一个个看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# geoadd key longitude latitude member [longitude latitude member..]# 增加一个经纬度的坐标# 两极无法添加，一般我们通过java程序一次性导入127.0.0.1:6379&gt; geoadd Suzhou 120.64239 31.36889 XiangChengDistrict 120.638317 31.159815 WuJiangDistrict 121.10891 31.4497 TaiCang 120.75225 31.65374 ChangShuCity 120.98074 31.38464 KunShanCity(integer) 5# geodist key member1 member2 [unit]# 获取两地之间的距离单位为米127.0.0.1:6379&gt; GEODIST Suzhou TaiCang WuJiangDistrict&quot;55133.1652&quot;127.0.0.1:6379&gt; GEODIST Suzhou TaiCang KunShanCity km&quot;14.1556&quot;# geohash key member [member..]# 获取member的二维的空间经纬度数据编码# 这个可以csdn搜一下具体的算法实现127.0.0.1:6379&gt; geohash Suzhou TaiCang1) &quot;wtw4gvhzf10&quot;# geopos key member [member..]# 查看member的经纬度127.0.0.1:6379&gt; geopos Suzhou TaiCang XiangChengDistrict1) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;120.64238995313644&quot; 2) &quot;31.368889085683811&quot;# georadius key longitude latitude radius m|km|ft|mi [WITHSCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC| ESC]# mi是英里，ft是英尺# 以给定的经纬度为中心，找到某一半径内的元素# WITHCOORD表示显示坐标# WITHDIST表示显示距离该点的位置# WITHHASH表示显示该地址的hash值# COUNT count表示显示几个# ASC| ESC 表示正序还是倒序127.0.0.1:6379&gt; georadius Suzhou 120.98080 31.28460 30 km withdist1) 1) &quot;KunShanCity&quot; 2) &quot;11.1271&quot;2) 1) &quot;TaiCang&quot; 2) &quot;22.0285&quot;# georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]# 以member为中心radius为半径，找到在此范围中的元素127.0.0.1:6379&gt; georadiusbymember Suzhou TaiCang 30 km withcoord withdist withhash asc1) 1) &quot;TaiCang&quot; 2) &quot;0.0000&quot; 3) (integer) 4054798020485654 4) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;KunShanCity&quot; 2) &quot;14.1556&quot; 3) (integer) 4054794184325796 4) 1) &quot;120.98073989152908&quot; 2) &quot;31.38463984296795&quot; geo的底层其实是Zset，我们可以使用Zset的命令去操作geo 1234567127.0.0.1:6379&gt; zrem Suzhou TaiCang(integer) 1127.0.0.1:6379&gt; zrange Suzhou 0 -11) &quot;WuJiangDistrict&quot;2) &quot;XiangChengDistrict&quot;3) &quot;ChangShuCity&quot;4) &quot;KunShanCity&quot; Hyperloglog 先来了解一下基数是什么？ 基数其实就是一个集合中不重复的元素个数，其实就是一个集合去重后的集合长度 业务场景： 网站的访问量（一个人访问一个网站多次，也算一个人） 传统使用set集合的重复无序的特性，可以保存用户的id，以set集合的长度作为标准。但是，专门使用一个set来保存用户id未免优点奢侈，如果id是分布式的会很复杂，导致set集合很庞大，所以需要一个方法来解决这个问题。 Hyperloglog就是用来解决此问题的算法。 优点：占用很小的内存空间存放2^64个数据，也只占用12kb 瑕疵：会有0.81%的错误率 123456789101112131415161718192021222324# pfadd key member [member..]127.0.0.1:6379&gt; pfadd set a b c d e f g h i j k l(integer) 1# pfcount key [key..]# 返回基数127.0.0.1:6379&gt; pfcount set(integer) 12127.0.0.1:6379&gt; pfadd set2 j k l m n(integer) 1127.0.0.1:6379&gt; pfcount set set2(integer) 14# pfmerge destkey sourcekey [sourcekey..]# 将sourcekey合并到destkey127.0.0.1:6379&gt; pfmerge set set2OK# 探究底层：# 我们获取一下此数据的数据类型，可以看到实际上存储的是string127.0.0.1:6379&gt; type setstring127.0.0.1:6379&gt; get set&quot;HYLL\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00Fm\\x80I\\xe8\\x80@\\xc4\\x84K\\\\\\x80D&lt;\\x848\\x80B=\\x80K\\x83\\x80B\\xed\\x84A\\xfc\\x8cG\\x8e\\x80Bm\\x80BZ&quot; Bitmap位存储，一般使用两种状态的区分 比如统计中国的男子和女子的数目 14亿个二进制数，0代表女子，1代表男 0 0 1 1 1 0 1 … 登录，头像是亮着的，未登录，头像是灰色的。 12345678910111213141516171819202122232425# setbit key offset value# 设置offset位是value127.0.0.1:6379&gt; setbit sign 0 0(integer) 0127.0.0.1:6379&gt; setbit sign 1 1(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0# 中国sign可以代表# 星期日未打卡# 星期一已打卡# 星期二未打卡# 星期三已打卡# getbit key offset# 查看该天是否打卡127.0.0.1:6379&gt; getbit sign 3(integer) 1# bitcount key [start end]# 查看sign中为1的个数127.0.0.1:6379&gt; BITCOUNT sign(integer) 2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"【1827-Easy】最少操作使数组递增","slug":"【1827-Easy】最少操作使数组递增","date":"2022-02-21T13:49:48.000Z","updated":"2022-02-25T15:08:04.671Z","comments":true,"path":"算法/2022/02/21/【1827-Easy】最少操作使数组递增/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/21/%E3%80%901827-Easy%E3%80%91%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E6%95%B0%E7%BB%84%E9%80%92%E5%A2%9E/","excerpt":"","text":"最少操作使数组递增给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。 比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。 请你返回使 nums 严格递增 的 最少 操作次数。 我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &lt;= i &lt; nums.length - 1 都有 nums[i] &lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。 示例 1： 123456输入：nums = [1,1,1]输出：3解释：你可以进行如下操作：1) 增加 nums[2] ，数组变为 [1,1,2] 。2) 增加 nums[1] ，数组变为 [1,2,2] 。3) 增加 nums[2] ，数组变为 [1,2,3] 。 示例 2： 12输入：nums = [1,5,2,4,1]输出：14 示例 3： 12输入：nums = [8]输出：0 提示： 1 &lt;= nums.length &lt;= 5000 1 &lt;= nums[i] &lt;= 104 Related Topics 贪心 数组 法一：分析：从第二位遍历数组，与前一位比较，将差值给后者补上并加一即可 上代码： 1234567891011121314class Solution &#123; public int minOperations(int[] nums) &#123; int sum=0; int temp; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i]-nums[i-1]&lt;=0)&#123; temp = nums[i-1]-nums[i]+1; sum += temp; nums[i] += temp; &#125; &#125; return sum; &#125;&#125; 因为不需要对原数组做出改动，所以以上可以简化成以下的代码 1234567891011class Solution &#123; public int minOperations(int[] nums) &#123; int sum=0; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i]-nums[i-1]&lt;=0)&#123; sum += nums[i-1]-nums[i]+1; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1380-Easy】矩阵中的幸运数","slug":"【1380-Easy】矩阵中的幸运数","date":"2022-02-21T13:15:58.000Z","updated":"2022-02-25T15:07:41.093Z","comments":true,"path":"算法/2022/02/21/【1380-Easy】矩阵中的幸运数/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/21/%E3%80%901380-Easy%E3%80%91%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","excerpt":"","text":"矩阵中的幸运数给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1： 123输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]输出：[15]解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2： 123输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]输出：[12]解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3： 12输入：matrix = [[7,8],[1,2]]输出：[7] 提示： m == mat.length n == mat[i].length 1 &lt;= n, m &lt;= 50 1 &lt;= matrix[i][j] &lt;= 10^5 矩阵中的所有元素都是不同的 Related Topics 数组 矩阵 法一：转置矩阵进行操作分析：该题其实就是马鞍数，我的思路是，转置矩阵，然后遍历原二维数组的每一行，先取得每一行的最小值所在的索引，然后取得这一列所在的最大值的索引，比较当前行数和最大值的索引是否相等，如果相等，则说明该数字即幸运数。这里不可以拿到最小值和最大值的值本身而是拿到索引，不然会有巧合出现。 上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int[][] reverse = reverse(matrix); int min; int max; for (int i = 0; i &lt; matrix.length; i++) &#123; // 拿到这一行的最小值的索引 min = indexOfMin(matrix[i]); // 拿到最小值这一列的最大值的索引， max = indexOfMax(reverse[min]); // matrix[i][min]==reverse[min][max] // 这里是先拿到每一行需要比较的值即matrix[i][min]， // 然后拿到min列i行的最大值matrix[i][max]比较是否相等, // 化简一下即为比较i与max的大小是否相等 if(i==max)&#123; result.add(matrix[i][min]); &#125; &#125; return result; &#125; public int[][] reverse(int[][] matrix)&#123; int[][] reverse = new int[matrix[0].length][matrix.length]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; reverse[j][i]=matrix[i][j]; &#125; &#125; return reverse; &#125; public int indexOfMin(int[] arr)&#123; int min = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;arr[min])&#123; min=i; &#125; &#125; return min; &#125; public int indexOfMax(int[] arr)&#123; int max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&gt;arr[max])&#123; max=i; &#125; &#125; return max; &#125;&#125; 法二：预拿最值分析：提前将每一行和每一列的最值都拿出来，然后扫描棋盘找到满足的数据 上代码： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int rowMin = new int[matrix.length]; Arrays.fill(rowMin,Integer.MAX_VALUE); int columnMax = new int[matrix[0].length]; Arrays.fill(columnMax,Integer.MIN_VALUE); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; rowMin[i] = Math.min(rowMin[i],matrix[i][j]); columnMax[j] = Math.max(columnMax[j],matrix[i][j]); &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if(rowMin[i]==matrix[i][j]&amp;&amp;columnMax[j]==matrix[i][j])&#123; result.add(matrix[i][j]); &#125; &#125; &#125; return result; &#125; public int findMin(int[] arr)&#123; int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; return min; &#125;&#125; 对于预处理还可以这样写： 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int rowMin = new int[matrix.length]; int columnMax = new int[matrix[0].length]; Arrays.fill(columnMax,Integer.MIN_VALUE); for (int i = 0; i &lt; matrix.length; i++) &#123; rowMin[i] = findMin(matrix[i]); for (int j = 0; j &lt; matrix[i].length; j++) &#123; columnMax[j] = Math.max(columnMax[j],matrix[i][j]); &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if(rowMin[i]==matrix[i][j]&amp;&amp;columnMax[j]==matrix[i][j])&#123; result.add(matrix[i][j]); &#125; &#125; &#125; return result; &#125; public int findMin(int[] arr)&#123; int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; return min; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【717-Easy】1比特与2比特字符","slug":"【717-Easy】1比特与2比特字符","date":"2022-02-21T12:27:37.000Z","updated":"2022-02-25T15:07:19.818Z","comments":true,"path":"算法/2022/02/21/【717-Easy】1比特与2比特字符/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/21/%E3%80%90717-Easy%E3%80%911%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/","excerpt":"","text":"1比特与2比特字符有两种特殊字符： 第一种字符可以用一个比特 0 来表示 第二种字符可以用两个比特(10 或 11)来表示、 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。 示例 1: 1234输入: bits = [1, 0, 0]输出: true解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2: 1234输入: bits = [1, 1, 1, 0]输出: false解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 提示: 1 &lt;= bits.length &lt;= 1000 bits[i] == 0 or 1 Related Topics 数组 法一：直接正序遍历分析：其实这个题目的意思数组中11、10这两种连续的组合就是一个整体，然后0是一个整体，返回的结果就是，这个数组按这种规则组合后，最后的那一个组合是不是0，如果是则返回true，反之则返回false。 首先，判断最后一个是否是1，如果为1则直接返回false 然后，遍历该数组到倒数第二个，如果当前的值是1，则用来遍历的计数器额外加1 最后，返回计时器是否等于数组的长度减1，如果相等，则说明最后一位的0未与倒数第二位匹配，满足题意 上代码： 12345678910111213141516class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int length = bits.length; if(bits[length-1]==1)&#123; return false; &#125; int i = 0; while(i&lt;length-1)&#123; if(bits[i]==1)&#123; i++; &#125; i++; &#125; return i==length-1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【2-Medium】两数相加","slug":"【2-Medium】两数相加","date":"2022-02-21T10:53:00.000Z","updated":"2022-05-01T05:31:53.234Z","comments":true,"path":"算法/2022/02/21/【2-Medium】两数相加/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/21/%E3%80%902-Medium%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ListNode 12345678//Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 示例1: 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 图示1： 图示2： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 Related Topics 递归 链表 数学 法一：链表转值计算分析：遇到这种链表的题，首先要先将逻辑图画出来。 经过观察可知，链表的第一位表示该数字的个位，第二位代表该数字的十位，以此类推。 一开始解题思路应该是，先将链表表示的数字算出来，然后先将两个数字加起来，然后再用该数字构建出来结果链表。 代码如下 1234567891011121314151617181920212223242526public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; long sum=compute(l1)+compute(l2); ListNode listNode = new ListNode(); // 这里的listNode是虚拟节点，最后返回的是该节点的下一个节点 ListNode temp = listNode; while (sum != 0) &#123; // 这里需要使用强转 // (sum%10)的结果是long类型，直接赋值给ListNode的int型的val会报错 temp.next = new ListNode((int)(sum%10)); temp = temp.next; sum /= 10; &#125; return listNode.next;&#125;/*** 该函数是为了计算链表所表示的值*/private int compute(ListNode node)&#123; int result = 0; for(int i = 1 ; node != null ; node = node.next)&#123; result += node.val *i; i *= 10; &#125; return result;&#125; 我们算一下int的最大值是多少，int是4个字节也就是32位，可以表示2^32个数字， 再来看long的最大值，long是8个字节也就是64位，可以表示2^64位。 此方法乍一看确实没问题，但是，请看题目要求 题目要求告诉我们，测试的时候可能会出现100位的数字，long类型最大值远远不够，所以当数字很大的时候，该方法就会崩盘。 这时候就需要考虑其他方法。比如，递归。 法二：递归分析：我们现在有两个链表，我们对其要清楚两点 两个链表的长度不一定相同 两个链表相加后，长度不一定不变 递归需要先将递归退出条件写出来，即两者都到尾部，就简单看看我画的思路图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode listNode = new ListNode(); add(l1,l2,listNode); return listNode; &#125; public ListNode add(ListNode a,ListNode b,ListNode temp)&#123; // 当两个链表都到头了，则退出递归 if(a==null&amp;&amp;b==null)&#123; return temp; &#125; // 此变量是用来标注下一次递归的时候两个链表是否是都尾部了 boolean flag=false; // 当a到尾部的时候，将temp的数据域变为自身加上b的数据域的值 if(a==null)&#123; temp.val+=b.val; // 在a已经到尾部的情况下，b的next为null，即b将在下一次递归到尾部了，则将flag变为true if(b.next==null)&#123; flag=true; &#125; // 当b到头的时候，将temp的数据域变为自身加上b的数据域的值 &#125;else if(b==null)&#123; temp.val+=a.val; // 在b已经到尾部的情况下，a的next为null，即a将在下一次递归到尾部了，则将flag变为true if(a.next==null)&#123; flag=true; &#125; &#125;else &#123; temp.val+=a.val+b.val; if(a.next==null&amp;&amp;b.next==null)&#123; flag=true; &#125; &#125; // left用来存储当前这一位的值是否&gt;=10，如果满足，则进1 int left=temp.val&gt;=10?1:0; // 将left作为初始值new出来temp的下一个指针 temp.next = new ListNode(left); // 为了防止超过十，所以这里做了取余的操作， temp.val = temp.val%10; // 如果下一次递归的时候两者都到了尾部，并且没有进1，则不需要new出来temp的next if(flag&amp;&amp;left==0)&#123; temp.next=null; &#125; //递归调用 return add(a==null?null:a.next,b==null?null:b.next,temp.next); &#125;&#125; 其实这种递归就是化简为繁了，下面这种做法才是我觉得最好的。 第二次写 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return add(l1,l2,0); &#125; public ListNode add(ListNode l1, ListNode l2, int bit) &#123; if (l1 == null &amp;&amp; l2 == null &amp;&amp; bit == 0) &#123; return null; &#125; int val = bit; // bit就是表示每次是否进位 if (l1 != null) &#123; val += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; val += l2.val; l2 = l2.next; &#125; ListNode node = new ListNode(val % 10); node.next = add(l1, l2, val / 10); return node; &#125;&#125; 法三：并行遍历分析：直接两条链表一起遍历，用left存储是否进位 1234567891011121314151617181920212223242526272829class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode cur = new ListNode(0); ListNode temp = cur; int left = 0; // 当两者有一个没有遍历到尾部就一直遍历 while(l1 != null || l2 != null) &#123; int x = (l1 == null ? 0 : l1.val); int y = (l2 == null ? 0 : l2.val); int sum = x + y + left; // left = sum &gt;= 10 ? 1 : 0;两者一样的，但是下者表达更简单 left = sum / 10; sum = sum % 10; temp.next = new ListNode(sum); temp = temp.next; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; // 做单独处理 if(left == 1) &#123; temp.next = new ListNode(left); &#125; return cur; &#125;&#125; 第二次写 123456789101112131415161718192021222324252627class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode t1 = l1; ListNode t2 = l2; int bit = 0; ListNode res = new ListNode(); ListNode temp = res; // 三种情况可以继续循环 // 1、tl未到头 // 2、t2未到头 // 3、bit为1，表示进位 while(t1 != null || t2 != null || bit != 0)&#123; int a = t1 == null? 0 : t1.val; int b = t2 == null? 0 : t2.val; // a+b+bit表示该位的和，放入该地方的是余数 temp.next = new ListNode((a+b+bit)%10); temp = temp.next; // bit表示的是是否满十进位，只要该数除以10，为1则表示该数大于10了 bit = (a+b+bit)/10; if(t1 != null) t1 = t1.next; if(t2 != null) t2 = t2.next; &#125; return res.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1-Easy】两数之和","slug":"【1-Easy】两数之和","date":"2022-02-21T10:52:45.000Z","updated":"2022-04-30T03:41:38.540Z","comments":true,"path":"算法/2022/02/21/【1-Easy】两数之和/","link":"","permalink":"http://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/21/%E3%80%901-Easy%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ Related Topics 数组 哈希表 法一：暴力枚举法分析：题目意思很明确，就是给你一个target，然后给你一个数组，在这个数组里面找到可以和是这个target的那两个数的索引数组 上代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[]&#123;-1,-1&#125;; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if(j!=i&amp;&amp;nums[j]==target-nums[i])&#123; result[0]=i; result[1]=j; return result; &#125; &#125; &#125; return result; &#125;&#125; 法二：哈希表分析：法一取到target-nums[i]使用的是遍历算法，那我们就可以使用hashmap在这一点提高效率 hashmap的 键为nums[i] 值为索引 上代码： 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 第二个解法的核心在于：hash 表是如何将 查找 target - x，元素从 O(N),降低到 O（1）的？ 其实算法中最基本的数据结构就两个，不管多么高深的算法底层都是这两个结构 一个是数组，效率为O(1) 一个是链表，效率为O(N) 要想达到O（1）的算法，底层一定是数组。put方法内部首先对 key做了 hash（）运算，将其映射到数组上，只要不做扩容，或者缩容，key 在数组的位置就是固定的。每次通过get方法获取值得时候，先取得其hash值，然后再通过数组下标的方式，直接返回，所以是O（1）的效率","categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"去IOE是什么？","slug":"去IOE是什么？","date":"2022-02-21T07:58:53.000Z","updated":"2022-02-21T10:43:35.445Z","comments":true,"path":"琐碎的知识/2022/02/21/去IOE是什么？/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/21/%E5%8E%BBIOE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"什么去IOE？I是以IBM为代表的小型机小型机与X86服务器的区别： 价格 一台小型机可以买3-4台X86服务器 指令 X86 兼容性好 性能差 小型机 兼容性差 性能好 性能 领域 O是以ORACLE为代表的关系型数据库架构2013年5月17日，最后一台IBM小型机在支付宝下线了，这个是去IOE的一个重要的一个节点。ORACLE数据库告别阿里巴巴是在2013年的7月10日，这一天阿里巴巴的一个重要广告系统的ORACLE数据库也下线了，也是淘宝最后一个ORACLE数据库，这两件事情合在一起啊，也是构成阿里巴巴的一个重要的一个里程碑。 阿里巴巴呢一直是采用的是ORCALE数据库，并利用小型机和高端的存储设备提高性能和数据库的性能，但随着业务的不停的发展，数据量愈发庞大。 传统的移动式ORACLE数据库的扩展，也存在着一些瓶颈。传统的ORACLE软件为代表的关系数据库，大多数呢是以集中式架构为主，这些传统的数据库软件是最大的特点呢，就是将所有的数据集中存储在一个数据库中，依赖大型的高端设备来提高处理的性能和扩展性，集中式数据库的扩展呢，主要是采用向上扩展的那这种方式啊，就是通过增加CPU内存的方式提高处理能力，这种处理的架构就使得数据库成为一个很大的一个系统瓶颈，越来越不适合目前海量数据对计算能力的一个需求。 E是以EMC为代表的高端SAN存储设备SAN：Storage Area Network EMC是一家美国信息存储公司。","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Redis-五大基础数据类型","slug":"Redis-五大基础数据类型","date":"2022-02-21T02:00:54.000Z","updated":"2022-02-24T03:51:49.953Z","comments":true,"path":"javaEE/Redis/2022/02/21/Redis-五大基础数据类型/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/21/Redis-%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基础知识redis默认有16个数据库Redis的瓶颈是根据机器的内存和网络带宽。 为什么单线程还可以这么快？redis是c语言写的，官网提供的性能数据 1s 11万读取 1s 8万写入 误区： 高性能的服务器一定是多线程的 多线程一定比单线程效率高 CPU—&gt;内存—&gt;硬盘 核心：redis将所有的数据都放入内存中，所以用单线程去操作效率是很高的，多线程（CPU上下文会切换，十分耗时），对于内存系统，没有上下文切换效率会很高，多次读写都是在一个CPU上的，没有线程调度的耗时 五大数据类型基础命令1234567891011121314151617181920212223242526272829303132333435363738# 切换数据库select index# 查看当前数据库的数据数dbsize# 查看当前所有符合pattern的keykeys pattern# 是否存在该key，存在则返回1，不存在则返回0exists key# 移除keymove key#设置kvset key value# 查看key存储的值get key# 查看类型type key# 设置过期时间为secondssexpire key seconds#查看剩余时间ttl key# 清空当前数据库flushdb# 清空所有的数据库的内容flushall# 随机输出一个keyrandomkey String123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# 追加key存储的value字符串# 如果key不存在，则该命令相当于set# append key valueappend key &quot;appendstring&quot;# 查看key存储的字符串的长度strlen key# 自增1，自减1的操作# incr key # decr key127.0.0.1:6379&gt; set views 1OK127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; incr views(integer) 3127.0.0.1:6379&gt; decr views(integer) 2127.0.0.1:6379&gt; decr views(integer) 1# 一次性加或者减指定数字的操作# incrby key increment# decrby key decrement127.0.0.1:6379&gt; incrby views 10(integer) 11127.0.0.1:6379&gt; decrby views 10(integer) 1# 获取一个范围内的字符串，即substring==&gt;[start,end)# 注意这里的getrange是闭区间，[start,end]# getrange key start end127.0.0.1:6379&gt; set name zhimaOK127.0.0.1:6379&gt; getrange name 0 3&quot;zhim&quot;127.0.0.1:6379&gt; getrange name 0 -1&quot;zhima&quot;# 替换字符串# setrange key offset value127.0.0.1:6379&gt; set key randomstringOK127.0.0.1:6379&gt; setrange key 3 xxx(integer) 12127.0.0.1:6379&gt; get key&quot;ranxxxstring&quot;# setex (set with expire) 设置过期时间# 设置该字段过期时间为30s# setex key seconds valuesetex key 30 &quot;expire&quot;# 如果不存在则设置值，在分布式锁中经常使用# setnx (set if not exist)# setnx key value127.0.0.1:6379&gt; set key1 value1OK127.0.0.1:6379&gt; get key1&quot;value1&quot;127.0.0.1:6379&gt; setnx key1 &quot;setnx&quot;(integer) 0127.0.0.1:6379&gt; set key1 &quot;setnx&quot;OK127.0.0.1:6379&gt; get key1&quot;setnx&quot;# 批量获取和设置值 # mget mset msetnx# mset key value [key value..]# mget key [key..]# msetex key value [key value..]127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; mget k1 k21) &quot;v1&quot;2) &quot;v2&quot;127.0.0.1:6379&gt; msetnx k1 modifiedv1 k4 v4 # 该操作是一个原子性的操作！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 删除# del key127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; keys *1) &quot;k1&quot;127.0.0.1:6379&gt; del k1(integer) 1127.0.0.1:6379&gt; keys *(empty list or set)# 对象set user:1&#123;name:zhangsan,age:3&#125; # 设置一个user:1对象 值为json字符串来保存# 这里的key是一个巧妙的属性：&#123;className&#125;:&#123;id&#125;:&#123;field&#125;，在redis中是可以的127.0.0.1:6379&gt; mset user:1:name zhima user:1:age 19OK127.0.0.1:6379&gt; keys *1) &quot;user:1:age&quot;2) &quot;user:1:name&quot;127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhima&quot;2) &quot;19&quot;# 组合命令# getset先取得当前的值并返回，然后修改当前的值# getset key value127.0.0.1:6379&gt; getset db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db modified&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;modified&quot; List可以给其设置一个使用规则，则可以将其实现栈或者队列的功能 1234567891011# 设置和取值# lrange key start stop [start,stop]127.0.0.1:6379&gt; lpush list1 v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list1 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lrange list1 0 11) &quot;v3&quot;2) &quot;v2&quot; 分析可知这里的lpush是头插入，也就是left插入，那与之对应的肯定还有个尾插入，即right插入，但是啊只有LRANGE操作来取得集合里的数据，没有RRANGE操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131127.0.0.1:6379&gt; rpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;# 删除头部的值并返回# lpop key127.0.0.1:6379&gt; lpop list&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;2) &quot;v3&quot;# 删除尾部的值并返回# rpop key127.0.0.1:6379&gt; rpop list&quot;v3&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 获取索引处的元素# lindex key index127.0.0.1:6379&gt; lpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lindex list 0&quot;v3&quot;# 获取集合长度# llen key 127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; llen list(integer) 3# 移除指定个数的匹配的值# lrem key count value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;4) &quot;v1&quot;127.0.0.1:6379&gt; lrem list 1 v1(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;127.0.0.1:6379&gt; lrem list 2 v3(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 截取指定位置的值# ltrim key start stop127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; ltrim list 0 2OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;# 将集合尾部元素移除，并在另一个集合头部加入一个元素# rpoplpush source destination127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; rpoplpush list otherlist&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lrange otherlist 0 -11) &quot;v1&quot;# 修改指定索引处元素的值127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lset list 0 modifiedOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;modified&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;# lpush key value [value...]# 当该集合不存在的时候会自动创建# lset key index value# 当该集合不存在的时候会报错# 在指定值的前面|后面插入值# linsert key BEFORE|AFTER pivot value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; linsert list before v2 brforev2(integer) 6127.0.0.1:6379&gt; linsert list after v4 afterv4(integer) 7127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;afterv4&quot;4) &quot;v3&quot;5) &quot;brforev2&quot;6) &quot;v2&quot;7) &quot;v1&quot; 该List实质上是使用链表实现的 栈：出栈（Lpop）入栈（Lpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Rpush） 队列：出队（Lpop）入队（Rpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Lpush） Set该集合的特点是：无序不重复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 添加一个元素# sadd key member [member..]# 查看所有的成员# smembers key127.0.0.1:6379&gt; sadd set a b c a(integer) 3127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;# 判断是否包含某个元素127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sismember set c(integer) 1127.0.0.1:6379&gt; sismember set d(integer) 0# 查看集合的长度127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; scard set(integer) 3# 删除某个元素# srem key member [member..]127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srem set a c(integer) 2127.0.0.1:6379&gt; smembers set1) &quot;b&quot;# 随机返回指定个数的元素# srandmember key count127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;b&quot;3) &quot;a# 随机删除指定个数的元素，不写count默认为1# spop key [count] 127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; spop set 31) &quot;c&quot;2) &quot;e&quot;3) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;d&quot;# 将一个指定的值，移到另一个集合中# smove source destination member127.0.0.1:6379&gt; sadd set a b c d e(integer) 5127.0.0.1:6379&gt; smove set set2 a(integer) 1127.0.0.1:6379&gt; smembers set21) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;# 交集 sinter key [key..]# 差集 sdiff key [key..]# 并集 sunion key [key..]127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;127.0.0.1:6379&gt; smembers set21) &quot;b&quot;2) &quot;a&quot;3) &quot;g&quot;127.0.0.1:6379&gt; sinter set set21) &quot;b&quot;127.0.0.1:6379&gt; sdiff set set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sunion set set21) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;a&quot;6) &quot;g&quot; HashMap集合，key-Map集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# hset key field value# 放入一个map# hget key field 127.0.0.1:6379&gt; hset hashmap name zhima(integer) 1127.0.0.1:6379&gt; hget hashmap name&quot;zhima&quot;# 设置和取得多个键值对# hmset key field name [field name..]# hmget key field [field..]127.0.0.1:6379&gt; hmset user:1 name zhim age 10OK127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhim&quot;2) &quot;10&quot;# 使用hset更新键值对127.0.0.1:6379&gt; hset user:1 name zhima(integer) 0127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhima&quot;2) &quot;19&quot;# 取得所有的键值对# hgetall key 127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;19&quot;# 获取键值对个数# hlen key127.0.0.1:6379&gt; hlen user:1(integer) 2# 删除键值对# hdel key field127.0.0.1:6379&gt; hdel user:1 name(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;age&quot;2) &quot;19&quot;# 是否存在该键值对# hexists key field127.0.0.1:6379&gt; hexists user:1 name(integer) 1127.0.0.1:6379&gt; hexists user:1 unknown(integer) 0# 获得所有的键# hkeys key# 获得所有的值# hvals key127.0.0.1:6379&gt; hkeys user:11) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt; hvals user:11) &quot;zhima&quot;2) &quot;19&quot;# 增加值# hincrby key field increment # ！注意：！这里没有自减的方法，但是可以为increment设置负数来实现减127.0.0.1:6379&gt; hincrby user:1 name 1(error) ERR hash value is not an integer127.0.0.1:6379&gt; hincrby user:1 age 2(integer) 21127.0.0.1:6379&gt; hmset user:2 name lizhi age &quot;19&quot;OK127.0.0.1:6379&gt; hgetall user:21) &quot;name&quot;2) &quot;lizhi&quot;3) &quot;age&quot;4) &quot;19&quot;127.0.0.1:6379&gt; hincrby user:2 age 2(integer) 21127.0.0.1:6379&gt; hincrby user:2 age -1(integer) 20# 如果不存在该字段，则添加该字段# 如果存在，则不进行操作# hsetnx key field value127.0.0.1:6379&gt; hsetnx user:1 name modified(integer) 0127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;127.0.0.1:6379&gt; hsetnx user:1 address unknown(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;5) &quot;address&quot;6) &quot;unknown&quot; Hashmap适合存储对象 Zset（有序列表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 添加值 这个score相当于权重，用来排序# zadd key [NX|XX] [CH] [INCR] score member [score member..]127.0.0.1:6379&gt; zadd myzset 1 one(integer) 1127.0.0.1:6379&gt; zadd myzset 2 two 3 three(integer) 2# 正序输出# zrange key start stop [withscores]127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;# 倒叙输出# zrevrange key start stop [withscores]127.0.0.1:6379&gt; zrevrange salary 0 -11) &quot;lizhi&quot;2) &quot;xiaozhang&quot;3) &quot;zhima&quot;# 携带权重输出127.0.0.1:6379&gt; zrange salary 0 -1 withscores1) &quot;zhima&quot;2) &quot;1000&quot;3) &quot;xiaozhang&quot;4) &quot;1500&quot;5) &quot;lizhi&quot;6) &quot;2000&quot;# zrangebyscore key min max [withscores] [limit offset count]# 获取score在min到max之间的元素，闭区间127.0.0.1:6379&gt; zrangebyscore salary 1000 16001) &quot;zhima&quot;2) &quot;xiaozhang&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf1) &quot;zhima&quot;2) &quot;xiaozhang&quot;3) &quot;lizhi&quot;# zrevrangebyscore key max min [withscores] [limit offset count]# 倒叙输出score在max到min之间的，闭区间，# [limit offset count]是指定显示从offset开始的count个数据，包括offset所在的元素127.0.0.1:6379&gt; zrevrangebyscore salary 1600 10001) &quot;xiaozhang&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zadd salary 10 xiaoming 27 ziaohzhyang 19 zhima 25 lizhi(integer) 4127.0.0.1:6379&gt; zrangebyscore salary 10 191) &quot;xiaoming&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 withscores1) &quot;xiaoming&quot;2) &quot;10&quot;3) &quot;zhima&quot;4) &quot;19&quot;5) &quot;lizhi&quot;6) &quot;25&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 limit 0 21) &quot;xiaoming&quot;2) &quot;zhima&quot;# 删除元素127.0.0.1:6379&gt; zrem salary xiaoming(integer) 1# 查看该集合的长度# zcard key127.0.0.1:6379&gt; zcard salary(integer) 3# 查看符合[min,max]区间的元素个数# zcount key min max127.0.0.1:6379&gt; zcount salary 10 19(integer) 2 注：以上命令只是常用命令，更多命令可以在官网查看 英文官网地址：https://redis.io/ 中文官网地址：http://www.redis.cn/","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-前期准备","slug":"Redis-前期准备","date":"2022-02-19T09:36:09.000Z","updated":"2022-02-21T04:15:07.083Z","comments":true,"path":"javaEE/Redis/2022/02/19/Redis-前期准备/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Redis/2022/02/19/Redis-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","excerpt":"","text":"Nosql我们先前学的都是mysql，它是关系型数据库，表与表之间有联系。 NoSql即非关系型数据库。 MySql MySql的瓶颈 数据太大了，一个机器就放不下了 30万以上的数据，需要使用索引（B+Tree） 访问量大的话，服务器压力大 解决方案：读写分离（垂直拆分） 因为80%网站对于数据的操作都是读取，不会产生并发问题，所以为了提升效率，当我们第一次读取完数据后，将数据放入缓存中，下一次查询如果是同样的业务，则直接从缓存中读取数据，会大大提升性能，解决了读的压力 解决方案：分库分表，MySql集群（水平拆分）每一个集群放一些表和数据库，这样的操作解决了写的压力 如今的数据数据量大，变化快，导致mysql无法很好的解决问题。 有的人使用mysql来存储一些比较大的文件，博客推文，图片等，数据库非常庞大，效率十分低下。 如果有一种数据库来专门处理这种数据，mysql的压力就变小了。这时候就需要使用Nosql了 特点 方便拓展（数据之间联系低，很好拓展） 大数据高性能（Redis1s读11万次，写8万次，Nosql的缓存记录，是一种细粒度的缓存，性能比较高） 数据多样，不需要事先设计数据库 大数据时代的3V：出现的一些问题 Volume 海量 Variety 多样 Velocity 实时 大数据时代的3高：对程序的要求 高性能 高可用（扩） 高并发 Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis+Tair 阿里+百度：Redis+MemeCache 应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于些日志系统等等。 数据模型：Key 指向的键值对Value，通常用hash table来实现 优点：查找速度快 缺点：数据无结构，通常只被当做字符串或者二进制存储 文档型数据库（BSON格式） MongoDB 基于分布式文件存储的数据库，C++编写的，主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中间的产物，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的 ConthDB 应用场景：web应用 数据模型：key-value键值对（Value为结构化数据） 优点：数据结构要求不严格表结构可不需要像关系型数据库那样需要预先定义表结构 缺点：查询效率不高，而且缺乏统一的查询语句 列存储数据库 HBase 应用场景：分布式文件系统 数据模型：以列簇式存储，将同一列数据存储在一起 优点：查找速度快，可拓展性强，容易实现分布式文件系统 缺点：功能相对局限 图形关系数据库 存的是关系，不是存图形的 Neo4j InfoGrid 应用场景：社交网络、相关推荐 数据模型：图架构 优点：利用图结构相关算法，比如最短路径寻址N度关系查找等 缺点：很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方式 Redis简介概述 Redis全名是Remote Dictionary Server ，即远程字典调用 默认端口是6379 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 它使用ANSI、C语言编写的、支持网络、可以基于内存亦可持久化的日志型、Key-value数据库、并提供多种语言的API，亦被称为结构化数据库 下载下载后直接解压即可12链接：https://pan.baidu.com/s/12ozkQkUss8GH70lf7qrinQ 提取码：nv5z 点击redis-server.exe即可启动服务 备注Redis推荐我们使用Linux使用redis，所以接下来使用阿里云服务器来学习redis 12链接:https://pan.baidu.com/s/1Hy1eFwcSqfftXrWv92-zug 提取码:u1ff 将压缩文件解压到服务器的opt目录下即可，进入解压后的目录，然后安装gcc-c++ 12yum install gcc-c++make 也可以使用docker创建redis容器 1234# 开启一个redis容器并设置密码docker run -it --name studyredis -p6379:6379 --requirepass lizhi9275 redis# 查看运行的容器docker ps","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"}]},{"title":"Springboot-shiro","slug":"SpringBoot-Shiro","date":"2022-02-17T03:56:42.000Z","updated":"2022-02-19T07:42:38.688Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","excerpt":"","text":"Shiro简介其实这个就是一个关于做安全管理的框架，他不仅可以和javaEE结合也可以和javaSE结合 提供的功能 Authentication：身份认证，登录，验证用户的身份 Authorization：授权， Session Management： Shiro内置的session，对其进行管理 Cryptography：加密，保证数据的安全性 Web Support： web支持，可以很好的集成到web环境 Caching： 缓存， Concurrency： 多并发 Testing：测试 Remember Me：”记住我”的功能 Shiro结构我们来观察一下Shiro的结构 解释一下出现的名词 subject：与当前应用交互的任何东西都可以是Subject，与Subject的所有交互都会委托给SecurityManager，Subject其实只是一个门面，SecurityManager 才是实际的执行者 SecurityManager：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，并且它管理着所有的Subject，它是Shiro的核心，它负责与Shiro的其他组件进行交互 Realm： Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager 要验证用户身份，那么它需要从Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行 快速开始（看一下直接过）导入依赖 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/jcl-over-slf4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置文件 log4j.properties 123456789101112131415161718log4j.rootLogger=INF0,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# GeneraL Apache Librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Defautt Shiro Logginglog4j.logger.org.apache.shiro=INF0# DisabLe verbose Logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini 12345678910111213141516171819202122232425[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27;（&quot;That&#x27;s the same combination on# my Luggage!!!&quot; ;)), and rote &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhe met&#x27; with password &#x27;Ludicrousspeed’and rotes &#x27;darklord’and &#x27;schwartzdarkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;tonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# RoLes with assigned permissions# Each Line conforms to the format defined in the# org.apache.shiro.reatm.text.TextConfigurationReatm#setRoleDefinitions JavaDoc# -[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard&#x27;* &#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is aLlowed to &#x27;drive&#x27; (action) the winnebago (type) with# ticense plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5 ShiroQuickStart.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ShiroQuickStart &#123; private static final Logger LOG = LoggerFactory.getLogger(ShiroQuickStart.class); public static void main(String[] args) &#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;,&quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if(&quot;aValue&quot;.equals(value))&#123; LOG.info(&quot;Retrieved the correct value&quot;); &#125; if(!currentUser.isAuthenticated())&#123; UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestar&quot;, &quot;vespa&quot;); token.setRememberMe(true); try&#123; currentUser.login(token); &#125;catch (UnknownAccountException uae)&#123; LOG.info(&quot;There is no user with username whith &quot;+ token.getPrincipal()); &#125;catch (IncorrectCredentialsException ice)&#123; LOG.info(&quot;Password for account&quot;+ token.getPrincipal()+&quot;was incorrect&quot;); &#125;catch (LockedAccountException lae)&#123; LOG.info(&quot;The Account for userName&quot;+ token.getPrincipal()+&quot;is locked. &quot; + &quot;Please contact your administrator to unlocked it&quot;); &#125;catch (AuthenticationException ae)&#123; //unexpected exception &#125; &#125; LOG.info(&quot;USER[&quot;+ currentUser.getPrincipal()+&quot;] logged in successfully&quot;); if(currentUser.hasRole(&quot;schwartz&quot;))&#123; LOG.info(&quot;May the Schwartz be with you&quot;); &#125;else &#123; LOG.info(&quot;Hello,Mere mortal&quot;); &#125; if(currentUser.isPermitted(&quot;lightsaber:wield&quot;))&#123; LOG.info(&quot;You may use a lightsaber ring use it wisely&quot;); &#125;else &#123; LOG.info(&quot;Sorry, light rings are for schwartz masters only&quot;); &#125; if(currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;))&#123; LOG.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate(id) &#x27;eagle5&#x27;. &quot; + &quot;Here are the keys-have fun!&quot;); &#125;else &#123; LOG.info(&quot;Sorry,you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago&quot;); &#125; currentUser.logout(); System.exit(0); &#125;&#125; 运行输出 123456789101112131415161718192021222324252627282930313233342022-02-17 14:33:37,982 DEBUG [org.apache.shiro.io.ResourceUtils] - Opening resource from class path [shiro.ini] 2022-02-17 14:33:38,021 DEBUG [org.apache.shiro.config.Ini] - Parsing [users] 2022-02-17 14:33:38,026 DEBUG [org.apache.shiro.config.Ini] - Parsing [roles] 2022-02-17 14:33:38,523 DEBUG [org.apache.shiro.config.IniFactorySupport] - Creating instance from Ini [sections=users,roles] 2022-02-17 14:33:38,571 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [roles] section. Processing... 2022-02-17 14:33:38,575 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [users] section. Processing... 2022-02-17 14:33:38,594 DEBUG [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - No sessionValidationScheduler set. Attempting to create default instance. 2022-02-17 14:33:38,595 INFO [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - Enabling session validation scheduler... 2022-02-17 14:33:38,625 DEBUG [org.apache.shiro.session.mgt.DefaultSessionManager] - Creating new EIS record for new session instance [org.apache.shiro.session.mgt.SimpleSession,id=null] 2022-02-17 14:33:39,022 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - Retrieved the correct value 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - Looked up AuthenticationInfo [null] from doGetAuthenticationInfo 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - No AuthenticationInfo found for submitted AuthenticationToken [org.apache.shiro.authc.UsernamePasswordToken - lonestar, rememberMe=true]. Returning null. 2022-02-17 14:33:39,030 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - There is no user with username whith lonestar SpringBoot整合Shiro先按照以下步骤把基本的环境搭好 导入依赖，这里只显示shiro的相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt; 实体类User.java 12345678910@Data@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User &#123; private int id; private String userName; private String password; private String perms;&#125; 配置类ShiroConfig.java 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); return shiroFilterFactoryBean; &#125; //DefaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Autowired UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; &#125; //realm,需要自定义，用来做授权和认证的 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; UserRealm.java 1234567891011121314151617public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserMapper userMapper; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); return null; &#125;&#125; index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;ul&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; user的add页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的add&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的del页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的delete&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的update页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的update&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; MyController.java 1234567891011121314151617181920212223242526272829package com.lizhi.springbootshiro.contoller;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MyController &#123; @GetMapping(&quot;/index&quot;) public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,shiro&quot;); return &quot;index&quot;; &#125; //这里是restful风格 @GetMapping(&quot;/user/&#123;method&#125;&quot;) public String operateUser(@PathVariable(&quot;method&quot;) String method)&#123; return &quot;user/&quot;+method; &#125;&#125; UserMapper.java user表中就三个字段。id,user_name,password,perms 12345@Mapperpublic interface UserMapper &#123; List&lt;User&gt; listAllUsers(); User getUserByName(String userName);&#125; UserMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.springbootshiro.mapper.UserMapper&quot;&gt; &lt;select id=&quot;listAllUsers&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` &lt;/select&gt; &lt;select id=&quot;getUserByName&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` where user_name = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt; 登录拦截登录拦截指的是，未登录的用户不得进入用户的增删改页面 下面是集中拦截规则，一般authc和perms用的比较多 1234567/** * anno： 无需认证即可访问 * authc：必须认证了才可以访问 * perms：必须拥有权限才可以访问 * roles：必须拥有某种角色才可以访问 * user：必须拥有记住我的功能的时候才可以访问（一般很少用） */ 这是在ShiroFilterFactoryBean中配置的 1234567891011121314151617@Beanpublic ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //设置该路径只有user:add才可以访问 filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //设置该路径只有user:update才可以访问 filterMap.put(&quot;/user/del&quot;,&quot;perms[user:del]&quot;); //设置该路径只有user:del才可以访问 filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;); //设置登录的路径 shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;); //设置登录成功的路径 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauth&quot;); //设置未授权的用户被访问后跳转的路径 return shiroFilterFactoryBean;&#125; login.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;p style=&quot;color: red&quot;&gt;[[$&#123;error&#125;]]&lt;/p&gt; &lt;form th:action=&quot;@&#123;/login.do&#125;&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; MyController中配置路径 123456789101112131415161718192021222324252627282930@GetMapping(&quot;/login&quot;)public String login()&#123; return &quot;login&quot;;&#125;@GetMapping(&quot;/unauth&quot;)@ResponseBody //这里偷懒没写页面了，而是直接将消息返回到页面中public String unauthorized()&#123; return &quot;未经授权无法访问此页面&quot;;&#125;@GetMapping(&quot;/login.do&quot;)public String doLogin(String userName, String password, Model model) &#123; //获取当前用户 Subject currentUser = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(userName, password); try&#123; currentUser.login(token);//这里下一步是到userRealm的认证方法 //如果没有抛出异常，则说明登录成功 Subject currentUser = SecurityUtils.getSubject(); //拿到shiro内部的session保存数据， currentUser.getSession().setAttribute(&quot;loginInfo&quot;,user); return &quot;index&quot;; &#125;catch (UnknownAccountException uae)&#123; model.addAttribute(&quot;error&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException ice)&#123; model.addAttribute(&quot;error&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125;&#125; 用户认证案例走到这里，你会发现无论怎么登录都是错的，那是因为我们还没有对用户进行认证。 用户认证指的是，当用户登录的时候，对其进行验证 1234567891011121314151617@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); /** * 数据库中读取数据 */ UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; User user = userMapper.getUserByName(token.getUsername()); if(user==null)&#123; //这里如果返回null的话，会自动抛出异常到下图处 return null; &#125; //这里的第一个参数user会设置给当前登录对象的Principal中。 //可以通过SecurityUtils.getSubject().getPrincipal()获取 //第二个参数传入正确的密码，即数据库中的密码，交给shiro来做密码的校验，如果密码错误，也会抛出异常到下图的地方 return new SimpleAuthenticationInfo(user, user.getPassword(),&quot;&quot;);&#125; 这里插上一嘴，在web环境中，通过subject拿到的session即web框架中的那个session。 但是如果shiro没有使用在web环境的话，内部也是有一个session的，但是那个就不是web中的session了。 用户授权好啦，现在案例已经可以跑起来了，并且如果账号密码正确的话是可以登录的，并且返回到主页 还记得我们在下图配置的这一串让人一头雾水的配置吗？ 这里就只是配置了一个规则，但是具体登录的用户的授权还没有做，我们现在去完成它吧 1234567891011121314@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //这里需要根据用户表的数据进行增加权限 Subject subject = SecurityUtils.getSubject(); //拿到用户认证的时候传入的user User currentUser = (User) subject.getPrincipal(); System.out.println(&quot;权限为：&quot;+ currentUser.getPerms()); //数据库中perms字段是以这样的形式存储的 user:add,user:update //所以需要将其用，分割然后使用工具类将其转换为集合传入addStringPermissions info.addStringPermissions(Arrays.asList(currentUser.getPerms().split(&quot;,&quot;))); return info;&#125; 现在就完成了所有的配置啦！大家可以尝试一下 这里再多完成一个需求，就是首页只显示用户具有权限的链接 首先需要导入thymeleaf的依赖，然后再导入命名空间xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 配置一个bean 12345//整合thymeleaf@Beanpublic ShiroDialect shiroDialect()&#123; return new ShiroDialect();&#125; index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;p&gt;[[$&#123;msg&#125;]]&lt;/p&gt; &lt;!--当session中没有登录信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo==null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;!--当session有信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo!=null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;!--或者像这样写，不用将用户信息存入session &lt;p shiro:notAuthenticated&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;p shiro:authenticated&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; --&gt; &lt;ul&gt; &lt;li shiro:hasPermission=&quot;user:add&quot;&gt;&lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:del&quot;&gt;&lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:update&quot;&gt;&lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 注销大家都应该注意到了，上面的页面中多了一个注销的链接，接下来我们来完成一下注销的功能 12345@GetMapping(&quot;/logout&quot;)public String logout()&#123; SecurityUtils.getSubject().logout(); return &quot;index&quot;;&#125; 是的，你没有看错，就是这么简单，shiro已经将其完美得封装好了 以上","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"swagger","slug":"SpringBoot-Swagger","date":"2022-02-17T02:11:19.000Z","updated":"2022-02-24T10:59:38.726Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","excerpt":"","text":"Swagger 号称世界上最流行的API框架 RestFul风格的API展示可以实现API文档和API定义同步更新 SpringBoot整合Swagger 导入相关依赖 1234567891011121314151617&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要web的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 写一个简单的Controller 1234567@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 开启Swagger功能 1234@Configuration@EnableSwagger2public class SwaggerConfig &#123; &#125; 访问swagger-ui.html 我们在ui的jar包中可以知道我们可以访问该页面 这是访问的页面 配置SwaggerSwagger中用来配置的bean是Docket 配置文档信息123456789101112131415161718@Beanpublic Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo());&#125;//配置swagger信息public ApiInfo apiInfo()&#123; return new ApiInfo( &quot;swagger测试&quot;,//文档名称 &quot;初次测试swagger&quot;,//文档描述 &quot;1.0&quot;,//版本号 &quot;http://li-zhi.net.cn/&quot;,//作者个人博客 new Contact(&quot;李智&quot;,&quot;http://li-zhi.net.cn/&quot;,&quot;1158778689@qq.com&quot;),//作者联系方式 &quot;Apache 2.0&quot;,//开源协议 &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() );&#125; 配置模型1234567@Controllerpublic class SwaggerModelConfig &#123; @GetMapping(&quot;/user&quot;) public User user()&#123; return new User(); &#125;&#125; 我是专门建了一个SwaggerModelConfig来放置所有的模型类 配置分组因为项目一般是分组协同开发，每个组各自开发的接口，那接口文档应该各自分开，所以就有了分组的需要 分组只需要配置一个groupName(“groupName”)即可 12345678910@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;);&#125; 配置扫描的接口这里主要讲两种方式，第一种是按路径扫描，第二种是按包名扫描 按路径扫描123456789@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .select() .paths(PathSelectors.ant(&quot;/user/**&quot;)) // 该配置下，该组会扫描所有的/user/下的所有的API .build();&#125; 按包名扫描123456789@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.lizhiswaggertest.controller&quot;)) //该配置下，该组会扫描所有此包下的API接口 .build();&#125; 在类RequestHandlerSelectors中还有其他的扫描机制，可自行研究 根据环境控制是否能访问swagger一般产品的开发都会有开发、测试、运维、上线等多套环境，根据不同的环境，控制是否可以访问swagger的ui界面 配置文件application.yml 1234567891011121314151617181920212223---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: test---server: port: 8083spring: profiles: pro---spring: profiles: active: dev 配置dev环境和test环境可以使用swagger 12345678@Beanpublic Docket docket1(Environment environment)&#123; Profiles devProfile = Profiles.of(&quot;dev&quot;,&quot;test&quot;); boolean dev = environment.acceptsProfiles(devProfile); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .enable(dev);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"单例设计模式","slug":"设计模式-单例设计模式","date":"2022-02-16T11:02:56.000Z","updated":"2022-02-25T01:43:38.836Z","comments":true,"path":"设计模式/2022/02/16/设计模式-单例设计模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式该设计模式解决的问题是，一个环境中只会存在一个该类的对象 该模式有五种实现方式 恶汉模式 懒汉模式 静态内部类模式 枚举模式 该设计模式的核心是构造方法私有化 饿汉模式恶汉模式：见名知意，就是在类被加载的时候就创建。 案例：Runtime类 缺点：浪费内存空间 我查了资料，查到了这个缺点，但是这个缺点我不时很能理解 123456789public class Hungry &#123; private final static Hungry HUNGRY = new Hungry(); private Hungry()&#123; &#125; public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 懒汉模式这种实现方式，我们从分几个版本从简单到复杂 Version 0112345678910111213public class LazyMan &#123; private static LazyMan lAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(lAZYMAN==null)&#123; //A lAZYMAN = new LazyMan(); &#125; return lAZYMAN; &#125;&#125; 缺点：只能在单线程中安全，多线程中是不安全的 现在有线程A和线程B，线程A走到了注解A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全 Version 02123456789101112public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public synchronized static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; LAZYMAN = new LazyMan(); &#125; return LAZYMAN; &#125;&#125; 缺点：为方法加锁，确实保证了单例模式，但是我们都知道同步方法，锁的是LazyMan的Class类，所以我们得知这种方式可以保证单例模式的线程安全。但是我们好好想想，当我们创建了第一个单例对象之后，还需要锁来保证同步吗？答案显而易见，肯定是不需要的，所以这种方式效率低下，需要改进，我们来看下一个版本 Version 03123456789101112131415public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; LAZYMAN = new LazyMan(); &#125; &#125; return LAZYMAN; &#125;&#125; 我们不使用同步方法来保证所有的线程同步，我们只对LAZYMAN对象还为null的线程同步，这时候又出现了问题。我们来分析一下 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全，我们发现这和我们没有加锁的时候的情形几乎一模一样。我们来看下一个版本，双重锁机制 Version 04public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125; &#125; 我个人的理解是第一重锁是为了过滤LAZYMAN为NULL的线程，第二重锁是为了保证只能有一个线程去创建对象，这时候我们似乎找不到什么破绽了，我们来继续往下看 Version 05123456789101112131415161718public class LazyMan &#123; private volatile static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125;&#125; 乍一看，好像和上一个版本没什么区别，仔细一看，其实区别是在这个单例变量的修饰符多了一个volatile。 volatile三大作用 保证可见性 不保证原子性 禁止该变量出现的地方发生指令重排 这里的话，我们使用到的特性是第三点，我们来分析一下 LAZYMAN = new LazyMan(); 这一句话其实执行了三个步骤 开辟一个内存空间 初始化对象 将该内存空间的地址指向变量 JVM内部会有一种叫指令重排的代码优化机制，这时候，这三者的顺序就有可能会改变。 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，开始执行LAZYMAN = new LazyMan();开辟内存空间后，没有先初始化对象，而是先将该内存空间的地址指向变量，这时候线程A抢回了CPU，这时候的LAZYMAN已经不是NULL了，直接将其返回了出去，但是这个对象其实还没有初始化，还是个空架子，这就出现了问题。 当然这种情况十分十分少，但是为了严谨性，最好还是加上volatile关键词禁止指令重排 静态内部类模式1234567891011public class StaticWay &#123; private StaticWay()&#123; &#125; public static class InnerClass&#123; private static final StaticWay STATICWAY = new StaticWay(); &#125; public static StaticWay getInstance()&#123; return InnerClass.STATICWAY; &#125;&#125; 该实现方式其实就是利用的JVM的一些特性 类的加载分为以下过程 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中生成一个代表该类的Class对象，作为方法区类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程，当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 ，JVM会保证类构造器在多线程环境下被正确加锁 其实最开始的饿汉单例模式也是也是这个原理 颠覆其实一路到了这里，以上方法都是不安全的。因为java有一个很牛X的包。 java.lang.reflect 我们在最开始说过，单例模式的本质就是构造器私有化，但是java的反射机制，它不讲武德，它可以直接修改权限修饰符。我们来看看代码。 12345678public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;Hungry&gt; constructor = Hungry.class.getDeclaredConstructor(null); constructor.setAccessible(true); Hungry hungry1 = Hungry.getInstance();; Hungry hungry2 = constructor.newInstance(); System.out.println(hungry1==hungry2);&#125;//可想而知最后的结果是 false 可不可以对其作出防御呢？ 1234567891011121314private Hungry()&#123; if(HUNGRY!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;&#125;Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) at com.lizhi.hungry.Hungry.main(Hungry.java:26)Caused by: java.lang.IllegalArgumentException: 请不要尝试使用反射破坏单例模式 at com.lizhi.hungry.Hungry.&lt;init&gt;(Hungry.java:15) ... 5 more 上述方法对饿汉已经作出了合适的防御，那对于懒汉模式，如果两个对象都是使用反射创建的呢？这时候这个防御就是形同虚设了，因为我们肯定是禁止反射去创建对象，所以这种肯定是不行的 123456789101112131415161718192021222324252627282930public class LazyMan &#123; private static LazyMan LazyMan; private LazyMan()&#123; if(LAZYMAN!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; synchronized (LazyMan.class)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 我们引入一个布尔值来完成这个任务 12345678910111213141516171819202122232425262728293031public class LazyMan &#123; private volatile static LazyMan LazyMan; private volatile static boolean flag ; private LazyMan()&#123; if(flag)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; flag=true; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance();// LazyMan lazyMan2 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance();// LazyMan lazyMan1 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 这样反射就无法控制我们的单例了！ 枚举类这时候有没有想起来我们在学javaSE的时候就学到了一个自带单例模式的类型，那就是枚举类Enum！ 我们来尝试攻击一下枚举类！ 1234567891011public enum SingleEnum &#123; SINGLETON; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;SingleEnum&gt; constructor = SingleEnum.class.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); SingleEnum single1 = constructor.newInstance(&quot;single&quot;, 2); SingleEnum single2 = constructor.newInstance(&quot;single&quot;, 2); System.out.println(single1==single2); &#125;&#125; 这时候发现报错了！！ 123Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:484) at com.lizhi.SingleEnum.main(SingleEnum.java:12) 我们点进newInstance方法看下源码， 1234567891011121314151617181920@CallerSensitive@ForceInline // to ensure Reflection.getCallerClass optimizationpublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, clazz, modifiers); &#125; if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125; 我们发现了这句话throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); 这就解释通了，原来是java的反射已经处理好了枚举类，使其真正的实现了安全的单例！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂设计模式","slug":"设计模式-工厂设计模式","date":"2022-02-16T11:01:20.000Z","updated":"2022-02-25T01:45:08.928Z","comments":true,"path":"设计模式/2022/02/16/设计模式-工厂设计模式/","link":"","permalink":"http://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂设计模式该设计模式解决的问题是：将类实例化的操作与使用对象的操作分开，让使用者不用知道具体参数就可以实例化出所需要的产品类，从而避免了在客户端代码中显式指定，实现了解耦。 该设计模式分为三种实现 简单工厂设计模式 工厂方法实现模式 抽象工厂实现模式 简单工厂设计模式一个汽车工厂生产汽车。有特斯拉、大众、五菱 车的接口 123public interface Car &#123; void printName();&#125; 大众 123456public class DaZhong implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;大众&quot;); &#125;&#125; 特斯拉 123456public class TeSiLa implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;特斯拉&quot;); &#125;&#125; 五菱 123456public class WuLin implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;五菱宏光&quot;); &#125;&#125; 工厂 12345678910111213public class CarFactory &#123; public static Car getCar(String carName)&#123; if(&quot;大众&quot;.equals(carName))&#123; return new DaZhong(); &#125;else if(&quot;五菱宏光&quot;.equals(carName))&#123; return new WuLin(); &#125;else if(&quot;特斯拉&quot;.equals(carName))&#123; return new TeSiLa(); &#125;else &#123; return null; &#125; &#125;&#125; 缺点：很难横向拓展，如果我后期需要加新的车型，需要改变原来的代码，不符合开闭原则（OOP七大原则） 优点：简单易懂 可以简单优化 1234567891011public class CarFactory &#123; public static Car getWuLin()&#123; return new WuLin(); &#125; public static Car getDaZhong()&#123; return new DaZhong(); &#125; public static Car getTeSiLa()&#123; return new TeSiLa(); &#125;&#125; 工厂方法实现模式还是简单工厂的模型，我们来换个工厂 这一次我们定义一个汽车工厂的接口 123public interface CarFactory &#123; Car getCar();&#125; 特斯拉工厂 123456public class TeSiLaCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new TeSiLa(); &#125;&#125; 大众工厂 123456public class DaZhongCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new DaZhong(); &#125;&#125; 五菱工厂 123456public class WuLinCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new WuLin(); &#125;&#125; 缺点：当汽车类型很多的时候，会有很多很多很多各自的工厂，没有必要 抽象工厂实现模式这次我们换一个场景：小米和华为都有路由器和手机的产品 路由器接口 1234public interface Router &#123; void doConfig(); void printInfo();&#125; 手机接口 1234public interface MobilePhone &#123; void sendMsg(); void callUp();&#125; 厂家接口 1234public interface ProductFactory &#123; MobilePhone getMobilePhone(); Router getRouter();&#125; 华为手机 1234567891011public class HuaWeiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;华为手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;华为手机打电话&quot;); &#125;&#125; 华为路由器 1234567891011public class HuaWeiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;华为路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;华为路由器打印详细信息&quot;); &#125;&#125; 小米路由器 1234567891011public class XiaoMiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;小米路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;小米路由器打印详细信息&quot;); &#125;&#125; 小米手机 1234567891011public class XiaoMiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;小米手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;小米手机打电话&quot;); &#125;&#125; 华为厂商 1234567891011public class HuaWeiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new HuaWeiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new HuaWeiRouter(); &#125;&#125; 小米厂商 1234567891011public class XiaoMiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new XiaoMiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new XiaoMiRouter(); &#125;&#125; 两个维度，第一个维度是产品族（路由器、手机），第二个维度是具体厂商（华为，小米）。 根据这两种维度分别设计了接口，抽象的工厂定义生产哪些产品族，具体的工厂具体实现自己的产品族","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot-Security","slug":"SpringBoot-Security","date":"2022-02-16T08:20:46.000Z","updated":"2022-02-16T10:44:14.790Z","comments":true,"path":"javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","excerpt":"","text":"简介Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理! Spring Security的两个主要目标是“认证”和“授权”（访问控制） “认证”(Authentication) “授权” (Authorization) 这个概念是通用的，而不是只在Spring Security 中存在。 基本使用 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 继承WebSecurityConfigurerAdapter 123@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 重写以下方法做出权限设置 1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //首页都可以访问，但是各个级别下的页面设置成只能各自的级别才可以访问 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/vip1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/vip2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/vip3/**&quot;).hasRole(&quot;vip3&quot;); //没有权限默认回到登录页面，loginPage设置登录页面，loginProcessingUrl设置登录提交的api //如果只写 http.formLogin();会有一个默认登录页面和默认的登录提交的api http.formLogin().loginPage(&quot;/login&quot;).loginProcessingUrl(&quot;/user/api/login&quot;); //设置退出时候使session失效，logoutSuccessUrl设置退出成功的页面 http.logout().invalidateHttpSession(true).logoutSuccessUrl(&quot;/index&quot;); //设置’记住我‘的功能 //remember-me为默认提交的参数 http.rememberMe().rememberMeParameter(&quot;remember&quot;);&#125; 重写以下方法做出授权处理 123456789101112@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; /** * 这里要从数据库读 */ //BCryptPasswordEncoder为密码设置加密，如果不设置会报错，也可以使用其他加密的类 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); auth.inMemoryAuthentication().passwordEncoder(encoder) .withUser(&quot;zhima&quot;).password(encoder.encode(&quot;a&quot;)).roles(&quot;vip1&quot;,&quot;vip3&quot;) .and() .withUser(&quot;lizhi&quot;).password(encoder.encode((&quot;123456&quot;))).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;);&#125; 测试 thymeleaf模板结合SpringSecurity导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 观察这个页面的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;!isAuthenticated()&quot;当用户没登录的时候--&gt; &lt;p&gt;首页&lt;/p&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;isAuthenticated()&quot;当用户登录的时候--&gt; 用户名：&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;name&quot;取出用户的用户名--&gt; 授权：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;principal.authorities&quot;取出用户的roles--&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;如果当前登录用户有vip1权限则显示此div--&gt; &lt;span&gt;vip1&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/1&#125;&quot;&gt;vip1-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/2&#125;&quot;&gt;vip1-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/3&#125;&quot;&gt;vip1-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;如果当前登录用户有vip2权限则显示此div--&gt; &lt;span&gt;vip2&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/1&#125;&quot;&gt;vip2-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/2&#125;&quot;&gt;vip2-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/3&#125;&quot;&gt;vip2-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;如果当前登录用户有vip3权限则显示此div--&gt; &lt;span&gt;vip3&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/1&#125;&quot;&gt;vip3-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/2&#125;&quot;&gt;vip3-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/3&#125;&quot;&gt;vip3-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"ForkJoin","slug":"ForkJoin","date":"2022-02-11T08:48:02.000Z","updated":"2022-02-11T09:27:57.367Z","comments":true,"path":"javaEE/JUC/2022/02/11/ForkJoin/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JUC/2022/02/11/ForkJoin/","excerpt":"","text":"ForkJoin什么是ForkJoin？并行执行任务，提交效率，大数据量的时候使用！ 把大任务拆分成小任务 ForkJoin特点：工作窃取内部维护的双端队列，两端都可以出 如何使用 创建ForkJoinPool对象 新建一个计算任务ForkJoinTask放入池子中计算 1234567891011121314151617181920212223242526272829303132package com.lizhi;import java.util.concurrent.RecursiveTask;public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private long start; private long end; private long temp = 10000L; public ForkJoinDemo(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override public Long compute()&#123; long result = 0; if(end-start&lt;temp)&#123; for (long i = start; i &lt;= end; i++) &#123; result+=i; &#125; &#125;else &#123; long middle = (start + end) / 2; ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start,middle); forkJoinDemo1.fork(); ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle,end); forkJoinDemo2.fork();//把任务压入线程队列 result = forkJoinDemo1.join()+ forkJoinDemo2.join(); &#125; return result; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"http://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"http://li-zhi.net.cn/tags/JUC/"}]},{"title":"函数式接口","slug":"函数式接口","date":"2022-02-11T07:13:29.000Z","updated":"2022-02-17T03:09:30.549Z","comments":true,"path":"琐碎的知识/2022/02/11/函数式接口/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"函数式接口函数式接口，即只有一个抽象方法的接口即为函数式接口，可以使用lambda表达式简化使用。 函数式接口一般接口上都会有@FunctionInterface注解做标记，作用是检查该接口是否只有一个抽象方法，如果不写，但是接口中确实只有一个抽象方法，也不会影响lambda的使用，下面我们来看一下一些常见的函数式接口 Function&lt; T , R &gt;函数型接口 T为传入参数的类型 R为返回值类型 123Function&lt;String, String&gt; f = s -&gt; s.substring(2,4);String apply = f.apply(&quot;asdas asd &quot;);System.out.println(apply); Predicate&lt; T &gt;断言型接口 T为传入参数的类型 返回值为Boolean 123Predicate&lt;String&gt; p = t-&gt;t.length()&gt;5;System.out.println(p.test(&quot;3223&quot;));System.out.println(p.test(&quot;saf223&quot;)); Consumer&lt; T &gt;消费者型接口 T为传入的参数 无返回值 123Consumer&lt;String&gt; consumer = c-&gt; System.out.println(&quot;我使用了&quot;+c);consumer.accept(&quot;123&quot;);consumer.accept(&quot;456&quot;); Supplier&lt; T &gt;生产者型接口 T为返回值类型 12Supplier&lt;String&gt; supplier = ()-&gt; UUID.randomUUID().toString();System.out.println(supplier.get());","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"线程池","slug":"JUC-线程池","date":"2022-02-11T06:31:26.000Z","updated":"2022-02-11T07:22:22.592Z","comments":true,"path":"javaEE/多线程/2022/02/11/JUC-线程池/","link":"","permalink":"http://li-zhi.net.cn/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022/02/11/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"线程池三大方法我们先看使用Executors创建的三种线程池 123Executors.newSingleThreadExecutor();//创建一个只有一个线程的线程池Executors.newFixedThreadPool();//创建一个固定数目的线程的线程池Executors.newCachedThreadPool();//缓存池，会复用之前使用过的线程 执行线程 12345678public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); &#125;&#125; 七大参数阿里巴巴规范中有这么一条 12345线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下：1）FixedThreadPool和SingleThreadPool: 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。2）CachedThreadPool: 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 我们来看看创建这三种线程池的构造方法 1234567891011121314151617public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以发现，这三个构造方法创建的对象其实都是ThreadPoolExecutor对象，只不过就是构造参数不一样。 参数 作用 int corePoolSize 核心线程池的大小 int maximumPoolSize 最大线程池的大小 long keepAliveTime 超时时间过后就释放 TimeUnit unit 超时时间单位 BlockingQueue&lt; Runnable&gt; workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂，创建线程的，一般不用动 RejectedExecutionHandler handler 拒绝策略 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize为一直开着的线程数，当workQueue已经满了，则继续开启线程直到maximumPoolSize，当线程数到了maximumPoolSize，然后workQueue也满了，如果还有新的任务，则使用handler拒绝策略对其进行处理。 当corePoolSize-maximumPoolSize区间的线程等待了workQueue时间后，还是没任务来，则关闭该区间的线程 123456789ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); CPU密集型和IO密集型最大线程数到底如何定义？ CPU密集型几核CPU就是几，可以保证效率最高 1Runtime.getRuntime().availableProcessors()//动态获取cpu核数 IO密集型程序里面有多少个非常消耗IO的线程，一般最大线程数设置为该数字的两倍 四大拒绝策略 AbortPolicy不处理此任务，并且抛出异常 CallerRunsPolicy不处理此任务，往上传递此任务，哪来的回哪里去 DiscardOldestPolicy不处理此任务，不会抛出异常 DiscardPolicy尝试和最老的那一个线程竞争，不会抛出异常","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"http://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JVM-简介","slug":"JVM-简介","date":"2022-02-10T04:24:26.000Z","updated":"2022-03-18T10:13:51.013Z","comments":true,"path":"javaEE/JVM/2022/02/10/JVM-简介/","link":"","permalink":"http://li-zhi.net.cn/javaEE/JVM/2022/02/10/JVM-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"JVM的体系结构下面是简易的结构图 栈中不会有垃圾回收 大部分JVM调优都是在堆内存上进行调优 详细的结构图如下 沙箱安全机制​ java安全模型的核心就是java沙箱（sandbox）。沙箱是一个限制程序运行的环境。沙箱机制就是将java代码限定在JVM特定的运行范围内，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源（CPU，内存，文件系统，网络）访问。不同级别的沙箱对这些资源的限制就不一样 ​ 所有的java程序运行都可以指定沙箱，可以指定安全策略。 ​ 在java中，将执行过程分为本地代码和远程代码两部分，本地代码是默认可信任的，而远程代码则被看做是不受信任的。对于授予信任的本地代码，可以访问一切本地资源。而对于非授予信任的远程代码在早期的java实现中，完全依赖于java沙箱机制。下图是jdk1.0的安全模型 ​ 但是如此严格的安全机制也给程序的功能拓展带来了障碍，比如用户希望远程代码访问本地资源的时候，就会被沙箱机制所拒绝。所以在后来的jdk1.1版本中，针对安全机制做出了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。下图是jdk1.1的安全模型 ​ 在jdk1.2的版本中，再次引进安全机制，增加了代码签名，不论是本地代码还是远程代码，都会按照用户的安全策略设定，由类加载器加载到JVM中权限不同的运行空间，来实现差异化的代码执行权限控制。下图是jdk1.2的安全模型 ​ 当前最新的安全机制实现，则引入了域（domain）的概念。JVM会把所有的代码加载到不同的系统和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。下图是jdk1.6的安全模型 ​ 组成沙箱的基本组件: 字节码校验器(bytecode verifier):确保java类文件遭循java语言规范。这样可以帮助ava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器(classloader):其中类装载器在3个方面对java沙箱起作用 它防止恶意代码去干涉善意的代码; 它守护了被信任的类库边界; 它将代码归入保护域，确定了代码可以进行哪些操作。 ​ 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由ava虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 从最内层IVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用; 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 存取控制器(access controller):存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包(security package):javasecurity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括: 安全提供者 消息摘要 数字签名 加密 鉴别 native凡是带了native关键词的方法，说明这个方法java语言实现不了，此方法会被放入本地方法栈中，该栈通过JNI（Java Native Interface）去调用底层的C或者C++语言写的方法。 方法区Method Area 方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单来说，所有定义的方法的信息都会被保存在该区域 静态变量、常量、类信息（构造方法，接口定义），运行时的常量池存放在方法区中，但是实例变量存在于内存区中，与方法区无关 PC寄存器程序计数器：Program Counter Register ​ 每个线程都有一个程序计数器，实现程序私有的，就是一个指针，指向方法区中的方法字节码 堆（Heap）一个JVM只有一个堆内存，堆内存的大小是可以调节的，里面一般放实例对象 堆内存细分为三个区域： 新生区 Young&#x2F;New 养老区 old 永久区 perm GC垃圾回收主要在伊甸园区和养老区 堆内存满了就会爆OOM（OutOfMemoryError）错误 所有的对象都是在伊甸园区产生的 伊甸园满了会触发轻GC，有的就直接死了，然后留下来的去往幸存区 如果幸存区满了，就去往老年区 如果老年区满了，触发一次重GC（伊甸园区和幸存者区都清一遍，活下来的去老年区） 垃圾处理器GCGC的作用区域只有堆 两种回收：轻GC 、Full GC GC的算法 标记清除法 标记整理法 标记复制算法 引用计数法（给每一个对象分配一个计数器，将计数器为0的对象清除） 标记复制法谁空谁是to幸存区 新生区主要使用复制算法 好处：没有内存碎片 坏处：浪费了内存空间 复制算法使用最佳场景：对象存活度较低的时候 标记清除法扫描这些活着的对象，清除没有标记的对象进行清除 缺点：两次扫描，浪费时间，会产生内存碎片 优点：不需要额外空间 标记整理法再次扫描，向一端移动存活的对象 分代收集算法 年轻代： 存活率低 复制算法 老年代 存活率高 标记清除+标记压缩混合实现 这五道面试题可以试着做一做 请你谈谈你对JVM的理解？java8虚拟机和之前的有什么不同？ 什么是OOM，什么是栈溢出？怎么分析？ JVM的常用调优参数有哪些？ 内存快照如何抓取？怎么分析Dump文件？ 谈谈你对类加载器的认识？","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"http://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://li-zhi.net.cn/tags/JVM/"}]},{"title":"if语句减少嵌套","slug":"if语句减少嵌套","date":"2022-02-07T12:32:09.000Z","updated":"2022-03-02T10:19:12.798Z","comments":true,"path":"琐碎的知识/2022/02/07/if语句减少嵌套/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/if%E8%AF%AD%E5%8F%A5%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97/","excerpt":"","text":"if的多重嵌套直接举栗子：有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 可以看到这里的if语句可能不是那么繁琐，但是当业务十分复杂或者当策略会经常变动的时候，需要经常修改源代码，这就严重违反了开闭原则，但是我可不可减少if的出现甚至不出现呢？ 下面我们结合以下两种解决方案来一步一步尝试解决问题 卫语句 策略模式 Version 1.1卫语句，就是将不符合的情况直接返回 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.0策略模式就是将各个会员的优惠方式提出一个接口，分别实现 策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2022-02-07T10:04:34.000Z","updated":"2022-02-07T11:13:21.241Z","comments":true,"path":"琐碎的知识/2022/02/07/Cookie和Session/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Cookie%E5%92%8CSession/","excerpt":"","text":"情景在线我们在登录完一个网站后，很长一段时间都不需要输入用户名和密码。大家有没有好奇这是为什么呢？ 学过HTTP的都知道，HTTP访问是无状态的，也就是说，服务器是不知道你这是第几次访问该网站的。 那么Cookie，Session就是来做到让服务器预先知道一些信息，其核心其实就是存储。 Cookie是存储在客户端的，Session是存储在服务器端的 下面我们来说说Cookie CookieCookie翻译为小饼干 该技术可以实现每次HTTP请求都自动带数据给服务器，从而实现服务器可以在请求的时候就预先知道一些信息。 流程图如下 我们可以在浏览器中查看Cookie 如果使用Cookie保存账号密码，那只要别人盗到你的Cookie，那么你的账号密码就泄露了！所以就出现了Session的技术 SessionSession翻译为会话 当我们打开一个浏览器进去网站，则开始一个会话，但是会话的结束比较模糊，可以自动设置session过期时间，也可以设置永不过期。 Session保存在服务器，当产生了一次会话，则服务器返回的时候携带存储session相关信息的Cookie，并保存在客户端，而这个session对象的信息则保存在服务器的数据库中。 下面是流程图","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Token","slug":"Token","date":"2022-02-07T10:01:03.000Z","updated":"2022-02-07T11:28:54.376Z","comments":true,"path":"琐碎的知识/2022/02/07/Token/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Token/","excerpt":"","text":"为什么会出现Token相信大家都知道Cookie和Session（不知道这两者的在我另外两篇博客里面有写，附上链接，Cookie和Session） 随着技术的发展，用户群体变的越来越大，如果服务器依旧使用基于Cookie的Session，在某一时间段有大量用户访问的话，服务器就会将大量的Session保存在数据库中，导致服务器性能降低，为了处理这种问题，就出现了一种技术，也就是JWT(JSON Web Token) Token JWT是由三部分组成的，分别是header、payload、signature header部分申明用什么算法生成签名 payload部分保存一些数据 signature部分保存header申明的算法生成的签名 小结Session、Cookie、Token都是是在服务器产生的 Cookie是保存SessionID的载体，但是Session对象是保存在服务器数据库中的 Token在服务器端生成，保存服务器端的密文，将token放入cookie发送诶客户端并交由客户端保存","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Ngrok","slug":"Ngrok","date":"2022-02-07T09:30:02.000Z","updated":"2022-02-07T10:00:22.913Z","comments":true,"path":"琐碎的知识/2022/02/07/Ngrok/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Ngrok/","excerpt":"","text":"使用Ngrok快速部署项目 打开https://ngrok.cc/ 注册一个账户 支付2块钱进行支付宝实名认证 点击开通隧道并翻到最后 开通隧道选项 说明： 隧道协议，两者即可 HTTP HTTPS（HTTPS需要绑定自己的域名，并且已经申请了SSL证书，才能有效，否则无法使用https。） 隧道名称 随便写即可 前置域名 写自己喜欢的 http验证用户名和密码 这里可以不写 确认信息，开通 进入隧道管理页面 ps：这里和我之前写的配置不一样，是因为一个用户只能免费开通一个http隧道 下载客户端 下载对应系统的软件，并解压 启动批处理命令 ps：我第一次使用的不是乱码，我也不理解这次使用为什么会乱码，这里不影响使用 输入隧道id，回车 如果之前配置了账号密码，则在此处需要输入账号密码 启动本地项目 注：本地项目启动的端口一定要和之前写的端口映射一致 打开网址测试 本地 Ngrok提供的网站访问","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"关于路径","slug":"关于路径","date":"2022-02-07T08:57:28.000Z","updated":"2022-02-07T09:14:03.166Z","comments":true,"path":"琐碎的知识/2022/02/07/关于路径/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84/","excerpt":"","text":"访问路径URL统一资源定位符，用于定位资源的一种方式。 通常的URL资源访问路径由两部分构成:资源路径与资源名称。 资源名称指的是要访问资源的直接名称，如show.html,或与要访问资源存在映射关系的间接名称，如show.do 资源路径，则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。 根据“资源路径是否可以独立完成资源准确定位”的判别标准,可以将访问路径分为绝对路径与相对路径 绝对路径绝对路径，是指根据给出的访问路径可以精确的定位到这个资源的路径 对于计算机中Web应用的绝对路径，则是指带访问协议的路径。即URL 相对路径相对路径,是指仅根据访问路径无法准确定位资源的路径。 相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。 参照路径的不同，所形成的可以准确定位资源的绝对路径也是不同的。 在进行资源访问时,必须要将相对路径转换为绝对路径才可完成资源的精确定位 绝对路径 &#x3D; 参照路径 + 相对路径 根据相对路径是否以斜杠开头，且路径指向的文件不同，其默认的参照路径是不一样的 以斜杠开头的相对路径前台路径所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。 例如，html、 css、 js中的路径，及jsp文件中静态部分的路径(HTML标签中的路径)。html 及jsp文件中的&lt; img src-&#x3D;*&#x2F;&gt;、&lt; a href&#x3D;””&gt;. &lt; form action&#x3D;””&gt;等标签中的以斜杠开头的路径都属于前台路径 前台路径的参照路径是Web服务器的根路径,即http://127.0.0.1:8080 将前台路径转换为绝对路径的工作,是由浏览器自动完成的。 该路径的作用是要为用户提交对某种资源的请求,是要查找并定位服务器中的某资源。 简单来说,前台路径的作用是“查找” 后台路径所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。 例如，java 代码中的路径、jsp文件动态部分java代码块)中的路径、xml等配置文件中的路径(配置文件是要被java代码解析后加载到内存的，其中的路径会出现在Java 代码中) 后台路径的参照路径是Web应用的根路径。http://127.0.0.1:8080/projectName 将后台路径转换为绝对路径的工作,是由服务器自动完成的。该路径的作用是标识出该资源在服务器中的路径，以便客户端能够按照这个设定路径来查找相应资源。简单来说,后台路径的作用是“标识” 以路径开头的相对路径以路径名称开头的相对路径，无论是出现在前台页面,还是出现在后台Java代码或配置文件中，其参照路径都是当前访问路径的资源路径。 即使是response 的sendRedirect()方法的参数路径,若不以斜杠开头，其也属于“以斜杠开头的相对路径”类的路径，参照路径为当前服务器的根路径 总结 相对路径类型 参照路径 相对路径转绝对路径的完成者 前台路径 当前Web服务器的根路径 浏览器 后台路径 当前Web应用的根路径 Web服务器 以路径名称开头的路径 当前访问路径的资源路径 浏览器&#x2F;Web服务器 PS： 对于response的sendRedirect( )方法完成的重定向 若其参数路径为“以斜杠开头的相对路径”这个后台路径是个特例。是由sendRedirect( )方法的本质决定的。这个方法不仅可以完成在当前项目中资源的跳转,还可以跳转到其它项目中的资源。所以这个后台路径的参照路径为“当前Web服务器的根”。所以要加resquest.getContextPath(); 注意，只有这一种重定向是特例,将来我们还会学习到其它方式实现的重定向，但那里的重定向就不是特例,而是遵循我们之前的路径转换理论 如果加斜杠和不加斜杠都可以完成跳转，就加上斜杠","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"SpringMVC-文件下载","slug":"SpringMVC-文件下载","date":"2022-01-31T06:57:54.000Z","updated":"2022-02-02T11:14:56.953Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件下载/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"文件下载文件下载很简单，只要设置一下响应头即可 页面： 123456789101112131415161718192021&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; ul li &#123; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;javascript:&quot;&gt;点击文字下载&lt;/a&gt;&lt;ul id=&quot;ul&quot;&gt; &lt;c:forEach items=&quot;$&#123;fileList&#125;&quot; var=&quot;file&quot;&gt; &lt;li&gt;&lt;a href=&quot;/fileDownLoad.do?fileName=$&#123;file&#125;&quot;&gt;$&#123;file&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Controller： 123456789101112131415161718@GetMapping(&quot;/fileDownLoad.do&quot;)public String fileDownLoad(String fileName,HttpServletRequest req,HttpServletResponse resp) throws IOException &#123; String realPath = req.getServletContext().getRealPath(&quot;\\\\download&quot;)+&quot;\\\\&quot;; File file = new File(realPath.concat(fileName)); resp.setHeader(&quot;Content-disposition&quot;,&quot;attachment; filename=&quot;+ URLEncoder.encode(file.getName(),&quot;UTF-8&quot;)); ServletOutputStream outputStream = resp.getOutputStream(); FileInputStream fis = new FileInputStream(file); byte[] buffer = new byte[1024]; int len=0; while((len=fis.read(buffer))&gt;0)&#123; outputStream.write(buffer,0,len); &#125; outputStream.flush(); fis.close(); outputStream.close(); return &quot;filedownload&quot;;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-文件上传","slug":"SpringMVC-文件上传","date":"2022-01-31T06:55:40.000Z","updated":"2022-02-01T07:18:07.250Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件上传/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"准备工作首先对于表单中的enctype属性做一个了解 application&#x2F;x-www&#x3D;form-urlencoded:默认方式，只处理表单中的value的属性值，采用这种编码方式的表单会将表单域中的值处理成URL编码方式 multipart&#x2F;form-data:这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会将文件域中的文件夜风撞到请求参数中 text&#x2F;plain:除了把空格改为“+”号外，其他字符不做编码处理，这种方式适合直接通过表单来发送邮件 文件上传是一个web项目中很常见的功能，在springmvc中有着很好的支持，但是springmvc默认上下文没有配置MultipartResolver，所以在做文件上传和下载前，需要配置MultipartResolver， 在原有包的基础上导入此包 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt; 注册MultipartResolver实例，id必须为multipartResolver，id必须为multipartResolver，id必须为multipartResolver，不然报错 12345&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; 以下就不赘述springMVC的配置文件了 上传单个文件页面： 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; controller： 12345678910111213141516171819202122@PostMapping(&quot;/singleFileUpload.do&quot;)public String singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false) CommonsMultipartFile avatar,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); return &quot;singleFileUpload&quot;;&#125; 上传多个文件其实和上传单个文件很像，只要input控件的name属性是一样的，那它们就是一组，下面来看看代码 controller：（两法，个人偏向于第二种） 12345678910111213141516171819202122232425@PostMapping(&quot;/multiFileUpload.do&quot;)public String multiFileUploadDo(@RequestParam(value = &quot;file&quot;,required = false) CommonsMultipartFile[] files,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload/multipart&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; for (int i = 0; i &lt; files.length; i++) &#123; //文件的全称，包括后缀 String avatarWholeName = files[i].getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 files[i].transferTo(new File(realSavePath)); &#125; return &quot;multiFileUpload&quot;;&#125; 1234567891011121314151617181920212223@PostMapping(&quot;/multiFileUpload.do&quot;)public Map multiFileUploadDo(HttpServletRequest request) throws IOException &#123; String realPath = request.getServletContext().getRealPath(&quot;\\\\multipartUpload&quot;)+&quot;\\\\&quot;; CommonsMultipartResolver cmr = new CommonsMultipartResolver(request.getServletContext()); if(cmr.isMultipart(request))&#123; MultipartHttpServletRequest req = (MultipartHttpServletRequest) request; MultiValueMap&lt;String, MultipartFile&gt; multiFileMap = req.getMultiFileMap(); for (String fieldName : multiFileMap.keySet()) &#123; String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); //创建存放文件的文件夹 File dir = new File(realPath + uuidPath + fieldName); dir.mkdirs(); List&lt;MultipartFile&gt; multipartFiles = multiFileMap.get(fieldName); for (MultipartFile f : multipartFiles) &#123; //如果文件为空，则忽略，不然会报错 if(!f.isEmpty())&#123; f.transferTo(new File(dir.getPath()+&quot;\\\\&quot;+f.getOriginalFilename())); &#125; &#125; &#125; &#125; return &quot;multiFileUpload&quot;;&#125; 页面： 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/multiFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 以上都是同步提交，下面我们使用异步提交并且将图片预览出来，这次只演示单个文件上传，多个文件上传同理。 异步提交并提供预览Controller： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@PostMapping(&quot;/reg.do&quot;)@ResponseBodypublic Map reg(User user,String relativePath)&#123; user.setAvatarUrl(&quot;\\\\upload\\\\&quot;.concat(relativePath)); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); System.out.println(user); map.put(&quot;result&quot;,&quot;success&quot;); return map;&#125;@PostMapping(&quot;/singleFileUpload.do&quot;)@ResponseBodypublic Map singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false)CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); if(avatar==null||avatar.isEmpty())&#123; map.put(&quot;result&quot;,&quot;fail&quot;); return map; &#125; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); map.put(&quot;result&quot;,&quot;success&quot;); //用来给页面显示图片 map.put(&quot;relativePath&quot;,&quot;\\\\upload\\\\&quot;.concat(realFileName)); //用来给前端判断是否需要再次上传 map.put(&quot;fileName&quot;,avatarWholeName); return map;&#125; 页面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;userName&quot; id=&quot;userName&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;number&quot; placeholder=&quot;请输入年龄&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;div style=&quot;display: none&quot; id=&quot;showimgcontainer&quot;&gt; &lt;img id=&quot;showimg&quot; width=&quot;400px&quot; height=&quot;400px&quot; style=&quot;border: solid 1px black&quot;/&gt; &lt;/div&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;submitBtn&quot; value=&quot;注册&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.form.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; let fileName; let relativePath; $(&#x27;#avatar&#x27;).change(()=&gt;&#123; if(fileName===$(&#x27;#avatar&#x27;)[0].files[0].name)&#123; return; &#125; let options = &#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&#x27;, dataType:&#x27;text&#x27;, success(data)&#123; data = JSON.parse(data); if(data.result===&#x27;fail&#x27;)&#123; alert(&quot;文件为空或者不存在&quot;); return; &#125; relativePath = data.relativePath; fileName = data.fileName; $(&#x27;#showimgcontainer&#x27;).show(); $(&#x27;#showimg&#x27;).attr(&#x27;src&#x27;,relativePath); &#125; &#125; $(&#x27;#form&#x27;).ajaxSubmit(options); &#125;) $(&#x27;#submitBtn&#x27;).click(()=&gt;&#123; $.ajax(&#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/reg.do&#x27;, method:&#x27;post&#x27;, data: &#123;relativePath:relativePath,userName:$(&#x27;#userName&#x27;).val(),age:$(&#x27;#age&#x27;).val()&#125;, success(data) &#123; if(data.result===&#x27;success&#x27;)&#123; alert(&quot;注册成功&quot;); window.location = &#x27;$&#123;pageContext.request.contextPath&#125;/login&#x27;; &#125;else &#123; alert(&quot;出错！请重试！&quot;); &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"Linux-管理（了解即可）","slug":"Linux-管理（了解即可）","date":"2022-01-31T06:14:13.000Z","updated":"2022-04-24T07:55:18.134Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-管理（了解即可）/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89/","excerpt":"","text":"账号管理 简介 在一开始的时候我们就提到，Linux是一个多用户的分时操作系统，任何一个需要使用系统资源的用户，都必须向系统管理员申请一个账号，然后以这个账号登录系统。 用户的账号一方面可以帮助系统管理员对使用系统资源的用户进行跟踪，并控制他们对资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护 每个用户都拥有一个唯一的用户名和密码 对于账号的管理，主要有以下操作 用户账号的添加，删除和修改 增加用户 1useradd -选项 用户名 选项 -m 自动创建这个用户的主目录 -d 指定用户的主目录在哪 -c 指定一段注释 -g 指定该用户的用户组 -G 指定用户所属的附加组 -s shell文件，指定用户的登录shell -u 用户号 ，如果有-o属性，则可以与其他人的标识号重复 用户名 指定用来登录的用户名 删除用户 12userdel -r 用户名 -g 分配组#删除用户的时候将其目录一并删除 修改用户信息 1usermod 创建的时候的一些参数，对应修改的内容的参数 修改用户密码 root用户 1passwd 用户名 普通用户 12passwdcurrent password 切换用户 root用户 切换用户的命令是：su username 从普通用户切换到root用户，可以使用命令：sudo su 在终端输入exit或者logout的时或者快捷方式Ctrl+d（其实就是exit），可以退回原来账户 在切换用户的之后，如果也想切换新用户的工作环境，则可以再su和username之间加入一个-，比如su - root $代表普通用户 #代表超级用户，即root用户 锁定账户 1234#锁定之后就不能登录了passwd -l 用户名#清空该用户的密码，也不能登录passwd -d 用户名 查看账户信息 1234cat /etc/passwd用户名：口令(不可见为X)：用户标识号：组标识号：注释性描述：主目录：登录shellcat /etc/shadom查看加密的密码 用户组的管理 属主，属组 每个用户都有一个用户组，root用户可以对一个用户组的全部用户进行集中管理（开发组，运维组、、、）。不同的Linux系统对于用户组的规定有所不同，如Linux下的用户属于与他同名的组，这个用户组在创建用户的时候创建 用户组的管理涉及，用户组的添加，用户组的删除和修改。其实这些操作都是在对&#x2F;etc&#x2F;group的文件进行更新 创建一个用户组 1gruopadd 用户组名称 创建用户组后可以得到一个id，可以通过-g参数指定该id 删除一个用户组 1groupdel 用户组名称 修改用户组权限信息和名字 1groupmod -g 用户组id -n 修改后用户组名称 用户组名称 查看所有的用户组 1cat /etc/group 磁盘管理 df [-h]，列出文件系统整体的磁盘使用量 du [-h]，检查当前磁盘的使用量 12du -sm /*#检查根目录下每个文件占用的容量 1234#将外部设备filename挂载到/mnt/filename下来实现访问mount /dev/filename /mnt/filename#unmount -f强制卸载unmount -f [挂载位置] 进程管理1、每一个程序都有自己的一个进程，每个进程都有一个id号 2、每个进程都会有一个父进程 3、两种运行方式，前台运行，后台运行 4、一般情况下，服务都是后台运行的 命令1ps 查看当前系统中正在执行的各种进程的信息 ps -xx： -a 显示当前终端运行的所有的进程信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数 123456#查看所有的进程ps -aux|grep mysqlps -aux|grep redis#|这个在Linux叫管道符 A|B#grep 过滤符合条件的字符串 这里只要知道就行 123456#可以查看父进程的信息ps -ef|grep mysql#进程树，更推荐pstree -p 显示父id -u 显示用户组 结束进程 123kill -9 进程id# 这个-9是信号代码，代表强制结束#如果有死循环了，就可以选择强制结束该进程 拓展内容查看网络123#在/etc/sysconfig/network-scripts/目录下是配置网络的#查看IP地址，网络配置ifconfig 创建文件1touch 文件名 往文件尾部写入值1echo &quot;Hello&quot; &gt;&gt;filename 关于主机名称1234#查看主机名称hostname#修改主机名称hostname newhostname 清屏1clear 链接在Linux中，链接分为软链接和硬链接 硬链接：A–B，B是A的硬链接，类似于拷贝了一份 可以这么理解，如果我把A删了，B也是可以访问到A这个文件 软链接：就是一种类似Windows下的快捷方式，A–B，B是A的软链接。 可以这么理解，如果我把A删了，则B无法再次访问A文件了 创建链接基础命令：ln 1234#设置B为A的硬链接，这时候的B是白色ln A B#设置C为A的软链接（又名符号链接），这时候的C是特殊颜色ln -s A C 会感觉这个硬链接和复制有点像，但是两者是有区别的 链接文件，他们的内容是同步的但是复制只是复制，不会同步数据 端口有关操作12345678910111213141516171819#查看开放的端口firewall-cmd --list-ports#开启防火墙service firewalld start#重启防火墙service firewalld restart#关闭防火墙service firewalld stop#查看当前firewalld的状态systemctl status firewalld#开启端口，记得在阿里云配置安全组firewall-cmd --zone=public --add-port=80/tcp --permanent#重启防火墙服务systemctl restart firewalld.service","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-vim编辑器","slug":"Linux-vim编辑器","date":"2022-01-31T06:12:29.000Z","updated":"2022-04-24T04:06:04.035Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-vim编辑器/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-vim%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"","text":"VIM编辑器 什么是VIM编辑器 VIM是从vi发展出来的一个文本编辑器，代码补全，编译，及错误跳转等功能特别丰富。Linux中必须会使用vim 三种使用模式基本上vim&#x2F;vi分为三种使用模式，分别是命令模式（Command mode）、输入模式（Insert mode）、底线命令模式（Last Line mode） 命令模式（Command mode）用户刚刚启动vim，便进入了命令模式 此状态下敲击键盘会被识别为命令，不会输入字符 以下为常用命令： 命令 作用 i 切换到输入模式 ： 切换到底线命令模式 k或者上箭头 光标向上移 j或者下箭头 光标向下移 h或者左箭头 光标向左移 l或者右箭头 光标向右移 Ctrl+f 向下移动一页，相当于pageDown Ctrl+b 向上移动一页，相当于pageUp Ctrl+d 向下移动半页 Ctrl+u 向上移动半页 0&#x2F;功能键[home] 将光标移动到该行的开头处 $&#x2F;功能键[end] 将光标移动到该行的结尾处 H 将光标移动到这个屏幕第一行的第一个字符所在的位置 M 将光标移动到这个屏幕中央的那一行的第一个字符所在的位置 L 将光标移动到这个屏幕最后一行的一个字符所在的位置 G 将光标移动到这个屏幕最后一行的一个字符所在的位置 nG n代表数字，表示移动到该文件的第几行 gg 移动到这个文件的第一行 n&lt;回车&gt; 光标向下移动n个字符（单独摁空格光标向下移动一个字符） n&lt;退格键&gt; 光标向左移动n个字符（单独摁退格键光标向左移动一个字符） n&lt;空格&gt; 光标向右移动n个字符（单独摁空格光标向右移动一个字符） 替换搜索 命令 作用 &#x2F; keyword 向下查询字符串keyword ？keyword 向上查询字符串keyword n 继续当前的查询动作 N 反向进行当前的查询动作 删除、复制、黏贴 命令 作用 x ，X 删除当前光标所在的字符 nx n为数字，连续向后删除n个字符 &lt;数字&gt;dd&#x2F;D 删除光标所在的那n整行(默认n为1) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除所在光标到该行最后 d0 删除所在光标到该行开头 &lt;数字&gt;yy 复制那一整行（默认n为1） y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在到该行的开始位置 y$ 复制光标所在到该行的结束位置 p，P p将复制的数据在光标的下一行黏贴，P将复制的数据在光标的上一行黏贴 J 将光标所在行与下一行的数据结合成同一行 Ctrl+r 重做 u 撤销 从命令模式切换到输入模式的其他命令 命令 i、I i为在当前光标处进入输入模式，I为在当前光标所在行的第一个字符所在处进入输入模式 a、A a为在当前光标的下一个字符处进入输入模式，A为在当前光标所在行的最后一个字符所在处进入输入模式 o、O o为在当前光标所在行的下一行输入一个新的一行，O为在当前光标所在行的上一行输入一个新的一行 r、R 进入取代模式，r为只取代一次，R为一直取代直到按下esc esc 退出到命令模式 输入模式（Insert mode）在此模式下，可以使用以下按键 这些操作和我们平时用的是一样的 底线命令模式（Last Line mode）在此模式下，我们的光标会移动到最底下，就可以输入一些命令了 命令 :w 保存 :w！ 若文件为只读属性，强制写入，跟权限有关 :q 退出vim :q! 不保存退出 !在vim中一般表示强制的意思 :wq 保存退出 :ZZ 如果档案没有改动，则不储存离开，若修改了，则储存后离开 :w[filename] 另存为到另一个文件 :r[filename] 在编辑的数据中，读入另一个档案的数据。亦将filename中的内动追加到光标所在行的后面 :n1,n2 w[filename] 将n1到n2的数据存储到filename这个文件中 :!command 暂时离开vim执行command命令，【例如：:! ls &#x2F;home】 :set nu 显示行号 :set nonu 取消显示行号","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-文件操作","slug":"Linux-文件操作","date":"2022-01-31T06:11:31.000Z","updated":"2022-04-24T05:01:53.449Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-文件操作/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"文件操作文件属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统no的安全性，Linux系统对于不同的用户访问同一文件夹的权限做出了规定 先前我们使用ls -al查看了文件属性，我们现在来看看这些开头的字符到底是什么意思吧 我们将每一行分为六组来看 第一组 这一组固定一共十个字符，拆分为第一个字符和后9个字符来看 第一个字符的含义 [d]代表目录 [-]代表文件 [l]代表这是一个链接文档（link file） [b]代表装置文件，里面可能有供存储的接口设备 [c]代表装置文件里面的串行端口设备，例如键盘或者鼠标 后九个字符的含义 接下来的字符中以三个为一组，且均是以[rwx]的三个参数的组合 r–》read读操作 w–》write写操作 x–》execute执行操作 如果对应位置没有权限，就会出现-号 第一组为属主的权限（该文件的所有者） 第二组为属组的权限（所有者的同组用户） 第三组为其他用户的权限（其他用户） 第二组 如果该项是文件夹，该数字表示文件夹中的包含文件数 如果是文件，则显示1 第三组 第一个参数表示属主 第二个参数表示属组（root组） 第四组 文件大小 第五组 创建时间 第六组 文件名 修改文属性件更改文件属组基础命令：chgrp 1chgrp [-R] 属组名 文件名 更改文件属主，也可以同时更改文件属组12chown [-R] 属主名 文件名chown [-R] 属主名：属组名 文件名 更改文件九大属性1chomd [-R] xyz 文件或者目录 Linux文件系统属性有两种设置方法，一种数字，一种符号。 Linux文件的基本权限有九个，分别是owner&#x2F;group&#x2F;others三种身份各自有自己的read&#x2F;write&#x2F;execute权限 文件的权限字符是[rwxrwxrwx]，这九个权限是三三一组的！我们可以使用数字来代表各个权限，各个权限的分数对照表如下： 1r:4 w:2 x:1 每种身份（owner&#x2F;group&#x2F;others）各自的三个权限（r&#x2F;w&#x2F;x）分数是需要累加的，举个栗子：[rwxrwx—] owner &#x3D; rwx &#x3D; 4 + 2 + 1&#x3D; 7 group &#x3D; rwx &#x3D; 4 + 2 + 1&#x3D; 7 others &#x3D; — &#x3D; 0 1chmod 770 filename 查看文件Linux系统中使用以下命令来查看文件的内容 cat 由第一行开始显示文件的内容 tac 由最后一行开始显示文件的内容 nl 显示的时候，输出行号 more 一页一页的显示文件的内容 空格翻页，enter代表向下看一行，:f代表当前行数，退出查看输入q，向下查询字符串使用命令/要查找的字符串向上查询使用命令?要查找的字符串，n代表继续搜寻下一个，N代表继续搜寻上一个 less 与 more相似，但是他可以往前翻页 上下键代表向上下翻页 head 只查看前几行 通过 -n 参数可以控制查看几行 tail 只查看尾巴几行 通过 -n 参数可以控制查看几行","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-目录操作","slug":"Linux-目录操作","date":"2022-01-31T06:10:26.000Z","updated":"2022-04-24T04:39:06.784Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-目录操作/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/","excerpt":"","text":"目录结构 以下是对这些目录的解释 &#x2F;bin: bin是Binary的缩写，这个目录存放着最经常使用的命令 &#x2F;boot: 这里存放的是启动Linux的时候使用的一些核心文件（不要动） &#x2F;dev: dev是Device的缩写，存放的是Linux的外设设备， &#x2F;etc: 这个目录是用来存放所有的系统管理所需要的配置文件和子目录 &#x2F;home: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是使用用户的账号来命名的 &#x2F;lib: 这里存放着系统最基本的动态连接共享库（不要动） &#x2F;lost+found: 这个目录一般是空的，但是当服务器意外关闭的时候，里面会存在一些错误文件（不要动） &#x2F;media: Linux系统会自动识别一些设备，例如u盘，光驱等等 &#x2F;mnt: 这个目录是给用户来临时挂载别的文件系统的（后面会把本地文件挂载在这个目录下） &#x2F;opt: 给主机额外安装软件所在的目录 &#x2F;proc: 这是一个虚拟的目录，他是系统内存的映射，我们可以通过直接访问这个目录来获得系统信息（不用管） &#x2F;root（也就是 ~ ）: 该目录是系统管理员目录，也称作超级权限者的用户主目录 &#x2F;sbin: s就是super的意思，这里存放的是系统管理员使用的系统管理程序 &#x2F;srv: 该目录用来存放一些守护进程启动之后需要提取的数据 &#x2F;sys: 这是Linux2.6内核的一个很大的改变，该目录下安装了2.6内核中新出现的一个文件系统sysfs &#x2F;tmp: 这个目录使用来存放一些临时文件的 &#x2F;usr: 这个目录用来存放用户的应用程序和文件 &#x2F;usr&#x2F;bin: 系统用户使用的应用程序 &#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护进程 **&#x2F;usr&#x2F;src: ** 内核源代码默认存放的地址 &#x2F;var: 这个目录用来存放着一些不断在拓充的东西，习惯性的将一些经常修改的目录放在该目录下 &#x2F;run: 是一个临时文件系统，存储系统启动以来的信息，当系统重启时，该目录下的文件应该被删掉（不用管） &#x2F;www: 存放服务器网站的相关的资源，环境，网站 不是每一个目录都一定会存在 关机指令基础指令：shutdown 123456789101112131415161718# Linux系统中为了提高磁盘的读写效率，对磁盘采用了“预读迟写”操作方式。当用户保存文件时，Linux核心并不一定立即将数据写入物理磁盘中，而是将数据保存在缓存区中，等到缓存区被填满了之后再将数据写入磁盘，这种方式确实极大地提高了读写效率，但是也有其所在的一些问题，当服务器遭受到断电或者其他意外情况的时候，缓存中的数据会直接丢失，这就会导致一些问题，sync就是将缓存中的东西直接写入到磁盘中去，无需等待缓存被填满#将数据同步到硬盘（关机前必须做）sync#服务器在十分钟后关机shutdown -h 10#立即关机shutdown -h now#在20:35关机shutdown -h 20:35#立马重启shutdown -r now#立马重启reboot 切换目录基础指令：cd 首先要知道这两个概念 决定路径 相对路径 绝对路径：指的是资源的全路径，比如D:\\APP\\Typora 相对路径：指的是资源在当前目录下的路径，比如我现在在D:\\APP目录下，我要定位到Typora这个目录，我可以直接使用Typora来表示该文件夹 12345678#进入根路径下的usr目录cd /usr#当前在根路径下，我要进入usr目录[root@iZbp18qscowpmxk6xpk38iZ /]#cd usr#返回上一级目录cd .. 查看目录基础指令：ls 123456789#查看所有的文件，包括隐藏文件，简写形式ls -a#以列表方式查看所有的文件的属性和权限，不包括隐藏文件ls -l#Linux中命令可以组合#以列表方式查看所有的文件，包括隐藏文件ls -al 目录操作创建一个目录1234mkdir 文件名#创建多级目录mkdir -p test1/test2/test3 删除一个目录12345#删除一个空目录rmdir test1#删除多级文件rmdir -p test1/test2/test3 复制一个目录1cp 源文件 目的文件夹 查看当前目录路径12345678910# 文件呈现不同颜色代表不同的含义# 白色 代表它是一个普通文件# 蓝色 代表它是一个文件夹# 绿色 代表它是一个可执行文件# 红色 代表它是一个压缩文件# 浅蓝色 代表它是一个链接文件# 红色闪烁 代表链接的文件有问题# 黄色 代表设备文件# 灰色 代表它是其他文件pwd 移除目录或者文件基础命令：rm -f 忽略不存在的文件，不会出现警告，强制删除 -r 递归删除根目录 -i 互动，删除询问是否删除 1rm -rf install.sh 移动目录或者文件基础命令：mv -f 强制 -u 只替换已经更新过的文件 1234mv 源文件 目标文件夹#重命名dir1为dir2mv dir1 dir2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-简介","slug":"Linux-简介","date":"2022-01-29T10:32:02.000Z","updated":"2022-04-24T03:31:11.143Z","comments":true,"path":"javaEE/Linux/2022/01/29/Linux-简介/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Linux/2022/01/29/Linux-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux简介其实Linux这个词本身指的是Linux内核。 我们所说的Linux操作系统其实是基于Linux内核的操作系统，就是Linux的发行版。 目前市面上比较知名的是：Ubuntu、RedHat、CnetOS、Oracle Linux等等 准备工作 准备一个Linux系统的服务器 如果没有经济基础，可以使用VMware，自己创建一个虚拟机用来学习。 这里建议大家去阿里云或者腾讯云购买一个服务器用来学习，这样的环境更真实，并且也不是很贵，具体如何购买，这里就不赘述了，可以自行到b站搜一搜。 工具 这里要下载两个工具，一个叫XShell，另一个叫XFtp。 XShell是用ssh来远程连接你购买的服务器。 XFtp是用来上传本地文件的。 这里我把安装包分享一下。 12链接:https://pan.baidu.com/s/1AgF6l1Bn74QGMpkwQRIHqA 提取码:hr1x 通常服务器会在一开始搭建一些环境，有这两种比较流行的组合 LAMP(Linux+Apache+MySQL+PHP) LNMP(Linux+Nginx+MySQL+PHP)（推荐） 这里嫌麻烦的可以安装一个宝塔，一键部署。 走进Linux系统开机会启动许多程序，在windows中我们叫它服务（“Service”），在Linux中我们叫它守护进程（“daemon”） 计算机中，一个正在执行的程序或命令，被叫做“进程”（process） 启动之后一直存在、常驻内存的进程，一般被叫做“服务”（service） 在Linux中记住两句话 一切皆文件，根目录是&#x2F; 最高权限为root，可以操作一切","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"}]},{"title":"SpringMVC-JSON","slug":"SpringMVC-JSON","date":"2022-01-29T02:05:17.000Z","updated":"2022-01-29T02:05:53.400Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","excerpt":"","text":"JSON(JavaScript Object Notation)JSON是一种十分轻量级的数据交换的格式，我们来讲一下处理JSON字符串的两个库 Jackson 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.1&lt;/version&gt;&lt;/dependency&gt; 将对象转为JSON字符串 12ObjectMapper mapper = new ObjectMapper();String json = mapper.writeValueAsString(user); 这时候，页面再次出现乱码问题 第一种原生的解决方案是 1@GetMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 第二种使用springmvc的配置文件，这段配置只针对jackson库 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 那我们怎么处理时间对象呢？ 12345678@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; Date date = new Date(); ObjectMapping objectMapping = new ObjectMapper(); return objectMapping.writeValueAsString(date);&#125;//返回的是当时的时间戳 下面是第一种方法 123456@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); return new ObjectMapper().writeValueAsString(sdf.format(new Date()));&#125; 这是第二种方法 123456789@GetMapping(&quot;/datejson2&quot;)@ResponseBodypublic String jsonDate2() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); mapper.setDateFormat(sdf); return mapper.writeValueAsString(new Date());&#125; FastJson 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt;&lt;/dependency&gt; 主要的三个类 JSONObject 对应JSON对象，可以使用get方法获取JSON对象的值 JSONArray 代表JSON数据 JSON代表JSONarray和JSONObject的转化 主要用这个类的静态方法去转化JSON字符串和对象","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-Controller","slug":"SpringMVC-Controller","date":"2022-01-29T02:02:36.000Z","updated":"2022-01-29T02:03:04.779Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","excerpt":"","text":"Controller控制器和mybatis不同，在springmvc中，注解开发才是主流，所以接下来都会使用注解来开发。 被@Controller标注的类是一个控制器类，其中的每一个方法都是一个控制器，都各自映射一个url地址 在spring中我们说过，使用注解的时候需要在spring的配置文件中开启注解扫描 12&lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt;&lt;!--这里最好写到controller包，因为该配置文件专注于处理Controller层的事情，不要将包扫描的范围扩大--&gt; 回顾spring中的常用注册bean的注解 12345@Component 普通组件@Service 服务层@Repository 持久层@Mapper mybatis的接口层@Controller 控制器层 因为我们配置的DispatcherServlet会拦截所有的请求，但是对于静态资源，我们不需要拦截对他做出处理，所以有了以下配置 12&lt;!-- Springmvc不处理静态文件--&gt;&lt;mvc:default-servlet-handler/&gt; @RequestMapping该注解可以作用于类上面或者方法上面 方法上面 该方法映射的url地址即为注解中的值 类上面 当其作用在类上面的时候，该控制器类中所有的方法的映射路径的前面都会加上该注解中的值 @GetMapping 该注解代表请求是get请求 @PostMapping 该注解代表请求是post请求 @PutMapping 该注解代表请求是put请求 @DeleteMapping该注解代表请求是delete请求 @RestController当类上不是@Controller注解而是@RestController时候，该类中所有的方法返回的值，不会跳转视图，而是返回JSON字符串 如果不想让类中所有的方法都返回字符串 则类上面使用@Controller注解，方法上使用@ResponseBody标注此方法返回的结果是一个JSON字符串不要被视图解析器解析 RestFul风格概念：RestFul就是一个资源定位及资源操作的风格。 它不是标准也不是协议，它就只是一个style。基于这种风格设计的软件可以更加简洁，更有层次，并且安全，更易于实现缓存等机制 传统方式操作资源通过不用的参数来实现不同的功能，方法单一，post和get http:&#x2F;locoalhost:8080&#x2F;item&#x2F;insertItem post提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;deleteitem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;queryItem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;updateitem post提交 使用RestFul风格操作资源 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;add&#x2F;参数&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;query&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… 本质其实就是通过不同的提交方式走不同的方法 结果跳转方式控制器最后直接return字符串的话默认请求转发 如果想要重定向字符串前面加“**redirect:**”即可 处理前端数据 如果提交参数的名称和方法的参数名一致的话， 提交数据：http://localhost:8080/user/add?name=lizhi&amp;age=20 1234@GetMapping(&quot;user/add&quot;)public String test01(String name,int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交参数和方法参数不一致的话 提交数据：http://localhost:8080/user/add?username=lizhi&amp;userage=20 1234@GetMapping(&quot;user/add&quot;)public String add(@RequestParam(&quot;username&quot;) String name,@RequestParam(&quot;userage&quot;)int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交的是一个对象 提交数据：http://localhost:8080/user/add 要求提交的表单要和属性的属性名一致，方法参数即可直接使用对象 1234@PostMapping(&quot;user/add&quot;)public String add(User user,Model model)&#123; return &quot;user&quot;;&#125; 返回前端数据 ModelAndView 该对象在初识mvc的时候已经见过，不再赘述 Model（这是一个接口） 该对象在使用注解开发的时候也已经见过，这里也不再赘述 ModelMap ModelMap实现了Model接口，继承了LinkedHashMap，所以它更强大，但是大部分情况下Model会更常用","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-简述","slug":"SpringMVC-简述","date":"2022-01-29T02:01:23.000Z","updated":"2022-01-29T02:08:21.939Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-简述/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-%E7%AE%80%E8%BF%B0/","excerpt":"","text":"Spring MVCModel 1时代所有请求直接转发到jsp然后在jsp编写业务代码，然后根据不同的结果跳转不同的页面 Model 2时代Controller 取得表单数据 处理业务逻辑 根据不同的情况跳转不同的页面 View 展示数据 Model 业务逻辑 保存数据 简介SpringMVC的特点： 轻量级，简单易学 与spring无缝结合，可以将mvc中所有需要的类注册到ioc容器中 高效，基于请求和响应的mvc框架 功能强大，RESTFUL风格，格式化，数据验证 约定大于配置 说白了学它就一个原因，因为它让我们开发变得简单了 原理 回顾servlet我们都学过java web，那时候我们对于前端的请求都是通过一个servlet来处理的，然后在servlet里面，处理前端传来的数据，调用业务逻辑，返回处理之后的数据，然后servlet根据这些数据，进行重定向或者请求转发 一个请求对应一个servlet，这就会导致我们在开发中写了大量的servlet，而且每次都需要在web.xml中注册，十分繁琐。 没有什么是加一层解决不了的，所以，springmvc在servlet之前加了一层来简化我们的开发 SpringMVC的web框架是以围绕DispatcherServlet（前端控制器，调度器，请求分发器）设计的。它的作用就是将请求分发到不同的处理器（方法或者类，下面的初识mvc是以类级作为处理器，但是一般都会使用方法级去做处理器） 下图是DispatcherServlet的结构图，我们可以看到一些在javaweb阶段比较眼熟的类，比如Servlet，GenericServlet，HttpServlet。因此我们可以得出，DispatcherServlet本质就是一个和我们当时写的servlet是一样的，只是他帮我们做了很多事情。 人到中年有三大件，枸杞大枣保温杯。 SpringMVC中也有三大件，分别是 处理器映射器（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 我们来看看这三大件是如何在springmvc中发挥作用的，原理图如下： 核心类图 简要分析 DispatcherServlet就可以简单理解为前端控制器，他会将所有客户端的请求拦截 将该请求发送给HandlerMapping实现类，该实现类根据url查找到对应的控制器，将结果返回给DispatcherServlet DispatcherServlet根据HandlerMapping解析的结果，适配并执行对应的控制器的逻辑， 控制器返回信息，HandlerAdapter实现类接收该信息并将其解析成ModelAndView对象返回到DispatcherServlet DispatcherServlet调用ViewResolver实现类将HandlerAdapter实现类传回来的视图逻辑和模型解析 视图解析器将解析后的逻辑视图名传回DispatcherServlet DispatcherServlet根据解析后的视图名称找到该视图 渲染视图，返回页面，作出响应","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-拦截器","slug":"SpringMVC-拦截器","date":"2022-01-28T14:48:50.000Z","updated":"2022-01-29T02:06:45.968Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-拦截器/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"SpringMVC中的拦截器其实此拦截器就是我们在javaweb阶段使用的过滤器，只不过是换了一个名字而已，换汤不换药，本质是一样的。 只不过拦截器是AOP思想的具体应用 过滤器： Servlet规范中的一部分，任何javaweb工程都可以使用 在url-pattern中配置了&#x2F;*后，会拦截所有的请求 拦截器： 拦截器是SpringMVC中才会有的，只有使用了此框架的工程才可以使用 拦截器只会拦截访问的控制器方法，如果访问的是静态资源是不会进行拦截的 自定义拦截器实现HandlerInterceptor接口 1234567891011121314151617181920212223242526272829package com.lizhi.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; /** * return true才会执行下一个拦截器 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;===处理前===&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;===处理后===&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;===清理===&quot;); &#125;&#125; 在Spring核心文件中注册拦截器 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/**会拦截这个请求下面的所有请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.lizhi.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-乱码","slug":"SpringMVC-乱码","date":"2022-01-28T14:48:01.000Z","updated":"2022-05-05T05:38:59.702Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-乱码/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E4%B9%B1%E7%A0%81/","excerpt":"","text":"乱码！一生之敌！！！UserController 123456789101112131415161718package com.lizhi.controller;import com.lizhi.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping(&quot;/login.do&quot;) public String login(User user, Model model)&#123; model.addAttribute(&quot;user&quot;,user); return &quot;index&quot;; &#125;&#125; login.jsp 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/user/login.do&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;name:$&#123;user.name&#125;age:$&#123;user.age&#125;&lt;/body&gt;&lt;/html&gt; 结果如下： 我们先尝试一下配置一个过滤器，这是第一种方案 1234567891011121314151617181920212223package com.lizhi.filter;import javax.servlet.*;import java.io.IOException;public class CharsetFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 记得去web.xml中注册 12345678&lt;filter&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.CharsetFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 我们尝试后发现，没有任何效果，那既然我们写的过滤器不行 那springmvc给我们写了一个专门处理乱码的过滤器，我们来配置一下，这是第二种方案，很稳妥 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 测试后发现，还是乱码！！这时候我们可以去看一下tomcat的config目录下的server.xml，找到connector标签并修改属性 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 发现还是不行，我们去找一个其他大佬自己写的过滤器试一试，这是第三种方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.lizhi.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.util.Map;public class EncodeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse resp = (HttpServletResponse) servletResponse; resp.setContentType(&quot;text/html;utf-8&quot;); HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletRequest myreq = new MyRequest(req); filterChain.doFilter(myreq, resp); &#125; @Override public void destroy() &#123; &#125;&#125;class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; private boolean hasEncode; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public Map getParameterMap() &#123; String method = request.getMethod(); if(&quot;post&quot;.equalsIgnoreCase(method))&#123; try&#123; request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;else if(&quot;get&quot;.equalsIgnoreCase(method))&#123; Map&lt;String,String[]&gt; parameterMap = request.getParameterMap(); if(!hasEncode)&#123; for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if(values!=null)&#123; for (int i = 0; i &lt; values.length; i++) &#123; try&#123; values[i] = new String(values[i].getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; @Override public String getParameter(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if(values==null)&#123; return null; &#125; return values[0]; &#125; @Override public String[] getParameterValues(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); return parameterMap.get(name); &#125;&#125; 结果测试发现，还是不对！其实乱码的问题到这里一般都会解决了，但是为什么还是不行呢？ 其实是在注册filter的时候就出错了，接下来看下面的正确配置，大家可以看一下有什么区别， 12345678&lt;filter&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.EncodeFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 有的小伙伴可能在一开始就看出来了，没错，就是&lt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&gt;这里的拦截路径我们应该使用/*而不是/ 两者有什么区别呢？ 前者是拦截一切请求，包括jsp 而后者会拦截除了jsp的所有资源 相信吃了这次亏，大家之后就再也不会忘记这个坑了！而且也了解了大部分乱码问题的解决方案！","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-第一个SpringMVC工程","slug":"SpringMVC-第一个SpringMVC工程","date":"2022-01-28T14:26:57.000Z","updated":"2022-01-29T02:04:25.357Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-第一个SpringMVC工程/","link":"","permalink":"http://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E7%AC%AC%E4%B8%80%E4%B8%AASpringMVC%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"初识SpringMVC第一步：创建普通maven工程 第二步：导入所需依赖 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 第三步：添加web支持 第四步：在web.xml中配置DispatcherServlet 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第五步：在资源路径下创建springmvc-servlet.xml配置文件，配置处理器映射器，处理器适配器，视图解析器 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.lizhi.controller.HelloServlet&quot;/&gt;&lt;/beans&gt; 第六步：创建HelloController实现Controller接口，并注册，id为路径 12345678910111213141516171819package com.lizhi.controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloServlet implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;msg&quot;,&quot;HelloSpringMVC&quot;); modelAndView.setViewName(&quot;hello&quot;); return modelAndView; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 第八步：启动tomcat测试 使用注解开发前四步如上 第五步：在springmvc-servlet中开启注解支持 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt; &lt;!-- Springmvc不处理静态文件--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--支持springmvc注解驱动在spring中一般采用@RequestMapping来完成映射关系要想让注解生效，则必须要向上下文注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerMapping实例这两个处理器分别是类级别和方法级别的而annotation-driven则帮助我们自动完成了这两个类的配置--&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第六步：创建Controller 123456789101112131415package com.lizhi.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class UserController &#123; @GetMapping(&quot;login&quot;) public String login(Model model)&#123; //model对象是页面模型，可以在此对象中放入业务返回的前端需要的数据 model.addAttribute(&quot;msg&quot;,&quot;请登录&quot;); return &quot;login&quot;; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建login.jsp 第八步：启动tomcat测试 如果出现404或者500错误可，尝试以下两种解决方案 在pom.xml中加入此段配置 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在artifact中加入lib目录，并将所需jar包导入其中","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"MyBatis映射器文件","slug":"MyBatis映射器文件","date":"2022-01-27T10:59:36.000Z","updated":"2022-01-27T11:01:38.799Z","comments":true,"path":"javaEE/MyBatis/2022/01/27/MyBatis映射器文件/","link":"","permalink":"http://li-zhi.net.cn/javaEE/MyBatis/2022/01/27/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8%E6%96%87%E4%BB%B6/","excerpt":"","text":"映射器文件mybatis的真正强大之处就在于它的语句映射。 正是因为此映射器文件，才使我们减少了将近95%的JDBC代码，使我们更专注于书写SQL语句 映射器文件只有这些顶级元素 cache cache-ref delete insert resultMap select sql update select该标签对标SQL语句的DQL语句，也就是select语句 123&lt;select id=&quot;getStudentById&quot; resultType=&quot;student&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 这个select语句映射namespace绑定的接口中的listTeachers方法 resultType定义返回值类型 #{id}是取到方法传入的参数 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 insert，update和delete这三个标签对标SQL语句的DML语句 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 sql该标签用来定义sql片段，一般用来定义一些可复用的SQL语句片段，使用include标签以在其他语句中使用 12345678910111213&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt; &lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt; &lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 参数如果传入一个复杂的对象，行为就会有点不一样了。比如： 1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; JDBC 要求，如果一个列允许使用 null 值，并且可能会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType) 字符串替换默认情况下，使用#{}获取参数的值的时候，mybatis会创建一个PreparedStatement对象，通过预编译，生成与#{}出现次数相同的占位符（即 ? ）这样更安全并且更迅速。 但是有时候想直接在SQL语句中插入一个字符串，不需要转义此字符串（即不需要占位符），比如ORDER BY语句，这时候可以使用${}语句，这样的话，mybatis就不会转义该字符串了 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个栗子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 而是可以只写这样一个方法： 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 结果集映射可以自定义一些复杂的返回值对象 简单结果集映射123456789@Data@NoArgsConstructor@AllArgsConstructor@Alias(&quot;aliasStudent&quot;)public class Student &#123; private Integer id; private String name; private Integer tid;&#125; 12345678&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select student_id,student_name,student_tid from student where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;studentMap&quot;&gt; &lt;id column=&quot;student_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;student_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;student_tid&quot; property=&quot;tid&quot;/&gt;&lt;/resultMap&gt; 高级结果集映射1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class Teacher &#123; private int id; private String name;&#125; 123456789101112&lt;resultMap id=&quot;teacherMap&quot; type=&quot;com.lizhi.pojo.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap的子标签 constructor 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association 一个复杂类型的关联,许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 constructor有些情况下，你会使用一个不可变类，即那些很少改变或者基本不变的类，即可以使用构造方法注入 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;&lt;/constructor&gt; id &amp; result12&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; 这些元素是结果映射的基础。 id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。 这两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 两个元素都有一些属性： 属性 描述 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 column 数据库中的列名，或者是列的别名。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 jdbcType支持的 JDBC 类型 为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY association该标签处理一个对象聚合另一个对象的关系。 mybatis有两种不同方式去加载关联 嵌套select查询：通过另一个SQL语句去加载复杂对象 嵌套结果查询：通过连接查询直接将所有的结果查询出来，放在一张表里面 嵌套select查询（不推荐）12345678910111213&lt;resultMap id=&quot;StudentMap&quot; type=&quot;student&quot;&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacherById&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;StudentMap&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 优点：SQL语句写起来方便 缺点：多层SQL嵌套，不易于维护，使用了mybatis的相关插件会导致select语句爆红，看起来不舒服 对于大型数据上，这里有一个“N+1查询问题”，问题描述如下 执行了一个单独的SQL语句去加载每一条记录的详细信息（就是+1） 对返回的列表的每一条记录，都需要执行这样的一个单独的SQL语句去加载详细信息（就是N） 这样会导致运行成千上万条sql语句，大大增加系统开销，这是我们不希望看到的 嵌套结果查询（推荐）123456789101112131415&lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; javaType=&quot;string&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot; javaType=&quot;string&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select s.id sid, s.name sname, tid, t.name tname from student s inner join teacher t on s.id = #&#123;id&#125; and tid = t.id&lt;/select&gt; 优点：配置resultMap十分方便，逻辑十分清楚，方便查错和维护 缺点：连接查询的SQL语句写起来难度大， collectioncollection可以说是多个类型的关联，所以与association的处理十分相似 嵌套select查询123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;student&quot; select=&quot;getStudentsByTid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTid&quot; resultType=&quot;student&quot;&gt; select * from student where tid = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt; 注意：这里需要使用ofType来指定集合的泛型 嵌套结果查询1234567891011121314&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT t.name tname,t.id tid,s.id sid, s.name sname FROM teacher t inner join student s on t.id=#&#123;id&#125; and s.tid=#&#123;id&#125;&lt;/select&gt; 缓存首先我们先来看一下到底什么是缓存？ 缓存这个词，相信大家对其不会陌生，因为我们在b站，腾讯视频这一类视频APP中都会缓存过一些视频。 那我们可以从中归纳出，缓存就是程序以某种形式将数据保存下来，方便下一次的使用。 那我们为什么需要使用缓存呢？ 我们都知道，我们程序员要追求三高，当然不会是高血脂，高血糖，高血压。我们所说的三高是高并发，高可用，高性能。众所周知，对于数据库的操作是比较消耗资源的。因此，多次连接数据库不利于我们达到三高，那么缓存就是会帮助我们达到三高的一种技术。 我们将用户经常查询，并且很少发生改变的数据放入缓存中，当用户下一次查询同样的数据时，就不用再去连接数据库查询数据了，减少了访问数据库的次数，减少了系统开销，从而提高了性能。 在mybatis中，存在着两种缓存机制：一级缓存和二级缓存 一级缓存该级别的缓存，mybatis是默认开启的，并且无法关闭。 该缓存是sqlSession级别的，也就是说作用域和我们之前谈过的sqlSession的作用域一致 因为用户大部分操作都是查询，但是如果出现了DML语句（即增删改）的时候，可能会对缓存中的数据造成了修改，为了安全起见，当发生增删改操作的时候，一级缓存即刻失效。 当然我们也可以手动清理缓存 二级缓存该级别的缓存，是默认关闭的，需手动打开 在mapper映射器文件中，添加以下一行代码 1234567&lt;cache/&gt;//或者加一些配置&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 在mybatis-config.xml文件中 123//可能有的小伙伴会说，该设置默认就是true，不需要写这一行代码//但是，为了显式说明我们开启了二级缓存，最好还是标注出来&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 注：如果在cache标签中没有加入readOnly&#x3D;“true”，则需要将模型类实现序列化接口（Serializable） 该缓存是namespace级别的，也就是和应用程序的生命周期一致 附上一张关于mybatis的原理图，仅供参考","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"http://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Spring-aop","slug":"Spring-aop","date":"2022-01-27T08:25:19.000Z","updated":"2022-02-24T11:00:34.477Z","comments":true,"path":"javaEE/Spring/2022/01/27/Spring-aop/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Spring/2022/01/27/Spring-aop/","excerpt":"","text":"AOPAOP为Aspect Oriented Programming的缩写，意思是面向切面编程，是通过预编译和运行期动态代理实现程序功能的统一维护的一种技术。 Spring框架两大重点，AOP和IOC(Inversion Of Control)控制反转 AOP是OOP的延续,是软件开发中的一个热点, 也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行解耦合,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性，同时提高了开发的效率。 作用及优势 作用：在程序运行期间，在不修改源码的情况下进行功能增强 优势：减少代码重复性，提高开发效率，并且便于维护 底层原理实际上，AOP的底层是通过Spring提供的的动态代理技术实现的。 在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 常用代理技术 JDK代理：基于接口的动态代理技术 Adivce.java 12345678public class Advice &#123; public void before()&#123; System.out.println(&quot;前置增强&quot;); &#125; public void after()&#123; System.out.println(&quot;后置增强&quot;); &#125;&#125; TargetInterface.java 123public interface TargetInterface &#123; void save();&#125; Target.java 123456public class Target implements TargetInterface &#123; @Override public void save()&#123; System.out.println(&quot;saving running......&quot;); &#125;&#125; ProxyTest.java 1234567891011121314151617181920public class ProxyTest &#123; public static void main(String[] args) &#123; final Target = new Target(); final Adivice = new Advice(); TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandle()&#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable &#123; advice.before(); Object invoke = method.invoke(target,args); advice.after(); return invoke; &#125; &#125; ); proxy.save(); &#125;&#125; cglib代理：基于父类的动态代理技术 ProxyTest.java 123456789101112131415161718192021222324public class ProxyTest &#123; public static void main(String[] args) &#123; Target target = new Target(); Enhance enhance = new Enhance(); //创建增强其 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(Target.class); //设置回调 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; enhance.before(); Object invoke = method.invoke(target, args); enhance.after(); return invoke; &#125; &#125;); //创建代理对象 Target proxy = (Target) enhancer.create(); proxy.save(); &#125;&#125; AOP相关术语Spring的AOP实现底层就是对上面的动态代理的代码进行了封装,封装后我们只需要对需要关注的部分进行代码编写,并通过配置的方式完成指定目标的方法增强。 Target (目标对象) :代理的目标对象 Proxy (代理) :一个类被AOP织入增强后,就产生一 个结果代理类 Joinpoint (连接点) :所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut (切入点) :所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice (通知&#x2F;增強) :所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect (切面) :是切入点和通知(引介)的结合 Weaving (织入) :是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect采用编译期织入和类装载期织入 开发明确事项 需要编写的内容 编写核心业务代码(目标类的目标方法) 编写切面类,切面类中有通知(增强功能方法) 在配置文件中，配置织入关系,即将哪些通知与哪些连接点进行结合 AOP技术实现的内容 Spring框架监控切入点方法的执行。 一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置,将通知对应的功能织入，完成完整的代码逻辑运行。 基于XML的AOP开发 步骤 导入AOP坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8.M1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建目标类和目标接口 创建切面类（内部有增强方法） 将目标类和切面类的对象的创建权交给Spring 在applicationContext.xml中配置中织入关系 测试 切点表达式1execution([修饰符]返回值类型 包名.类名.方法名(参数列表)) 访问修饰符可以省略 返回值类型、 包名、类名、方法名可以使用星号*代表任意 包名与类名之间一 个点.代表当前包下的类,两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数,任意类型的参数列表 1234567891011121314//代表切口是com.lizhi.aop.Target类的返回void的method的无参数方法execution (public void com.itheima.aop.Target.method() )//代表切口是com.lizhi.aop.Target类的返回void的所有方法，参数个数为任意execution (void com.itheima.aop.Target.*(.. ))//代表切口是com.lizhi.aop包下的所有类的所有方法，参数个数为任意execution(* com.lizhi.aop.*.*(..))//代表切口是com.lizhi.aop包及其子包下的所有类所有方法，参数个数为任意execution(* com.lizhi.aop..*.* (..) )//代表切口是项目下的所有包的所有方法，参数为任意参数execution(* *..*.*(..) ) 通知类型 名称 通知类型 说明 前置通知 aop:before 指定增强的方法在切入点之前执行 后置通知 aop:after-returning 指定增强的方法在切入点之后执行 环绕通知 aop:around 指定增强的方法在切入点之前和之后都会执行 异常抛出通知 aop:throwing 指定增强的方法在出现切点异常时执行 最终通知 aop:after 无论增强方式执行是否有异常都会执行 around 1234567//ProceedingJoinPoint指的是正在执行的连接点==切点public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕前增强。。。。。&quot;); Object obj = pjp.proceed();//切点方法 System.out.println(&quot;环绕后增强。。。。。&quot;); return obj;&#125; 切点表达式的抽取 123456&lt;apo:config&gt; &lt;aop:aspect&gt; &lt;apo:pointcut id=&quot;myPointcut&quot; expression=&quot;excution( * com.lizhi.apo.*.*(..))&quot;&gt;&lt;/apo:pointcut&gt; &lt;apo:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/apo:before&gt; &lt;/aop:aspect&gt;&lt;/apo:config&gt; 基于注解的AOP开发 创建目标接口和目标类(内部有切点) 创建切面类(内部有增强方法) 将目标类和切面类的对象创建权交给spring 在切面类中使用注解配置织入关系 在配置文件中开启组件扫描和AOP的自动代理 测试","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"http://li-zhi.net.cn/categories/javaEE/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://li-zhi.net.cn/tags/Spring/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2022-01-27T08:21:11.000Z","updated":"2022-01-27T08:22:15.896Z","comments":true,"path":"琐碎的知识/2022/01/27/面向接口编程/","link":"","permalink":"http://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/01/27/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"面向接口编程是什么大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因:解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了: 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解接口从更深层次的理解，应是定义(规范，约束)与实现(名实分离的原则)的分离。 接口的本身反映了系统设计人员对系统的抽象理解。接口应有两类: 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class) 第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface) 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向的区别面向对象编程指的是，我们考虑问题的时候，以对象为单位，考虑它的属性和方法 面向过程编程指的是，我们考虑问题的时候，以一个具体的流程（事务过程）为单位，考虑它的实现 接口设计与非接口设计是针对复用技术层面的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"MyBatis的xml配置","slug":"MyBatis配置","date":"2022-01-26T15:44:33.000Z","updated":"2022-01-27T07:40:23.106Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis配置/","link":"","permalink":"http://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置Configuration在MyBatis中，配置文件的顶层结构如下 Configuration properties settings typeAliases typeHandlers objectFactory plugins environments environment dataSource transactionManager databaseIdProvider mappers 属性properties123&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; resource属性可以导入在外部properties配置文件中的属性到properties标签中 property标签可以定义一些属性 配置好的属性可以在该文件中使用${}来替换需要动态配置的属性值 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 比如上方的driver的值会由db.properties文件中对应的值来替换 如果在多个地方进行了配置Java代码，外部文件，properties标签，则按照以下顺序加载 先加载properties标签中的属性 再加载外部文件中配置的属性，如果有重复的属性，则覆盖旧的属性 最后加载Java代码中的属性，如果有重复的属性，覆盖旧的属性 因此，通过java方法传入的属性具有最高的优先级，外部文件优先级次之，properties标签中的属性优先级最为低 设置settings以下为重要的几个配置，需要掌握 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 类型别名typeAliases在映射器XML文件中，resultType属性在配置了类型别名后，可以不需要写全限定名，可以写在这里起的别名 在此包下的所有类都被默认起别名为类名开头小写，该默认值被注解@Alias()覆盖 123&lt;typeAliases&gt; &lt;package name=&quot;com.lizhi.pojo&quot;/&gt;&lt;/typeAliases&gt; 可以单独为一个类起别名， 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.lizhi.pojo.Teacher&quot; alias=&quot;teacher&quot;/&gt;&lt;/typeAliases&gt; 下面为一些常见的java类型内建的类型别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date map Map 环境配置Environmentsmybatis可以配置多套环境，这种机制有利于将SQL映射应用于多种数据库之中。开发，测试，生成环境需要有不同的配置。 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意一些关键点 environment的id属性，该属性是唯一性标识环境的值 在environments的default属性中通过id指定环境配置 事务管理器transactionManagertype指定事务管理器 mybatis中有两种事务管理器（也就是type &#x3D; “JDBC|MANAGED”） JDBC-这个配置直接使用了JDBC的提交和回滚机制，依赖于数据源的连接来管理事务管理作用域 MANAGED-这个配置几乎什么都不做，一般不选用 如果使用mybatis+Spring 则没有必要配置事务管理器，因为Spring模块会使用自带的事务管理器来覆盖此配置 数据源dataSourcetype指定数据源类型 dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源 有三种内置的数据源格式 UNPOOLED这个数据源的实现每次连接会打开和关闭连接会有点慢，但是对于一些小型应用已经足够了， 此类型的数据源只需要配置以下几种属性 driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒） POOLED这个数据源的实现利用了池的概念将JDBC的连接对象组织起来，避免了创建新的连接实例的时候所必需的初始化和认证时间，可以使web应用响应速度变快，该类型的数据源除了以上UNPOOLED的属性外还有以下常用配置 poolMaximumActiveConnections – 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。 JNDI(用得少，略)","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"http://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"MyBatis入门","slug":"MyBatis入门","date":"2022-01-26T15:43:33.000Z","updated":"2022-01-27T07:40:32.707Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis入门/","link":"","permalink":"http://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"MyBatis回顾JDBC 注册驱动 获取连接 获取数据库操作对象 执行SQL，操作数据库 处理结果集 关闭连接 Connection可以获得PreparedStatement或者Statement ResultSet是SQL语句执行后返回的对象 PreparedStatement和Statement是用来执行SQL语句的对象 两者的区别： PreparedStatement对SQL语句做了预编译，很好的解决了SQL注入的问题。 Statement是单纯的对字符串进行拼接，会产生SQL注入的问题 简介Def： MyBatis是一个优秀的持久层的框架，支持定制化SQL语句，存储过程以及高级映射，大大简化了JDBC的笨重的代码。 MyBatis可以使用XML配置文件或者注解的方式来配置和映射原生类型、接口和pojo（Plain Object Java Object） 持久层是什么？持久层是一个将应用中产生的数据保存到数据库的过程 思路：导入依赖—》编写代码—》测试 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 入门MyBatis中最重要的三个类 SqlSessionFactoryBuilder SqlSessionFactory SqlSession 每个基于MyBatis的应用都是以一个SqlSessionFactory实例为核心的。这个实例需要通过SqlSessionFactoryBuilder加载配置文件获得。这个配置文件可以通过两种方式获得，第一种是以XML文件的形式存在，第二种是在java代码对象的形式存在 构建SqlSessionFactory mybatis-config.xml配置构建SqlSessionFactory所需要的参数 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 在java中加载配置文件，通过SqlSessionFactoryBuilder构建SqlSessionFactory实例 123String resource=&quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 通过java代码配置不推荐，略 构建SqlSessionSqlSession，通过此对象获得接口的映射器实例，该映射对象对标JDBC中接口的实现类 123456//开启一个sqlSession对象，默认关闭自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession();//开启自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession(true);TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); 映射SQL语句 通过XML配置文件的方式和接口做绑定，实现接口方法 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.mapper.TeacherMapper&quot;&gt; &lt;select id=&quot;listTeachers&quot; resultType=&quot;com.lizhi.pojo.Teacher&quot;&gt; SELECT * FROM teacher &lt;/select&gt;&lt;/mapper&gt; mapper标签的namespace属性指向被绑定的接口 标签内书写SQL语句，id为接口中的方法名 select标签实现select方法 insert标签实现insert方法 update标签实现update方法 delete标签实现delete方法 通过注解的方式实现SQL映射 12@Select(&quot;SELECT * FROM teacher WHERE id = #&#123;id&#125;&quot;)Teacher getTeacherById(int id); 选择何种方式实现SQL映射，取决于自身。 但是如果SQL复杂的情况下，尽量不要使用注解开发，使用XML的方式去做SQL映射 三个对象的作用域（Scope） SqlSessionFactoryBuilder 该对象就一个作用，通过读取一些配置获取SqlSessionFactory实例对象。 我们没有理由一直保留它，因为SqlSessionFactory将被保存在全局作用域中，以保证所有的XML解析资源可以被释放给做其他事情，所以它的作用域应该是局部变量 SqlSession 该对象就一个作用，通过getMapper方法获取映射器实例。 每个线程都应该有它自己的SqlSession对象，因为该对象不是线程安全的，因此它是不能被共享的，所以它的最佳作用域是局部变量。 在web框架中，可以将其放到request的作用域中，返回一个响应前，关闭SqlSession对象，这个关闭操作很重要 SqlSessionFactory 该对象就一个作用，通过openSession方法获取SqlSession对象。 因为SqlSession对象是线程不安全的，所以每次查询数据库都需要一个新的SqlSession对象，既然SqlSessionFactoryBuilder的作用域为局部变量，那么在我们第一次创建出来SqlSessionFactory对象的时候，就可以将其保存在全局作用域中，下次就不需要再创建SqlSessionFactoryBuilder对象了，所以SqlSessionFactory的最佳作用域是全局唯一变量。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"http://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Maven","slug":"Maven","date":"2022-01-26T15:36:37.000Z","updated":"2022-01-27T07:42:59.603Z","comments":true,"path":"javaEE/Maven/2022/01/26/Maven/","link":"","permalink":"http://li-zhi.net.cn/javaEE/Maven/2022/01/26/Maven/","excerpt":"","text":"MavenMaven简介学maven首先记住一句话，约定大于配置 Maven是什么 本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（pom） POM(Project Object Model)：项目对象模型 pom.xml—&gt;项目管理模型——&gt;依赖管理（Dependency）—&gt;本地仓库—&gt;私服仓库—&gt;中央 Maven有什么用 项目构建：提供标准化，跨平台的自动化项目构建方式 依赖管理：方便快捷的管理项目依赖的资源包，避免资源间的版本冲突问题 统一开发结构：提供标准的，统一的项目结构 下载与安装 官网：http://maven.apache.org/ 下载地址：http://maven.apache.org/download.cgi Maven环境配置 依赖java，所以需要JAVA_HOME 设置Maven自身的运行环境，需要配置MAVEN_HOME Maven基础概要仓库仓库：用于存储资源，包含各种jar包 仓库分类 本地仓库：自己电脑上的存储资源的仓库，连接远程仓库获取资源 远程仓库：非本机上的仓库，为本地仓库提供资源 中央仓库：由Maven团队维护，存储所有开源资源的仓库 私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库中获取资源 私服的作用 保护具有版权的资源，包含购买或者自主研发的jar 中央仓库中的jar都是开源的，不能存储具有版权的资源 一定范围内共享资源，就对内开放，不对外开放 坐标GAV 坐标：Maven中的坐标主要用于描述仓库中资源的位置，记住这个网站 https://mvnrepository.com/ Maven主要组成部分 groupId：定义当前项目隶属的组织名称（通常是域名反写 org.mybatis） artifactId：定义该项目的项目名称（通常是模块名称） version：定义当前项目的版本号 packaging：定义该项目的打包方式 作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成 本地仓库配置maven默认的本地仓库目录在c盘用户文件夹下的.m2文件夹中，如有需要，可在配置文件中自行配置。 在这里举个例子，我需要将D:\\APP\\Maven\\mvn-repo该目录作为我的maven本地仓库的路径。 创建mvn-repo文件夹，在此文件夹中创建repository目录 在maven安装根目录下的config文件夹下找到settings.xml找到以下配置所在，照着以下配置修改 12345678910//这里改成自己需要配置的仓库目录&lt;localRepository&gt;D:\\APP\\Maven\\mvn-repo\\repository&lt;/localRepository&gt;//阿里云的镜像服务器，会加快jar包的下载速度，直接复制即可&lt;mirrors&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirrors&gt; 将此份配置文件保存并复制到mvn-repo文件夹中 全局setting（maven的config中的setting文件）和用户setting（尽量和全局setting一样）区别 全局setting定义了当前计算机中Maven的公共配置 用户setting定义了当前用户的配置 创建maven项目手工普通maven工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-quickstart -Dversion = 0.0.1-snapshot -DinteractiveMode = false web工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-webapp -Dversion = 0.0.1-snapshot -DinteractiveMode = false 依赖管理依赖配置123456789101112&lt;!--设置当前项目所需要的依赖--&gt;&lt;dependencies&gt; &lt;!--设置具体的依赖--&gt; &lt;dependency&gt; &lt;!--依赖所属的群组id--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!--依赖所属的项目id--&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--依赖的版本号--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖传递依赖具有传递性 直接传递：在当前项目中，通过依赖配置建立的依赖关系 间接关系：被依赖的资源如果依赖其他的资源，当前项目间接依赖其他项目 依赖冲突 路径优先：当依赖中出现相同的资源时，层次越深，优先级越低，层次越浅，优先级越高 声明优先：当资源在相同层次被依赖时，配置顺序靠前的覆盖顺序靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖（主动表示断开）123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;!--不透明--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 排除依赖（主动断开） 排除依赖指的是主动断开依赖的资源，被排除的资源无需指定版本—不需要 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖范围12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies 依赖的jar包默认情况下可以在任何地方使用，可以通过scope标签设定起作用范围 作用范围 主程序范围有效（main文件范围内） 测试范围有效（test文件夹范围） 是否参与打包（package指令范围内） scope 主代码 测试代码 打包 示例 compile Y Y Y log4j test Y junit provided Y Y servlet-api runtime Y jdbc 依赖范围的传递性 带有依赖范围的资源在进行传递的时候，作用范围将会受到影响 行是直接依赖，列是间接依赖 compile test provided runtime compile compile test provided runtime test provided runtime runtime test provided runtime 生命周期以及插件生命周期 Maven对项目构建的生命周期划分为3套 clean：清理工作 default：核心工作，例如编译、测试、打包、部署等 site：产生报告，发布站点等 clean生命周期 pre-clean 执行一些需要在clean之前立即完成的工作 clean 移除所有上一次构件生成的文件 post-clean 执行一些需要在clean之后立即完成的工作 default生命周期 site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备工作 site-deploy 将生成的站点文档部署到特定服务器上面去 插件 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能 默认maven在各个生命周期上绑定有预设的功能 通过插件可以自定义其他功能","categories":[{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"http://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://li-zhi.net.cn/tags/Maven/"}]},{"title":"first","slug":"first","date":"2022-01-16T10:39:26.000Z","updated":"2022-01-16T10:39:58.900Z","comments":true,"path":"uncategorized/2022/01/16/first/","link":"","permalink":"http://li-zhi.net.cn/uncategorized/2022/01/16/first/","excerpt":"","text":"测试博客的发布","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"http://li-zhi.net.cn/categories/javaEE/JVM/"},{"name":"JavaScript","slug":"javaEE/JavaScript","permalink":"http://li-zhi.net.cn/categories/javaEE/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/categories/Redis/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"http://li-zhi.net.cn/categories/javaEE/Redis/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"http://li-zhi.net.cn/categories/javaEE/JUC/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringBoot/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"http://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"http://li-zhi.net.cn/categories/javaEE/SpringMVC/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"http://li-zhi.net.cn/categories/javaEE/Linux/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"http://li-zhi.net.cn/categories/javaEE/MyBatis/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"http://li-zhi.net.cn/categories/javaEE/Spring/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"http://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://li-zhi.net.cn/tags/Linux/"},{"name":"javaEE","slug":"javaEE","permalink":"http://li-zhi.net.cn/tags/javaEE/"},{"name":"JVM","slug":"JVM","permalink":"http://li-zhi.net.cn/tags/JVM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://li-zhi.net.cn/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"http://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Redis","slug":"Redis","permalink":"http://li-zhi.net.cn/tags/Redis/"},{"name":"JUC","slug":"JUC","permalink":"http://li-zhi.net.cn/tags/JUC/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://li-zhi.net.cn/tags/SpringBoot/"},{"name":"多线程","slug":"多线程","permalink":"http://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://li-zhi.net.cn/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://li-zhi.net.cn/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://li-zhi.net.cn/tags/Spring/"},{"name":"Maven","slug":"Maven","permalink":"http://li-zhi.net.cn/tags/Maven/"}]}