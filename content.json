{"meta":{"title":"芝麻的blog","subtitle":"百 事 可 乐","description":"芝麻的blog","author":"芝麻","url":"https://li-zhi.net.cn","root":"/"},"pages":[{"title":"标签","date":"2022-01-27T03:32:41.000Z","updated":"2022-10-04T13:44:08.523Z","comments":false,"path":"tags/index.html","permalink":"https://li-zhi.net.cn/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-26T14:34:59.000Z","updated":"2022-01-26T14:35:42.811Z","comments":true,"path":"about/index.html","permalink":"https://li-zhi.net.cn/about/index.html","excerpt":"","text":"这个是about页面"},{"title":"分类","date":"2022-01-27T03:28:29.000Z","updated":"2022-10-23T00:50:10.215Z","comments":false,"path":"categories/index.html","permalink":"https://li-zhi.net.cn/categories/index.html","excerpt":"","text":""},{"title":"有料","date":"2022-01-26T14:36:13.000Z","updated":"2022-07-29T13:09:41.266Z","comments":true,"path":"sometips/index.html","permalink":"https://li-zhi.net.cn/sometips/index.html","excerpt":"","text":"Windows下端口占用问题解决1234567891011121314# 查看端口netstat -ano# 查询指定端口netstat -ano | findstr &quot;端口号&quot;# 根据进程pid查询进程名称netstat |findstr &quot;进程pid&quot;# 根据pid杀死任务taskkill /f /pid &quot;进程pid&quot;# 根据进程名杀死任务taskkill -f -t -im &quot;进程名称&quot; Spring核心配置文件的模板1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Docker命令图 Dockerfile文件格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 基础镜像，tag不写默认为latest# 只能写一次FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;# example# FROM centos# 作者信息name一般为邮箱MAINTAINER &lt;name&gt;# example# MAINTAINER zhima&lt;1158778689@qq.com&gt;# 设置镜像的元数据标签信息LABEL &lt;info&gt;# example# LABEL version=&quot;1.0&quot;# LABEL description=&quot;this is description&quot;# 设置环境变量ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...# example# ENV DIRPATH /path# 设置运行RUN CMD ENTRYPOINT的用户名USER &lt;userName&gt;USER &lt;UID&gt;# 设置工作目录# 对RUN,CMD,ENTRYPOINT,COPY,ADD生效# 如果不存在则会创建WORKDIR 镜像内地址# example# 使用$读取环境变量# WORKDIR $DIRPATH# 定义变量# 在docker build创建镜像的时候，使用 --build-arg &lt;varname&gt;=&lt;value&gt;来指定参数ARG &lt;name&gt;[=&lt;default value&gt;]# 为子镜像设置命令# 当本镜像作为其他容器的基础镜像的时候，INSTRUCTION会在子镜像运行的时候执行ONBUILD [INSTRUCTION]# example# ONBUILD RUN ls -al# 添加文件到镜像# source可写# 宿主机的绝对路径# 本Dockerfile所在目录的相对路径# url，如果使用url，则此ADD相当于wget# source如果是压缩包，则会自动解压ADD &lt;source&gt; &lt;dest&gt;# 复制文件到镜像中# COPY的&lt;source&gt;只能是本地文件，其他用法与ADD一致COPY &lt;source&gt; &lt;dest&gt;# 在**构建**镜像的时候运行的命令，一般是安装命令RUN &lt;command&gt;RUN [&quot;executable&quot;,&quot;param1&quot;]# example# RUN yum install -y gcc# 下面三行RUN命令是为了解决以下这个错误的# Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist# RUN cd /etc/yum.repos.d/# RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*# RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*# 暴露容器运行时的监听端口给外部EXPOSE &lt;port&gt;# 但是EXPOSE并不会使容器访问主机的端口# 如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -p参数# 数据卷# 这种是匿名数据卷 宿主机会在/var/lib/docker/volumes下生成一个随机命名的目录# 可以在运行容器的时候，指定挂载卷的名字# -v 卷名:镜像内想要被挂载的地址2VOLUME [&quot;镜像内想要被挂载的地址1&quot;,&quot;镜像内想要被挂载的地址2&quot;]VOLUME &quot;镜像内想要被挂载的地址1&quot; &quot;镜像内想要被挂载的地址2&quot; # 容器**运行**的时候运行的命令CMD &lt;command&gt;CMD [&quot;executable&quot;,&quot;param1&quot;]# example# CMD [&quot;cd&quot;,&quot;/usr/local&quot;]# CMD cd /usr/local # 容器运行的时候运行的命令ENTRYPOINT java -jar demo.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;]# ENTRYPOINT和CMD的区别# 不同之处# 1.ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖# 2.如果我们在Dockerfile种同时写了ENTRYPOINT和CMD# 并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数# 3.docker run image &lt;参数&gt;# 传入的参数会追加在ENTRYPOINT之后# 如果是CMD，会直接覆盖此CMD# 相同之处# 只能写一条，如果写了多条，那么只有最后一条生效# 容器启动时才运行# 如果我们在Dockerfile种同时写了ENTRYPOINT和完整的CMD，ENTRYPOINT一定会执行，CMD不会执行 Docker-compose格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 指定compose版本，一般3.1就可以了version: &#x27;3.1&#x27;# 服务列表services: # 自定义服务名 service_name1: # 使用docker build构建镜像 # Dockerfile的地址 build: context: . dockerfile: custom-Dockerfile # 如果dockerfile文件名就叫Dockerfile，则可以使用简写模式 # build: . # 如果有build则是指定构建出来的镜像的镜像名 # 如果没有build则是指定运行的镜像 image: &lt;imageName&gt;:&lt;tag&gt; # 指定运行容器的名称 container_name: &lt;container_name&gt; # 容器卷技术 volumes: - /usr/local/mysql # 匿名挂载 - VolumeName:/home/zhima #具名挂载 - /temp/mysql/config:/etc/mysql/conf.d # 宿主机挂载 # 端口映射 ports: - &quot;宿主机端口:容器端口&quot; # 运行容器的时候的参数 command: [ &quot;param1&quot;, &quot;param2&quot; ] # 指定加入的网络 networks: - network1 - network2 # 第二个服务 service_name2: # 使用构建好的镜像 image: &lt;imageName&gt;:&lt;tag&gt; stdin_open: true # 类似于docker run -d tty: true # 类似于docker run -t depends_on: - service_name1networks: network1: driver: bridge network2: driver: bridge Git命令图 SpringMVC的web.xml模板123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 数据库模板配置文件123spring.datasource.url=jdbc:mysql://locoalhost:3306/dbname?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 MyBatis配置文件的模板核心配置文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;/configuration&gt; 映射器xml文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.youkeda.comment.dao.UserDAO&quot;&gt;&lt;/mapper&gt; druid连接池配置文件maven坐标12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 一部分核心配置文件12345678910111213141516171819202122232425262728293031323334spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/dbName?serverTimezone=UTC&amp;useUnicodestrue&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid druid特有配置 druid: initialSize: 5 minIdle: 5 maxActive: 20 maxwait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计栏截的filters，stat: 监控统计、Log4j: 日志记录、wall: 防御sqL注入 #如果允许时报借 java.Lang.CLassNotFoundException: org.apache.Log4j.Priority filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourcestat: true connectionProperties: druid.stat.mergesqletrue;druid.stat.slowSq1Millis=500 stat-view-servlet: enabled: true url-pattern: /druid/* login-password: admin login-username: 123456 allow: deny: 后台监控页面也可以通过以下方式配置 12345678910@Beanpublic ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean&lt;Servlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); params.put(&quot;loginUserName&quot;,&quot;admin&quot;); params.put(&quot;loginPassword&quot;,&quot;123456&quot;); params.put(&quot;allow&quot;,&quot;localhost&quot;); bean.setInitParameters(params); return bean;&#125; 去除druid的广告1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.lizhi.springbootdata;import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure;import com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties;import com.alibaba.druid.util.Utils;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.*;import java.io.IOException;@Configuration@ConditionalOnWebApplication@AutoConfigureAfter(DruidDataSourceAutoConfigure.class)@ConditionalOnProperty(name = &quot;spring.datasource.druid.stat-view-servlet.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)public class RemoveDruidAdConfig &#123; /** * 方法名: removeDruidAdFilterRegistrationBean * 方法描述: 除去页面底部的广告 * @param properties * @return org.springframework.boot.web.servlet.FilterRegistrationBean * @throws */ @Bean public FilterRegistrationBean removeDruidAdFilterRegistrationBean(DruidStatProperties properties) &#123; // 获取web监控页面的参数 DruidStatProperties.StatViewServlet config = properties.getStatViewServlet(); // 提取common.js的配置路径 String pattern = config.getUrlPattern() != null ? config.getUrlPattern() : &quot;/druid/*&quot;; String commonJsPattern = pattern.replaceAll(&quot;\\\\*&quot;, &quot;js/common.js&quot;); final String filePath = &quot;support/http/resources/js/common.js&quot;; //创建filter进行过滤 Filter filter = new Filter() &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(request, response); // 重置缓冲区，响应头不会被重置 response.resetBuffer(); // 获取common.js String text = Utils.readFromResource(filePath); // 正则替换banner, 除去底部的广告信息 text = text.replaceAll(&quot;&lt;a.*?banner\\&quot;&gt;&lt;/a&gt;&lt;br/&gt;&quot;, &quot;&quot;); text = text.replaceAll(&quot;powered.*?shrek.wang&lt;/a&gt;&quot;, &quot;&quot;); response.getWriter().write(text); &#125; @Override public void destroy() &#123; &#125; &#125;; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(filter); registrationBean.addUrlPatterns(commonJsPattern); return registrationBean; &#125;&#125; GitHub加速https://gitee.com/docmirror/dev-sidecar?_from=gitee_search 高质量项目https://github.com/kon9chunkit/Github-Chinese-Top-Charts#%E7%9B%AE%E5%BD%95 官方文档https://docs.github.com/cn maven中资源导出出现问题123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; CORS跨域请求的配置1234567891011121314151617import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowCredentials(true) .allowedOriginPatterns(&quot;*&quot;) .maxAge(2000); &#125;&#125; 12345678910111213141516171819202122232425import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig1 &#123; private static final long MAX_AGE=24*60*60; private CorsConfiguration buildConfig()&#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); corsConfiguration.setMaxAge(MAX_AGE); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter()&#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;,buildConfig()); return new CorsFilter(source); &#125;&#125; SpringSession的配置123456789101112131415161718192021222324252627282930import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.session.MapSessionRepository;import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;import org.springframework.session.web.http.CookieSerializer;import org.springframework.session.web.http.DefaultCookieSerializer;import java.util.concurrent.ConcurrentHashMap;@Configuration@EnableSpringHttpSessionpublic class SpringHttpSessionConfig &#123; @Bean public CookieSerializer cookieSerializer() &#123; DefaultCookieSerializer serializer = new DefaultCookieSerializer(); serializer.setCookieName(&quot;JSESSIONID&quot;); // 用正则表达式配置匹配的域名，可以兼容 localhost、127.0.0.1 等各种场景 serializer.setDomainNamePattern(&quot;^.+?\\\\.(\\\\w+\\\\.[a-z]+)$&quot;); serializer.setCookiePath(&quot;/&quot;); serializer.setUseHttpOnlyCookie(false); // 最大生命周期的单位是秒 serializer.setCookieMaxAge(48 * 60 * 60); return serializer; &#125; @Bean public MapSessionRepository sessionRepository() &#123; return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); &#125;&#125; Log4j 核心配置文件12345678910111213141516171819202122232425#将等级为DEBUG的志信息输出到console和file这两个目的地。console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#范制台偷出的相关设置log4j.appender.console =org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target=System.outlog4j.appender.console.Threshold=DEBUglog4j.appender.console.layout =org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file =org.apache.log4j.RollingFileAppender#日志文件输出的磁盘路径log4j.appender.file.File=./log/lizhi.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日去输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.Preparedstatement=DEBUG 字体图标的使用使用字体图标前，添加字体申明，参考如下或者直接在style.css文件中复制 1234567891011@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?suef9x&#x27;); src: url(&#x27;fonts/icomoon.eot?suef9x#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?suef9x&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?suef9x&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?suef9x#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block;&#125; 记得修改字体（font-family）为icomoon"}],"posts":[{"title":"【437-Medium】路径总和Ⅱ","slug":"【437-Medium】路径总和Ⅱ","date":"2022-10-22T07:35:53.000Z","updated":"2022-11-10T09:18:13.897Z","comments":true,"path":"javaEE/2022/10/22/【437-Medium】路径总和Ⅱ/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/22/%E3%80%90437-Medium%E3%80%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/","excerpt":"","text":"路径总和Ⅱ给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 示例 1： 123输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。 示例 2： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：3 提示: 二叉树的节点个数的范围是 [0,1000] -109 &lt;= Node.val &lt;= 109 -1000 &lt;= targetSum &lt;= 1000 Related Topics 树 深度优先搜索 二叉树 深度优先搜索这道题与之前做过的二叉树路径的题目不同 之前做的题目中的路径都是要求从根节点开始到叶子节点结束 但是这道题要求路径不需要从根节点开始，也不需要在叶子节点结束，路径方向必须是向下的（只能从父节点到子节点）。 那么这种路径怎么做呢？ 那不能从根节点出发，这个根节点是特定的，就是整棵树的根节点root 但是root的左子树的根节点是root.left，root的右子树的根节点是root.right 所以我只需要对每一个子树进行求解，然后求和即可 1234567891011121314151617181920212223242526272829class Solution &#123; // 找到以root为根节点的树的路径和为targetSum的路径个数 public int pathSum(TreeNode root, int targetSum) &#123; if (root==null)&#123; return 0; &#125; // 求得以root为根的树的路径总和 int rootLead = count(root,targetSum); // 求得以root.left为根的树的路径总和 int leftLead = pathSum(root.left,targetSum); // 求得以root.right为根的树的路径总和 int rightLead = pathSum(root.right,targetSum); return rootLead + leftLead + rightLead; &#125; // 找到以root为根节点的树的路径和为targetSum的路径个数，这个路径是从根节点出发 private int count(TreeNode root,long sum)&#123; if(root==null)&#123; return 0; &#125; // 根节点的数字就满足了sum，自成一个路径 // 这里为什么不能直接返回，因为可能左子树会出现一正一负的情况，然后也是符合和为sum的情况 int me = (root.val == sum) ? 1 : 0; // 在root.left找满足sum-root.val的节点 int leftCount = count(root.left,sum-root.val); // 在root.right找满足sum-root.val的节点 int rightCount = count(root.right,sum-root.val); return me + leftCount + rightCount; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【752-Medium】打开转盘锁","slug":"【752-Medium】打开转盘锁","date":"2022-10-22T05:42:04.000Z","updated":"2022-11-10T09:21:31.668Z","comments":true,"path":"javaEE/2022/10/22/【752-Medium】打开转盘锁/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/22/%E3%80%90752-Medium%E3%80%91%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/","excerpt":"","text":"打开转盘锁你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。 示例 1: 123456输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 示例 2: 123输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。 示例 3: 123输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。 提示： 1 &lt;= deadends.length &lt;= 500 deadends[i].length == 4 target.length == 4 target 不在 deadends 之中 target 和 deadends[i] 仅由若干位数字组成 Related Topics 广度优先搜索 数组 哈希表 字符串 BFS这是一道典型的广度优先的题目 我的理解是和回溯算法一样，也有三个要素 1、路径：密码字符串 2、结束条件：密码字符串和target一致 3、选择列表：密码的每一位都可以拨一下 和回溯不同的是，BFS不需要撤销选择而是保存选择到一个队列中，一般还需要一个visited用来排除已经走过的路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123; // BFS public int openLock(String[] deadends, String target) &#123; // 初始状态 String begin = &quot;0000&quot;; // 保存所有的状态 Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); // 用来排除走过的路 // 0000通过plus(str,3)0001 // 下一次循环0001有可能subOne(str,3)又回到0000，这样就是死循环了 Set&lt;String&gt; visited = new HashSet&lt;&gt;(); // 死亡序列 Set&lt;String&gt; dead = new HashSet&lt;&gt;(); Collections.addAll(dead, deadends); // 将begin放入队列中 queue.offer(begin); visited.add(begin); int size; // 记录步数 int count = 0; // 开始BFS while(!queue.isEmpty())&#123; size = queue.size(); for(int i = 0;i &lt; size;i++)&#123; String poll = queue.poll(); // 如果poll在死亡列表中，跳过这次的选择，poll被放弃 if (dead.contains(poll))&#123; continue; &#125; // 找到了密码，结束循环，返回步数 if(poll.equals(target))&#123; return count; &#125; // 对每一位进行加减操作，如果没有被访问过，则放入queue和visited中 for(int j = 0;j &lt; begin.length();j++)&#123; String temp = subOne(poll,j); if(!visited.contains(temp))&#123; visited.add(temp); queue.offer(temp); &#125; temp = plusOne(poll,j); if(!visited.contains(temp))&#123; visited.add(temp); queue.offer(temp); &#125; &#125; &#125; // 记录步数 count++; &#125; // 说明是死局 return -1; &#125; // 做出选择 private String subOne(String str,int index)&#123; char[] arr = str.toCharArray(); if (arr[index]==&#x27;0&#x27;)&#123; arr[index] = &#x27;9&#x27;; &#125;else &#123; arr[index] -= 1; &#125; return String.valueOf(arr); &#125; // 做出选择 private String plusOne(String str,int index)&#123; char[] arr = str.toCharArray(); if (arr[index]==&#x27;9&#x27;)&#123; arr[index] = &#x27;0&#x27;; &#125;else &#123; arr[index] += 1; &#125; return String.valueOf(arr); &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【48-Medium】旋转图像","slug":"【48-Medium】旋转图像","date":"2022-10-22T03:52:17.000Z","updated":"2022-11-10T09:16:20.598Z","comments":true,"path":"javaEE/2022/10/22/【48-Medium】旋转图像/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/22/%E3%80%9048-Medium%E3%80%91%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2： 12输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 提示： n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 Related Topics 数组 数学 矩阵 解法这种题目一般都需要数学知识 所有数字顺时针旋转90° 我们可以先将矩阵镜面翻转，然后对每一行逆转 然后就得到了顺时针旋转90°的矩阵 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public void rotate(int[][] matrix) &#123; // 镜像翻转 mirror(matrix); for (int[] row : matrix) &#123; reverseRow(row); &#125; &#125; private void mirror(int[][] matrix)&#123; int width = matrix.length; for (int i = 0; i &lt; width; i++) &#123; for (int j = i; j &lt; width; j++) &#123; // 将matrix[i][j]和matrix[j][i]交换 swap(i,j,j,i,matrix); &#125; &#125; &#125; // 逆转这一行 // 利用双指针技巧原地修改原数组 private void reverseRow(int[] arr)&#123; // [left,right] int left = 0; int right = arr.length-1; while (left&lt;=right)&#123; int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; left++; right--; &#125; &#125; private void swap(int x1,int y1,int x2,int y2,int[][] matrix)&#123; int temp = matrix[x1][y1]; matrix[x1][y1] = matrix[x2][y2]; matrix[x2][y2] = temp; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【300-Medium】最长递增子序列","slug":"【300-Medium】最长递增子序列","date":"2022-10-22T02:36:35.000Z","updated":"2022-11-10T09:17:51.642Z","comments":true,"path":"javaEE/2022/10/22/【300-Medium】最长递增子序列/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/22/%E3%80%90300-Medium%E3%80%91%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你能将算法的时间复杂度降低到 O(n log(n)) 吗? Related Topics 数组 二分查找 动态规划 动态规划这是一道动态规划的问题 我们先来找找状态，这道题的状态肯定是数组的索引，所以我们就来看下如何通过这个状态求得答案 先给这个函数 lengthOfLIS(int[] nums,int index)一个定义：返回以nums[index]结尾的最长递增子序列的长度 base case是当index为 0 的时候，返回 1 ，即它自成一个递增数组 然后遍历数组取得最大值 12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int max = 0; // 找到最大值 for (int i = 0; i &lt; nums.length; i++) &#123; max = Math.max(lengthOfLIS(nums,i),max); &#125; return max; &#125; // 函数定义是返回以nums[index]结尾的最长递增子序列的长度 private int lengthOfLIS(int[] nums,int index)&#123; // base case if(index==0)&#123; return 1; &#125; int res = 1; for(int j = 0;j &lt; index ;j++)&#123; // 当nums[index]比nums[j]大的话，那就lengthOfLIS(nums,j)+1和res作比较，取最大 if(nums[index]&gt;nums[j])&#123; res = Math.max(lengthOfLIS(nums,j)+1,res); &#125; &#125; return res; &#125;&#125; 备忘录然后就是添加一个备忘录来优化 1234567891011121314151617181920212223242526272829class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int max = 0; int[] meno = new int[nums.length]; Arrays.fill(meno,-1); for (int i = 0; i &lt; nums.length; i++) &#123; max = Math.max(lengthOfLIS(nums,i,meno),max); &#125; return max; &#125; // 函数定义是返回以nums[index]结尾的最长递增子序列的长度 private int lengthOfLIS(int[] nums,int index,int[] meno)&#123; if (meno[index]!=-1)&#123; return meno[index]; &#125; if(index==0)&#123; meno[0] = 1; return 1; &#125; int res = 1; for(int j = 0;j &lt; index ;j++)&#123; if(nums[index]&gt;nums[j])&#123; res = Math.max(lengthOfLIS(nums,j,meno)+1,res); &#125; &#125; meno[index] = res; return res; &#125;&#125; 动态规划最后就是动态规划了！ 1234567891011121314151617181920class Solution &#123; public int lengthOfLIS(int[] nums) &#123; // dp[i]的意思是以nums[i]结尾的最长递增子序列的长度 int[] dp = new int[nums.length]; Arrays.fill(dp,1); for(int i=0;i &lt; nums.length;i++)&#123; for(int j=0;j &lt; i;j++)&#123; if(nums[i]&gt;nums[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; &#125; // 取得数组中得最大值 int res = 0; for (int i = 0; i &lt; dp.length; i++) &#123; res = Math.max(res, dp[i]); &#125; return res; &#125;&#125; 二分查找这道题有一个特殊的解法，当然哈，一般人也想不到这种解法，就当看个乐子了。 然后按以下逻辑维护这样的一个结构 1、找到第一个堆顶元素比其大的堆，更新堆顶元素 2、如果找不到，则添加一个新的堆，将该元素放入该堆 这样你就会发现这些堆顶元素是递增的，然后堆的个数其实就是最长递增子序列（Longest Increasing SubSequence） 123456789101112131415161718192021222324252627282930public int lengthOfLIS(int[] nums) &#123; // 维护每个最小堆的堆顶元素 int[] top = new int[nums.length]; // 一开始没有堆 int piles = 0; int left; int right; int mid; int target; for(int i=0;i&lt;nums.length;i++)&#123; target = nums[i]; left = 0; right = piles; // 维护区间[left,right) // 找到最左边的 while(left&lt;right)&#123; mid = left + (right-left)/2; if(top[mid]&gt;target)&#123; right=mid; &#125;else if(top[mid]&lt;target)&#123; left = mid+1; &#125;else &#123; right=mid; &#125; &#125; if(left==piles)piles++; top[left] = target; &#125; return piles;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【72-Hard】编辑距离","slug":"【72-Hard】编辑距离","date":"2022-10-22T00:15:46.000Z","updated":"2022-11-10T09:16:48.037Z","comments":true,"path":"javaEE/2022/10/22/【72-Hard】编辑距离/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/22/%E3%80%9072-Hard%E3%80%91%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"编辑距离给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;) 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 Related Topics 字符串 动态规划 递归暴力穷举动态规划问题都需要走这几步： 暴力递归–&gt;带备忘录的递归–&gt;动态规划 动态规划问题三特点 1、重叠子问题：重复计算相同的子问题 2、最优子结构：子问题的最优解可以推导到父问题的最优解 3、状态转移方程：状态如何转变 两个重点 1、哪些是状态：变化的量就是状态，有几个变化的量就有几个状态 2、状态转移方程 对于字符串，我们都会使用一个从0开始或者从str.length()-1的指针开始遍历整个字符串 1234567891011121314151617181920212223242526272829303132public int minDistance(String word1, String word2) &#123; // 两个字符串都从后向前遍历 return minDistance(word1,word2, word1.length()-1, word2.length()-1);&#125;private int minDistance(String word1, String word2, int i, int j) &#123; // 代表word1已经遍历完毕 // 然后返回word2没遍历完的长度 // 表示将word2还没遍历完的字符添加到word1的操作步数 if (i==-1)&#123; return j+1; &#125; // 代表word2已经遍历完成 // 返回word1还没遍历完的长度 // 表示删除word1前面还没遍历完的步数 if (j==-1)&#123; return i+1; &#125; // 如果两个位置的字符相同，同时向前走一位即可，不添加操作步数 if (word1.charAt(i)==word2.charAt(j))&#123; return minDistance(word1,word2,i-1,j-1); &#125; // 对三种操作进行取最小值 return min( minDistance(word1, word2, i, j - 1) + 1,//插入，即word2向前走一位 minDistance(word1, word2, i - 1, j) + 1,//删除，即word1向前走一位 minDistance(word1, word2, i - 1, j - 1) + 1);//替换，即两者都向前走一位&#125;// 取得三个的最小值private int min(int a,int b,int c)&#123; return Math.min(Math.min(a,b),c);&#125; 如何发现有子问题的存在呢？ 我们将以上代码中递归调用的地方取出来 123minDistance(word1, word2, i, j - 1)minDistance(word1, word2, i, j - 1)minDistance(word1, word2, i - 1, j - 1) 如果我先递归调用minDistance(word1, word2, i, j - 1)，然后递归调用minDistance(word1, word2, i - 1, j)，那不就是调用了minDistance(word1, word2, i - 1, j - 1)吗？ 如果先调用的minDistance(word1, word2, i, j - 1)，然后递归调用minDistance(word1, word2, i - 1 , j)，那不就是调用了minDistance(word1, word2, i - 1, j - 1)吗？ 所以这里是一定有重叠的计算 接下来我们使用一个备忘录来记录计算结果，减少重复计算 带备忘录的穷举123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int minDistance(String word1, String word2) &#123; // meno[i][j]的含义是编辑长度为 int[][] meno = new int[word1.length()+1][word2.length()+1]; for (int[] row : meno) &#123; // 随便取什么负数都可以，除了-1 Arrays.fill(row, -3); &#125; return minDistance(word1,word2, word1.length(), word2.length(),meno); &#125; // i代表word1的编辑长度 // j代表word2的编辑长度 private int minDistance(String word1, String word2, int i, int j, int[][] meno) &#123; // 如果word1到头了，直接返回word2的剩余长度 if (i==0)&#123; return j; &#125; // 如果word2到头了，直接返回word1的剩余长度 if (j==0)&#123; return i; &#125; // 如果备忘录有值，直接返回 if (meno[i][j]!=-3)&#123; return meno[i][j]; &#125; // 如果字符相等，两者都往前 if (word1.charAt(i-1)==word2.charAt(j-1))&#123; return minDistance(word1,word2,i-1,j-1, meno); &#125; int min = min( minDistance(word1, word2, i, j - 1, meno) + 1,//插入 minDistance(word1, word2, i - 1, j, meno) + 1,//删除 minDistance(word1, word2, i - 1, j - 1, meno) + 1);//替换 // 记录值 meno[i][j] = min; return min; &#125; // 取得三个的最小值 private int min(int a,int b,int c)&#123; return Math.min(Math.min(a,b),c); &#125;&#125; 动态规划接下来就是正宗的动态规划了！ 其实带备忘录的递归最后的meno和dp数组是一样的 但是meno是自底往上计算而来，dp是自上往下计算而来 到了这里，这题的状态指的是i和j 状态转移方程如下 12345f(i,j) = &#123; j , i=0 i , j=0 min(f(i-1,j)+1,f(i,j-1)+1,f(i-1,j-1)+1) , i!=0&amp;&amp;j!=0 &#125; 代码如下 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int minDistance(String word1, String word2) &#123; // dp数组的定义是长度为i的word1变为长度为j的word2的最小编辑距离 // 即：s1[0,i-1]到s2[0,j-1]的最小编辑距离 int[][] dp = new int[word1.length()+1][word2.length()+1]; // 先初始化dp数组，将一些base case写入数组 // 如果word1长度为i，word2的长度为0，则word1最少需要i步删除 for (int i = 1; i &lt;= word1.length(); i++) &#123; dp[i][0] = i; &#125; // 如果word1长度为0，word2的长度为i，则word1最少需要i步增加 for (int i = 1; i &lt;= word2.length(); i++) &#123; dp[0][i] = i; &#125; // word1的编辑长度从1变到word1.length() // word2的编辑长度从1变到word2.length() for (int i = 1; i &lt;= word1.length(); i++) &#123; for (int j = 1; j &lt;= word2.length(); j++) &#123; if (word1.charAt(i-1)==word2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125;else &#123; // 取最小步骤 dp[i][j] = min( dp[i][j-1]+1,//增加 dp[i-1][j]+1,//删除 dp[i-1][j-1]+1);//替换 &#125; &#125; &#125; // 返回最后的结果 return dp[word1.length()][word2.length()]; &#125; private int min(int a,int b,int c)&#123; return Math.min(Math.min(a,b),c); &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【773-Hard】滑动谜题","slug":"【773-Hard】滑动谜题","date":"2022-10-21T00:38:17.000Z","updated":"2022-11-10T09:20:59.060Z","comments":true,"path":"javaEE/2022/10/21/【773-Hard】滑动谜题/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/21/%E3%80%90773-Hard%E3%80%91%E6%BB%91%E5%8A%A8%E8%B0%9C%E9%A2%98/","excerpt":"","text":"滑动谜题在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示。一次 移动 定义为选择 0 与一个相邻的数字（上下左右）进行交换. 最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。 给出一个谜板的初始状态 board ，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。 示例 1： 123输入：board = [[1,2,3],[4,0,5]]输出：1解释：交换 0 和 5 ，1 步完成 示例 2: 123输入：board = [[1,2,3],[5,4,0]]输出：-1解释：没有办法完成谜板 示例 3: 1234567891011输入：board = [[4,1,2],[5,0,3]]输出：5解释：最少完成谜板的最少移动次数是 5 ，一种移动路径:尚未移动: [[4,1,2],[5,0,3]]移动 1 次: [[4,1,2],[0,5,3]]移动 2 次: [[0,1,2],[4,5,3]]移动 3 次: [[1,0,2],[4,5,3]]移动 4 次: [[1,2,0],[4,5,3]]移动 5 次: [[1,2,3],[4,5,0]] 提示： board.length == 2 board[i].length == 3 0 &lt;= board[i][j] &lt;= 5 board[i][j] 中每个值都 不同 Related Topics 广度优先搜索 数组 矩阵 BFS这道题的重点就是以哪个视角做题 如果以每个不空的位置的视角做，会十分复杂 如果我们以0的位置的视角来做，移动数字即移动空格，这样的视角让我们只需要关注0的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class Solution &#123; public int slidingPuzzle(int[][] board) &#123; // 保存路径 Queue&lt;int[][]&gt; queue = new LinkedList&lt;&gt;(); // 用来排除已经走过的路 HashSet&lt;String&gt; visited = new HashSet&lt;&gt;(); queue.offer(board); visited.add(parseString(board)); // 记录步数 int count = 0; int size; while (!queue.isEmpty()) &#123; size = queue.size(); for (int i = 0; i &lt;size; i++) &#123; int[][] poll = queue.poll(); // 如果满足结束条件，直接返回步数 if (end(poll))&#123; return count; &#125; // 找到0的位置 int[] zeroIndex = findZero(poll); int x = zeroIndex[0]; int y = zeroIndex[1]; int[][] exchange; String str; // 左边有位置 if (y&gt;0)&#123; exchange = exchange(x, y, x, y - 1, poll); str = parseString(exchange); if (!visited.contains(str)) &#123; visited.add(str); queue.offer(exchange); &#125; &#125; // 上面有位置 if (x&gt;0)&#123; exchange = exchange(x,y,x-1,y,poll); str = parseString(exchange); if (!visited.contains(str)) &#123; visited.add(str); queue.offer(exchange); &#125; &#125; // 下边有位置 if (x&lt;board.length-1)&#123; exchange = exchange(x, y, x + 1, y, poll); str = parseString(exchange); if (!visited.contains(str)) &#123; visited.add(str); queue.offer(exchange); &#125; &#125; // 右边有位置 if (y&lt;board[0].length-1)&#123; exchange = exchange(x, y, x, y + 1, poll); str = parseString(exchange); if (!visited.contains(str)) &#123; visited.add(str); queue.offer(exchange); &#125; &#125; &#125; count++; &#125; return -1; &#125; // 将二维矩阵转化为字符串 private String parseString(int[][] board)&#123; StringBuilder stringBuffer = new StringBuilder(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; stringBuffer.append(board[i][j]); &#125; &#125; return stringBuffer.toString(); &#125; // 判断是否满足结束条件 private boolean end(int[][] board)&#123; int index = 1; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j]!=index)&#123; return false; &#125; index=(index+1)%6; &#125; &#125; return true; &#125; // 交换board的[x1,y1]和[x2,y2] private int[][] exchange(int x1,int y1,int x2,int y2,int[][] board)&#123; int[][] res = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; System.arraycopy(board[i], 0, res[i], 0, board[0].length); &#125; res[x1][y1] = board[x2][y2]; res[x2][y2] = board[x1][y1]; return res; &#125; // 找到0在棋盘中的位置 private int[] findZero(int[][] board)&#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j]==0)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 优化上面那种的空间复杂度不得了 我们来优化一下，将二维的棋盘转换为一维的棋盘来做 这种优化的重点在于理解parseNeighborMap 将每一个二维数组中的元素映射到一维数组中，并且通过其一维索引可以得到其所有邻居的一维索引 这话说的绕的 直接看图 1Map&lt;Integer, List&lt;Integer&gt;&gt; neighborMap = parseNeighborMap(board); 下面看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class Solution &#123; public int slidingPuzzle(int[][] board) &#123; // 目标状态 String target = &quot;123450&quot;; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); Map&lt;Integer, List&lt;Integer&gt;&gt; neighborMap = parseNeighborMap(board.length,board[0].length); visited.add(parseString(board)); queue.offer(parseString(board)); int count = 0; int size; while (!queue.isEmpty())&#123; size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; String poll = queue.poll(); if (poll.equals(target))&#123; return count; &#125; int idx = getZeroIndex(poll); // 得到所有的邻居与其交换位置 for (Integer neighbor : neighborMap.get(idx)) &#123; String exchange = swap(poll, idx, neighbor); if (!visited.contains(exchange))&#123; queue.offer(exchange); visited.add(exchange); &#125; &#125; &#125; // 记录步数 count++; &#125; // 无解返回-1 return -1; &#125; // 得到0所在的位置 private int getZeroIndex(String str)&#123; for(int i = 0;i &lt; str.length();i++)&#123; if(str.charAt(i)==&#x27;0&#x27;)&#123; return i; &#125; &#125; return -1; &#125; // 得到邻居映射 private Map&lt;Integer, List&lt;Integer&gt;&gt; parseNeighborMap(int height,int width)&#123; Map&lt;Integer, List&lt;Integer&gt;&gt; res = new HashMap&lt;&gt;(); for (int i = 0; i &lt; height * width; i++) &#123; res.put(i,new LinkedList&lt;&gt;()); &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; // 一维的索引 int oneDimension = getOneDimension(i,j); // 可以向上走 if (i&gt;0)&#123; res.get(oneDimension).add(getOneDimension(i-1,j)); &#125; // 可以向下走 if (i&lt;height-1)&#123; res.get(oneDimension).add(getOneDimension(i+1,j)); &#125; // 可以向左走 if (j&gt;0)&#123; res.get(oneDimension).add(getOneDimension(i,j-1)); &#125; // 可以向右走 if (j&lt;width-1)&#123; res.get(oneDimension).add(getOneDimension(i,j+1)); &#125; &#125; &#125; return res; &#125; // 得到在宽为width的二维矩阵坐标为[x,y]的一维索引 private int getOneDimension(int x,int y,int width)&#123; return x * width + y; &#125; // 交换str的a和b位置，返回一个新的字符串 private String swap(String str,int a,int b)&#123; char[] chars = str.toCharArray(); char temp = chars[a]; chars[a] = chars[b]; chars[b] = temp; return String.valueOf(chars); &#125; // 将二维矩阵转换为字符串 private String parseString(int[][] board)&#123; StringBuilder stringBuffer = new StringBuilder(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; stringBuffer.append(board[i][j]); &#125; &#125; return stringBuffer.toString(); &#125;&#125; 回溯回溯解题，但是因为这题需要的是最小步数，所以这种方法看看就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Solution &#123; int count; public int slidingPuzzle(int[][] board) &#123; Map&lt;Integer, List&lt;Integer&gt;&gt; available = getAvailable(board.length, board[0].length); count = 0; char[] track = parseString(board).toCharArray(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); slidingPuzzle(track,available,visited); return count; &#125; private boolean end(char[] track)&#123; char[] target = &quot;123450&quot;.toCharArray(); for (int i = 0; i &lt; track.length; i++) &#123; if (target[i]!=track[i])&#123; return false; &#125; &#125; return true; &#125; private boolean slidingPuzzle(char[] track, Map&lt;Integer, List&lt;Integer&gt;&gt; available, Set&lt;String&gt; visited) &#123; if (end(track))&#123; return true; &#125; int zeroIndex = findZero(track); for (Integer nei : available.get(zeroIndex)) &#123; exchange(track,nei,zeroIndex); String stackString = String.valueOf(track); if (visited.contains(stackString)) &#123; continue; &#125; visited.add(stackString); count++; if (slidingPuzzle(track,available,visited)) &#123; return true; &#125; exchange(track,nei,zeroIndex); count--; &#125; return false; &#125; private int findZero(char[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i]==&#x27;0&#x27;)&#123; return i; &#125; &#125; return -1; &#125; private void exchange(char[] arr,int i,int j)&#123; char temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; private String parseString(int[][] board)&#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; sb.append(board[i][j]); &#125; &#125; return sb.toString(); &#125; private Map&lt;Integer, List&lt;Integer&gt;&gt; getAvailable(int height,int width)&#123; Map&lt;Integer, List&lt;Integer&gt;&gt; res = new HashMap&lt;&gt;(); for (int i = 0; i &lt; height * width; i++) &#123; res.put(i,new LinkedList&lt;&gt;()); &#125; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; // 一维的索引 int oneDimension = i * width + j; // 可以向上走 if (i&gt;0)&#123; res.get(oneDimension).add((i-1)*width+j); &#125; // 可以向下走 if (i&lt;height-1)&#123; res.get(oneDimension).add((i+1)*width+j); &#125; // 可以向左走 if (j&gt;0)&#123; res.get(oneDimension).add(i*width+j-1); &#125; // 可以向右走 if (j&lt;width-1)&#123; res.get(oneDimension).add(i*width+j+1); &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【215-Medium】数组中的第k个最大的元素、","slug":"【215-Medium】数组中的第k个最大的元素","date":"2022-10-20T09:02:00.000Z","updated":"2022-11-10T09:17:07.233Z","comments":true,"path":"javaEE/2022/10/20/【215-Medium】数组中的第k个最大的元素/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/20/%E3%80%90215-Medium%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"数组中的第k个最大的元素给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1: 12输入: [3,2,1,5,6,4], k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4 提示： 1 &lt;= k &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 Related Topics 数组 分治 快速选择 排序 堆（优先队列） 堆利用优先队列，其本质就是二叉堆。 将所有元素放入一个最大堆，然后将堆顶元素出堆k-1次，最后的堆顶元素就是第k大的元素，这个方法的空间复杂度比较大 1234567891011121314151617class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; // java默认优先级队列的实现是最小堆，所以需要传入一个lambda表达式 PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a); // 将所有元素放入最大堆 for (int num : nums) &#123; maxHeap.add(num); &#125; int res ; // 将堆顶元素弹出k-1次 for (int i = 0; i &lt; k-1; i++) &#123; maxHeap.poll(); &#125; // 返回堆顶元素 return maxHeap.peek(); &#125;&#125; 快速选择其实就是利用了快排中的拆分数组的函数partition，将基准值放到其该放的位置，并将其位置返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if (k&gt;nums.length)&#123; return -1; &#125; // 维护的区间是[left,right] int[] copy = new int[nums.length]; // 因为不能修改原数组 // 复制数组nums到copy中 System.arraycopy(nums, 0, copy, 0, nums.length); shuffle(copy); // 如果我要第k大的元素 // 那就是要第nums.length-k+1小的元素 // 即升序排序后索引为nums.length-k的元素 k = nums.length-k; int left = 0; int right = copy.length-1; int mid; while (left&lt;=right)&#123; mid = partition(copy,left,right); // 说明k排名比较靠前，所以需要继续向左边找，缩小右边界 if (mid &gt; k)&#123; right = mid - 1; &#125;else if (mid &lt; k)&#123; left = mid + 1; &#125;else &#123; return copy[mid]; &#125; &#125; return -1; &#125; // 随即置换算法 private void shuffle(int[] nums)&#123; Random random = new Random(); for (int i = 0; i &lt; nums.length; i++) &#123; // 每次取[i,nums.length) int r = random.nextInt(nums.length - i) + i; exchange(nums,r,i); &#125; &#125; private int partition(int[] nums, int left, int right) &#123; int pivot = nums[left]; // [left,leftIndex)&lt;=pivot // (rightIndex,right]&gt;pivot int leftIndex = left+1; int rightIndex = right; while (true)&#123; while (nums[leftIndex]&lt;=pivot&amp;&amp;leftIndex&lt;=right)&#123; leftIndex++; &#125; // nums[leftIndex]&gt;pivot while (nums[rightIndex]&gt;pivot&amp;&amp;rightIndex&gt;=left)&#123; rightIndex--; &#125; // nums[rightIndex]&lt;=pivot // 如果rightIndex已经走到了leftIndex的左边，返回 if (leftIndex&gt;=rightIndex)&#123; break; &#125; exchange(nums,leftIndex,rightIndex); &#125; // 最后出来的时候，nums[rightIndex]&lt;=pivot的 exchange(nums,rightIndex,left); return rightIndex; &#125; private void exchange(int[] nums,int a,int b)&#123; int temp = nums[a]; nums[a] = nums[b]; nums[b]=temp; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【37-Hard】解数独","slug":"【37-Hard】解数独","date":"2022-10-20T03:14:43.000Z","updated":"2022-11-10T09:16:06.152Z","comments":true,"path":"javaEE/2022/10/20/【37-Hard】解数独/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/20/%E3%80%9037-Hard%E3%80%91%E8%A7%A3%E6%95%B0%E7%8B%AC/","excerpt":"","text":"解数独编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1： 123输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 &#39;.&#39; 题目数据 保证 输入数独仅有一个解 Related Topics 数组 回溯 矩阵 回溯这里需要关注一下题目给的提示，我们来一一分析 第一条和第二条告诉我们，传入的数组是一个固定9 * 9的矩阵 第三条告诉我们&#39;.&#39;指的是空位 第四条告诉我们题目传入的数独只有一个答案，这就代表着我最后穷举出来解满足条件的只有一个 回溯三要素 1、路径：填上的数字，就是棋盘上的数字 2、选择列表：&#39;1&#39;-&#39;9&#39; 3、结束条件：穷举到最后一个格子（由第四条提示可得） 下面直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public void solveSudoku(char[][] board) &#123; // 辅助函数 solveSudoku(board,0,0); &#125; // 路径：已经被填上数字的棋盘，即row之前 // 对每一个格子的选择列表: 1 - 9 // 结束条件：穷举到最后一行 private boolean solveSudoku(char[][] board, int row, int column) &#123; // 返回true，结束递归 // 到了最后一行 if (row==board.length)&#123; return true; &#125; // 到了这一行的结尾了，换行 if (column==board[0].length)&#123; return solveSudoku(board,row+1,0); &#125; // 如果已经有数字了，直接下一列 // 因为给出的棋盘中有的格子中是有数字的 if (board[row][column]!=&#x27;.&#x27;)&#123; return solveSudoku(board,row,column+1); &#125; // 穷举 for (char ch = &#x27;1&#x27;; ch &lt;= &#x27;9&#x27;; ch++) &#123; // 如果要填写的数字不合法，直接跳过此次选择 if (!valid(board,row,column,ch))&#123; continue; &#125; // 做出选择 board[row][column] = ch; // 如果已经得到答案，直接结束穷举，返回true if(solveSudoku(board,row,column+1))&#123; return true; &#125; // 撤销选择 board[row][column] = &#x27;.&#x27;; &#125; // [row][column]这个格子填1-9都不合法，回退上一个格子，撤销上一次的选择 return false; &#125; // 判断要填入[row,column]的这个key是否符合规则 private boolean valid(char[][] board, int row, int column, char key) &#123; for (int i = 0; i &lt; board.length; i++) &#123; // 这一列不能有重复数字 if (board[i][column]==key)&#123; return false; &#125; // 这一行不能用重复数字 if (board[row][i]==key)&#123; return false; &#125; // 九宫格不能有重复数字 // 这里要斟酌一下的 if (board[(row / 3) * 3 + i / 3][(column / 3) * 3 + i % 3]==key)&#123; return false; &#125; &#125; return true; &#125;&#125; 我们来看下这个valid函数中判断九宫格内是否有重复数字的代码 123if (board[(row / 3) * 3 + i / 3][(column / 3) * 3 + i % 3]==key)&#123; return false;&#125; 12345row/3 可以将其映射到其对应的九宫格行column/3 可以将其映射到其对应的九宫格列i -&gt; [0,1,2,3,4,5,6,7,8]i/3 -&gt; [0,0,0,1,1,1,2,2,2]i%3 -&gt; [0,1,2,0,1,2,0,1,2] 进阶如果我将提示的第四条，即只有一个正确答案这个条件删除，那这道题该怎么做？ 其实也不难，只要改变结束条件即可，上述代码是直接将可以穷举到最后的答案返回 因为题目说了只有唯一解，所以我不需要再对其进行判断 既然删除了只有唯一解这个条件，那我就要对穷举到最后的答案进行验证 怎么验证呢，那就是验证每一行每一列对角线加起来都是一样的 12345678910111213141516171819202122232425262728293031private boolean valid(int[][] board)&#123; int sum = Arrays.stream(board[0]).sum(); int row = 0; int column = 0; int downCatercorner = 0; int upCatercorner = 0; // 计算行列和对角线的和 for (int i = 0; i &lt; board.length; i++) &#123; row = 0; for (int j = 0; j &lt; board[0].length; j++) &#123; row += board[i][j]; column +=board[j][i]; // 从左上角到右下角的对角线 if (i==j)&#123; downCatercorner+=board[i][j]; &#125; // 从左下角到右上角的对角线 if (i+j==board.length-1)&#123; upCatercorner += board[i][j]; &#125; &#125; // 每一次循环中对比行和列的和 if (row!=sum||column!=sum)&#123; return false; &#125; row = 0; column=0; &#125; // 最后对比对角线的和 return downCatercorner == sum &amp;&amp; upCatercorner == sum;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【46-Medium】全排列","slug":"【46-Medium】全排列","date":"2022-10-20T00:18:57.000Z","updated":"2022-11-10T09:16:13.938Z","comments":true,"path":"javaEE/2022/10/20/【46-Medium】全排列/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/20/%E3%80%9046-Medium%E3%80%91%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 Related Topics 数组 回溯 回溯全排列，这是很经典的一道回溯的问题 回溯三要素 1、路径：已经做出了哪些选择 2、选择列表：可以选择的元素集合 3、结束条件：到了决策树的叶子节点处了 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 这个是结果集用来保存结果的 List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); // 路径 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); // 辅助函数 backtrack(nums,track,res); return res; &#125; // 路径：track中的数字 // 选择列表：通过track和nums推得 // 结束条件：track的长度等于nums的长度 private void backtrack(int[] nums, LinkedList&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; res)&#123; // 到了叶子节点处 if (track.size()== nums.length)&#123; // 将当前路径加入到结果集 res.add(new LinkedList&lt;&gt;(track)); return; &#125; // 遍历选择列表 for (int i = 0; i &lt; nums.length; i++) &#123; // 筛选掉不符合要求的选择列表 if (track.contains(nums[i]))&#123; continue; &#125; // 做出选择 track.add(nums[i]); // 回溯 backtrack(nums,track,res); // 撤销选择 track.removeLast(); &#125; &#125;&#125; 所有的回溯问题，其实就是一棵决策树的遍历过程。 在前序位置做出选择，在后序位置撤销选择","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【51-Hard】N皇后","slug":"【51-Hard】N皇后","date":"2022-10-19T08:12:28.000Z","updated":"2022-11-10T09:16:26.604Z","comments":true,"path":"javaEE/2022/10/19/【51-Hard】N皇后/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/19/%E3%80%9051-Hard%E3%80%91N%E7%9A%87%E5%90%8E/","excerpt":"","text":"N皇后按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例 1： 123输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 12输入：n = 1输出：[[&quot;Q&quot;]] 提示： 1 &lt;= n &lt;= 9 Related Topics 数组 回溯 回溯N皇后问题和全排列问题被称为回溯问题的两大经典问题 今天我们就来盘一盘N皇后问题 回溯题目三大基本元素 路径、选择列表、结束条件 我们来一 一看看在这道题目中都和什么对应 路径 路径就是已经选择将皇后放哪后的棋盘board 选择列表 选择列表就是每一行的每一列放QUEUE 结束条件 结束条件就是当选择到了最后一行，则将当前棋盘加入到结果集中去 下面上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Solution &#123; // 空位 private static final String EMPTY = &quot;.&quot;; // 皇后 private static final String QUEUE = &quot;Q&quot;; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; // 结果集，用来保存所有符合要求的结果 List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); // 用n初始化棋盘 String[][] board = new String[n][n]; // 用空位填充每一个位置 fillEmpty(board); // 辅助函数 solveNQueens(board,0,res); return res; &#125; // 将棋盘置空 private void fillEmpty(String[][] board) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; board[i][j] = EMPTY; &#125; &#125; &#125; // 装配结果集到符合题目要求的格式 private List&lt;String&gt; assemble(String[][] board)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); StringBuffer temp = new StringBuffer(); for (String[] row : board) &#123; for (String c : row) &#123; temp.append(c); &#125; res.add(temp.toString()); temp = new StringBuffer(); &#125; return res; &#125; // 回溯函数 private void solveNQueens(String[][] board, int row, List&lt;List&lt;String&gt;&gt; res) &#123; // 符合退出条件 if (row==board.length)&#123; res.add(assemble(board)); return; &#125; // 对每一列进行选择 for (int column = 0; column &lt; board[0].length; column++) &#123; // 如果选择不符合要求，直接跳过此次选择 if (!valid(board,row,column))&#123; continue; &#125; board[row][column] = QUEUE; solveNQueens(board,row+1,res); board[row][column] = EMPTY; &#125; &#125; // 判断此次选择是否合法 // 注意：这里还没做出选择，只是预判此次选择是否合法 private boolean valid(String[][] board, int row, int column) &#123; // 上方 for (int r = 0; r &lt; row; r++) &#123; if (board[r][column].equals(QUEUE))&#123; return false; &#125; &#125; // 左边不需要，因为我是对每一行的每一列进行选择，并且选择之后会撤销，所以不需要进行行上的判断 /*for (int c = 0; c &lt; column; c++) &#123; if (board[row][c].equals(QUEUE))&#123; return false; &#125; &#125;*/ // 左上方 for (int r = row - 1, c = column - 1; r &gt;= 0 &amp;&amp; c &gt;= 0; r-- , c--) &#123; if (board[r][c].equals(QUEUE))&#123; return false; &#125; &#125; // 右上方 for (int r = row - 1, c = column + 1; r &gt;= 0 &amp;&amp; c &lt;board[0].length; r-- , c++) &#123; if (board[r][c].equals(QUEUE))&#123; return false; &#125; &#125; return true; &#125;&#125; 以下是 n=4 的递归树 黄色的小方块表示此次选择是合法的 红色的小方块表示此次选择是不合法的，直接跳过此次选择 绿色的屏障表示的此次选择到了结束条件，直接将其放入结果集中 回溯问题无非就是遍历一颗递归树，然后在前序位置判断这次选择是否合法，如果合法就进入子树，然后在后序位置将此次选择撤销","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【22-Medium】括号生成","slug":"【22-Medium】括号生成","date":"2022-10-18T12:44:00.000Z","updated":"2022-11-10T09:15:52.713Z","comments":true,"path":"javaEE/2022/10/18/【22-Medium】括号生成/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/18/%E3%80%9022-Medium%E3%80%91%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"","text":"括号生成数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 12输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;] 示例 2： 12输入：n = 1输出：[&quot;()&quot;] 提示： 1 &lt;= n &lt;= 8 Related Topics 字符串 动态规划 回溯 回溯这是我第一次写的时候直接套用的回溯框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public List&lt;String&gt; generateParenthesis(int n) &#123; // 用来保存结果的集合 List&lt;String&gt; res = new ArrayList&lt;&gt;(); // 路径 char[] trace = new char[n * 2]; // 选择列表 char[] choices = new char[]&#123;&#x27;(&#x27;,&#x27;)&#x27;&#125;; backTrace(0,trace,res,choices); return res;&#125;private void backTrace(int index, char[] trace, List&lt;String&gt; res,char[] choices) &#123; // 如果索引到了路径的长度，说明结束了 if (index==trace.length)&#123; // 还要判断左右括号的数目是否相等 if (isAdd(trace)) &#123; res.add(String.valueOf(trace)); &#125; return; &#125; for (char choice : choices) &#123; // 如果加入choice后，trace不合法，则直接跳过本次递归 if (!isStringValid(trace,index,choice))&#123; continue; &#125; trace[index] = choice; backTrace(index+1,trace,res,choices); trace[index] = &#x27; &#x27;; &#125;&#125;// 判断左右括号是否相等private boolean isAdd(char[] trace)&#123; int left = 0; int right = 0; for (int i = 0; i &lt; trace.length; i++) &#123; if (trace[i]==&#x27;(&#x27;)&#123; left++; &#125;else if (trace[i]==&#x27;)&#x27;)&#123; right++; &#125; &#125; return left==right;&#125;// 判断是否可以将choice加入到index的位置private boolean isStringValid(char[] trace, int index, char choice) &#123; int left = 0; int right = 0; for (int i = 0; i &lt; index; i++) &#123; if (trace[i]==&#x27;(&#x27;)&#123; left++; &#125;else if (trace[i]==&#x27;)&#x27;)&#123; right++; &#125; if (right&gt;left)&#123; return false; &#125; &#125; if (choice==&#x27;(&#x27;)&#123; left++; &#125;else if (choice==&#x27;)&#x27;)&#123; right++; &#125; return left &gt;= right;&#125; 这种方法的递归树会很大 原因在于，修剪的力度不够大，isStringValid只能判断当前的index位是否可以加入choice 但是无法保证最后生成的字符串是符合左右括号数目相等的 所以需要在满足推出条件的时候，再次判断是否符合左右括号数目一致 导致此方法时间复杂度很高 优化这道题目对于每一次决策的选择列表中只有两种选择，[&#39;(&#39;,&#39;)] 并且需要频繁计算左右括号的数目 所以我们可以记录左右括号的剩余数目 从而使用括号剩余数目来判断当前生成的字符串是否合法 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); char[] trace = new char[n * 2]; // index从0开始 // 还剩下n个左括号 // 还剩下n个右括号 // trace用来记录路径 // res用来收集结果 backTrace(0,n,n,trace,res); return res;&#125;private void backTrace(int index,int left,int right, char[] trace, List&lt;String&gt; res) &#123; // 如果剩下的右括号比左括号少 // n = 5 // 剩下了4个左括号，1个右括号 ，这是错的情况 // 剩下了4个右括号，1个左括号 ，这是对的情况 // 剩下了3个右括号，3个左括号 ，这是对的情况 // 说明左括号多放了 if (right &lt; left)&#123; return; &#125; // 如果剩余的左括号个数小于0 if (left &lt; 0)&#123; return; &#125; // 长度到达要，因为不符合要求的字符串已经被修剪 // 所以能走到这里的肯定是合法的字符串了 // 将其加入到结果集合中 if (index == trace.length)&#123; res.add(String.valueOf(trace)); return; &#125; trace[index]=&#x27;(&#x27;; // 左括号个数-1 backTrace(index+1,left-1,right,trace,res); trace[index] = &#x27;)&#x27;; // 右括号个数-1 backTrace(index+1,left,right-1,trace,res);&#125; 这里给出优化后 n=2 的递归树 优化前的 n=2 的递归树 n=2 看不出优化后明显的增加修剪的力度 感兴趣的可以自己画一画 n=3 的递归树，你就会发现有很明显的区别","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【563-Easy】二叉树的坡度","slug":"【563-Easy】二叉树的坡度","date":"2022-10-18T00:04:44.000Z","updated":"2022-11-10T09:20:17.371Z","comments":true,"path":"javaEE/2022/10/18/【563-Easy】二叉树的坡度/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/18/%E3%80%90563-Easy%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/","excerpt":"","text":"二叉树的坡度给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度就是其所有节点的坡度之和。 示例 1： 1234567输入：root = [1,2,3]输出：1解释：节点 2 的坡度：|0-0| = 0（没有子节点）节点 3 的坡度：|0-0| = 0（没有子节点）节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）坡度总和：0 + 0 + 1 = 1 示例 2： 12345678910输入：root = [4,2,9,3,5,null,7]输出：15解释：节点 3 的坡度：|0-0| = 0（没有子节点）节点 5 的坡度：|0-0| = 0（没有子节点）节点 7 的坡度：|0-0| = 0（没有子节点）节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15 示例 3： 12输入：root = [21,7,14,1,1,2,2,3,3]输出：9 提示： 树中节点数目的范围在 [0, 104] 内 -1000 &lt;= Node.val &lt;= 1000 Related Topics 树 深度优先搜索 二叉树 遍历1234567891011121314151617181920class Solution &#123; int res; public int findTilt(TreeNode root) &#123; res = 0; traverseA(root); return res; &#125; // 返回的是以root为根的树的节点总和 private int traverseA(TreeNode root) &#123; if (root==null)&#123; return 0; &#125; int left = traverseA(root.left); int right = traverseA(root.right); // 累加 res += Math.abs(right-left); return root.val + left + right; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【904-Medium】水果成篮","slug":"【904-Medium】水果成篮","date":"2022-10-17T09:57:13.000Z","updated":"2022-11-10T09:21:25.319Z","comments":true,"path":"javaEE/2022/10/17/【904-Medium】水果成篮/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/17/%E3%80%90904-Medium%E3%80%91%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","excerpt":"","text":"水果成篮你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length Related Topics 数组 哈希表 滑动窗口 滑动窗口这就是一个典型的滑动窗口的问题 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int totalFruit(int[] fruits) &#123; // key是水果种类 // value是篮子中的水果数目 HashMap&lt;Integer,Integer&gt; window = new HashMap&lt;&gt;(); int max = 1; int left = 0; int right = 0; int fruitType; // 维护的区间是[left,right) while (right &lt; fruits.length)&#123; // 拿到当前的水果类型 fruitType = fruits[right]; // 将对应的水果类型的数目加1 window.merge(fruitType,1, Integer::sum); // 如果窗口大小大于2则缩小窗口 while (window.size()&gt;2)&#123; fruitType = fruits[left]; if (window.merge(fruitType,-1,Integer::sum)==0) &#123; window.remove(fruitType); &#125; left++; &#125; max = Math.max(getSum(window), max); right++; &#125; return max; &#125; // 封装好一个函数，用来计算窗口中所有水果的数量和 private int getSum(HashMap&lt;Integer, Integer&gt; window) &#123; int sum = 0; for (Integer fruitType : window.keySet()) &#123; sum += window.get(fruitType); &#125; return sum; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【226-Easy】翻转二叉树","slug":"【226-Easy】翻转二叉树","date":"2022-10-17T09:47:52.000Z","updated":"2022-11-10T09:17:14.535Z","comments":true,"path":"javaEE/2022/10/17/【226-Easy】翻转二叉树/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/17/%E3%80%90226-Easy%E3%80%91%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 示例 2： 12输入：root = [2,1,3]输出：[2,3,1] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 Related Topics 树 深度优先搜索 广度优先搜索 二叉树 遍历遍历一棵树的同时将左右子树互换位置 1234567891011121314151617181920class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; // 辅助函数 traverse(root); return root; &#125; private void traverse(TreeNode root) &#123; if (root==null)&#123; return; &#125; // 暂存root的左子树的根节点 TreeNode temp = root.left; // 将其替换 root.left = root.right; root.right = temp; traverse(root.left); traverse(root.right); &#125;&#125; 分解问题invertTree函数给予它一个定义：返回以root为根节点的翻转后的二叉树 123456789101112131415class Solution &#123; // 函数定义：返回以`root`为根节点的翻转后的二叉树 public TreeNode invertTree(TreeNode root) &#123; if (root==null)&#123; return null; &#125; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); // 直接将返回的right赋值给root的left root.left = right; // 直接将返回的left赋值给root的right root.right = left; return root; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1022-Easy】从根到叶的二进制之和","slug":"【1022-Easy】从根到叶的二进制之和","date":"2022-10-09T02:24:22.000Z","updated":"2022-11-10T09:21:38.642Z","comments":true,"path":"javaEE/2022/10/09/【1022-Easy】从根到叶的二进制之和/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/09/%E3%80%901022-Easy%E3%80%91%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E5%92%8C/","excerpt":"","text":"从根到叶的二进制之和给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。 例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。 返回这些数字之和。题目数据保证答案是一个 32 位 整数。 示例 1： 123输入：root = [1,0,1,0,1,0,1]输出：22解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 示例 2： 12输入：root = [0]输出：0 提示： 树中的节点数在 [1, 1000] 范围内 Node.val 仅为 0 或 1 Related Topics 树 深度优先搜索 二叉树 遍历一棵树1234567891011121314151617181920212223class Solution &#123; int sum; public int sumRootToLeaf(TreeNode root) &#123; sum = 0; traverseSumRootToLeaf(root,0); return sum; &#125; public void traverseSumRootToLeaf(TreeNode root,Integer val)&#123; if (root==null) &#123; return; &#125; // 累加先将val左移，然后或上root的val val = (val &lt;&lt; 1) | root.val; if(root.left==null&amp;&amp;root.right==null)&#123; // 到了叶子节点就将val的值加到sum中 sum += val; return; &#125; traverseSumRootToLeaf(root.left,val); traverseSumRootToLeaf(root.right,val); &#125;&#125; 分解问题二进制之和 &#x3D; 左子树二进制之和 + 右子树二进制之和 12345678910111213141516class Solution &#123; public int sumRootToLeaf(TreeNode root) &#123; return traverseSumRootToLeaf(root,0); &#125; public int traverseSumRootToLeaf(TreeNode root,Integer val)&#123; if (root==null) &#123; return 0; &#125; val = (val &lt;&lt; 1) | root.val; if(root.left==null&amp;&amp;root.right==null)&#123; return val; &#125; return traverseSumRootToLeaf(root.left,val) + traverseSumRootToLeaf(root.right,val); &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【230-Medium】二叉搜索树中第k小的元素","slug":"【230-Medium】二叉搜索树中第k小的元素","date":"2022-10-09T01:16:03.000Z","updated":"2022-11-10T09:17:28.698Z","comments":true,"path":"javaEE/2022/10/09/【230-Medium】二叉搜索树中第k小的元素/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/09/%E3%80%90230-Medium%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"二叉搜索树中第k小的元素给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 12输入：root = [3,1,4,null,2], k = 1输出：1 示例 2： 12输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3 提示： 树中的节点数为 n 。 1 &lt;= k &lt;= n &lt;= 104 0 &lt;= Node.val &lt;= 104 进阶：如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？ Related Topics 树 深度优先搜索 二叉搜索树 二叉树 利用中序遍历众所周知 二叉搜索树的中序遍历是升序排序 那我们就可以利用这一点来完成这道题 1234567891011121314151617181920212223242526// 记录当前排名int rank;// 记录第k小的值int val;public int kthSmallest(TreeNode root, int k) &#123; rank = 0; val = 0; traverse(root,k); return val;&#125;public void traverse(TreeNode root,int k)&#123; if(root==null)&#123; return; &#125; traverse(root.left,k); // 排名加1 rank++; // 如果排名和 k 相同了 if(rank==k)&#123; // 保存第k小的值 val = root.val; // 找到了就不需要继续找右子树了 return; &#125; traverse(root.right,k);&#125; 为节点添加信息对于BST，我们如果要搜索一个值，我们会怎么做？ 根据二叉搜索树的定义，左小右大 如果搜索的值比当前节点的值大，则只需要往右边搜索 如果搜索的值比当前节点的值小，则只需要往左边搜索 从而避免了全树搜索，达到了O(logN)级别的复杂度 123456789101112131415public TreeNode search(TreeNode root,int key)&#123; if(root==null)&#123; return null; &#125; // 如果root的值和key相同了，则返回 if(root.val == key)&#123; return root; &#125; // 如果root的val大于key，则说明key在root的左子树 if(root.val &gt; key)&#123; return search(root.left,key); &#125; // key在root的右子树 return search(root.right,key);&#125; 那么对于这一题，我们现在是全树搜索，复杂度是O(N)，我可不可以做到logN级别呢？ 那么关键点就在于每个节点需要知道自己排第几，这样的话，也就可以根据刚刚说的思路走，达到O(logN)级别的复杂度 假如节点知道自己排名第m，我需要找排名是k的元素 1、m==k，则当前元素就是排名第 k 的元素 2、m &lt; k，则说明第 k 个数在当前节点的右边，则去右子树搜索第k - m - 1位元素 3、m &gt; k，则说明第 k 个数在当前节点的左边 那么这个m如何得到呢？ 回到二叉搜索树的定义，左小右大，中序遍历升序排序 我们随便找一颗二叉搜索树观察可知，每一个节点的排名就是其左子树的节点总数 + 1 那么我可以将TreeNode设计成这样 123456public void TreeNode&#123; public int size; public int val; public TreeNode left; public TreeNode right;&#125; 有了size字段，我可以通过其左子树根节点的size + 1即可得到自身的排名 注意：此方法无法在力扣提交，因为我们无法改变力扣中TreeNode的结构，但是需要你掌握此技巧 123456789101112131415161718192021222324252627282930313233343536373839// 记录第k小的值int val;public int kthSmallest(TreeNode root, int k) &#123; val = 0; // 填充每个节点的size fillSize(root); traverse(root,k); return val;&#125;public int fillSize(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = fillSize(root.left); int right = fillSize(root.right); root.size = left + right + 1; return root.size;&#125;public void traverse(TreeNode&lt;Integer&gt; root,int k)&#123; if(root==null)&#123; return; &#125; int rank = root.left == null ? 1 : root.left.size + 1; if(rank==k)&#123; // 如果k==rank，则找到第k小的元素，直接返回并保存节点的值 val = root.val; return; &#125;else if(rank &gt; k)&#123; // 如果rank &gt; k则说明第k个元素在左子树中 traverse(root.left,k); &#125;else &#123; // 如果rank &lt; k则说明 第k个元素在右子树中 // 这里需要将k的值传入k - rank - 1的原因是 // traverse的定义是在以root为根的树中，找第k个元素 // 所以在总树中第k个元素，就是在其右子树中k-rank-1个元素 // rank &gt; k的情况中，第k个元素就在其左子树中，所以不需要改变k的值，直接传入k即可 traverse(root.right,k - rank - 1); &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【538-Medium】把二叉搜索树转换为累加树","slug":"【538-Medium】把二叉搜索树转换为累加树","date":"2022-10-09T01:00:07.000Z","updated":"2022-11-10T09:20:04.012Z","comments":true,"path":"javaEE/2022/10/09/【538-Medium】把二叉搜索树转换为累加树/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/09/%E3%80%90538-Medium%E3%80%91%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","excerpt":"","text":"把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 12输入：root = [0,null,1]输出：[1,null,1] 示例 3： 12输入：root = [1,0,2]输出：[3,3,2] 示例 4： 12输入：root = [3,2,4,1]输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 Related Topics 树 深度优先搜索 二叉搜索树 二叉树 二叉搜索树的基础知识BST（Binary Search Tree || Binary Sorted Tree）二叉搜索树（也就是二叉排序树） 它两个特点 1、对于每一个节点node，都有其左子树的所有节点都小于node的val，右子树的所有节点都大于node的val 2、中序遍历的结果是升序排序 1234567891011121314public List&lt;Integer&gt; asc;public List&lt;Integer&gt; asc(TreeNode root)&#123; asc = new ArrayList&lt;&gt;(); asc(root); return asc;&#125;public void asc(TreeNode root)&#123; if(root==null)&#123; return; &#125; asc(root.left); asc.add(root.val); asc(root.right);&#125; 那如果我想得到一个BST的降序排序呢？ 难道是拿到BST的中序遍历结果，然后逆转过来 逆转的想法没错，但是这个逆转可以提前一点做 对于中序顺序，我们给的定义是 左子树 + 根节点 + 右子树 这就是升序，那么对于降序，逆转一下，不就是 右子树 + 根节点 + 左节点吗 1234567891011121314public List&lt;Integer&gt; asc;public List&lt;Integer&gt; asc(TreeNode root)&#123; asc = new ArrayList&lt;&gt;(); asc(root); return asc;&#125;public void asc(TreeNode root)&#123; if(root==null)&#123; return; &#125; asc(root.right); asc.add(root.val); asc(root.left);&#125; 解题有了基础知识的铺垫，这道题就很简单了 需要将每个节点 node 的新值等于原树中大于或等于 node.val 的值之和 那不就是使用降序的顺序遍历一下 并且使用一个累加器记录累加状态即可 123456789101112131415161718// 累加器，记录累加状态public int counter;public TreeNode asc(TreeNode root)&#123; counter = 0; asc(root); return root;&#125;public void asc(TreeNode root)&#123; if(root==null)&#123; return; &#125; asc(root.right); // 累加 counter += root.val; // 更新值 root.val = counter; asc(root.left);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【623-Medium】在二叉树中增加一行","slug":"【623-Medium】在二叉树中增加一行","date":"2022-10-09T00:19:21.000Z","updated":"2022-11-10T09:20:48.397Z","comments":true,"path":"javaEE/2022/10/09/【623-Medium】在二叉树中增加一行/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/09/%E3%80%90623-Medium%E3%80%91%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/","excerpt":"","text":"在二叉树中增加一行给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例 1: 12输入: root = [4,2,6,3,1,5], val = 1, depth = 2输出: [4,1,1,2,null,null,6,3,1,5] 示例 2: 12输入: root = [4,2,null,3,1], val = 1, depth = 3输出: [4,2,null,1,1,3,null,null,1] 提示: 节点数在 [1, 104] 范围内 树的深度在 [1, 104]范围内 -100 &lt;= Node.val &lt;= 100 -105 &lt;= val &lt;= 105 1 &lt;= depth &lt;= the depth of tree + 1 Related Topics 树 深度优先搜索 广度优先搜索 二叉树 遍历因为涉及到增加子树 所以肯定需要知道在增加位置的节点的父母节点 那么也就是说要在父母节点的时候就需要预知是否需要增加子树 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; // 用来存储需要增加位置的深度 int dep; public TreeNode addOneRow(TreeNode root, int val, int depth) &#123; // 深度为 1 的时候需要单独讨论 // 这种情况比较简单 if(depth == 1)&#123; TreeNode newRoot = new TreeNode(val); newRoot.left = root; return newRoot; &#125; dep = depth; // root视为第一层 addOneRowOnDepth(root,val,1); return root; &#125; private void addOneRowOnDepth(TreeNode root, int val, int curDepth) &#123; if(root==null)&#123; return; &#125; // 在父母节点处预知需要增加子树 // 需要在dep处增加节点 // 也就是给dep-1处的节点增加左右子树 if(dep==curDepth+1)&#123; // 先将节点创建出来 TreeNode left = new TreeNode(val); TreeNode right = new TreeNode(val); // 将left的left置为root的left left.left = root.left; // 将root的left置为刚刚创建的节点 root.left = left; // 将left的left置为root的left right.right=root.right; // 将root的left置为刚刚创建的节点 root.right = right; // 这里直接返回，深度越往下遍历越大，其子树不可能再满足条件了 return ; &#125; addOneRowOnDepth(root.left, val, curDepth + 1); addOneRowOnDepth(root.right, val, curDepth + 1); &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【979-Medium】在二叉树中分配硬币","slug":"【979-Medium】在二叉树中分配硬币","date":"2022-10-08T07:40:11.000Z","updated":"2022-11-10T09:21:18.976Z","comments":true,"path":"javaEE/2022/10/08/【979-Medium】在二叉树中分配硬币/","link":"","permalink":"https://li-zhi.net.cn/javaEE/2022/10/08/%E3%80%90979-Medium%E3%80%91%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/","excerpt":"","text":"在二叉树中分配硬币给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。 返回使每个结点上只有一枚硬币所需的移动次数。 示例 1： 123输入：[3,0,0]输出：2解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。 示例 2： 123输入：[0,3,0]输出：3解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。 示例 3： 12输入：[1,0,2]输出：2 示例 4： 12输入：[1,0,0,null,3]输出：4 提示： 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N Related Topics 树 深度优先搜索 二叉树 这题难在如何计算最小的移动次数 node的值就三种情况1、n(大于1)、0 1 它已经满足条件了 n(大于1) 它可以为其父亲节点提供n-1个硬币 0 它需要一个硬币，也就是需要从其父节点那拿一个硬币 123456789101112131415161718class Solution &#123; int count; public int distributeCoins(TreeNode root) &#123; count = 0; distribute(root); return count; &#125; private int distribute(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; int leftMore = distribute(root.left); int rightMore = distribute(root.right); count+=Math.abs(leftMore) + Math.abs(rightMore); return leftMore+rightMore+root.val-1; &#125;&#125; 说实在的这道题需要一定的数学理解力","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【315-Hard】计算右侧小于当前元素的个数","slug":"【315-Hard】计算右侧小于当前元素的个数","date":"2022-10-02T01:16:49.000Z","updated":"2022-10-20T11:45:37.068Z","comments":true,"path":"算法/刷题篇/2022/10/02/【315-Hard】计算右侧小于当前元素的个数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/10/02/%E3%80%90315-Hard%E3%80%91%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"计算右侧小于当前元素的个数给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例 1： 1234567输入：nums = [5,2,6,1]输出：[2,1,1,0] 解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 示例 2： 12输入：nums = [-1]输出：[0] 示例 3： 12输入：nums = [-1,-1]输出：[0,0] 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 Related Topics 树状数组 线段树 数组 二分查找 分治 有序集合 归并排序 法一：暴力老样子，先上最简单的方法，暴力遍历，两层循环搞定 12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; countSmaller(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; res.add(i,0); &#125; int count; for (int i = 0; i &lt; nums.length; i++) &#123; count = 0; for (int j = i; j &lt; nums.length; j++) &#123; if(nums[i]&gt;nums[j])&#123; count++; &#125; &#125; res.set(i,count); &#125; return res; &#125;&#125; OK，测试通过！ 提交！ 难度为Hard的题目这么好过吗？不可能的，双层循环必然是顶不住大数据的拷打的 接下来我们来考虑如何将复杂度降低 法二：分治回顾归并排序我们第一次接触分治思想应该都是在归并算法吧 想想第一次学归并算法的时候的一脸懵逼到现在的两眼呆滞，归并怎么写的来着？ 这一次解决这道题目的同时，将归并算法也理解的透透的！ 先来回顾一下归并排序的图解 先将数组不断拆分，拆到只剩一个元素 一个元素自然是排好序的 然后将拆分后的两个有序数组合并 不断重复，即可得到一个排好序的数组 下面是归并排序的几种写法 都是升序 12345678910111213141516171819202122232425262728293031323334/*** 这种写法的特点是会频繁创建数组，并且不是直接操作原数组，返回的是一个新数组* 不是很建议这样写，但是这种方法最适合一开始理解*/private static int[] mergeSort(int[] range) &#123; if(range.length == 1)&#123; return range; &#125; int mid = range.length &gt;&gt; 1 ; int[] leftArray = mergeSort(Arrays.copyOfRange(range, 0, mid)); int[] rightArray = mergeSort(Arrays.copyOfRange(range, mid, range.length)); return mergeSortedArray(leftArray,rightArray);&#125;private static int[] mergeSortedArray(int[] leftArray, int[] rightArray) &#123; int[] res = new int[leftArray.length + rightArray.length]; int index = 0; int left = 0; int right = 0; while (left &lt; leftArray.length &amp;&amp; right &lt; rightArray.length)&#123; if(leftArray[left] &lt;= rightArray[right])&#123; res[index++] = leftArray[left++]; &#125;else &#123; res[index++] = rightArray[right++]; &#125; &#125; while (left &lt; leftArray.length)&#123; res[index++] = leftArray[left++]; &#125; while (right &lt; rightArray.length)&#123; res[index++] = rightArray[right++]; &#125; return res;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/*** 这种方法主要特点是使用left、right、mid直接分割原数组* 直接操作原数组，但是也需要频繁创建辅助数组temp，空间复杂度有点大*/private static int[] mergeSort(int[] range) &#123; if(range.length == 1)&#123; return range; &#125; mergeSortSelf(range,0,range.length-1); return range;&#125;private static void mergeSortSelf(int[] range, int left, int right) &#123; if(right == left)&#123; return; &#125; int mid = left + (right - left ) / 2; mergeSortSelf(range, left, mid); mergeSortSelf(range, mid+1, right); int[] temp = new int[right - left + 1]; int index = 0; int leftIndex = left; int rightIndex = mid + 1; while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right)&#123; if(range[leftIndex] &lt;= range[rightIndex])&#123; temp[index++] = range[leftIndex++]; &#125;else &#123; temp[index++] = range[rightIndex++]; &#125; &#125; while (leftIndex &lt;= mid)&#123; temp[index++] = range[leftIndex++]; &#125; while (rightIndex &lt;= right)&#123; temp[index++] = range[rightIndex++]; &#125; index = 0; for (int i = left; i &lt;= right; i++,index++) &#123; range[i] = temp[index]; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 这种方法主要特点是使用left、right、mid直接分割原数组* 提前准备一个temp* 这种方法是比较常用的*/private static int[] mergeSort(int[] range) &#123; if(range.length == 1)&#123; return range; &#125; mergeSortSelf(range, 0, range.length-1, new int[range.length]); return range;&#125;private static void mergeSortSelf(int[] range, int left, int right,int[] temp) &#123; // 已经分割到了一个元素了，无法再分割了 if(right == left)&#123; return; &#125; // 从中间分割数组 int mid = left + (right - left ) / 2; mergeSortSelf(range, left, mid); mergeSortSelf(range, mid+1, right); // 将这次需要合并的区间暂存在辅助数组temp中 for(int i = left;i &lt;= right; i++)&#123; temp[i] = range[i]; &#125; // 这是左边数组的左边界 int leftIndex = left; // 这是右边数组的左边界 int rightIndex = mid + 1; // 总共需要循环这么多次 for(int i = left;i &lt;= right; i++)&#123; if(leftIndex == mid + 1)&#123; // 左边数组已经遍历完毕了，所以直接将右边数组剩余元素替换到原数组中 range[i] = temp[rightIndex++]; &#125;else if(rightIndex == right + 1)&#123; // 右边数组已经遍历完毕了，所以直接将左边数组剩余元素替换到原数组中 range[i] = temp[leftIndex++]; &#125;if(temp[leftIndex] &lt;= temp[rightIndex])&#123; // 左边数组的当前元素比右边数组的当前元素小，所以将左边数组的当前元素放入原数组中，并将左边数组的遍历索引向后 range[i] = temp[leftIndex++]; &#125;else if (temp[leftIndex] &gt; temp[rightIndex])&#123; // 左边数组的当前元素比右边数组的当前元素大，所以将右边数组的当前元素放入原数组中，并将右边数组的遍历索引向后 range[i] = temp[rightIndex++]; &#125; &#125;&#125; 解题那么归并排序的思路如何帮我们做这道题呢？ 这道题主要就需要在合并的时候做文章 这里我们使用ASC（升序） 初始状态 情况 A temp[leftIndex]&gt;temp[rightIndex] 所以将temp[rightIndex]替换nums[i]，rightIndex自增 情况 B temp[leftIndex] &lt;= temp[rightIndex] 所以将temp[leftIndex]替换nums[i]，leftIndex自增 这个时候注意一点，temp中[mid+1,rightIndex-1]区间的元素都是比temp[leftIndex]小的元素，长度为rightIndex-mid-1 所以temp[leftIndex]的右侧比其小的元素数量加上此数量 情况 A temp[leftIndex] &gt; temp[rightIndex] 所以将temp[rightIndex]替换nums[i] rightIndex自增 情况 C rightIndex==right+1 右边数组已经合并完成了 那么左边数组的[leftIndex,mid]的所有元素的右边都有rightIndex-1-(mid+1)=&gt;rightIndex-mid-1个元素比其小 leftIndex自增 思路就是如上 但是有一个问题，就是如何保存每个元素的右边有多少比其小的元素数量 nums的每个元素都会变化位置，所以原本元素会改变原本索引位置 这里直接告诉大家，就是使用index数组保存数组中每一个元素对应的原数组的索引 用count数组存储每个元素的右边有多少比其小的元素数量 count[i]的意思是原数组中第 i 个元素的右边比其小的元素数目 index[i]的意思是排序好的数组中第 i 个元素在原数组中的索引 temp辅助数组是用来合并数组的 tempIndex的作用是合并数组的时候，帮助维护index数组的辅助数组 下面看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public List&lt;Integer&gt; countSmaller(int[] nums) &#123; int length = nums.length; int[] count = new int[length]; // 这个存的是nums的每一位原本的索引位置 int[] index = new int[length]; for (int i = 0; i &lt; index.length; i++) &#123; index[i]=i; &#125; // 暂存nums的数组 int[] temp = new int[length]; // 暂存nums的数组的每个元素的原本索引位置 int[] tempIndex = new int[length]; countSmaller(nums,0, length -1,tempIndex ,temp ,index, count); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int c : count) res.add(c); return res; &#125; private void countSmaller(int[] nums,int left,int right,int[] tempIndex, int[] temp,int[] index, int[] count) &#123; if(right==left)return; int mid = left + (right-left)/2; countSmaller(nums,left,mid,tempIndex,temp,index,count); countSmaller(nums,mid+1,right,tempIndex,temp,index,count); // 备份原数组和索引 // temp[i]对应的就是nums[i] // tempIndex[i]对应的就是nums[i]的原数组索引 for (int i = left; i &lt;= right; i++) &#123; temp[i] = nums[i]; tempIndex[i]= index[i]; &#125; int leftIndex = left; int rightIndex = mid + 1; for (int i = left; i &lt;= right; i++) &#123; if (leftIndex == mid+1)&#123; // 当左边数组已经合并完成了，则直接将temp[rightIndex]替换nums[i] // 用temp[rightIndex]替换nums[i] nums[i] = temp[rightIndex]; // index[i]的原索引也要被tempIndex[rightIndex]替换 index[i] = tempIndex[rightIndex]; rightIndex++; &#125;else if (rightIndex == right+1)&#123; // 这就是上面的情况C // 需要更新count数组 nums[i] = temp[leftIndex]; index[i] = tempIndex[leftIndex]; count[tempIndex[leftIndex]] += rightIndex-mid-1; leftIndex++; &#125;else if(temp[leftIndex] &lt;= temp[rightIndex])&#123; // 这是情况 B // 需要更新count数组 nums[i] = temp[leftIndex]; index[i] = tempIndex[leftIndex]; count[tempIndex[leftIndex]] += rightIndex-mid-1; leftIndex++; &#125;else if(temp[leftIndex]&gt;temp[rightIndex])&#123; // 这是情况 A nums[i] = temp[rightIndex]; index[i] = tempIndex[rightIndex]; rightIndex++; &#125; &#125; &#125;&#125; 简化法二在法二中，我们对于index、tempIndex、temp、nums、count数组更新的把握真的很ex 有没有一种简化维护这五个数组的方法！！ 有！！ 我们可以封装一个类Unit，这个类中包括了元素值和索引值 123456789class Unit &#123; public int index; public int source; public Unit(int index, int source) &#123; this.index = index; this.source = source; &#125;&#125; 然后我们将nums改造成元素为unit的数组 那么我们的辅助数组temp也是元素为unit的数组 接下来的思路就是和之前的一样了 下面的代码我使用的升序，和降序的思想是一样的 但是对于count的维护是不一样的，仔细体会一下吧 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;Integer&gt; countSmaller(int[] nums) &#123; int length = nums.length; int[] count = new int[length]; Unit[] arr = new Unit[length]; Unit[] temp = new Unit[length]; for (int i = 0; i &lt; length; i++) arr[i] = new Unit(i,nums[i]); countSmaller(arr,0, length -1, temp, count); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int c : count) res.add(c); return res;&#125;private void countSmaller(Unit[] nums,int left,int right, Unit[] temp, int[] count) &#123; if(right == left) &#123; return; &#125; int mid = left + (right - left) / 2; countSmaller(nums, left,mid, temp, count); countSmaller(nums, mid+1, right, temp, count); for (int i = left; i &lt;= right; i++) &#123; temp[i] = nums[i]; &#125; int leftIndex = left; int rightIndex = mid+1; for (int i = left; i &lt;= right; i++) &#123; if(leftIndex == mid+1)&#123; nums[i] = temp[rightIndex++]; &#125;else if(rightIndex == right+1)&#123; nums[i] = temp[leftIndex++]; &#125;else if(temp[leftIndex].source &gt;= temp[rightIndex].source)&#123; // 在倒序顺序中 // 只有左边数组要替换nums[i]的时候才需要更新count数组 // [rightIndex,right]这个区间内的元素都是比temp[leftIndex]小的 count[temp[leftIndex].index] += right-rightIndex+1; nums[i] = temp[leftIndex++]; &#125;else &#123; nums[i] = temp[rightIndex++]; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【652-Medium】寻找重复的子树","slug":"【652-Medium】寻找重复的子树","date":"2022-09-30T13:07:45.000Z","updated":"2022-10-04T12:49:29.121Z","comments":true,"path":"算法/刷题篇/2022/09/30/【652-Medium】寻找重复的子树/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/30/%E3%80%90652-Medium%E3%80%91%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/","excerpt":"","text":"寻找重复的子树给你一棵二叉树的根节点 root ，返回所有 重复的子树 。 对于同一类的重复子树，你只需要返回其中任意 一棵 的根结点即可。 如果两棵树具有 相同的结构 和 相同的结点值 ，则认为二者是 重复 的。 示例 1： 12输入：root = [1,2,3,4,null,2,4,null,null,4]输出：[[2,4],[4]] 示例 2： 12输入：root = [2,1,1]输出：[[1]] 示例 3： 12输入：root = [2,2,2,3,null,3,null]输出：[[2,3],[3]] 提示： 树中的结点数在 [1, 5000] 范围内。 -200 &lt;= Node.val &lt;= 200 Related Topics 树 深度优先搜索 哈希表 二叉树 分析题目的意思就是根据给出的二叉树，找到该树中重复的子树 将其根节点放入一个集合中返回 重复的要求是根节点的值相同，并且结构相同 我们之前说过，二叉树的问题，一般有两种解决思路 第一种是遍历，第二种是分解问题 这道题需要寻找重复的子树，根本无法分解问题，必须将一整颗树遍历之后才可以得到结果 所以我们这道题只能使用遍历的思想 那么遍历框架长啥呀 12345678910void traverse(TreeNode root) &#123; if (root == null) &#123; return; &#125; /**前序遍历代码所在位置*/ traverse(root.left); /**中序遍历代码所在位置*/ traverse(root.right); /**后序遍历代码所在位置*/&#125; 接下来我们来思考如何判断子树重复呢？ 请考虑以下两个问题 1、我怎么知道以自己为根的树长啥样？ 2、我怎么知道有没有和我相同的子树，如何判等？ 如何表示以自己为根的树 那不就是根节点+左子树+右子树吗！ 即序列化以自己为根的子树 比如以1为根的树的表示是1,2,#,#,3,4,#,#,5,#,#（#表示的是空） 这是先序顺序的表示，中序，后序顺序的表示也就大同小异了 这里要选择哪一种访问顺序来表示呢，还是说都可以？ 我们来思考一下，我们在什么时候可以得到自己的左右子树和根节点的所有信息 对，就是后序顺序，那么我们先写好得到后序顺序来实现序列化的函数 123456789101112private String traverse(TreeNode root) &#123; // 空节点 if (root == null) &#123; return &quot;#&quot;; &#125; // 将左右子树序列化成字符串 String left = traverse(root.left); String right = traverse(root.right); // 左右子树加上自己，就是以自己为根的二叉树表示结果 String subTree = left + &quot;,&quot; + right + &quot;,&quot; + root.val; return subTree;&#125; 如何知道有没有和我相同的子树我如何知道其他子树长啥样，那我肯定需要保存其他子树的后序顺序表示的结果 那就使用一个hashMap存储子树的序列化字符串 key为序列化结果，value是该序列化出现的次数 123456789101112131415161718192021222324public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) &#123; // 记录所有子树的序列化以及其出现的次数 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 记录重复的子树根节点 LinkedList&lt;TreeNode&gt; res = new LinkedList&lt;&gt;(); traverse(root,map,res); return res;&#125;public String traverse(TreeNode root,Map&lt;String,Integer&gt; map,List&lt;TreeNode&gt; res) &#123; if (root == null) &#123; return &quot;#&quot;; &#125; String left = traverse(root.left); String right = traverse(root.right); String subTree = left + &quot;,&quot; + right+ &quot;,&quot; + root.val; int time = map.getOrDefault(subTree, 0); // 多次重复也只会被加入结果集一次 if (time == 1) &#123; res.add(root); &#125; // 给重复子树对应的出现次数加一 map.merge(subTree,1, Integer::sum); return subTree;&#125; 最后这道题的解答就是 123456789101112131415161718192021222324252627282930class Solution &#123; // 空的字符串 private static final String NULL = &quot;#&quot;; // 分隔符的字符串 private static final String SEPARATOR = &quot;,&quot;; public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) &#123; // 用来存放子树序列化 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); // 用来存放最后的结果 List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); findDuplicateSubtrees(root,map,res); return res; &#125; // 这里的返回值主要是为了序列化root为根的子树 // 调用者不需要使用此返回值 private String findDuplicateSubtrees(TreeNode root, Map&lt;String, Integer&gt; map, List&lt;TreeNode&gt; res) &#123; if(root==null)&#123; return NULL; &#125; String left = findDuplicateSubtrees(root.left,map,res); String right = findDuplicateSubtrees(root.right,map,res); String subTree = left + SEPARATOR + right + SEPARATOR + root.val; int time = map.getOrDefault(subTree, 0); if(time == 1)&#123; res.add(root); &#125; map.merge(subTree,1, Integer::sum); return subTree; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【297-Hard】二叉树的序列化和反序列化","slug":"【297-Hard】二叉树的序列化和反序列化","date":"2022-09-29T08:27:38.000Z","updated":"2022-10-12T09:51:51.429Z","comments":true,"path":"算法/刷题篇/2022/09/29/【297-Hard】二叉树的序列化和反序列化/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/29/%E3%80%90297-Hard%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"二叉树的序列化和反序列化序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例 1： 12输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 示例 4： 12输入：root = [1,2]输出：[1,2] 提示： 树中结点数在范围 [0, 104] 内 -1000 &lt;= Node.val &lt;= 1000 Related Topics 树 深度优先搜索 广度优先搜索 设计 字符串 二叉树 所谓序列化其实就是将一个二维的二叉树将其用一维的方式表示出来，那这不就是将其遍历吗？ 二叉树有几种遍历方式？四种，前序遍历，中序遍历，后序遍历，层次遍历 接下来我就使用这四种顺序来实现serialize和deserialize 前序我们先来看如何使用前序的顺序来序列化一棵二叉树 序列化前序遍历的框架 12345678void traverse(TreeNode root) &#123; if (root == null) &#123; return; &#125; /**前序遍历代码所在位置*/ traverse(root.left); traverse(root.right);&#125; 我只需要在前序的位置加上部分逻辑即可 12345678910111213141516171819public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root) &#123; sb = new StringBuilder(); traverse(root); return sb.toString(); &#125; StringBuilder sb; void traverse(TreeNode root) &#123; if (root == null) &#123; sb.append(NULL).append(SEPARATOR); return; &#125; sb.append(root.val).append(SEPARATOR); traverse(root.left); traverse(root.right); &#125;&#125; 进一步优化以已移除成员变量sb 123456789101112131415161718public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); traverse(root,sb); return sb.toString(); &#125; void traverse(TreeNode root,StringBuilder sb) &#123; if (root == null) &#123; sb.append(NULL).append(SEPARATOR); return; &#125; sb.append(root.val).append(SEPARATOR); traverse(root.left,sb); traverse(root.right,sb); &#125;&#125; 分解问题来实现 12345678910111213public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; //返回以root为根节点的序列化字符串 // 根节点 + SEPARATOR + 左子树序列字符串 + SEPARATOR + 右子树序列字符串 public String serialize(TreeNode root) &#123; if (root == null) &#123; return NULL; &#125; return root.val + SEPARATOR + serialize(root.left) + SEPARATOR + serialize(root.right); &#125;&#125; 反序列化接下来我们来通过此序列化字符串来反序列化出二叉树 这里的序列化字符串其实是前序遍历的结果 但是因为序列中包括了NULL 所以可以根据此序列唯一性构造一棵二叉树 123456789101112131415161718192021222324public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; // index存的是source的当前索引 private int index = 0; public TreeNode deserialize(String data) &#123; String[] source = data.split(SEPARATOR); this.index = 0; return deserialize(source); &#125; private TreeNode deserialize(String[] source) &#123; // 如果索引超过数组长度或者当前索引所在位置是NULL对应的字符 // 则说明调用本次递归的节点是叶子节点，直接返回null作为左子树或者右子树 if (index &gt; source.length - 1 || Objects.equals(source[index], NULL)) &#123; index++; return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(source[index++])); root.left = deserialize(source); root.right = deserialize(source); return root; &#125;&#125; 或者使用一个辅助集合，这样就不需要成员变量index了 1234567891011121314151617181920212223public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; TreeNode deserialize(String data) &#123; // 将字符串转化成列表 LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for (String s : data.split(SEPARATOR)) &#123; nodes.addLast(s); &#125; return deserialize(nodes); &#125; TreeNode deserialize(LinkedList&lt;String&gt; nodes) &#123; if (nodes.isEmpty()) return null; // 列表最左侧就是根节点 String first = nodes.removeFirst(); if (first.equals(NULL)) return null; TreeNode root = new TreeNode(Integer.parseInt(first)); root.left = deserialize(nodes); root.right = deserialize(nodes); return root; &#125;&#125; 后序写完了前序的代码，后序的代码就很好写了 序列化还是先从序列化开始 这里只需要将代码换个位置即可 123456789101112131415161718public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); traverse(root,sb); return sb.toString(); &#125; void traverse(TreeNode root,StringBuilder sb) &#123; if (root == null) &#123; sb.append(NULL).append(SEPARATOR); return; &#125; traverse(root.left,sb); traverse(root.right,sb); sb.append(root.val).append(SEPARATOR); &#125;&#125; 其他的方式同理，不再赘述 反序列化前序遍历中第一个元素就是根节点，所以取出的是第一个元素 但是后序遍历的最后一个元素才是根节点，所以需要从最后一个元素开始取 1234567891011121314151617181920212223public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; TreeNode deserialize(String data) &#123; // 将字符串转化成列表 LinkedList&lt;String&gt; nodes = new LinkedList&lt;&gt;(); for (String s : data.split(SEPARATOR)) &#123; nodes.addLast(s); &#125; return deserialize(nodes); &#125; TreeNode deserialize(LinkedList&lt;String&gt; nodes) &#123; if (nodes.isEmpty()) return null; String last = nodes.removeLast(); if (first.equals(NULL)) return null; TreeNode root = new TreeNode(Integer.parseInt(last)); // 这里需要注意，因为是从后往前取元素的，所以是先构造右子树，然后才是左子树 root.right = deserialize(nodes); root.left = deserialize(nodes); return root; &#125;&#125; OK，next！ Go ahead！ 中序emmmm 中序遍历的方式是行不通的 因为无法实现反序列化方法 deserialize。 序列化方法 serialize 依然一样的容易，只要把字符串的拼接操作放到中序遍历的位置就行了 123456789101112131415161718public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); traverse(root,sb); return sb.toString(); &#125; void traverse(TreeNode root,StringBuilder sb) &#123; if (root == null) &#123; sb.append(NULL).append(SEPARATOR); return; &#125; traverse(root.left,sb); sb.append(root.val).append(SEPARATOR); traverse(root.right,sb); &#125;&#125; 如果实现反序列方法 首先要构造 root 节点。 前序遍历得到的 nodes 列表中，第一个元素是 root 节点的值 后序遍历得到的 nodes 列表中，最后一个元素是 root 节点的值。 中序遍历中，root 的值被夹在两棵子树的中间， 我们不知道根节点的确切索引位置，无法找到 root 节点 也就无法进行反序列化 层次一般涉及到层次遍历，就需要使用到队列这种数据结构 序列化先看代码 123456789101112131415161718192021class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); StringBuilder stringBuilder = new StringBuilder(); queue.offer(root); TreeNode cur; while (!queue.isEmpty())&#123; cur = queue.poll(); if(cur==null)&#123; stringBuilder.append(NULL).append(SEPARATOR); continue; &#125; stringBuilder.append(cur.val).append(SEPARATOR); queue.offer(cur.left); queue.offer(cur.right); &#125; return stringBuilder.toString(); &#125; 图解 文解先弄清楚所有变量的作用 queue用在暂存节点，因为其先进先出的特性 （ 1 的左子树根节点 2 先进入队列，然后右子树根节点 3 进入节点，然后是 2 先出队） 使得其可以让我们层次遍历一颗二叉树 cur是每次出队的元素 stringBuilder用来保存最后序列化的结果 首先将根节点放入队列，然后进入循环 每次将队首元素出队，赋值给cur 如果cur为NULL，则追加NULL和分隔符，并跳出此次循环 如果不为NULL，则先追加cur的值和分隔符，然后将其左子树和右子树直接入队 （左子树先入队，然后是右子树入队） 当队列为空的时候，则得到序列化后的结果 优化1234567891011121314151617181920class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public String serialize(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); StringBuilder stringBuilder = new StringBuilder(); queue.offer(root); TreeNode cur; while (!queue.isEmpty())&#123; while((cur=queue.poll())!=null)&#123; stringBuilder.append(cur.val).append(SEPARATOR); queue.offer(cur.left); queue.offer(cur.right); &#125; stringBuilder.append(NULL).append(SEPARATOR); &#125; return stringBuilder.toString(); &#125;&#125; 反序列化和前序和后序一样，层次遍历可以确定根节点的位置，所以是可以实现反序列化的。 这里使用nodes队列来保存创建的根节点 source保存元数据 首先source第一个元素一定是一棵树的根节点，所以直接将其构造出来，将其放入队列 循环就从i=1开始 取得队首元素，然后取得元数组中i所在位置的元素，并使得i++ 如果其不是NULL，则创建节点作为队首元素的左节点，并将其加入队列 然后再取得原数组中i所在的位置，并使得i++ 如果其不是NULL，则创建节点作为队首元素的右节点，并将其加入队列 当原数组全部读取完毕，则反序列化结束 1234567891011121314151617181920212223242526272829public class Codec &#123; private static final String NULL = &quot;#&quot;; private static final String SEPARATOR = &quot;,&quot;; public TreeNode deserialize(String data)&#123; if(data.isEmpty()||Objects.equals(NULL,data))&#123; return null; &#125; String[] source = data.split(SEPARATOR); TreeNode root = new TreeNode(Integer.parseInt(source[0])); Queue&lt;TreeNode&gt; nodes = new LinkedList&lt;&gt;(); nodes.offer(root); for (int i = 1; i &lt; source.length;) &#123; TreeNode r = nodes.poll(); String left = source[i++]; if(!Objects.equals(NULL,left))&#123; r.left = new TreeNode(Integer.parseInt(left)); nodes.offer(r.left); &#125; String right = source[i++]; if(!Objects.equals(NULL,right))&#123; r.right = new TreeNode(Integer.parseInt(right)); nodes.offer(r.right); &#125; &#125; return root; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【560-Medium】和为K的子数组","slug":"【560-Medium】和为K的子数组","date":"2022-09-27T13:20:06.000Z","updated":"2022-10-04T12:49:05.191Z","comments":true,"path":"算法/刷题篇/2022/09/27/【560-Medium】和为K的子数组/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/27/%E3%80%90560-Medium%E3%80%91%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"和为K的子数组给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。 示例 1： 12输入：nums = [1,1,1], k = 2输出：2 示例 2： 12输入：nums = [1,2,3], k = 3输出：2 提示： 1 &lt;= nums.length &lt;= 2 * 104 -1000 &lt;= nums[i] &lt;= 1000 -107 &lt;= k &lt;= 107 Related Topics 数组 哈希表 前缀和 法一：暴力使用前缀和如果不知道前缀和数组的知识的，可以先移步这篇文章【303-Easy】区域和检索-数组不可变 这里先构造一个nums的前缀和数组 然后遍历这个前缀和数组 外层循环从前缀和第一个元素开始遍历，内层循环从外层循环的下一个元素开始遍历 当内层循环的元素减去外层循环的元素等于 k 的时候，则说明满足题目条件，计数器加1 当外层循环结束，即得到答案 123456789101112131415public int subarraySum(int[] nums, int k) &#123; int res = 0; int[] preSum = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length; i++) &#123; preSum[i] = preSum[i-1] + nums[i-1]; &#125; for (int i = 0; i &lt; preSum.length; i++) &#123; for (int j = i + 1; j &lt; preSum.length; j++) &#123; if(preSum[j] - preSum[i] == k)&#123; res++; &#125; &#125; &#125; return res;&#125; 这种方法简单粗暴，但是时间复杂度是O（N^2），我们引入hash表来提升性能 法一：hash表+前缀和引入一个hash表用来存什么呢，我们来看以下几种方案 方案一：hash表就是一个变相的前缀和（key - 前缀和 value-索引） 方案二：hash表就是一个记录前缀和出现次数的表（key - 前缀和 value - 前缀和出现次数） 我们来思考一下第一种方案，如果选择第一种方案，并且遇到这样的数组，nums = &#123;-1 , 1 , -1 , 1&#125; 则hash表中存储的就是&#123;0 - 3,-1 - 3&#125;，第一次出现前缀和为 0 和 -1 的记录被覆盖了，所以使用这种方案，最后统计出来肯定是缺情况的 那我们就选择方案二来解决这个问题 123456789101112131415public int subarraySum(int[] nums, int k) &#123; int res = 0; // key为前缀和 value为该前缀和出现的次数 Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int counter = 0; for (int i = 0; i &lt; nums.length; i++) &#123; counter += nums[i]; if(map.containsKey(counter-k))&#123; res += map.get(counter-k); &#125; map.merge(counter,1, Integer::sum); &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1352-Medium】最后K个数的乘积","slug":"【1352-Medium】最后K个数的乘积","date":"2022-09-27T05:36:04.000Z","updated":"2022-10-04T12:49:02.035Z","comments":true,"path":"算法/刷题篇/2022/09/27/【1352-Medium】最后K个数的乘积/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/27/%E3%80%901352-Medium%E3%80%91%E6%9C%80%E5%90%8EK%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF/","excerpt":"","text":"最后K个数的乘积请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法： 1. add(int num) 将数字 num 添加到当前数字列表的最后面。 2. getProduct(int k) 返回当前数字列表中，最后 k 个数字的乘积。 你可以假设当前列表中始终 至少 包含 k 个数字。 题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。 示例： 12345678910111213141516171819输入：[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;][[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]输出：[null,null,null,null,null,null,20,40,0,null,32]解释：ProductOfNumbers productOfNumbers = new ProductOfNumbers();productOfNumbers.add(3); // [3]productOfNumbers.add(0); // [3,0]productOfNumbers.add(2); // [3,0,2]productOfNumbers.add(5); // [3,0,2,5]productOfNumbers.add(4); // [3,0,2,5,4]productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40productOfNumbers.getProduct(4); // 返回 0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0productOfNumbers.add(8); // [3,0,2,5,4,8]productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 提示： add 和 getProduct 两种操作加起来总共不会超过 40000 次。 0 &lt;= num &lt;= 100 1 &lt;= k &lt;= 40000 Related Topics 设计 队列 数组 数学 数据流 法一：暴力这题很好理解，但是如果想要写出一个复杂度低的算法不是一件简单的事情 下面我们先来用最简单最通俗易懂的方法来实现 因为数组长度不定，所以使用source用来存储原数组 返回最后k个数字的乘积getProduct，那我只需要遍历source的最后k个数字并将其相乘返回即可 123456789101112131415161718class ProductOfNumbers &#123; private List&lt;Integer&gt; source; public ProductOfNumbers() &#123; source = new ArrayList&lt;&gt;(); &#125; public void add(int num) &#123; source.add(num); &#125; public int getProduct(int k) &#123; int res = 1; for (int i = k; i &gt; 0; i--) &#123; res*=source.get(source.size()-i); &#125; return res; &#125;&#125; 好，没有问题，提交！ 但是Medium的题目会这么简单吗？NO！ 只有通过大测试数据，算法才算通过 这种简单的算法，虽然好想，但是扛不住大数据，接下来介绍一种新解法 法二：前缀积在看这个之前，最好先了解过前缀和的知识，可以移步这篇文章【303-Easy】区域和检索-数组不可变 且听我解释各变量的作用，再看代码 source和之前的作用是一样的，是用来存储原数组的 size就是原数组的长度 zeroIndex代表的是 0 最后一次出现的位置 preMultiply的作用是存储前缀积的结果的，但是这里的preMultiply和之前的前缀和的定义略有不同 这里preMultiply.get(i)的定义是 i &gt; zeroIndex 原数组在[zeroIndex+1,i]的累乘 i &lt; zeroIndex 无定义 1234567891011121314151617181920212223242526272829303132class ProductOfNumbers &#123; private List&lt;Integer&gt; source; private List&lt;Integer&gt; preMultiply; private int size; private int zeroIndex; public ProductOfNumbers() &#123; size = 0; zeroIndex = -1; source = new ArrayList&lt;&gt;(); preMultiply = new ArrayList&lt;&gt;(); preMultiply.add(1); &#125; public void add(int num) &#123; source.add(num); if (num==0)&#123; preMultiply.clear(); preMultiply.add(1); zeroIndex = size; &#125;else &#123; preMultiply.add(preMultiply.get(size-zeroIndex-1)*num); &#125; size++; &#125; public int getProduct(int k) &#123; if(k &gt; size-zeroIndex-1)&#123; return 0; &#125; return preMultiply.get(size-zeroIndex-1)/preMultiply.get(size-zeroIndex-k-1); &#125;&#125; 图解 这一步比较特殊，当我出现了 0 的时候所有的前缀积都无效了，所以直接清除，然后记录 0 出现的位置 接下来解释一下代码 1、构造函数 构造函数做的事就是初始化一些变量，这些变量的意义前面讲述过了这里就不赘述了 2、add函数 首先将其直接放入source集合中 接下来对于不同的num做出不同的处理 num为 0 重置前缀积集合，即清空集合，并放入 1 更新zeroIndex （这里直接将size赋值给zeroIndex的原因是size是方法结束之后才自增的，自增前的size表示的就是当前元素的索引） num不为0 更新前缀积集合，这里的size-zeroIndex-1需要理解（这里我当时是通过画图推敲得知） 我的理解就是将当前值乘以原数组 0 之后的所有数的乘积得到的值放入前缀积 3、getProduct函数 size-zeroIndex-1就是原数组 0 之后有几个数字 如果这个数字比 k 小，则可以直接返回 0 不然，则返回preMultiply.get(size-zeroIndex-1)/preMultiply.get(size-zeroIndex-k-1); preMultiply.get(size-zeroIndex-1)是原数组在 0 之后所有数字的乘积 preMultiply.get(size-zeroIndex-k-1)是原数组在 0 之后所有数字，倒数第 k 个数到 0 后第一个数的乘积 注：如果size-zeroIndex-k-1为 0 ，则没有意义，就是 1 ，占位用的","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【525-Medium】连续数组","slug":"【525-Medium】连续数组","date":"2022-09-27T00:10:08.000Z","updated":"2022-10-04T12:48:58.712Z","comments":true,"path":"算法/刷题篇/2022/09/27/【525-Medium】连续数组/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/27/%E3%80%90525-Medium%E3%80%91%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/","excerpt":"","text":"连续数组给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 123输入: nums = [0,1]输出: 2说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。 示例 2: 123输入: nums = [0,1,0]输出: 2说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 不是 0 就是 1 Related Topics 数组 哈希表 前缀和 法一：直接使用前缀和由于「0 和 1 的数量相同」等价于「1 的数量减去 0 的数量等于 0」 我们可以将数组中的 0 视作−1，则原问题转换成「求最长的连续子数组，其元素和为 0」 也就是说构建前缀和数组的时候，当原数组的数为0的时候将其当作-1累加到前缀和数组中 那么我只要使用一个right指针指向preSum的最后一位 找到最前面的与其相同的元素，将其索引相减 更新最大值，最后即可得到答案 1234567891011121314151617181920212223public int findMaxLength(int[] nums) &#123; int[] preSum = new int[nums.length+1]; preSum[0] = 0; for (int i = 1; i &lt;= nums.length; i++) &#123; if(nums[i-1] == 1)&#123; preSum[i] = preSum[i-1] + 1; &#125;else &#123; preSum[i] = preSum[i-1] - 1; &#125; &#125; int right = nums.length; int max = Integer.MIN_VALUE; while (right &gt;= 0)&#123; for (int i = 0; i &lt; preSum.length; i++) &#123; if(preSum[i] == preSum[right])&#123; max = Math.max(max,right-i); break; &#125; &#125; right--; &#125; return max;&#125; 这种方法虽然实现起来简单，但是扛不住大数据的打压（红框里面的是滚动条） 主要问题出在最后更新最大长度的方法上，他是一个两层循环，内存循环占据了主要的时间 我们想想也是，我们只是需要找到最前面的那个值所对应的索引，其他的遍历都是无效遍历 下面我们来使用hash表来优化 法二：Hash+前缀和先看代码 123456789101112131415161718192021public int findMaxLength(int[] nums) &#123; //key为累加和的值 value为[0,value]区间 Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int counter = 0; map.put(counter,-1); int max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i]==0)&#123; counter--; &#125;else &#123; counter++; &#125; if(map.containsKey(counter))&#123; max = Math.max(max,i-map.get(counter)); &#125;else &#123; // [0,i]的和 map.put(counter,i); &#125; &#125; return max;&#125; 我们不需要创建数组preSum，只需要维护一个变量 counter存储前缀和即可。 具体做法是，遍历数组 nums，当遇到元素 1 的时候将 counter的值加 1，当遇到元素 0 时将 counter的值减 1 遍历过程中使用哈希表存储每个前缀和第一次出现的下标。 前缀和为0的结束下标为 -1，在遍历之前，要先存入键值对 (0,-1) 为什么是 -1 ？ 因为索引是从0开始的，假如前4个元素（ -1 ，1 ，1 ，-1 ）之和为0了 则最后一个 -1 的索引是3，而这里的长度应该是4，所以前缀和为 0 的第一次前缀和出现的位置应该是-1 遍历过程中，如果 counter 的值在哈希表中已经存在，则更新最大值 如果 counter的值在哈希表中不存在，则将当前余数和当前下标 i 的键值对存入哈希表中。","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【304-Medium】二维区域和检索-矩阵不可变","slug":"【304-Medium】二维区域和检索-矩阵不可变","date":"2022-09-26T13:05:26.000Z","updated":"2022-10-04T13:56:57.626Z","comments":true,"path":"算法/刷题篇/2022/09/26/【304-Medium】二维区域和检索-矩阵不可变/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/26/%E3%80%90304-Medium%E3%80%91%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/","excerpt":"","text":"二维区域和检索-矩阵不可变给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。 示例 1： 1234567891011输入: [&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;][[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]输出: [null, 8, 11, 12]解释:NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和) 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 200 -105 &lt;= matrix[i][j] &lt;= 105 0 &lt;= row1 &lt;= row2 &lt; m 0 &lt;= col1 &lt;= col2 &lt; n 最多调用 104 次 sumRegion 方法 Related Topics 设计 数组 矩阵 前缀和 前缀和数组如果不知道前缀和数组的知识的，可以先移步这篇文章【303-Easy】区域和检索-数组不可变 如果你已经会了前缀和数组，读完这道题目的第一反应就是前缀和数组来简化计算 下面看代码 1234567891011121314151617181920class NumMatrix &#123; // preSums[i][j]代表的意思是以（0，0）为左上顶点，（i-1，j-1）为右下顶点的矩形的面积 private int[][] preSums; public NumMatrix(int[][] matrix) &#123; preSums = new int[matrix.length+1][matrix[0].length+1]; for (int i = 1; i &lt;= matrix.length; i++) &#123; for (int j = 1; j &lt;= matrix[0].length; j++) &#123; preSums[i][j]=matrix[i-1][j-1]+preSums[i-1][j]+preSums[i][j-1]-preSums[i-1][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; if(row1&lt;0||col1&lt;0||row2&lt;row1||col2&lt;col1)&#123; return -1; &#125; return preSums[row2+1][col2+1]-preSums[row1][col2+1]-preSums[row2+1][col1]+preSums[row1][col1]; &#125;&#125; 这里还是使用一个范式来表达 这里一定要弄清楚preSums[i][j]的含义是 以nums的（0，0）为左上角，（i-1，j-1）为右下角的矩阵的面积 反过来如果我需要得到以（i，j）为右下角的矩阵的面积使用的就是preSums[i+1][j+1]","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【303-Easy】区域和检索-数组不可变","slug":"【303-Easy】区域和检索-数组不可变","date":"2022-09-26T12:33:40.000Z","updated":"2022-10-04T12:48:34.936Z","comments":true,"path":"算法/刷题篇/2022/09/26/【303-Easy】区域和检索-数组不可变/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/26/%E3%80%90303-Easy%E3%80%91%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/","excerpt":"","text":"区域和检索-数组不可变给定一个整数数组 nums，处理以下类型的多个查询: 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;= right 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] ) 示例 1： 1234567891011输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示： 1 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 0 &lt;= i &lt;= j &lt; nums.length 最多调用 104 次 sumRange 方法 Related Topics 设计 数组 前缀和 法一：暴力遍历1234567891011121314151617class NumArray &#123; private int[] nums; public NumArray(int[] nums) &#123; this.nums = nums; &#125; public int sumRange(int left, int right) &#123; if(left&lt;0||right&lt;0||left&gt;=this.nums.length||right&gt;=this.nums.length)&#123; return -1; &#125; int sum = 0; for (int i = left; i &lt;= right; i++) &#123; sum+=nums[i]; &#125; return sum; &#125;&#125; 这种方法是最好想到的 但是它的时间复杂度是 O(N)，其中N代表 nums 数组的⻓度 接下来我们来看一种辅助数组来使得时间复杂度降低到O(1) 法二：前缀和数组前缀和数组是数组中的一种常见的用于范围求和的辅助数组 下面先看代码实现 1234567891011121314class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length+1]; for (int i = 1; i &lt;= nums.length; i++) &#123; preSum[i]=preSum[i-1]+nums[i-1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right+1]-preSum[left]; &#125;&#125; 前缀和数组是原数组长度+1，表示的是nums的前n个元素之和 我们先使用数组int[] nums = &#123;-2,1,3,-4,2&#125;构建一下前缀和数组 这样可能不好观察如何得到nums的[left,right]范围和的公式 我们换种方式，下面来看下前缀和数组的范式 这样就很好观察如何通过前缀和数组preSums得到原数组的[left,right]的和 我如果要nums在[2,4]范围的和，是不是得nums的前4个元素之和减去nums的前1个元素之和 使用前缀和数组来表达，即preSums[right+1]-preSums[left] preSums[right+1]代表nums的前right+1的和 为什么是right+1？ 因为这里的left和right是索引，是从0开始的 preSums[left]代表nums的前left的和 前缀和要理清的地方就是preSums的第i个元素代表的是nums前i个元素之和 i=0就是nums的前0个元素，那不就是0吗 i&gt;1就是nums的[0,i-1]的范围之和 相关题目 难度 力扣链接 博客文章链接 Medium 304. 二维区域和检索 - 矩阵不可变 Medium 525. 连续数组 Medium 560. 和为 K 的子数组 Hard 862. 和至少为 K 的最短子数组 Medium 1352. 最后 K 个数的乘积","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【2306-Hard】公司命名","slug":"【2306-Hard】公司命名","date":"2022-09-18T12:55:17.000Z","updated":"2022-10-04T12:48:18.451Z","comments":true,"path":"算法/刷题篇/2022/09/18/【2306-Hard】公司命名/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/09/18/%E3%80%902306-Hard%E3%80%91%E5%85%AC%E5%8F%B8%E5%91%BD%E5%90%8D/","excerpt":"","text":"公司命名给你一个字符串数组 ideas 表示在公司命名过程中使用的名字列表。公司命名流程如下： 从 ideas 中选择 2 个 不同 名字，称为 ideaA 和 ideaB 。 交换 ideaA 和 ideaB 的首字母。 如果得到的两个新名字 都 不在 ideas 中，那么 ideaA ideaB（串联 ideaA 和 ideaB ，中间用一个空格分隔）是一个有效的公司名字。 否则，不是一个有效的名字。 返回 不同 且有效的公司名字的数目。 示例 1： 123456789101112131415输入：ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]输出：6解释：下面列出一些有效的选择方案：- (&quot;coffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee conuts&quot; 。- (&quot;donuts&quot;, &quot;coffee&quot;)：对应的公司名字是 &quot;conuts doffee&quot; 。- (&quot;donuts&quot;, &quot;time&quot;)：对应的公司名字是 &quot;tonuts dime&quot; 。- (&quot;donuts&quot;, &quot;toffee&quot;)：对应的公司名字是 &quot;tonuts doffee&quot; 。- (&quot;time&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;dime tonuts&quot; 。- (&quot;toffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee tonuts&quot; 。因此，总共有 6 个不同的公司名字。下面列出一些无效的选择方案：- (&quot;coffee&quot;, &quot;time&quot;)：在原数组中存在交换后形成的名字 &quot;toffee&quot; 。- (&quot;time&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。- (&quot;coffee&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。 示例 2： 123输入：ideas = [&quot;lack&quot;,&quot;back&quot;]输出：0解释：不存在有效的选择方案。因此，返回 0 。 提示： 2 &lt;= ideas.length &lt;= 5 * 104 1 &lt;= ideas[i].length &lt;= 10 ideas[i] 由小写英文字母组成 ideas 中的所有字符串 互不相同 Related Topics 位运算 数组 哈希表 字符串 枚举 法一：暴力破解1234567891011121314151617181920212223class Solution &#123; public long distinctNames(String[] ideas) &#123; long count = 0; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; ideas.length; i++) &#123; map.put(ideas[i],i); &#125; for (int i = 0; i &lt; ideas.length; i++) &#123; for (int j = i+1 ; j &lt; ideas.length; j++) &#123; if(i==j)&#123; continue; &#125; char first = ideas[i].charAt(0); char second = ideas[j].charAt(0); if(map.get(ideas[j].replaceFirst(&quot;^\\\\w&quot;,String.valueOf(first)))==null&amp;&amp; map.get(ideas[i].replaceFirst(&quot;^\\\\w&quot;,String.valueOf(second)))==null)&#123; count+=2; &#125; &#125; &#125; return count; &#125;&#125; 法二：二维矩阵1234567891011121314151617181920212223242526272829class Solution &#123; public long distinctNames(String[] ideas) &#123; long count = 0; Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(ideas)); int[][] cnt = new int[26][26]; // cnt[i][j]代表首字母为i，并且可以将首字母替换为j的元素的个数 Map&lt;String,char[]&gt; map = new HashMap&lt;&gt;(); for (String idea : ideas) &#123; char[] temp = idea.toCharArray(); map.put(idea,temp); for (int i = 0; i &lt; 26; i++) &#123; temp[0] = (char)(&#x27;a&#x27; + i); if(!set.contains(String.valueOf(temp)))&#123; cnt[idea.charAt(0)-&#x27;a&#x27;][i]++; &#125; &#125; &#125; for (String idea : ideas) &#123; char[] temp = map.get(idea); for (int i = 0; i &lt; 26; i++) &#123; temp[0] = (char)(&#x27;a&#x27; + i); if(!set.contains(String.valueOf(temp)))&#123; count+=cnt[i][idea.charAt(0)-&#x27;a&#x27;]; &#125; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【94-Easy】二叉树的中序遍历","slug":"【94-Easy】二叉树的中序遍历","date":"2022-08-30T09:49:21.000Z","updated":"2022-10-04T12:47:23.814Z","comments":true,"path":"算法/刷题篇/2022/08/30/【94-Easy】二叉树的中序遍历/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/08/30/%E3%80%9094-Easy%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"二叉树的中序遍历给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[1,3,2] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ Related Topics 栈 树 深度优先搜索 二叉树 法一：递归12345678910111213141516class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; return inOrder(root); &#125; public List&lt;Integer&gt; inOrder(TreeNode node)&#123; if(node==null)&#123; return new ArrayList&lt;&gt;(); &#125; ArrayList&lt;Integer&gt; now = new ArrayList&lt;&gt;(); now.addAll(inOrder(node.left)); now.add(node.val); now.addAll(inOrder(node.right)); return now; &#125;&#125; 法二：迭代12345678910111213141516class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); while(root!=null||!stack.isEmpty())&#123; while (root!=null)&#123;//1 stack.push(root); root = root.left; &#125; root = stack.pop();//2 res.add(root.val); root = root.right; &#125; return res; &#125;&#125; res用来存最后的中序遍历结果 stack使用LinkedList来充当，用来存取二叉树的中序遍历的节点 注释1处：只要当前节点不为空，就一直将其左节点放入stack中 注释2处：拿到第一个需要放入结果集的节点 下面是图解 蓝色箭头所指就是当前的root 每次展示的都是循环结束后的root的状态 以此类推，之后的就像这样不断迭代即可得到res数组 前序、后序遍历结果也可按照此思路完成解答 先序遍历 1234567891011121314public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); while(root!=null||!stack.isEmpty())&#123; while (root!=null)&#123; res.add(root.val); stack.push(root); root = root.left; &#125; root = stack.pop(); root = root.right; &#125; return res;&#125; 后序遍历 12345678910111213141516171819202122232425public List&lt;Integer&gt; inorderTraversal(TreeNode&lt;Integer&gt; root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&lt;Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); TreeNode&lt;Integer&gt; temp = null; while(root!=null||!stack.isEmpty())&#123; while (root!=null)&#123; stack.push(root); root = root.left; &#125; root = stack.peek(); // root.right==null代表的是当前节点没有右节点，即右子树遍历完成 // root.right==temp代表的是右子树遍历完成 if(root.right==null||root.right==temp)&#123; res.add(root.val); // temp代表的当前子树的根节点 temp = root; stack.pop(); // 使其拿到栈中的下一个元素 root = null; &#125;else &#123; root = root.right; &#125; &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"并发中Interrupt的相关知识","slug":"并发中Interrupt的相关知识","date":"2022-07-25T08:21:32.000Z","updated":"2022-11-06T12:48:00.711Z","comments":true,"path":"javaEE/JUC/2022/07/25/并发中Interrupt的相关知识/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/07/25/%E5%B9%B6%E5%8F%91%E4%B8%ADInterrupt%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Interruptinterrupt()是线程类的成员方法，作用是打断线程 与之有关的还有isInterrupted()和interrupted() interrupt()的作用是分情况的 当线程被join()、sleep()、wait()阻塞的时候 使用此方法，会设置打断标记为false，并且抛出异常InterruptedException 当线程正在运行的时候 使用此方法，会设置打断标记为true，但是不会影响线程继续运行 当线程使用Thread.park()挂起 使用此方法，会设置打断标记为true，但是不会抛出异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Interrupts this thread. * * &lt;p&gt; Unless the current thread is interrupting itself, which is * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method * of this thread is invoked, which may cause a &#123;@link * SecurityException&#125; to be thrown. * * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125; * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;, * methods of this class, then its interrupt status will be cleared and it * will receive an &#123;@link InterruptedException&#125;. * * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125; * then the channel will be closed, the thread&#x27;s interrupt * status will be set, and the thread will receive a &#123;@link * java.nio.channels.ClosedByInterruptException&#125;. * * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125; * then the thread&#x27;s interrupt status will be set and it will return * immediately from the selection operation, possibly with a non-zero * value, just as if the selector&#x27;s &#123;@link * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked. * * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt * status will be set. &lt;/p&gt; * * &lt;p&gt; Interrupting a thread that is not alive need not have any effect. * * @throws SecurityException * if the current thread cannot modify this thread * * @revised 6.0 * @spec JSR-51 */public void interrupt() &#123; if (this != Thread.currentThread()) &#123; checkAccess(); // thread may be blocked in an I/O operation synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // set interrupt status b.interrupt(this); return; &#125; &#125; &#125; // set interrupt status interrupt0();&#125; isInterrupted此方法也是线程类的成员方法，作用是返回打断标记 12345678910111213141516/** * Tests whether this thread has been interrupted. The &lt;i&gt;interrupted * status&lt;/i&gt; of the thread is unaffected by this method. * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &#123;@code true&#125; if this thread has been interrupted; * &#123;@code false&#125; otherwise. * @see #interrupted() * @revised 6.0 */public boolean isInterrupted() &#123; return isInterrupted(false);&#125; interrupted此方法是Thread的静态方法，作用是重置当前运行线程的打断标记（就是将打断标记置为false），并返回之前的打断标记 1234567891011121314151617181920/** * Tests whether the current thread has been interrupted. The * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method. In * other words, if this method were to be called twice in succession, the * second call would return false (unless the current thread were * interrupted again, after the first call had cleared its interrupted * status and before the second call had examined it). * * &lt;p&gt;A thread interruption ignored because a thread was not alive * at the time of the interrupt will be reflected by this method * returning false. * * @return &#123;@code true&#125; if the current thread has been interrupted; * &#123;@code false&#125; otherwise. * @see #isInterrupted() * @revised 6.0 */public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://li-zhi.net.cn/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Docker-基础","slug":"Docker-基础","date":"2022-07-13T10:18:52.000Z","updated":"2022-10-04T13:52:36.179Z","comments":true,"path":"javaEE/Docker/2022/07/13/Docker-基础/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Docker/2022/07/13/Docker-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Docker-基础回顾hello-world我们先来回顾一下hello-world的案例 下面是完整的流程图 12345678先在本地查找是否存在hello-world镜像 有则直接使用此镜像创建一个容器并运行 没有则连接镜像服务器查找是否存在hello-world镜像 如果在镜像服务器查找到了该镜像，则将该镜像下载到本地，然后建一个容器并运行 如果没有，则报错 下面介绍关于镜像和容器的命令 Docker镜像命令搜索镜像123456789101112131415[root@zhima ~]# docker search --help# 使用说明Usage: docker search [OPTIONS] TERM# 在docker hub上搜索TERM镜像Search the Docker Hub for images# 可选参数Options:# 过滤# 栗子 -f=STARS=3000意思的筛选出STARS大于3000的 -f, --filter filter Filter output based on conditions provided# 格式化输出，使用go语言的模板 --format string Pretty-print search using a Go template# 限制数量 --limit int Max number of search results (default 25) --no-trunc Don&#x27;t truncate output 拉取镜像1234567891011121314[root@zhima ~]# docker pull --helpUsage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 从仓库拉取一个镜像或者一个仓库Pull an image or a repository from a registry# 可选项Options:# 下载全部的版本 -a, --all-tags Download all tagged images in the repository# 跳过镜像认证，默认开启 --disable-content-trust Skip image verification (default true) --platform string Set platform if server is multi-platform capable# 跳过冗长的输出，等到下载结束后再输出镜像id -q, --quiet Suppress verbose output 查看本地镜像123456789101112131415161718[root@zhima ~]# docker images --helpUsage: docker images [OPTIONS] [REPOSITORY[:TAG]]# 列举镜像List imagesOptions:# 展示全部的镜像，默认添加 -a, --all Show all images (default hides intermediate images)# 显示完整的镜像id --digests Show digests# 过滤 -f, --filter filter Filter output based on conditions provided# 格式化输出 --format string Pretty-print images using a Go template --no-trunc Don&#x27;t truncate output# 只显示镜像简写id -q, --quiet Only show image IDs 删除本地镜像12345678910[root@zhima ~]# docker rmi --helpUsage: docker rmi [OPTIONS] IMAGE [IMAGE...]# 删除镜像Remove one or more imagesOptions:# 强制删除 -f, --force Force removal of the image --no-prune Do not delete untagged parents 查看镜像层级构建信息1234567891011121314[root@zhima ~]# docker history --helpUsage: docker history [OPTIONS] IMAGE# 展示镜像的历史（构建信息）Show the history of an imageOptions:# 格式化输出 --format string Pretty-print images using a Go template# 以可读化好的方式展示 -H, --human Print sizes and dates in human readable format (default true) --no-trunc Don&#x27;t truncate output# 只显示镜像id -q, --quiet Only show image IDs 打标签12345[root@zhima ~]# docker tag --helpUsage: docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]# 给SOURCE_IMAGE打上新的标签，并使用TARGET_IMAGE保存Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE Docker容器命令创建一个容器 这里因为可选项太多，我只放一些常用的 12345678910111213141516171819202122232425262728293031[root@zhima ~]# docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 创建并使用COMMAND运行一个容器Run a command in a new containerOptions:# 后台启动容器 -d, --detach Run container in background and print container ID# 保持标准输出流打开 -i, --interactive Keep STDIN open even if not attached# 挂载宿主机文件系统 --mount mount Attach a filesystem mount to the container# 指定容器名字 --name string Assign a name to the container# 指定容器所在网络 --network network Connect a container to a network# 给容器登录用户的特权 --privileged Give extended privileges to this container# 指定端口映射 -p 宿主机端口:容器暴露端口 -p, --publish list Publish a container&#x27;s port(s) to the host# 随机指定端口映射 -P, --publish-all Publish all exposed ports to random ports# 容器的根文件系统只读 --read-only Mount the container&#x27;s root filesystem as read only# 推出容器的时候，自动删除容器 --rm Automatically remove the container when it exits# 分配一个伪终端并绑定到容器的标准输入上 -t, --tty Allocate a pseudo-TTY# 数据卷，将容器内的目录挂载到宿主机的目录 -v, --volume list Bind mount a volume 12345678[root@zhima ~]# docker create --helpUsage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]# 创建一个容器，但是不运行Create a new containerOptions: # 与docker run 一致，这里不重复了 删除一个容器1234567891011[root@zhima ~]# docker rm --helpUsage: docker rm [OPTIONS] CONTAINER [CONTAINER...]# 删除一个或者多个容器Remove one or more containersOptions:# 强制删除，即使它在运行状态 -f, --force Force the removal of a running container (uses SIGKILL)# 删除挂载的宿主机目录 -v, --volumes Remove anonymous volumes associated with the container 查看容器12345678910111213141516171819202122[root@zhima ~]# docker ps --helpUsage: docker ps [OPTIONS]# 展示容器List containersOptions:# 展示所有的容器 -a, --all Show all containers (default shows just running)# 条件过滤 -f, --filter filter Filter output based on conditions provided# 格式化输出 --format string Pretty-print containers using a Go template# 控制显示个数，包括停止的容器 -n, --last int Show n last created containers (includes all states) (default -1)# 显示最近创建的容器，包括停止的容器 -l, --latest Show the latest created container (includes all states) --no-trunc Don&#x27;t truncate output# 只显示容器id -q, --quiet Only display container IDs# 显示容器占用内存 -s, --size Display total file sizes 停止容器123456789[root@zhima ~]# docker stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]# 停止一个或者多个容器Stop one or more running containersOptions:# 在ints后停止容器 -t, --time int Seconds to wait for stop before killing it (default 10) 运行容器1234567891011[root@zhima ~]# docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]# 启动一个或者多个已经停止的容器Start one or more stopped containersOptions:# 启动并进入容器 -a, --attach Attach STDOUT/STDERR and forward signals# 启动并进入容器的标准输出设备 -i, --interactive Attach container&#x27;s STDIN 重启容器12345678[root@zhima ~]# docker restart --helpUsage: docker restart [OPTIONS] CONTAINER [CONTAINER...]Restart one or more containersOptions: -t, --time int Seconds to wait for stop before killing the container (default 10) 暂停容器12345[root@zhima ~]# docker pause --helpUsage: docker pause CONTAINER [CONTAINER...]Pause all processes within one or more containers 取消暂停容器12345[root@zhima ~]# docker unpause --helpUsage: docker unpause CONTAINER [CONTAINER...]Unpause all processes within one or more containers 查看容器的源数据12345678910111213[root@zhima ~]# docker inspect --helpUsage: docker inspect [OPTIONS] NAME|ID [NAME|ID...]Return low-level information on Docker objectsOptions:# 格式化输出 -f, --format string Format the output using the given Go template# 展示容器的占用内存 -s, --size Display total file sizes if the type is container# 将JSON数据转化为特殊类型 --type string Return JSON for specified type 查看容器日志123456789101112131415[root@zhima ~]# docker logs --helpUsage: docker logs [OPTIONS] CONTAINERFetch the logs of a containerOptions:# 显示详细的数据 --details Show extra details provided to logs# 日志继续输出 -f, --follow Follow log output# 只展示尾部n条数据 -n, --tail string Number of lines to show from the end of the logs (default &quot;all&quot;)# 展示时间戳 -t, --timestamps Show timestamps 进入容器内部12345[root@zhima ~]# docker attach --helpUsage: docker attach [OPTIONS] CONTAINER# 直接进入容器当前正在运行的标准输出Attach local standard input, output, and error streams to a running container 12345678910111213141516171819[root@zhima ~]# docker exec --helpUsage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]# 在运行的容器中运行一个新的commandRun a command in a running containerOptions:# 在后台运行command -d, --detach Detached mode: run command in the background# 设置环境变量 -e, --env list Set environment variables# 读取文件中的环境变量 --env-file list Read in a file of environment variables# 保持输出流开启 -i, --interactive Keep STDIN open even if not attached# 给予此command登录用户的权力 --privileged Give extended privileges to the command# 分配一个伪终端 -t, --tty Allocate a pseudo-TTY 一般我们都会使用docker exec -it containerId|containerName /bin/bash进入容器 退出容器1234# 关闭当前的输出流，如果容器中没有其他输出流，容器就会自己关闭exit# 保持当前输出流开启Ctrl+p+q 如果容器中没有前台运行的command，则会自动关闭容器 查看容器开放端口12345[root@zhima ~]# docker port --helpUsage: docker port CONTAINER [PRIVATE_PORT[/PROTO]]List port mappings or a specific mapping for the container 查看容器内进程信息12345[root@zhima ~]# docker top --helpUsage: docker top CONTAINER [ps OPTIONS]Display the running processes of a container 宿主机和容器内的文件复制123456789101112131415[root@zhima ~]# docker cp --helpUsage: # 将容器内的文件复制到宿主机内docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-# 将宿主机中的文件复制到容器内docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATHCopy files/folders between a container and the local filesystemUse &#x27;-&#x27; as the source to read a tar archive from stdinand extract it to a directory destination in a container.Use &#x27;-&#x27; as the destination to stream a tar archive of acontainer source to stdout. 命令总结 镜像的理解什么是镜像镜像是一种轻量级、可执行的独立软件包 它包含运行某个软件所需要的所有内容，包括代码，运行时（一个程序在运行或者在被执行的依赖）、库，环境变量和配置文件。 镜像加载原理 UnionFS UnionFS (联合文件系统) 是一种分层、轻量级并且高性能的文件系统 它支持对文件系统的修改作为一次一次的提交做一层层的叠加 联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录 BootFS BootFS(Boot file system)主要包含Bootloader和Kernel Bootloader主要是引导加载Kernel内核，Linux刚启动时会加载Bootfs文件系统 当Bootloader加载完成之后整个内核就都在内存中了 此时内存的使用权已由Bootfs转交给内核，系统也会卸载BootFS RootFS RootFS (root file system) ，在Bootfs之上。包含的就是典型Linux系统中的&#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc等标准目录和文件。Rootfs就是各种不同的操作系统发行版,比如Ubuntu , Centos等等。 docker的centos镜像为什么那么小？ 对于一个精简的OS，RootFS可以很小，只包含一些最基本的命令、工具、库就可以了 当我们启动了一个容器，它底层可以直接使用宿主机已经加载好的Kernel 就不需要自己再虚拟一套环境，重新使用BootFS加载一个新的内核，大大节省了开销 Union 文件系统是Docker镜像的基础。 镜像可以通过分层来进行继承,基于基础镜像(没有父镜像) , 可以制作各种具体的应用镜像。 当我们拉取一个镜像 我们可以发现 该镜像是一层一层下载的而不是一整个下载的 这就符合了UnionFS的特性 前面几层是在我下载其他镜像的时候已经下载过了 就可以直接拿来使用，不需要再次下载，实现了资源共享，极大的节省了内存 查看镜像分层1docker image inspect imageId|imageName 特点Docker镜像都是只读的 当使用命令启动了一个新的容器的时候 该镜像先被复制 接着一个新的可写层被添加到该复制后的镜像的顶层 这一层就是容器层 所以当我们新建了一个容器后，如果想将本次修改后的容器打包成一个新的镜像，就需要使用docker commit命令 1234567891011[root@zhima volumes]# docker commit --helpUsage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container&#x27;s changesOptions: -a, --author string Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;) -c, --change list Apply Dockerfile instruction to the created image -m, --message string Commit message -p, --pause Pause container during commit (default true) 数据卷数据卷技术，说白了，其实就是文件的同步 我们创建了一个MySQL的容器，我们不对其做任何措施 如果我们误删除或者有人恶意删除了该容器 那么里面保存的数据也就随之丢失了 这是一件十分恶劣的事情 所以为了防止这种事情 我们就需要使用一种技术，将容器内保存数据的目录挂载到宿主机上 这种技术就是数据卷技术 使用这里我们部署一个MySQL来让大家明白如何使用卷技术 12345678910111213# -v 宿主机目录:容器内目录# -p 宿主机短裤:容器端口# -d 后台启动# -e 设置环境变量[root@zhima home]# docker run --name mysql01 -v /home/mysql:/usr/share/mysql -v /home/mysql/conf:/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd49309c0ab18 mysql &quot;docker-entrypoint.s…&quot; 6 seconds ago Up 4 seconds 33060/tcp, 0.0.0.0:49102-&gt;3306/tcp mysql01[root@zhima conf]# cd /home/mysql/data/[root@zhima data]# lsauto.cnf binlog.000002 ca-key.pem client-cert.pem #ib_16384_0.dblwr ib_buffer_pool ib_logfile0 ibtmp1 mysql performance_schema public_key.pem server-key.pem undo_001binlog.000001 binlog.index ca.pem client-key.pem #ib_16384_1.dblwr ibdata1 ib_logfile1 #innodb_temp mysql.ibd private_key.pem server-cert.pem sys undo_002 删除容器之后，宿主机中仍然保存着容器内的数据 12345[root@zhima data]# docker stop mysql01mysql01[root@zhima data]# lsauto.cnf binlog.000002 ca-key.pem client-cert.pem #ib_16384_0.dblwr ib_buffer_pool ib_logfile0 #innodb_temp mysql.ibd private_key.pem server-cert.pem sys undo_002binlog.000001 binlog.index ca.pem client-key.pem #ib_16384_1.dblwr ibdata1 ib_logfile1 mysql performance_schema public_key.pem server-key.pem undo_001 具名挂载和匿名挂载12345# 匿名挂载，我不指定宿主句的路径，指定容器内的路径[root@zhima home]# docker run --name mysql01 -v /usr/share/mysql -v /etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql# 具名挂载，我不指定宿主句的路径，但是指定一个名字，并指定容器内的路径[root@zhima home]# docker run --name mysql01 -v mysql_data:/usr/share/mysql -v mysql_config:/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql 不管是具名挂载还是匿名挂载都是docker自动在/var/lib/docker/volumes目录下创建文件夹 只不过具名挂载可以自己指定该文件夹的名字 数据卷容器如何做到多个容器间数据共享呢？ 那就需要使用数据卷容器技术，其实就是一个可选项，下面看使用 123[root@zhima home]# docker run --name mysql01 -v mysql_data:/usr/share/mysql -v mysql_config/etc/mysql/conf.d -p 49102:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker run --name mysql02 --volumes-from mysql01 -p 49103:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql[root@zhima home]# docker run --name mysql03 --volumes-from mysql01 -p 49103:3306 -d -e MYSQL_ROOT_PASSWORD=123456 mysql mysql01就叫数据卷容器 mysql02、mysql03就会和mysql01的挂载是一样的 即mysql02和mysql03都和mysql01一样挂载到了宿主机的同个目录 /var/lib/docker/volumes/mysql_data和/var/lib/docker/volumes/mysql_cofig 对数据卷的操作12345678910111213# 对卷的操作[root@zhima etc]# docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes DockerfileDockerfile就是用来构建docker镜像的文件 1、Dockerfile中的保留关键词使用的时候都必须是大写 2、指令是从上到下执行的 3、#表示注释 4、每一个指令都会创建并提交一层镜像层 指令Dockerfile中的指令 指令 说明 FROM 说明镜像使用的基础镜像 MAINTAINER 设置镜像的作者 ADD 构建镜像的时候复制文件到容器内 COPY 构建镜像的时候复制文件到容器内 RUN 设置容器的启动命令 ONBUILD 设置镜像的ONBUILD指令 WORKDIR 设置运行RUN CMD ENTRYPOINT COPY ADD指令的工作目录 USER 设置运行RUN CMD ENTRYPOINT的用户名 STOPSIGNAL 设置容器退出的时候的信号量 ARG 设置编译镜像的时候加入的参数 LABEL 设置镜像的标签 CMD 编译镜像的时候运行的脚本 ENV 设置容器的环境变量 EXPOSE 设置镜像暴露的端口 ENTRYPOINT 设置容器的入口程序 VOLUME 设置容器的挂载卷 小试牛刀自己制作一个带网络配置和vim的centos镜像 123456789101112131415161718192021222324252627FROM centosMAINTAINER zhima&lt;1158778689@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATH# 下面三行RUN命令是为了解决以下这个错误的# Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlistRUN cd /etc/yum.repos.d/RUN sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*RUN sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*RUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD [&quot;ls&quot;,&quot;-l&quot;]CMD /bin/bash 构建构建命令 12345678910111213[root@zhima home]# docker build --helpUsage: docker build [OPTIONS] PATH | URL | -Build an image from a DockerfileOptions:# Dockerfile的名字 -f, --file string Name of the Dockerfile (Default is &#x27;PATH/Dockerfile&#x27;)# 生成的镜像的标签 -t, --tag list Name and optionally a tag in the &#x27;name:tag&#x27; format docker build -f Dockerfile -t myImageName:tag ./ 构建镜像 1[root@zhima lizhi]# docker build -t mycentos:1.0 . 启动容器12[root@zhima lizhi]# docker run -it --name centos1 mycentos:1.0[root@49ea92e17942 local]# CMD和ENTRYPOINT我们来试一下构建这个Dockerfile，并运行 123FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;] 构建 12345678910[root@zhima lizhi]# docker build -t mycentos .Sending build context to Docker daemon 17.92kBStep 1/2 : FROM centos ---&gt; 5d0da3dc9764Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in a1e70a05d8ddRemoving intermediate container a1e70a05d8dd ---&gt; 00433fd4c299Successfully built 00433fd4c299Successfully tagged mycentos:latest 运行 123[root@zhima lizhi]# docker run -it --name &quot;centos1&quot; mycentos. .dockerenv dev home lib64 media opt root sbin sys usr.. bin etc lib lost+found mnt proc run srv tmp var 可以发现，进入容器之后，就执行了ls -a命令 我们尝试一下在启动的时候加入一些参数 12[root@zhima lizhi]# docker run -it --name &quot;centos2&quot; mycentos -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown. 我们发现容器并没有执行ls -al，而是直接报错了 其实这就是CMD的特性，当我在启动容器的时候添加了一个CMD后 镜像中定义的CMD就被覆盖掉了 单独的-l当然会报错了 我们来看一下使用ENTRYPOINT会怎么样 修改Dockerfile 123FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] 重新构建 12345678910[root@zhima lizhi]# docker build -t mycentos .Sending build context to Docker daemon 17.92kBStep 1/2 : FROM centos ---&gt; 5d0da3dc9764Step 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 22ef40dea625Removing intermediate container 22ef40dea625 ---&gt; 73a3d51b4d84Successfully built 73a3d51b4d84Successfully tagged mycentos:latest 运行容器 123456789101112131415161718192021222324[root@zhima lizhi]# docker run -it --name &quot;centos1&quot; mycentos -ltotal 56drwxr-xr-x 1 root root 4096 Jul 14 08:52 .drwxr-xr-x 1 root root 4096 Jul 14 08:52 ..-rwxr-xr-x 1 root root 0 Jul 14 08:52 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 2020 bin -&gt; usr/bindrwxr-xr-x 5 root root 360 Jul 14 08:52 devdrwxr-xr-x 1 root root 4096 Jul 14 08:52 etcdrwxr-xr-x 2 root root 4096 Nov 3 2020 homelrwxrwxrwx 1 root root 7 Nov 3 2020 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Sep 15 2021 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 2020 mediadrwxr-xr-x 2 root root 4096 Nov 3 2020 mntdrwxr-xr-x 2 root root 4096 Nov 3 2020 optdr-xr-xr-x 191 root root 0 Jul 14 08:52 procdr-xr-x--- 2 root root 4096 Sep 15 2021 rootdrwxr-xr-x 11 root root 4096 Sep 15 2021 runlrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 2020 srvdr-xr-xr-x 13 root root 0 Jan 29 10:27 sysdrwxrwxrwt 7 root root 4096 Sep 15 2021 tmpdrwxr-xr-x 12 root root 4096 Sep 15 2021 usrdrwxr-xr-x 20 root root 4096 Sep 15 2021 var 可以发现，容器执行的是ls -al，-l指令被追加给了ENTRYPOINT定义的语句","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"}]},{"title":"Docker-导言","slug":"Docker-导言","date":"2022-07-13T10:18:48.000Z","updated":"2022-10-04T13:52:31.594Z","comments":true,"path":"javaEE/Docker/2022/07/13/Docker-导言/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Docker/2022/07/13/Docker-%E5%AF%BC%E8%A8%80/","excerpt":"","text":"Docker-导言Docker出现的原因每一款产品的出示都是为了解决一些痛点问题 相信我们都经历过这种场景 我们的项目在本地跑起来一点毛病都没有 开心地将jar包分享给同学 过了一会，同学一脸嫌弃地找你去看他在服务器上运行后齐刷刷的报错信息，觉得你写的代码不行，跑都跑不起来 看了报错，发现他没有安装redis，没有安装es，没有安装mysql等等软件 这时候就很无奈了，只能帮其一步步进行安装，进行配置 安装完成后，可能还要调一堆的bug，浪费了大量的时间 我们现在的结构是(Linux + jar + Redis环境 + ES环境 + Mysql环境… ) 这就会导致上面出现的问题，就算他早就安装了这些软件，如果版本和你使用的不一致，那么也有可能报错 这时候，就希望有样东西可以帮我们解决这个问题 那么这个东西就是Docker 在使用Docker之后，结构就变成了(Linux+（jar + Redis环境 + ES环境 + Mysql环境… ）) 将jar包和环境一起打包，就不会出现开头出现的问题啦 下面让我们来学习Docker吧 认识Docker传统运行应用 所有的应用都是跑在同一个宿主机上 使用共同的类库（Lib） 所以请你想象这种场景： APP1(将其比作放射物质)+APP2(将其比作食物) 那么这种情况下，APP2会被APP1破坏 如果有些应用又依赖APP1，那么就会牵扯很多应用无故躺枪 导致Linux大环境牵连受损，很难处理 当我们使用了Docker技术之后 所有的应用都是在Docker的管理下运行的 这里的应用就要换个名字了，叫容器 每一个容器都有一套自己的环境，并且不会受到其他容器环境的影响，容器之间是相互隔绝的 就算有两个水火不容的应用出现在了同一个容器中，也不会影响到其他容器的环境 下面看一下Docker官方给出的一张体系架构图 优势传统虚拟机技术 VS Docker容器技术 虚拟机实现资源隔离的方法是利用独立的OS，并利用Hypervisor虚拟化CPU、内存、IO设备等实现的 Docker比虚拟机有更少的抽象层，不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源 而虚拟机加载GuestOs是分钟级启动的 docker利用的是宿主机的内核，而不需要Guest OS。 因此，Docker通过镜像新建一个容器的时候，不需要像虚拟机一样重新加载一个虚拟机内核 我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。 而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。 另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的 所以docker对比虚拟机在资源消耗上也占有比较大的优势。 在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机 安装Docker123456789101112131415161718192021222324252627282930313233#卸载之前的Dockersudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#下载需要的安装包sudo yum install -y yum-utils#设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https:\\\\download.docker.com\\linux\\centos\\docker-ce.repo#默认是国外的 sudo yum-config-manager \\ --add-repo \\ https:\\\\mirrors.aliyun.com\\docker-ce\\linux\\centos\\docker-ce.repo#阿里云的 # 更新yum软件包索引sudo yum makecache fast#安装Docker引擎 docker-ce docker-ee sudo yum install docker-ce docker-ce-cli containerd.io#启动docker sudo systemctl start docker #测试是否启动成功docker version 如果你购买了阿里云、百度云、腾讯云的服务器，可以配置一个容器镜像加速 这个镜像加速走的是服务器内网，写我的也没有用哦 卸载Docker123456#卸载docker依赖sudo yum remove docker-ce docker-ce-cli containerd.io#删除资源sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2022-07-09T03:19:07.000Z","updated":"2022-09-27T10:21:33.572Z","comments":true,"path":"琐碎的知识/2022/07/09/正则表达式/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式前言相信大家对正则的态度就是 但是当每次在需要做校验或者的时候，都会十分狼狈的去百度，去CSDN 将找到的正则表达式直接copy过来，也不会去看里面写的啥 直接就信心满满的去运行 然后就要么报错，要么啥也没匹配到 看别人写的java代码，我们是痛苦的 看别人写的正则表达式，我们感受不到痛苦，是绝望的，直接放弃了 实在受不了这种任人宰割的感觉，所以就花了几天彻彻底底地将正则学了一遍 最真实地感觉就是，正则不简单，得把它当作一种语言去学 这样才可以拿出态度去接受它 下面是学习笔记 介绍正则表达式是由普通字符（如英文字母）以及特殊字符（也称为元字符）组成的文字模式 该模式对文本查找时需要匹配的一个或多个字符串描述，给出一个匹配模板。 它可以大大简化文本识别工作，现已超出了某种语言或某个系统的局限，成为被人们广为使用的工具。 先给大家介绍一个在线检测正则表达式的网站，十分好用！ 链接如下：https://regex101.com 声明：以下我使用的某些概念在不同网站上，不同视频中，都会有不同的叫法，我会尽量将所有的讲法都标注 修饰符下面在开始正题之前，我要先给大家讲一个修饰符的概念。 我自己在学这个的时候，没有哪一个视频或者教程会将修饰符放到最前面 但是在我学下来，我觉得如果将这个知识点放在最前面，而且这个知识点也不难，只是一个概念 这可能会有利于大家的学习，所以我就尝试将此知识点前置 在正则表达式中有很多修饰符 我们只看常用的四个 大家注意这个地方，这个地方显示的就是当前开启的修饰符 global 可以看到这其中的区别就是 非全局模式只匹配了第一个匹配成功的 而全局模式则匹配了所有匹配成功的 multi line这里只演示^的情况 这里要有个前置知识，就是 ^匹配文本开头 $匹配文本结尾 我们都知道文本只有一个开头和一个结尾 但是开启了multi line之后 ^不仅可以匹配文本开头而且可以匹配行首 $不仅可以匹配文本结尾而且可以匹配行尾 single line 这里也需要有前置知识 .可以匹配除了\\n之外的所有字符 开启了single line之后 .可以匹配所有的字符，包括\\n insensitive 该修饰符就是关闭大小写敏感 即a和A是一样的 简单匹配固定字符串假如我要在下列文本中匹配export字符串，我们可以这么写 这就是对固定字符串的匹配，这很简单 范围字符 又叫元字符 在正则表达式中，我们有以下表示一定范围的字符 符号 名称 . 匹配除 \\n 以外的任何一个字符 \\d 匹配单个数字字符，相当于[0-9] \\D 匹配单个非数字字符，相当于[^0-9] \\w 匹配单个数字、大小写字母、下划线字符，相当于[0-9a-zA-Z_] \\W 匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z] \\s 匹配任意一个\\n、空格、tab \\b 匹配每一个单词的前和后 注意：一个范围字符只可以匹配一个属于该范围的字符 ​ 一个！一个！一个！ ​ 输入.发现除了\\n全亮了是因为开启了global修饰符！ 这里没什么好说的，背下，下面给一张图帮助记忆 自定义范围字符对于十六进制的颜色，#后面只能出现数字和a-f的字符 我们发现内置的这些范围字符都不太好用 这时候就需要使用自定义范围字符 想要定义自定义范围字符，就需要使用[] 下面我们来写匹配十六进制的自定义范围字符 自己写全 [0123456789abcdef] 使用-连接符 [0-9a-f] []还有几种写法，我们使用案例来说明 栗一数据如下，匹配80年代和90年代以外的 123456姓名 生日芝麻 2001-05-22章一 1993-08-09沈家怡 1999-05-22陆力丹 1989-02-19王子怡 2002-12-15 在[]内部的开头写^表示匹配除了方括号里面出现的字符 栗二匹配特殊字符^或者$或者. 但是小伙伴可能写的顺序不是这样的，你可能是这样写的[^$.] 这里如果^放在第一位，他就会使用栗一种的功能 如果我就是想要用这种顺序写，但是还想匹配^特殊字符本身，可不可以呢？ 当然可以啦，这里需要使用转义字符\\登场了 栗三这个案例就有点难了，我们来匹配正确的车牌号，匹配规则如下 普通车牌特征： 第1位是表籍贯的汉字 第2位是表城市的大写字母，不包括I和O。因为容易和数字0和1混淆 后5位是字母加数字，也不包括I和O 测试数据如下 1234567891011121314湘C4ASF7湘G9AWSE湘O392LEY鲁E2S1EF湘D219U5湘AS2BKN皖91L2IZ鲁I0H8F鲁R10Y2FA湘1R9GJ3鲁REF02H鲁2319G7鲁3RGN90N鲁23G90K 基本逻辑控制在正则表达式中只有且和或这两种逻辑关系，我们这里用一个案例来引出或 匹配规则：匹配所有的http状态码 401：未授权 403：无权限访问 404：找不到资源 500：服务内部错误 测试数据如下 1234567891011121314404500309403230401400234325401923482340325 那且呢？ 其实我们早就使用过且了 就比如我们这个案例中，404不就是且么？ 4并且0并且4 这三个数字同时满足，才匹配出来404 数量控制我们回顾一下之前的匹配十六进制颜色的案例 测试数据如下： 12345678910111213.el-header &#123; background-color: #BC0D13 color: #CCCCCC line-height: 60px;&#125;.el-aside &#123; color: #5fe3a1&#125;.active &#123; background-color: #0086b3;&#125; &#123;&#125;就是数量控制的语法，我们来看看不使用数量控制的时候应该怎么写 &#123;n&#125; 指定出现固定次数 &#123;n,&#125; 指定至少出现n次 &#123;n,m&#125; 指定出现n到m次 简写形式 符号 等价 * &#123;0,&#125; + &#123;1,&#125; ? &#123;0,1&#125; 懒惰匹配和贪婪匹配该知识点我们配合案例来食用 匹配所有的span标签 测试数据 1&lt;span&gt;span1&lt;/span&gt;kongge&lt;span&gt;span2&lt;/span&gt; 我们先来尝试一下 我们发现，它竟然全匹配了，这是为什么呢？ 解释 +会尽量一直往后匹配，一直到无法匹配.为止 本来匹配到span1后面的&lt;符号的时候，就可以停止匹配了 但是因为默认开启的是贪婪匹配，啥意思呢？ 就是&lt;还是符合.的吧，那就继续匹配 直到匹配到span2后面的&lt;的时候，发现如果再匹配span2后面的&lt;了 那么我们正则表达式中最后的&lt;/span&gt;就没法匹配了，所以.就匹配到span2中的2为止 那让我们开启懒惰模式看看结构 解释 +会尽量一直往后匹配，一直到无法匹配为止 匹配到span1后面的&lt;符号的时候 发现其实这个&lt;已经可以匹配正则最后的&lt;了 那就结束匹配吧，所以就匹配出了第一组span标签 注意点： 开启懒惰模式中的?和我们在数量控制中的?是不一样的 懒惰模式中的?只能写在数量控制&#123;&#125;后面 数量控制&#123;&#125;只可以写在范围字符后面[a-f]或者\\d这种 这里需要好好理解一下 删除所有的HTML注释测试数据如下 有三种注释哦 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;!-- &lt;div&gt;&lt;/div&gt;--&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;test&quot;/&gt; &lt;!-- &#123;&#123;test&#125;&#125; --&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; test: &#x27;&#x27; &#125;, /* methods: &#123; &#125;,*/ watch: &#123; test: &#123; handler: function (newData,oldData) &#123; console.log(newData); console.log(oldData); &#125;, // immediate: true &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 进阶分组分组指将匹配的内容，使用()划分成多个组块，分好的组可用于在匹配后提取、反向引用以及替换操作。 下面使用两个案例来做说明 提取信息转sql什么意思呢？就是将提取出来的数据转化为DML语句 栗：insert into user(name,age,sex,birthday) values(&#39;芝麻&#39;,&#39;19&#39;,&#39;男&#39;,&#39;2001-05-22&#39;) 测试数据如下 12345芝麻 2001/05/22 19岁 男章一 1993-08-09 20岁 女沈家怡 1999.05.22 21岁 女陆力丹 1989-02-19 19岁 男王子怡 2002-12-15 19岁 男 $组号可以拿到括号中匹配的内容 匹配正确的自闭和标签测试数据如下 1234567&lt;span&gt;span1&lt;/span&gt;&lt;h2&gt;h22&lt;/h2&gt;&lt;h2&gt;h23&lt;/h3&gt;&lt;h3&gt;h32&lt;/h2&gt;&lt;h1&gt;h11&lt;/h1&gt;&lt;div&gt;d iv1&lt;/div&gt;&lt;span&gt;wrong&lt;/dspan&gt; 在正则表达式中使用\\组号来反向引用前面匹配的组 $0表示整个匹配的字符串 注意反向引用只用在表达式中引用之前的分组 匹配所有的JavaScript中的字符串JavaScript中有三种字符串 1231、&#x27;&#x27;2、&quot;&quot;3、`` 测试文本 12345678910111213141516171819const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const server = http.createServer();server.on(&quot;request&quot;,(req,resp)=&gt;&#123; let url = req.url; if(url===&#x27;/favicon.ico&#x27;)&#123; resp.end(); return; &#125; resp.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); console.log(`访问的网址的$&#123;url&#125;，访问方法是$&#123;req.method&#125;`); let data = fs.readFileSync(path.join(__dirname,url)); resp.end(data);&#125;)server.listen(&#x27;80&#x27;,()=&gt;&#123; console.log(&#x27;服务启动\\&quot;成功\\&quot;，80端口&#x27;);&#125;) 下面做个拓展分组还有以下四种情况 ?&lt;名称&gt;命名分组 (?:)移除分组 (())嵌套分组 (\\d)+分组中使用量词 命名分组默认情况下通过组号来取值，此外也可以自定义命名组，语法是(?&lt;名称&gt; ) 然后在程序中就可以通过&lt;&gt;中的名称来取值。 如：&lt;(?&lt;title&gt;(\\S+?))&gt;.*&lt;\\/\\1&gt; 该表达式就命名了一个title的组，在js的结果中就可通过title属性取值。 注意： 这种命名组只能用于在程序中提取操作，不能进行反向引用，也不能用在替换操作中。 也正因为这种局限性所以命名组使用的很少。 移除分组()即用于子表达式，同时也是一个分组。 如果只想用作子表达式，而不想用于分组就可以使用(?: )从分组列表中移除。 比如(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;) 该表达式就只存在两个组，月$1和日$2。 嵌套分组比如：((\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)) 其组号的命名顺序是以开括号出现顺序为准。 $1指的是一个整体 $2指的是年 $3指的是月 $4指的是日 按照(的顺序进行编组 大小写转换在Idea、VS Code、Sublime、Notepad++等工具进行替换操作时，还可以使用下表中操作符进行大小写转换 操作符 描述 \\u 单个转大写 转换下一个字符为大写 \\U 全部转大写 转换\\U后所有字符转大写 \\U…\\E 区间转大写 \\U与\\E区间的内容转大写 \\l 单个转小写 转换一下个字符为小写 \\L 全部转小写 转换\\L后所有字符转小写 \\L…\\E 区间转小写 \\L与\\U区间的内容转小写 边界断言介绍是边界断言让正则表达式有了条件判断的能力 先来看个栗子感受一下 匹配所以姓名，不能带着表头中的姓名 测试数据 123456姓名 生日 年龄 性别芝麻 2001/05/22 19岁 男章一 1993-08-09 20岁 女沈家怡 1999.05.22 21岁 女陆力丹 1989-02-19 19岁 男王子怡 2002-12-15 19岁 男 这里面的(?!)就是前置否定断言 在断言这里，网上的，视频的教程对其的称呼真的是层出不穷， 表达式 环视 预查 边界断言 零宽断言 (?= ) 向前肯定环视 正向肯定预查 边界前置肯定断言 零宽度正预测先行断言 (?! ) 向前否定环视 正向否定预查 边界前置否定断言 零宽度负预测先行断言 (?&lt;= ) 向后肯定环视 反向肯定预查 边界后置肯定断言 零宽度正回顾后发断言 (?&lt;! ) 向后否定环视 反向否定预查 边界后置否定断言 零宽度负回顾后发断言 管他叫什么呢，反正我们只要知道它是断言，然后怎么使用就行了 这里只需要四组图就可以记住这四个断言的作用了 (?=芝)就是芝前面的那个地方 (?!芝)就是除了芝前面地方的其他所有地方 (?=芝)就是芝后面的那个地方 (?!芝)就是除了芝后面地方的其他所有地方 虽然案例很简陋，但是只要理解了这四句话，边界断言就轻轻松松拿下 匹配错误的十六进制颜色测试数据如下 正确的16进制颜色规则 1、#开头 2、6个16进制数字或者3个 12345678#BC0D13#a3e32d#a656e3#e00#91e376#assdas##14e3ce 实现这种题目的步骤就是 先找到符合要求的16进制颜色 然后使用向前否定环视 即可找到不符合要求的16进制颜色 找出所有符合条件的密码 密码长度是8-20位 大小写字母以及数字必须都有一个。 测试数据 12345678e3c3d2D322386e374W2e3a34fDas213498h94DIOJ239830239ur23u90asdasasd5fe362IKds2ab93Fbf45bbaSd9 提取JavaScript中的合法变量名测试数据 12345678910111213141516171819const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const 1server = http.createServer();server.on(&#x27;request&#x27;,(req,resp)=&gt;&#123; var url = req.url; if(url===&#x27;/favicon.ico&#x27;)&#123; resp.end(); return; &#125; resp.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); console.log(`访问的网址的$&#123;url&#125;，访问方法是$&#123;req.method&#125;`); let _data = fs.readFileSync(path.join(__dirname,url)); resp.end(data);&#125;)server.listen(&#x27;80&#x27;,()=&gt;&#123; console.log(&#x27;服务启动成功，80端口&#x27;);&#125;) 添加千分号每三位加入一个,做分割 测试数据 12345671234997813241230981240941270491277124091247014387413129932908723451972 JAVA中的正则java.util.regex 是一个用正则表达式所定制的模式来对字符串进行匹配工作的类库包 它主要包括两个类：Pattern 和 Matcher 。 Pattern： 一个 Pattern 是一个正则表达式经编译后的表现模式。 Matcher：一个 Matcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 首先一个 Pattern 实例定制了一个所用语法与 PERL 类似的正则表达式经编译后的模式 然后一个 Matcher 实例在这个给定的 Pattern 实例的模式控制下进行字符串匹配后的后续工作，比如替换啊 PatternPattern 的主要方法如下 方法名称 解释 static Pattern compile(String regex) 将给定的正则表达式编译并赋予给 Pattern 类 static Pattern compile(String regex, int flags) 对指定字符串的截取，参数配置如下 int flags() 返回当前 Pattern 的匹配 flag 参数 Matcher matcher(CharSequence input) 生成一个给定命名的 Matcher 对象 static boolean matches(String regex, CharSequence input) 编译给定的正则表达式并对输入的字串以该正则表达式为模开展匹配 String pattern() 返回该Patter对象所编译的正则表达式 一个正则表达式，也就是一串有特定意义的字符 可以首先要编译成为一个 Pattern 类的实例 这个 Pattern 对象可以使用 matcher(String str) 方法来生成一个 Matcher 实例 接着便可以使用该 Matcher 实例对目标字符串进行匹配后的后续工作 现在我们先来看一个简单的例子 123456789101112// 生成一个 Pattern，同时编译一个正则表达式Pattern p = Pattern.compile(&quot;[/\\\\]+&quot;);//用 Pattern 的 split() 方法把字符串按 &quot;/&quot; 和 &quot;\\&quot;分割String[] result = p.split( &quot;Kevin has seen《LEON》seveal times,because it is a good film.&quot; +&quot;/ 凯文已经看过《这个杀手不太冷》几次了\\因为它是一部&quot; +&quot;好电影。/名词:凯文。&quot;);for (int i = 0; i &lt; result.length; i++)&#123; System.out.println(result[i]);&#125; 上述代码的运行结果为： Kevin has seen《LEON》seveal times,because it is a good film.凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。名词:凯文。 MatcherMatcher 对象是一个状态机器，它依据 Pattern 对象做为匹配模式对字符串展开匹配检查。 例：下面是一个对单词 dog 出现在输入字符串中出现次数进行计数的例子： 123456789101112String regex = &quot;\\\\bdog\\\\b&quot;;String input = &quot;dog dog dogtie&quot;;Pattern p = Pattern.compile(regex);Matcher m = p.matcher(input); // 获取 matcher 对象int count = 0;while (m.find()) &#123; count++; System.out.println(&quot;Match number &quot; + count); System.out.println(&quot;start(): &quot; + m.start()); System.out.println(&quot;end(): &quot; + m.end());&#125; 上述代码的执行结果为： Match number 1 &#x2F;&#x2F; 第一次出现 （下标 0-2）start(): 0 &#x2F;&#x2F; 开始下标 0end(): 3 &#x2F;&#x2F; 结束下标 3Match number 2 &#x2F;&#x2F; 第二次出现（下标 4-6）start(): 4 &#x2F;&#x2F; 开始下标 4end(): 7 &#x2F;&#x2F; 结束下标 7 dogtie中的dog没有被匹配是因为我们要的是单独的单词dog而不是在其他单词中的dog matches 和 lookingAt 这两个方法都用来尝试匹配一个输入序列模式。 它们的不同是 matches 要求整个序列都匹配 而lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。 1234567891011String regex = &quot;foo&quot;;String input = &quot;fooooooooooooooooo&quot;;String input2 = &quot;ooooofoooooooooooo&quot;;Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(input);Matcher matcher2 = pattern.matcher(input2);System.out.println(&quot;lookingAt(): &quot; + matcher.lookingAt());System.out.println(&quot;matches(): &quot; + matcher.matches());System.out.println(&quot;lookingAt(): &quot; + matcher2.lookingAt()); 上述代码的执行结果为： lookingAt(): truematches(): falselookingAt(): false replaceFirst 和 replaceAll 这两个方法用来替换匹配正则表达式的文本。 不同的是，replaceFirst 只会替换第一次匹配 replaceAll 替换所有匹配。 下面的例子来解释这个功能： 123456789101112131415String regex = &quot;dog&quot;;String input1 = &quot;The dog says meow. All dogs say meow.&quot;;String input2 = &quot;The dog says meow. All dogs say meow.&quot;;String replace = &quot;cat&quot;;Pattern p = Pattern.compile(regex);Matcher m1 = p.matcher(input1);Matcher m2 = p.matcher(input2);input1 = m1.replaceAll(replace);input2 = m2.replaceFirst(replace);System.out.println(input1);System.out.println(input2); 上述代码的执行结果为： The cat says meow. All cats say meow.The cat says meow. All dogs say meow. 从上面的结果，我们可以发现，replaceFirst 方法只将第一个 dog 替换成了 cat。而 replaceAll 方法却将两个 dog 都替换成了 cat。 好啦，结束了 正则差不多就这些内容了 如果你发现了错误 望留言批评指正！","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Vue2-基础5","slug":"Vue2-基础5","date":"2022-06-30T23:45:18.000Z","updated":"2022-09-27T13:58:04.332Z","comments":true,"path":"前端/Vue2/2022/07/01/Vue2-基础5/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/07/01/Vue2-%E5%9F%BA%E7%A1%805/","excerpt":"","text":"Vue2-基础5动画效果在隐藏元素之前执行一段动画 在显示元素之前显示一段动画 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;show=!show&quot;&gt;显示/隐藏&lt;/button&gt; &lt;transition name=&quot;come&quot; appear&gt; &lt;h2 v-show=&quot;show&quot;&gt;Hello，World！&lt;/h2&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Test&quot;, data()&#123; return &#123; show: true &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.come-enter-active &#123; animation: move 1s linear;&#125;.come-leave-active &#123; animation: move 1s linear reverse;&#125;@keyframes move &#123; from &#123; transform: translateX(-100%); &#125; to &#123; transform: translateX(0px); &#125;&#125;h2 &#123; background: greenyellow; width: 300px&#125;&lt;/style&gt; 过渡效果1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;show = !isShow&quot;&gt;显示/隐藏&lt;/button&gt; &lt;transition-group name=&quot;hello&quot; appear&gt; &lt;h1 v-show=&quot;!show&quot; key=&quot;1&quot;&gt;Hello！&lt;/h1&gt; &lt;h1 v-show=&quot;show&quot; key=&quot;2&quot;&gt;World!&lt;/h1&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Test&#x27;, data() &#123; return &#123; show:true &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; h1&#123; background-color: orange; &#125; /* 进入的起点、离开的终点 */ .hello-enter,.hello-leave-to&#123; transform: translateX(-100%); &#125; .hello-enter-active,.hello-leave-active&#123; transition: 0.5s linear; &#125; /* 进入的终点、离开的起点 */ .hello-enter-to,.hello-leave&#123; transform: translateX(0); &#125;&lt;/style&gt; 配置代理发起网络请求我们有以下四种方式 12341.xhr window上的对象，原生2.jQuery 内置了ajax请求，但是本身注重的是DOM节点操作3.axios 封装了chr，十分轻量，promise风格4.fetch window上的对象，原生，包装了两层promise 这里我们使用axios来做网络请求 1npm i axios CORS(Cross-Origin Resource Sharing ) 前端中发出ajax请求的时候经常会出现的一种错误，叫做跨域请求 这是因为违背了同源策略 1、同协议 2、主机名 3、端口号 解决方案 1、后端返回数据的时候，加上一些特殊的响应头即可 2、配置代理服务器 服务器之间互相访问是不受同源策略的限制的 所以我们可以配置一个和我们自己的端口号一致的代理服务器 将请求转发给它 让它去请求其他端口上的服务器得到数据后再将其返回 我们可以使用nginx或者借助vue-cli来配置一个代理服务器 这里我们借助vue-cli 开启代理服务器（方式一） 12345module.exports = &#123; devServer: &#123; proxy: &#x27;http://localhost:5000&#x27; &#125;, &#125; 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 开启代理服务器（方式二） 12345678910111213141516module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/hello&#x27;: &#123; target: &#x27;http://localhost:5000&#x27;, // ws: true, //用于支持websocket // changeOrigin: true //用于控制请求头中的host值 &#125;, &#x27;/demo&#x27;: &#123; target: &#x27;http://localhost:5001&#x27;, // ws: true, //用于支持websocket // changeOrigin: true //用于控制请求头中的host值 &#125; &#125; &#125;&#125; 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 。 默认插槽父组件： 123&lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt;&lt;/Category&gt; 子组件： 123456&lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽父组件： 123456789&lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt;&lt;/Category&gt; 子组件： 1234567&lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽作用：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。 父组件： 123456789101112131415&lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Category&gt;&lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt;&lt;/Category&gt; 子组件： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125;&lt;/script&gt; 路由每一个Vue的大型项目都会用到路由，所以这部分十分重要 无路由，无SPA应用 我们回顾一下以前写的web应用的结构 1234- index.html- user.html- pay.html- category.html 然后每个页面中又有链接可以实现互相跳转，这就是典型的多页面应用 SPA应用（Single page web application）：单页面应用 只要点击侧边栏的目录，功能区就会切换到特定的页面，不会刷新页面，实现局部刷新，这就是单页面应用 路由就是用来实现这个切换，路由器就是用来管理这些路由的 概念路由就是一组key-value的对应关系 多个路由，由一个路由器统一管理 路由分类 后端路由 key就是路径 value就是函数，函数返回对这次请求响应的数据 前端路由 key就是理解 value就是组件，什么样的路径，展示什么样的组件 基本路由实现以下功能 默认显示pageA组件 点击pageA按钮，切换pageA组件 点击pageB按钮切换pageB组件 安装Vue-router 1npm i vue-router 安装插件 1234567891011import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;Vue.config.productionTip = falseVue.use(VueRouter)new Vue(&#123; render: h =&gt; h(App), router&#125;).$mount(&quot;#app&quot;) 创建pageA和pageB组件 123456789101112131415&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageA&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789101112131415&lt;template&gt; &lt;div&gt; 我是pageB的内容 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageB&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 创建/router文件夹并创建index.js 1234567891011121314151617181920212223// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 我们先写声明式路由 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;点以下按钮切换页面&lt;/h3&gt; &lt;div style=&quot;margin-bottom: 30px;display: flex;width: 120px;justify-content: space-between&quot;&gt; &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt; &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageB&quot;&gt;PageB&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt;&lt;style scoped&gt;.container &#123; padding: 30px;&#125;.active &#123; color: red; text-decoration: none;&#125;.item &#123; text-decoration: none;&#125;&lt;/style&gt; 总结： 12345678910111. 被切换走的组件实际上是被销毁了2. router-link经过编译后，实际上生成的是a标签，这是声明式路由的一个小弊端 我们后面会使用编程式路由来实现跳转功能，会更加灵活3. pageA和pageB的实例上都多了两个属性$route和$router $route指的是自身的路由规则和状况 $router是全局的路由器 4. 路由组件（pageA和pageB这种需要路由规则才会显示的组件）一般放在pages文件夹下 一般组件放在components文件夹下 嵌套路由 1234567891011121314151617181920212223242526272829303132333435// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;,//这里千万不要加上/ component: PageAA &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) PageA.vue 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;ul&gt; &lt;!--这里要写完整的路径，因为我们有可能会跳转到其他页面去，所以我们必须得写完整的路径--&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAA&quot;&gt;pageAA&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAB&quot;&gt;pageAB&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageA&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 命名路由在创建路由器的时候，为路由起名字 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;import PageContent from &quot;@/components/PageContent&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;, component: PageAA, &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; //起名 name: &quot;detailRoute&quot;, path: &quot;pageContent&quot;, component: PageContent &#125; ] &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 那么在切换的时候，就可以使用名字来选择路由了 12345678&lt;router-link :to=&quot;&#123; name: &#x27;detailRoute&#x27;, query: &#123; pageDetail: p &#125;&#125;&quot;&gt;&#123;&#123;p.title&#125;&#125;&lt;/router-link&gt; query参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; 我是pageAB的内容 &lt;ul&gt; &lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;router-link :to=&quot;&#123; path: &#x27;/pageA/pageAB/pageContent&#x27;, query: &#123; pageDetail: p &#125; &#125;&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageAB&quot;, data()&#123; return &#123; pageList: [ &#123; id: &#x27;001&#x27;, content: &#x27;我是pageABA的内容&#x27;, title: &#x27;pageABA&#x27;, &#125;, &#123; id: &#x27;002&#x27;, content: &#x27;我是pageABB的内容&#x27;, title: &#x27;pageABB&#x27;, &#125;, &#123; id: &#x27;003&#x27;, content: &#x27;我是pageABC的内容&#x27;, title: &#x27;pageABC&#x27;, &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.id&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.title&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.query.pageDetail.content&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageContent&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; params参数123456789101112131415161718192021&lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;router-link exact-active-class=&quot;active&quot; :to=&quot;`/pageA/pageAB/pageContent/$&#123;p.id&#125;/$&#123;p.title&#125;/$&#123;p.content&#125;`&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt;&lt;/li&gt;&lt;!--或者这样写--&gt;&lt;li v-for=&quot;p in pageList&quot; :key=&quot;p.id&quot;&gt; &lt;!--这里必须使用name参数来指定路由，不然会失效--&gt; &lt;router-link :to=&quot;&#123; name: &#x27;detailRoute&#x27;, params: &#123; id: p.id, title: p.title, content: p.title &#125; &#125;&quot;&gt; &#123;&#123;p.title&#125;&#125; &lt;/router-link&gt;&lt;/li&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 该文件专门用于创建整个应用的路由器import VueRouter from &#x27;vue-router&#x27;//引入组件import PageA from &quot;@/components/PageA&quot;;import PageB from &quot;@/components/PageB&quot;;import PageAA from &quot;@/components/PageAA&quot;;import PageAB from &quot;@/components/PageAB&quot;;import PageContent from &quot;@/components/PageContent&quot;;//创建并暴露一个路由器export default new VueRouter(&#123; routes:[ &#123; path: &quot;/&quot;, component: PageA &#125;, &#123; path:&#x27;/pageA&#x27;, component:PageA, children: [ &#123; path: &quot;pageAA&quot;, component: PageAA, &#125;, &#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; name: &quot;detailRoute&quot;, path: &quot;pageContent/:id/:title/:content&quot;, component: PageContent, &#125; ] &#125;, ] &#125;, &#123; path:&#x27;/pageB&#x27;, component:PageB &#125; ]&#125;) 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.params.title&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;$route.params.content&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageContent&quot;&#125;&lt;/script&gt; query和params的区别 12341. query的对象写法中，path可以是路径也可以是路由名 但是params必须是路由名2. params需要在路由器的配置文件中提前声明 props配置我们发现读取query和params传过来的参数的时候 需要不断使用$route.query.xxx或者$route.params.xxx，十分繁琐 如果需要简化，则需要使用props配置项 12345678910111213141516171819202122232425262728&#123; path: &quot;pageAB&quot;, component: PageAB, children: [ &#123; name: &quot;detailRoute&quot;, path: &quot;pageContent/:id/:title/:content&quot;, component: PageContent, //第一种写法，该对象的所有kv都会以props的形式传给该组件 // props: &#123; // a: &#x27;a&#x27;, // b: &#x27;b&#x27;, // &#125; //props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给该组件。 //props: true, //props的第三种写法，值为函数,推荐 props($route)&#123; return &#123; id:$route.query.id, title:$route.query.title, content:$route.query.content &#125; &#125; &#125; ]&#125; replace属性使用router-link标签实现跳转，浏览器对于历史记录的存储是这样的 这种模式叫push模式 它将一条条记录压入栈中 如果我们想实现以下这种模式 这种模式叫replace模式 它将上一条记录覆盖下一条记录 router-link默认是push模式 增加replace属性以使用replace模式 1&lt;router-link class=&quot;item&quot; replace active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt; 编程式路由修改以上案例 1、切换pageA、pageB的a改为button 2、以push模式切换pageA 3、以replace模式切换pageB 4、前进、后退 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;点以下按钮切换页面&lt;/h3&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button @click=&quot;goBack&quot;&gt;后退&lt;/button&gt; &lt;button @click=&quot;goForward&quot;&gt;前进&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button @click=&quot;gotoPageA&quot;&gt;PageA&lt;/button&gt; &lt;button @click=&quot;gotoPageB&quot;&gt;PageB&lt;/button&gt;&lt;!-- &lt;router-link class=&quot;item&quot; replace active-class=&quot;active&quot; to=&quot;/pageA&quot;&gt;PageA&lt;/router-link&gt;--&gt;&lt;!-- &lt;router-link class=&quot;item&quot; active-class=&quot;active&quot; to=&quot;/pageB&quot;&gt;PageB&lt;/router-link&gt;--&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods:&#123; gotoPageA()&#123; this.$router.push(&quot;/pageA&quot;) &#125;, gotoPageB()&#123; this.$router.replace(&quot;/pageB&quot;) &#125;, goBack()&#123; this.$router.back(); &#125;, goForward()&#123; this.$router.forward(); &#125;, &#125;&#125;&lt;/script&gt;&lt;style&gt;.container &#123; padding: 30px;&#125;.active &#123; color: red; text-decoration: none;&#125;.item &#123; text-decoration: none;&#125;.buttons &#123; margin-bottom: 30px; display: flex; width: 120px; justify-content: space-between;&#125;&lt;/style&gt; 编程式路由导航就是不通过router-link实现 而是手动使用router控制的路由跳转 123456789101112131. 如果要传入参数，就不能使用字符串了，而是要使用对象写法gotoDetail(p)&#123; this.$router.push(&#123; name: &#x27;detailRoute&#x27;, params: &#123; id: p.id, title: p.title, content: p.title &#125; &#125;);&#125;2. 编程式路由会更加灵活，不是说router-link不好 缓存路由组件现在再加一个需求在下图出加入一个input组件，然后再pageAA和pageAB之间跳转的时候，input中的数据不会丢失 之前我们说过，组件被切换走后，会被销毁 那么我们如何阻止这次的销毁呢 只要在pageA的组件中将router-view用keep-alive包裹即可 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; 我是pageA的内容 &lt;ul&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAA&quot; active-class=&quot;active&quot;&gt;pageAA&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/pageA/pageAB&quot; active-class=&quot;active&quot;&gt;pageAB&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;keep-alive include=&quot;PageAB&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 这里也可以这样写，缓存这个路由视图中的PageAB组件 &lt;keep-alive :include=&quot;[&#x27;PageAB&#x27;]&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; --&gt; &lt;!-- 这里不写inclue属性的话，这个视图中所有的组件都会被缓存 &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;PageA&quot; &#125;&lt;/script&gt; 新的生命周期钩子在这个地方展示一个透明度一直发生改变的文字 123&lt;li :style=&quot;&#123;opacity&#125;&quot;&gt; 加油！！！&lt;/li&gt; 然后开启一个定时器，对opacity的值进行操作 123456789mounted() &#123; this.timer = setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0) this.opacity=1 &#125;,16);&#125;,beforeDestroy() &#123; clearInterval(this.timer);&#125; 这里其实就出现了问题 我们已经将其设置为了缓存路由 那么当我们切换到其他组件的时候 该定时器还在周而复始的跑，这是不对的 这时候就需要两个新的路由钩子 这是路由独有的两个钩子 1234567891011activated() &#123; // 当切换到该组件，则该回调被调用 this.timer = setInterval(()=&gt;&#123; this.opacity-=0.01; if(this.opacity&lt;=0) this.opacity=1 &#125;,16);&#125;,deactivated() &#123; // 当该组件被切换走，则调用该回调 clearInterval(this.timer);&#125; 路由守卫全局路由守卫12345678910//全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用，使用next()放行// to和from都是route信息router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;前置路由守卫&#x27;,to,from,next)&#125;)//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;&#123; console.log(&#x27;后置路由守卫&#x27;,to,from)&#125;) 独享路由守卫在路由器的路由规则中配置以下逻辑 独享路由守卫没有后置的守卫 12345678&#123; name:&#x27;detailRoute&#x27;, path:&#x27;pageContent&#x27;, component:News, beforeEnter: (to, from, next) =&gt; &#123; console.log(&#x27;独享前置路由守卫&#x27;,to,from) &#125;&#125;, 组件路由守卫在组件中加入以下逻辑 123456789//通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123; console.log(&#x27;beforeRouteEnter&#x27;,to,from)&#125;,//通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123; console.log(&#x27;beforeRouteLeave&#x27;,to,from)&#125; 三个路由守卫可以配合使用哦 history模式和hash模式我们看到地址栏中始终有#号 #后面的路径都不会发送给服务器 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 那么如何切换模式呢？ vue-router默认开启的是hash模式，如果想要切换模式，只需要在创建路由器的时候，传入一个配置项mode: &#39;history&#39; 这时候你会发现地址栏的#都不见了 讲到这里，有的小伙伴肯定要说了，那我肯定要使用history模式，这样的路径看着才舒服 history模式下，路径确实舒服，但是hash模式的兼容性比较好，history涉及到一个项目上线的问题 我们使用npm run build打包 然后你就发现了出现了一个特殊的文件夹 history模式部署上线我们使用express搭建一个微型的服务器来部署我们的前端项目 1、新建文件夹 mkdir server 2、初始化项目 npm init 3、安装express npm i express 4、创建static文件夹将dist目录下的所有文件放到其中 5、创建server.js并编写服务器端代码 1234567891011const express = require(&#x27;express&#x27;);const app = express();app.use(express.static(__dirname+&#x27;/static&#x27;));app.listen(5005,(err)=&gt;&#123; if(!err)&#123; console.log(&#x27;服务器启动成功&#x27;); &#125;&#125;) 6、启动服务器 node server.js 7、访问localhost:5005并点击 出现问题这时候这个大问题就出现了，我们刷新页面 我们发现了404错误，这是为什么呢？因为服务器并没有该资源 hash模式部署上线那我们使用hash模式再次build，访问尝试 再次刷新，发现并没有出现404 解决history模式的问题我们再次回到history模式，来解决该问题 这个问题需要后端来配合 我们这里使用nodejs做后端，所以我们使用nodejs的技术来解决问题 安装一个库npm install --save connect-history-api-fallback 123456789101112const express = require(&#x27;express&#x27;);const history = require(&#x27;connect-history-api-fallback&#x27;);const app = express();app.use(history())app.use(express.static(__dirname+&#x27;/static&#x27;));app.listen(5005,(err)=&gt;&#123; if(!err)&#123; console.log(&#x27;服务器启动成功&#x27;); &#125;&#125;) 组件库我们真正开发项目的时候，我们不会所有的页面结构都是自己写，我们会使用第三方的组件库，接下来我来介绍几个比较常用的组件库 移动端 Vant https://2x.antdv.com/components/overview-cn CubeUI https://didi.github.io/cube-ui/#/zh-CN MintUI http://mint-ui.github.io/#!/zh-cn nutUI https://nutui.jd.com/#/zh-CN/component/button 京东打造 PC端 Ant Design https://2x.antdv.com/components/overview-cn 蚂蚁金服打造 ElementUI https://element.eleme.cn/#/zh-CN 饿了么打造 如果想使用这些组件库，我们只需要去这些官网查看官方文档即可","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础4","slug":"Vue2-基础4","date":"2022-06-28T06:51:46.000Z","updated":"2022-07-09T10:08:53.929Z","comments":true,"path":"前端/Vue2/2022/06/28/Vue2-基础4/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/28/Vue2-%E5%9F%BA%E7%A1%804/","excerpt":"","text":"Vue2基础4修改默认配置通过vue inspect &gt; output.js可以查看Vue脚手架的默认配置 创建vue.config.js 可选配置项可以去官网查看 123456789module.exports = &#123; pages: &#123; index: &#123; // page 的入口 entry: &#x27;src/main.js&#x27; &#125; &#125;, lintOnSave: false&#125; ref属性123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出按钮的DOM元素和School的Vc对象&lt;/button&gt; &lt;School ref=&quot;sch&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import School from &#x27;./components/School&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;School&#125;, methods: &#123; showDOM()&#123; console.log(this.$refs.btn) //真实DOM元素 console.log(this.$refs.sch) //School组件的实例对象（vc） &#125; &#125; &#125;&lt;/script&gt; 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素 应用在组件标签上是组件实例对象（vc） props配置项父组件想给子组件传数据，即可通过props配置项来实现 Student.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, //简单声明接收 props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;] &#125;&lt;/script&gt; 使用该组件 1&lt;School name=&#x27;zs&#x27; age=18 sex=&#x27;男&#x27;/&gt; 我们来观察一下props接收到的数据放在了哪里 可以看到，使用props接收到的数据都被放在了vc对象上 我们还发现_data中并没有这些数据 props接收的数据不可修改 1&lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt; 12345methods: &#123; updateAge()&#123; this.age++ &#125;&#125; 如果一定想修改，则需要使用data配置一下数据做个中转 并且展示的时候也使用data中中转的那个变量 1&lt;h2&gt;学生年龄：&#123;&#123;myAge&#125;&#125;&lt;/h2&gt; 12345data()&#123; return &#123; myAge: this.age &#125;&#125; 接收的同时对数据进行类型限制 如果要对类型做限制，需要通过以下写法 12345props:&#123; name:String, age:Number, sex:String&#125; 传入数据 1&lt;Student name=&quot;芝麻&quot; :age=&quot;19&quot; sex=&quot;男&quot;/&gt; 如果是这样传入的 1&lt;Student name=&quot;芝麻&quot; age=&quot;19&quot; sex=&quot;男&quot;/&gt; 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制 1234567891011121314props:&#123; name:&#123; type:String, //name的类型是字符串 required:true, //必要的，父亲组件一定要传该数据 &#125;, age:&#123; type:Number, default:99 //默认值 &#125;, sex:&#123; type:String, required:true &#125;&#125; mixin混入就是子组件可以共享mixin中配置的配置项 达到全局共享的效果，达到复用的目的，减少代码重复性 混合文件就是我们在构造vc的时候传入的配置项 只不过单独将其拿了出来 1234567891011121314151617export const hooks = &#123; created()&#123; console.log(&#x27;数据代理、数据劫持已完成&#x27;) &#125;, mounted() &#123; console.log(&#x27;挂载完成！&#x27;) &#125;&#125;export const getData = &#123; data() &#123; return &#123; x:100, y:200 &#125; &#125;,&#125; 全局混入（全局配置）：Vue.mixin(xxx) 局部混入（配置项）：mixin: [&#39;aaa&#39;] 注意点： 123451、钩子以外的配置项 如果混合中有，则以配置项中优先级高 如果混合中没有，则整合进配置项中2、将两者的生命周期组合在一起 先执行自己的钩子，然后执行mixin中的钩子 插件我们在平时生活工作中，一款好用的插件可以极大地提高我们的生产效率，在Vue中也有这样的插件 我们来定义一个插件试一试 123456789101112131415161718192021222324252627282930313233export default &#123; //...代表使用插件的时候传入的参数 install(Vue,...)&#123; //全局过滤器 Vue.filter(&#x27;filterName&#x27;,function(value)&#123; return ... &#125;) //定义全局指令 Vue.directive(&#x27;directiveName&#x27;,&#123; //指令与元素成功绑定时 bind(element,binding)&#123; //... &#125;, //指令所在元素被插入页面时 inserted(element,binding)&#123; //... &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; //... &#125; &#125;) //定义混入 Vue.mixin(&#123; //... &#125;) //给Vue原型上添加一个方法（vm和vc就都能用了） Vue.prototype.hello = ()=&gt;&#123;alert(&#x27;你好啊&#x27;)&#125; &#125;&#125; 在main.js中使用 123import plugins from &#x27;./plugins&#x27;Vue.use(plugins) style标签scoped属性1234&lt;style scoped&gt;在这个里面写的css样式只会作用于该文件的结构 如果不加scoped则会作用于所有符合条件的html结构&lt;/style&gt; lang属性12345&lt;style scoped lang=&quot;scss&quot;&gt; 如果你想使用Less或者Scss来写css则需要下载编译工具 npm i less-loader npm i scss-loader&lt;/style&gt; Todos案例 提前声明：此案例会循序渐进地讲到很多知识点，请务必不要跳过 静态页面代码App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot;&gt; &lt;/div&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;敲代码&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;睡觉&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;todo&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;吃饭&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot;&gt;&lt;span&gt;已经完成0/全部3&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; &#125; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;.todos &#123; list-style: none; padding: 0; border: 1px solid #ccc;&#125;.todo &#123; height: 50px; padding: 0 0 0 20px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: space-between;&#125;.task &#123; width: 100%; height: 40px; padding-left: 20px; box-sizing: border-box&#125;.container &#123; border: 1px solid black; padding: 10px; width: 30%; margin: 40px auto&#125;.buttons &#123; margin-right: 20px; width: 20%; display: none; justify-content: space-between;&#125;.todo:hover .buttons &#123; display: flex;&#125;.todo:hover &#123; background: #4dd9d5;&#125;.delete &#123; background: red; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;.update &#123; background: #2e6da4; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;&lt;/style&gt; 动态数据现在将数据放到data中，再补充一点逻辑吧 接下来就不写style标签啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot; @keydown.enter=&quot;insertNewTask&quot;&gt; &lt;/div&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt; &lt;span&gt;&#123;&#123; todo.content &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot;&gt;&lt;span&gt;已经完成&#123;&#123;hasDone&#125;&#125;/全部&#123;&#123;totalSum&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data()&#123; return &#123; task: &#x27;&#x27;, todos: [ &#123;id: &#x27;002&#x27;,content: &#x27;睡觉&#x27;,done: true&#125;, &#123;id: &#x27;001&#x27;,content: &#x27;打代码&#x27;,done: true&#125;, &#123;id: &#x27;003&#x27;,content: &#x27;吃饭&#x27;,done: false&#125;, &#123;id: &#x27;004&#x27;,content: &#x27;刷抖音&#x27;,done: true&#125;, ], hasDone: 0, &#125; &#125;, mounted() &#123; this.hasDone = this.todos.filter(t=&gt;t.done).length; &#125;, methods:&#123; deleteSelf(id)&#123; &#125;, updateSelf(id)&#123; &#125;, insertNewTask()&#123; &#125; &#125;, computed: &#123; totalSum()&#123; return this.todos.length; &#125; &#125;&#125;&lt;/script&gt; 抽离组件App作为王者居然写了这么多结构代码，哪里有什么组件化的思想，所以我们抽离出一个个组件 Top.vue 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;h2 style=&quot;text-align: center&quot;&gt;Todos&lt;/h2&gt; &lt;input class=&quot;task&quot; type=&quot;text&quot; placeholder=&quot;请输入待办事项，回车确认添加&quot; v-model=&quot;task&quot; @keydown.enter=&quot;insertNewTask&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Top&quot;, data()&#123; return &#123; task: &#x27;&#x27;, &#125; &#125;, methods:&#123; insertNewTask()&#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.task &#123; width: 100%; height: 40px; padding-left: 20px; box-sizing: border-box&#125;&lt;/style&gt; ShowTodosContainer.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;ul class=&quot;todos&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot; @click=&quot;choose(todo.id)&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt; &lt;span&gt;&#123;&#123; todo.content &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;delete&quot; @click=&quot;deleteSelf(todo.id)&quot;&gt;删除&lt;/button&gt; &lt;button class=&quot;update&quot; @click=&quot;updateSelf(todo.id)&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ShowTodosContainer&quot;, props: [&#x27;todos&#x27;], data()&#123; return &#123; todos: this.todos &#125; &#125;, methods:&#123; deleteSelf(id)&#123; &#125;, updateSelf(id)&#123; &#125;, choose(id)&#123; this.todos.forEach(t=&gt;&#123; if(t.id===id)&#123; t.done=!t.done; &#125; &#125;) &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.todos &#123; list-style: none; padding: 0; border: 1px solid #ccc;&#125;.todo &#123; height: 50px; padding: 0 0 0 20px; border-bottom: 1px solid #ccc; display: flex; align-items: center; justify-content: space-between;&#125;.buttons &#123; margin-right: 20px; width: 20%; display: none; justify-content: space-between;&#125;.todo:hover .buttons &#123; display: flex;&#125;.todo:hover &#123; background: #4dd9d5;&#125;.delete &#123; background: red; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;.update &#123; background: #2e6da4; color: #CCCCCC; font-size: 10px; cursor: pointer;&#125;&lt;/style&gt; 这里补充一个知识点 123456对于&lt;input type=&quot;checkbox&quot;&gt;1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 PageFooter.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;footer&quot;&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot; v-model=&quot;allHasDone&quot;&gt; &lt;span&gt;已经完成&#123;&#123;hasDone&#125;&#125;/全部&#123;&#123;totalSum&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button class=&quot;deleteAll&quot; @click=&quot;deleteAllTodos&quot;&gt; 删除所有代办 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;PageFooter&quot;, props: [&#x27;todos&#x27;], data()&#123; return &#123; allHasDone: false &#125; &#125;, computed: &#123; totalSum()&#123; return this.todos.length; &#125;, hasDone()&#123; let length = this.todos.filter(t=&gt;t.done).length; this.allHasDone = length === this.todos.length; return length; &#125;, &#125;, methods: &#123; deleteAllTodos()&#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.footer &#123; display: flex; justify-content: space-between;&#125;.deleteAll &#123; background: red; height: 30px; width: 200px; cursor:pointer; color: #4dd9d5&#125;&lt;/style&gt; 实现所有功能插入新代办1234567891011insertNewTask()&#123; if(this.task === &#x27;&#x27;)&#123; return alert(&#x27;请不要输入空的代办！&#x27;) &#125; this.todos.push(&#123; id:nanoid(), content: this.task, hasDone: false &#125;) this.task=&#x27;&#x27;&#125; 删除单个代办123deleteSelf(id)&#123; this.todoList.splice(0,this.todoList.length,...this.todoList.filter(t=&gt;t.id!==id));&#125;, 删除所有代办123deleteAllTodos()&#123; this.todoList.splice(0,this.totalSum,...this.todoList.filter(t=&gt;!t.done))&#125; 勾选1&lt;input type=&quot;checkbox&quot; style=&quot;margin-right: 10px&quot; v-model=&quot;allHasDone&quot; @click=&quot;chooseAll&quot;&gt; 123chooseAll()&#123; this.todoList.forEach(t=&gt;t.done=!this.allHasDone);&#125; 注意点：先处理点击事件，然后数据才更新，所以要取反 更新代办这个有点麻烦，需要再添加一个组件，使用动态样式来控制其显示 UpdateDialog.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=&quot;dialog&quot;:class=&quot;&#123;&#x27;clear&#x27;:showDialog&#125;&quot; @click.self=&quot;close&quot;&gt; &lt;div class=&quot;form&quot;&gt; &lt;h2&gt;请修改代办&lt;/h2&gt; &lt;span class=&quot;close&quot; @click=&quot;close&quot;&gt;X&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;updatedTaskContent&quot;&gt; &lt;button style=&quot;margin-right: 20px&quot; @click=&quot;updateTask&quot;&gt; 修改 &lt;/button&gt; &lt;button @click=&quot;close&quot;&gt; 取消 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;UpdateDialog&quot;, props: [&#x27;task&#x27;,&#x27;showDialog&#x27;], data()&#123; return &#123; updatedTaskContent: this.task.content, propTask: this.task &#125; &#125;, methods:&#123; close()&#123; this.$emit(&#x27;closeDialog&#x27;) &#125;, updateTask()&#123; this.propTask.content=this.updatedTaskContent &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.dialog &#123; position: absolute; display: none; top: 0px; bottom: 0; left: 0px; right: 0px; background: rgba(0,0,0,0.2);&#125;input &#123; width: 400px; margin-bottom: 20px;&#125;.form &#123; position: relative; width: 30%; height: 300px; margin: 40px auto; background: beige; padding: 20px;&#125;.close &#123; display: block; position: absolute; top: -10px; right: 0px; cursor: pointer;&#125;.clear &#123; display: block;&#125;&lt;/style&gt; 这里使用的自定义事件 我在使用该组件的时候传入一个函数，然后组件内部就可以使用this.$emit(&#39;自定义事件名&#39;)来调用该事件 1&lt;UpdateDialog :showDialog=&quot;showUpdateDialog&quot; :task=&quot;choosedTask&quot; @closeDialog=&quot;closeDialog&quot;/&gt; 这个如果这样写会产生一个问题，就是我的task确实是动态传的，但是因为我可能会取消本次更新操作 所以我不可以这样写，这样写的话，取消按钮就是一个小丑 1&lt;input type=&quot;text&quot; v-model=&quot;task.content&quot;&gt; 所以就必须得先存一份传入的值是吧，所以就应该像我刚刚那么写 但是你会发现还是有问题，检查之后发现是我存储的数据是固定在第一次传入的数据，可是我什么时候改变data中的数据呢？ 监视属性我们监视一下task，当其发生了改变，将其覆盖data中的数据 123456watch:&#123; task()&#123; this.updatedTaskContent=this.task.content; this.propTask = this.task; &#125;&#125; 使用v-if配合使用1234&lt;UpdateDialog v-if=&quot;JSON.stringify(choosedTask)!==&#x27;&#123;&#125;&#x27;&quot; :showDialog=&quot;showUpdateDialog&quot; :task=&quot;choosedTask&quot; @closeDialog=&quot;closeDialog&quot;/&gt; 如果使用这种方法的话，我在closeDialog中需要将choosedTask赋值为空对象 自动获取焦点1&lt;input ref=&quot;input&quot; type=&quot;text&quot; v-model=&quot;updatedTaskContent&quot; @keyup.enter=&quot;updateTask&quot;&gt; 如果是监视属性实现的话 需要在监视方法中加入以下逻辑 12345678task()&#123; this.updatedTaskContent=this.task.content; this.propTask = this.task; //当页面解析完成之后再执行回调函数 this.$nextTick(function ()&#123; this.$refs.input.focus(); &#125;)&#125; 如果是v-if实现的话 需要再挂载的时候加入以下逻辑 123456mounted() &#123; this.$nextTick(function ()&#123; console.log(this); this.$refs.input.focus(); &#125;)&#125;, 存储在App中封装一个save函数，将其传递给子组件，在所有对数组造成更新的地方都使用this.$emit(&#39;save&#39;)调用该函数 123save()&#123; sessionStorage.setItem(&quot;todos&quot;,JSON.stringify(this.todos))&#125; 自定义事件 这个是相对于js中内置事件（keyup、click等等）的存在 js内置事件是给HTML元素使用的 自定义事件是给组件用的 主要作用就是实现父子组件之间的通信 绑定事件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt;&lt;div class=&quot;app&quot;&gt; &lt;h1&gt;学生姓名是:&#123;&#123;studentName&#125;&#125;&lt;/h1&gt; &lt;!-- 通过父组件给子组件传递函数类型的props实现：子给父传递数据 --&gt; &lt;Teacher :getSchoolName=&quot;getSchoolName&quot;/&gt; &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据 --&gt; &lt;Student @getStudentName=&quot;getStudentName&quot;/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Student from &#x27;./components/Student&#x27; import School from &#x27;./components/School&#x27; export default &#123; name:&#x27;App&#x27;, components:&#123;School,Student&#125;, data() &#123; return &#123; studentName:&#x27;&#x27; &#125; &#125;, methods: &#123; getTeacherName(name)&#123; console.log(&#x27;App收到了学校名：&#x27;,name) &#125;, getStudentName(name)&#123; console.log(&#x27;App收到了学生名：&#x27;,name) this.studentName = name &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .app&#123; background-color: gray; padding: 5px; &#125;&lt;/style&gt; 绑定事件的另一种方式 123mount()&#123; this.$refs.student.$on(&#x27;getStudentName&#x27;,this.getStudentName) //绑定自定义事件 &#125; 触发事件School.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;school&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendSchoolName&quot;&gt;把学校名给App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;School&#x27;, props:[&#x27;getSchoolName&#x27;], data() &#123; return &#123; name:&#x27;尚硅谷&#x27;, address:&#x27;北京&#x27;, &#125; &#125;, methods: &#123; sendSchoolName()&#123; this.getSchoolName(this.name) &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .school&#123; background-color: skyblue; padding: 5px; &#125;&lt;/style&gt; Student.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;student&quot;&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, data() &#123; return &#123; name:&#x27;张三&#x27;, sex:&#x27;男&#x27;, &#125; &#125;, methods: &#123; sendStudentlName()&#123; //触发Student组件实例身上的getStudentName事件 this.$emit(&#x27;getStudentName&#x27;,this.name) &#125; &#125;, &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; .student&#123; background-color: pink; padding: 5px; margin-top: 30px; &#125;&lt;/style&gt; 自定义事件的触发本质还是由html的原生事件触发后，我们自己决定触发哪一个自定义事件的 props实现和自定义事件实现的区别：props需要手动接收 解绑事件1this.$off(&#x27;getStudentName&#x27;) //解绑一个自定义事件 组件使用js原生事件1&lt;Student ref=&quot;student&quot; @click.native=&quot;show&quot;/&gt; 组件间通信我们发现，组件之间的通信十分地重要，我们来理一理到现在我们学会了那些组件之间通信的方法， 1231.props ===》适用于父给子传递数据和函数 ===》特点：需要手动接收，并且传递地如果是数据则不能修改2.自定义事件 ===》适用于子给父传递数据 ===》特点：使用$emit调用 我们发现如果两个兄弟之间想要通信 则只能将数据状态提升 将数据放到两者共同地父组件上面去 然后父组件使用上述方法向两者传递信息 如果嵌套层级比较多，则需要多次多层传递数据，会比较麻烦 难道就只能这样了吗？NO！接下来我会讲解三种强大的方法实现任意组件之间的通信 全局事件总线全局事件总线其实十分简单，就是使用自定义事件来实现的 只不过我们事件全部绑定在vm对象上 安装全局事件总线12345678//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), beforeCreate() &#123; Vue.prototype.$bus = this //安装全局事件总线 &#125;,&#125;) 不是一定要叫$bus 绑定事件123this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123; console.log(&#x27;我是School组件，收到了数据&#x27;,data)&#125;) 触发事件1this.$bus.$emit(&#x27;hello&#x27;,this.name) 解绑事件在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。 123beforeDestroy() &#123; this.$bus.$off(&#x27;hello&#x27;)&#125; 原理：1、自定义事件 2、VueComponent.prototype.__proto__ === Vue.prototype 消息订阅与发布消息发布与订阅是一种思想，具体实现有很多种，我们这里选用pubsub-js库 1npm i pubsub-js 订阅和取消订阅消息即设置事件和回调 即需要数据的组件 123456789mounted() &#123; this.pubId = pubsub.subscribe(&#x27;hello&#x27;,(msgName,data)=&gt;&#123; console.log(this) // console.log(&#x27;有人发布了hello消息，hello消息的回调执行了&#x27;,msgName,data) &#125;)&#125;,beforeDestroy() &#123; pubsub.unsubscribe(this.pubId)&#125;, 发布消息即发送数据的组件 1pubsub.publish(&#x27;hello&#x27;,666) Vuex它是专门在Vue中实现集中式状态管理的一个插件，对Vue应用中多个组件的共享状态进行集中式的管理，也是一种任意组件间通信的方式 状态其实指的就是数据 x是所有组件都需要使用的，所以我们将x存入Vuex中 Vuex原理图 此图摘自官网 我们可以看到该图被虚线包起来的部分即Vuex的三大重要的工具，Actions，Mutations，State State译为状态，我们将需要共享的数据放入其中 Actions译为行为，我们会将对于数据的前置操作放入其中，比如条件判断，发出Ajax请求等 Mutations译为加工，我们真正对于数据的修改就是在这里进行的 Vue组件和Vuex工具之间的通信，有以下API，dispatch，commit，mutate，render 只有dispatch和commit是我们手动调用的，其他两个都是由Vuex帮我们调用的，无需我们操心 dispatch是我们在组件内调用的，发出对数据操作的请求 commit是我们在actions或者Vue组件中调用的，让其对数据做出真正的改变 接下来我们直接使用案例来驱动 求和案例效果图 我们先将这个功能实现 因为还没有到组件共享的时候，所以现在先不使用Vuex 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; &lt;h2&gt;当前求和为&#123;&#123;sum&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;select name=&quot;step&quot; id=&quot;stepSelect&quot; v-model=&quot;step&quot;&gt; &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;addOnCondition&quot;&gt;当前为奇数再加&lt;/button&gt; &lt;button @click=&quot;addAfter&quot;&gt;过一秒再加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Count&quot;, data()&#123; return &#123; sum: 0, step: 1 &#125; &#125;, methods:&#123; add()&#123; this.sum+=this.step; &#125;, sub()&#123; this.sum-=this.step; &#125;, addOnCondition()&#123; if(this.sum % 2)&#123; this.add(); &#125; &#125;, addAfter()&#123; setTimeout(()=&gt;&#123; this.add(); &#125;,1000); &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;button &#123; margin-left: 10px;&#125;&lt;/style&gt; 准备接下来我们做些使用Vuex前的准备 创建store/index.js文件 123456789101112131415import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; &#125;, mutations:&#123; &#125;, state:&#123; &#125;,&#125;) 在main.js中引入该文件并并在创建vm的时候传入 123456789import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &quot;./store&quot;;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App), store&#125;).$mount(&#x27;#app&#x27;) 使用接下来我们新建一个组件ShowSum组件，该组件的功能就是用来展示Count组件中的sum，现在我们就使用Vuex来实现此功能 先将数据都交给Vuex管理 Count.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; &lt;h2&gt;当前求和为&#123;&#123;$store.state.sum&#125;&#125;&lt;/h2&gt; &lt;div&gt; &lt;select name=&quot;step&quot; id=&quot;stepSelect&quot; v-model=&quot;step&quot;&gt; &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;sub&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;addOnCondition&quot;&gt;当前为奇数再加&lt;/button&gt; &lt;button @click=&quot;addAfter&quot;&gt;过一秒再加&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Count&quot;, data()&#123; return &#123; step: 1 &#125; &#125;, methods:&#123; add()&#123; this.$store.dispatch(&#x27;add&#x27;,this.step); &#125;, sub()&#123; this.$store.dispatch(&#x27;sub&#x27;,this.step) &#125;, addOnCondition()&#123; this.$store.dispatch(&#x27;addOnCondition&#x27;,this.step) &#125;, addAfter()&#123; this.$store.dispatch(&#x27;addAfter&#x27;,this.step) &#125;, &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;button &#123; margin-left: 10px;&#125;&lt;/style&gt; store/index.js 1234567891011121314151617181920212223242526272829303132333435import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; add(context,value)&#123; context.commit(&#x27;INCREASE&#x27;,value); &#125;, sub(context,value)&#123; context.commit(&#x27;DECREASE&#x27;,value) &#125;, addOnCondition(context,value)&#123; if(value%2!==0)&#123; context.commit(&#x27;INCREASE&#x27;,value) &#125; &#125;, addAfter(context,value)&#123; setTimeout(()=&gt;&#123; context.commit(&#x27;INCREASE&#x27;,value) &#125;,1000); &#125;, &#125;, mutations:&#123; INCREASE(state,value)&#123; state.sum+=value; &#125;, DECREASE(state,value)&#123; state.sum-=value; &#125; &#125;, state:&#123; sum: 0, &#125;,&#125;) ShowSum.vue 1234567891011&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; Count组件的sum值是：&#123;&#123;$store.state.sum&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ShowSum&quot;&#125;&lt;/script&gt; 当我们想要拿到state中的数据的时候，需要使用$store.state.xxx，十分麻烦，所以Vuex就为我们提供了工具mapState 1234567891011121314151617&lt;template&gt;&lt;div style=&quot;padding: 20px&quot;&gt; Count组件的sum值是：&#123;&#123;sum&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from &quot;vuex&quot;;export default &#123; name: &quot;ShowSum&quot;, computed:&#123; ...mapState([&#x27;sum&#x27;]) &#125;&#125;&lt;/script&gt; 拓展1、getters的使用 getters我们可以理解为计算属性，就是将state中的数据加工后返回给用户 1234567891011121314151617181920import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; actions: &#123; &#125;, mutations:&#123; &#125;, getters:&#123; bigSum(state)&#123; return state.sum*10 &#125; &#125;, state:&#123; &#125;,&#125;) 2、mapGetters，mapActions，mapMutations工具 我们对于state中的数据可以使用mapState来将其方便地从Vuex中拿出来 对于getters、actions、mutations中的方法和数据我们也有对应的工具将其从Vuex中拿出 3、模块化开发 如果数据还有分类，我们就可以使用模块化开发 store/index.js 1234567891011121314151617181920212223import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)import teacher from &quot;@/store/roles/teacher&quot;;import student from &quot;@/store/roles/student&quot;;import enterprise from &quot;@/store/roles/enterprise&quot;;import log from &#x27;@/store/log&#x27;import constant from &quot;@/store/constant&quot;;import common from &quot;@/store/common&quot;;const store = new Vuex.Store(&#123; modules: &#123; log, constant, common, teacher, student, enterprise &#125;&#125;)export default store; 使用模块化开发要注意一个点，就是在各个文件中需要开启命名空间 采用模块化开发使用后，mapXXX工具的使用方法就发生了改变，改变如下 1234...mapState(&#x27;模块名&#x27;,[&#x27;state参数名&#x27;]),...mapGetters(&#x27;模块名&#x27;,[&#x27;getters参数名&#x27;]),...mapActions(&#x27;模块名&#x27;,[&#x27;actions函数名&#x27;]),...mapMutations(&#x27;模块名&#x27;,[&#x27;mutations函数名&#x27;]),","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础3","slug":"Vue2-基础3","date":"2022-06-22T07:53:57.000Z","updated":"2022-07-09T10:08:49.344Z","comments":true,"path":"前端/Vue2/2022/06/22/Vue2-基础3/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/22/Vue2-%E5%9F%BA%E7%A1%803/","excerpt":"","text":"Vue2基础3条件渲染 案例：如图 使用v-if12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;span&gt;现在的n值是&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;n++&quot;&gt;点我n自增1&lt;/button&gt;&lt;br&gt; &lt;button @click=&quot;n--&quot;&gt;点我n自减1&lt;/button&gt;&lt;br&gt; &lt;div v-if=&quot;n&lt;3&quot;&gt;我在n小于3的时候出现&lt;/div&gt; &lt;div v-else-if=&quot;n&lt;7&quot;&gt;我在n大于3小于7的时候出现&lt;/div&gt; &lt;div v-else&gt;我在n&gt;7的时候显示&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; n: 0 &#125; &#125; &#125;)&lt;/script&gt; 使用v-show123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;span&gt;现在的n值是&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;n++&quot;&gt;点我n自增1&lt;/button&gt;&lt;br&gt; &lt;button @click=&quot;n--&quot;&gt;点我n自减1&lt;/button&gt;&lt;br&gt; &lt;div v-show=&quot;n&lt;3&quot;&gt;我在n小于3的时候出现&lt;/div&gt; &lt;div v-show=&quot;n&gt;=3&quot;&gt;我在n大于3的时候出现&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; n: 0 &#125; &#125; &#125;)&lt;/script&gt; 区别12341. v-show的原理是将被此指令标记的DOM元素的display属性设置为none，从而实现隐藏的效果 v-if的原理是直接将此DOM元素直接从DOM树中删除2. 如果这个元素会频繁切换显示隐藏，则使用v-show，不需要频繁创建节点 如果这个元素不会频繁切换显示隐藏，只是在初始化的时候进行判断显示隐藏，则使用v-if 列表渲染 案例：将数组数据展示在页面上 123456789data()&#123; return &#123; people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125; ] &#125;&#125; 使用v-for指令 12345&lt;ul&gt; &lt;li v-for=&quot;item in people&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 这样就完成了最基本的遍历，如果我需要得到每一次遍历的索引，只需要加入一个形参即可 12345&lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; OK，这里其实遗漏了一个很重要很重要的一个属性key，这个key就是每一个节点的标识，所以可以直接使用数组每一个对象的id属性，或者是index 123456&lt;ul&gt; &lt;!--&lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt;--&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 这个key是干嘛的呢？这就要好好扒一扒了，来吧，整活！ 虚拟DOM的DIFF算法啥啊这是，怎么从key直接跳到了什么虚拟DOM的DIFF算法了？走错片场了？ 没有没有，要解释key就要先知道这个知识 现在的代码，很简单，就是比刚刚多了一个添加一个人的按钮和一个input框 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;button @click.once=&quot;addPerson&quot;&gt;添加一个人&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125;&lt;input type=&quot;text&quot; v-model=&quot;item.name&quot;&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125; ] &#125; &#125;, methods: &#123; addPerson()&#123; this.people.unshift(&#123;id: &#x27;002&#x27;,name: &#x27;小马&#x27;,age: 21,sex: &#x27;男&#x27;&#125;) &#125; &#125; &#125;)&lt;/script&gt; 说明问题 然后点击添加一个人，你会发现一个很严重的错误，输入塌陷 加入:key=&quot;index&quot;之后，一样出现这个错误 加入:key=&quot;item.id&quot;之后，我们发现，这个错误就消失了 既然意识到了错误和解决错误的方法，那我们就来好好捋一下为什么，下面看图，图有点乱，请仔细观看 key为index的情况 解释几个点吧： 1、粉色的×表示匹配失败，不可以复用，蓝色的√表示匹配成功，可以复用 2、左下角的橙色的删除号表示该元素直接删除 3、下半部分的橙色箭头表示直接复用之前生成的真实DOM节点 4、左半部分的绿色箭头表示需要从虚拟节点重新生成真实DOM节点 key为id的情况 key不写的情况如果不写key的话，Vue默认将index作为key，所以这种情况和key为index的情况是一样的 总结123456789101112131、key的作用 作为每一个DOM虚拟节点的唯一性标识，当数据发生改变的时 在Diff算法时，新虚拟DOM节点找到与自身key相同的旧虚拟DOM节点进行比较 如果相同，则直接将旧虚拟DOM节点生成的真实DOM节点直接拿来复用 如果不同，则将新虚拟DOM节点生成新真实DOM节点2、用index做key会出现的问题 (1)如果出现了对顺序改变的操作，则会导致旧真实DOM无法复用，效率降低 (2)如果有输入类控件，则会出现输入塌陷的问题3、如何设置key (1)如果只是展示，不会产生逆序插入，逆序删除等会影响顺序的情况，则使用index即可 (2)如果会对顺序造成影响，则不能使用index作为key，而是需要使用唯一性标识 列表过滤 需求：输入姓关键词，回车出现名字中带有该关键词的 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;请输入姓关键词&quot; @keyup.enter=&quot;filterData&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in people&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125;-&#123;&#123;item.sex&#125;&#125;&lt;input type=&quot;text&quot;&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; keyword: &#x27;&#x27;, people: [ &#123;id: &#x27;001&#x27;,name: &#x27;张三&#x27;,age: 18,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;002&#x27;,name: &#x27;芝麻&#x27;,age: 20,sex: &#x27;男&#x27;&#125;, &#123;id: &#x27;003&#x27;,name: &#x27;李四&#x27;,age: 17,sex: &#x27;女&#x27;&#125;, ], showData: people &#125; &#125;, methods: &#123; filterData()&#123; this.showData = this.people.filter(p=&gt;p.name.indexOf(this.keyword)!==-1); &#125; &#125; &#125;)&lt;/script&gt; 列表排序1234567&lt;button @click=&quot;sortByAge&quot;&gt;按年龄排序&lt;/button&gt;methods: &#123; sortByAge()&#123; this.showData = this.people.sort((p1,p2)=&gt;p2.age-p1.age); &#125;&#125; 修改列表第一个人的信息(奏效)12345678&lt;button @click=&quot;updatePerson&quot;&gt;修改第一个人的年龄为20&lt;/button&gt;methods: &#123; updatePerson()&#123; this.people[0].age = 20; this.showData = this.people; &#125;&#125; 彻底修改列表一个人的信息(失效)123456&lt;button @click=&quot;updatePersonComplete&quot;&gt;彻底修改一个人的信息&lt;/button&gt;updatePersonComplete()&#123; this.people[0] = &#123;id: &#x27;004&#x27;,name: &#x27;老马&#x27;,age: 18,sex: &#x27;女&#x27;&#125;; this.showData = this.people;&#125; 为什么这种方式修改数据，Vue没有检测到呢？ 这就要讲到Vue监测数据变化(响应式)的原理了 响应式原理之前我在讲数据代理的时候，其实已经讲到了Vue响应式的原理，现在我们来正式给小伙伴讲一讲 Vue监测数据分为两种，一种是数组，还有一种是对象。我们先从监测对象开始，然后再讲监测数组。 监测对象前期准备 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;div&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/div&gt; &lt;div&gt;学校：&#123;&#123;school&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let data = &#123; name: &#x27;zhima&#x27;, sex: &#x27;男&#x27;, age: 19, hobbies: [&#x27;王者&#x27;,&#x27;原神&#x27;,&#x27;睡觉&#x27;,&#x27;干饭&#x27;], school: &#123; name: &#x27;南京某高校&#x27;, address: &#x27;南京&#x27; &#125; &#125; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data &#125;);&lt;/script&gt; 我们先来回顾一下数据代理是什么 先输出一下vm对象 我们在data中配置的对象先经过Vue加工变成Observer对象 然后将其放到vm对象上的_data属性中 然后将_data中的数据全部代理到vm对象上 让我们可以直接使用&#123;&#123;&#125;&#125;读取vm身上的属性 这就是数据代理 我们修改了vm身上的属性实际上修改的是_data中的数据 , 然后页面就更新成了修改后的新的数据 或者直接修改_data中的数据,页面也会更新为修改后的数据 这样看来,响应式数据的原理是在_data中.还记得我之前提到的数据劫持吗? Vue的响应式就是通过数据劫持来实现的,而数据劫持又是通过Object.defineProperty实现的,_data的每一个属性都有一个setter函数,当_data中任何一个数据 发生了改变,都会走这个setter方法,那么在这个时候,我就可以执行一遍重新渲染页面的方法,从而使得页面数据更新 监测数组我们先来观察一下_data中的hobbies数组的样子,我们发现它没有给每一个元素设置一个getter&#x2F;setter,那它是怎么实现响应式的呢 这里就不绕弯了 Vue里面对于数组的监测是 通过包装数组方法,先对页面进行更新,然后再调用原生的数组上的方法对数组进行更改 有以下这几种 push() pop() shift() unshift() splice() sort() reverse() Vue中的push不是原生的push 所以只有当你使用以上这些方法的时候,Vue才会监测到,然后对页面进行更新,这就解释了先前的那个案例,直接将数组第一个元素替换的时候,Vue并没有监测到. 但如果数组元素是对象,它一样还是会有getter&#x2F;setter 过滤器功能：先将数据作出处理再将数据进行显示 案例：显示格式化后的时间 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;div&gt; 时间戳：&#123;&#123;nowTime&#125;&#125; &lt;/div&gt; &lt;div&gt; 计算属性格式化后的时间是：&#123;&#123;fmtTime&#125;&#125; &lt;/div&gt; &lt;div&gt; 方法格式化后的时间是:&#123;&#123;getFmtTime()&#125;&#125; &lt;/div&gt; &lt;div&gt; 过滤器格式化后的时间：&#123;&#123;nowTime | timeFormatter&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; nowTime: Date.now() &#125; &#125;, computed:&#123; fmtTime() &#123; return dayjs(this.nowTime).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;); &#125; &#125;, methods: &#123; getFmtTime(value) &#123; return dayjs(value).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;); &#125; &#125;, filters:&#123; timeFormatter(value)&#123; return dayjs(value).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 以上这个过滤器叫局部过滤器，还有一种过滤器，叫全局过滤器 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;!--这里的过滤器第一个传入的参数永远是待处理的数据，这里传入的就直接是第二个参数第三个第四个参数--&gt; 过滤器格式化后的时间：&#123;&#123;nowTime | globalTimeFormatter(&#x27;YYYY-MM-DD&#x27;)&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //全局过滤器 Vue.filter(&#x27;globalTimeFormatter&#x27;,(value,formatStr=&#x27;YYYY-MM-DD HH:mm:ss&#x27;)=&gt;&#123; return dayjs(value).format(formatStr); &#125;)&lt;/script&gt; 注意点：过滤器不是必要的，因为我们使用计算属性或者方法都可以实现，这只是一种方式 自定义指令 指令是什么？ 指令就是v-on开头的一些语法，就是自己封装一些逻辑 需求1：定义一个v-big指令，会把绑定的数值放大10倍。 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt; &lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data() &#123; return &#123; n: 1 &#125; &#125;, directives:&#123; // big函数何时会被调用？ // 1.指令与元素成功绑定时。 // 2.指令所在的模板被重新解析时。 big(element,binding)&#123; console.log(&#x27;big&#x27;,this) //注意此处的this是window element.innerText = binding.value * 10 &#125; &#125; &#125;&lt;/script&gt; 需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#root&#x27;, data() &#123; return &#123; n: 1 &#125; &#125;, directives:&#123; fbind:&#123; //指令与元素成功绑定时（一上来） bind(element,binding)&#123; element.value = binding.value &#125;, //指令所在元素被插入页面时 inserted(element,binding)&#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; element.value = binding.value &#125; &#125; &#125; &#125;&lt;/script&gt; 这两个都是局部指令，我们来看看全局指令 123456789101112 Vue.directive(&#x27;fbind&#x27;,&#123; bind(element,binding)&#123; element.value = binding.value &#125;, inserted(element,binding)&#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding)&#123; element.value = binding.value &#125;&#125;) 注意点： 123指令定义时不加v-，但使用时要加v-；指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。 生命周期定义：Vue中每一个生命周期都对应着一个钩子（函数），当Vue走到该生命周期阶段的时候，就会自己调用该钩子。 黄色的标签是我加的注释，其他的流程都是从Vue官网查看的 最常用的就是mounted和destoryed 一般在mounted钩子中初始化数据（Ajax请求），在destoryed钩子中删除定时器，解绑自定义事件等收尾工作 组件 模块化的概念 如果所有的js代码都在一个文件中，那么后期维护和更新会非常吃力。所以就有了模块化的概念了，这里可以看看我之前写的JavaScript的模块化规范 组件的定义 用来实现局部功能效果的所有代码和资源的集合（HTML、CSS、JavaScript） 传统开发我们先来看看传统开发的结构 其存在的问题是 1、代码复用率不高 2、依赖关系混乱，后期难以维护 组件开发 我们来看看官网给我们的图 最上层的就是vm对象，它管理所有的组件对象 在Vue中有两种使用组件化开发的思路 1、非单文件组件 2、单文件组件 非单文件组件定义组件123456789101112const hello = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return &#123; name:&#x27;Tom&#x27; &#125; &#125;&#125;) 这里的data配置项我们说过可以写成两种形式 1、函数式 2、对象式 到了组件开发，这个data配置项就必须是函数式 避免组件被复用时，数据存在引用关系。 注册组件 局部注册 1234567new Vue(&#123; el:&#x27;#app&#x27;, //第二步：注册组件（局部注册） components:&#123; hello &#125;&#125;) 全局注册 1Vue.component(&#x27;hello&#x27;,hello) 使用组件123&lt;div id=&quot;app&quot;&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt; 注意点： 123456789101112131415161718192021222324252627282930313233343536373839401.关于组件名: 一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： (1)组件名尽可能回避HTML中已有的元素名称 (2)可以使用name配置项指定组件在开发者工具中呈现的名字2.关于组件标签: 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt;不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。3.关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。4.关于this指向： (1).组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。 (2).new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。6.Vc和Vm的区别 两者最大的差别就是vc没有el配置项，vc只能依附vm 其他的配置项可以说是一样的 7.重要的内置关系 函数上的prototype属性叫显示原型属性 对象上的__proto__属性叫隐式原型属性 两者指向的都是同一个原型对象 实例对象的隐式原型属性指向自己缔造者的原型对象 VueComponent.prototype.__proto__ === Vue.prototype 让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 单文件组件（脚手架）这里我们就可以使用脚手架（Vue CLI）啦！ CLI（Command Line Interface）命令行接口，我们就叫它脚手架 首先，你必须要有node和gitbash的环境 在gitbash的命令行中输入以下命令 12345678# 下载脚手架npm i @vue/cli -g# 创建Vue项目vue create 项目名# 启动Vue项目npm run serve 注意 如果你是在idea中的终端运行的vue create 项目名报了以下错误，有以下两种解决方案 1、以管理员身份打开idea 2、使用命令行到当前目录下使用该命令 这是正常启动成功的界面 脚手架的HelloWorld案例界面 观察项目结构 main.js12345678910// 引入Vueimport Vue from &#x27;vue&#x27;// 引入App根组件import App from &#x27;./App.vue&#x27;// 关闭生产提示Vue.config.productionTip = false// 创建vm对象new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 我们之前是这么写的 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; template: `&lt;App&gt;&lt;/App&gt;`, components: &#123;App&#125;&#125;).$mount(&#x27;#app&#x27;) 我们运行，发现报错了，报错如下 大概意思是脚手架使用的运行时版本的Vue，它没有模板解析器 你可以将模板放入render函数中，或者使用完整版的Vue 来解决问题 使用完整版Vue1import Vue from &#x27;vue/dist/vue&#x27; 发现不报错了，页面也正常显示了 使用render函数12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render(createElement)&#123; return createElement(App) &#125;&#125;).$mount(&#x27;#app&#x27;) 一个参数省略小括号 12345678910import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: createElement=&gt;&#123; return createElement(App) &#125;&#125;).$mount(&#x27;#app&#x27;) 直接写返回语句省略花括号和return 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: createElement =&gt; createElement(App)&#125;).$mount(&#x27;#app&#x27;) 换个参数名 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 为什么要使用残缺版的Vue呢？ 模板解析器占了Vuejs源码的1&#x2F;3的体积，为了减少打包后的体积，所以就将模板解析器删去，用更小的render函数来完成该任务 App.vue12345678910111213141516171819202122232425262728&lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import HelloWorld from &#x27;./components/HelloWorld.vue&#x27; export default &#123; name: &#x27;App&#x27;, components: &#123; HelloWorld &#125; &#125;&lt;/script&gt;&lt;style&gt; #app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125;&lt;/style&gt; 我们可以看到一个vue文件可以分为三部分 第一部分是用来写HTML结构的 第二部分是用来写JavaScript的 第三部分是用来写样式的 index.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--针对IE，让IE浏览器最高级别渲染页面--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;!--引入页面图标&lt;%= BASE_URL %&gt;可以拿到项目根路径，就是public文件夹--&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;!--设置网站名字，拿着package.json中配置的name作为网站名--&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--当网站不支持JavaScript的时候，显示noscript中的内容--&gt; &lt;noscript&gt; &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;!--容器--&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础2","slug":"Vue2-基础2","date":"2022-06-21T03:33:37.000Z","updated":"2022-07-09T10:08:43.822Z","comments":true,"path":"前端/Vue2/2022/06/21/Vue2-基础2/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/21/Vue2-%E5%9F%BA%E7%A1%802/","excerpt":"","text":"Vue2基础2事件处理v-on这里我们要接触一个全新的配置项methods和一个新的指令语法v-on，我们以需求为导向来学习这一节 需求一：点击按钮，控制台显示欢迎信息 HTML 123456&lt;div id=&quot;app&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;!--按钮绑定点击事件，回调函数是welcome--&gt; &lt;button v-on:click=&quot;welcome&quot;&gt;欢迎&lt;/button&gt;&lt;/div&gt; JavaScript 1234567891011121314new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; name: &#x27;kerwin&#x27;, msg: &#x27;坚持很难，但很酷&#x27; &#125; &#125;, methods:&#123; welcome()&#123; console.log(`Hello,$&#123;this.name&#125;`) &#125; &#125;&#125;) 这里有几个知识点 1、模板字符串 1被``包裹的字符串被叫做模板字符串，它的特点是，在其中可以使用$&#123;&#125;语法读取变量 2、methods中配置的函数，this指的应该是vm对象，这就对应着前面我说的一句话 所有被Vue管理的函数(不能是箭头函数)，其内部的this都是vm对象，所以可以使用this.xxx直接获取属性的值 3、观察vm对象，发现在methods中配置的函数，都出现在了vm身上 4、简写形式，常用 1&lt;button @click=&quot;welcome&quot;&gt;欢迎&lt;/button&gt; 需求二：点击按钮，提示当前鼠标位置 这就需要使用事件参数，其实在welcome方法的参数列表中，Vue默认为咱们传递了一个参数，只不过刚刚我们没有使用而已，我们接收打印一下看看 123welcome($event)&#123; console.log($event)&#125; 既然有了这个对象($event)，那我获取当前鼠标位置，只需要读取该对象的pageX属性和pageY属性即可 这里也可以不叫$event，叫它a啊b啊都可以，但是习惯起见，我就以$event来接收它了 需求3：我想将name传参进去，而不是使用this去读取 HTML 1&lt;button @click=&quot;welcome($event,name)&quot;&gt;欢迎&lt;/button&gt; JavaScript 123welcome($event,name)&#123; console.log(`Hello,$&#123;name&#125;`)&#125; 这里有个注意点，如果我在这里是这样写的&lt;button v-on:click=&quot;welcome(name)&quot;&gt;欢迎&lt;/button&gt; 那么welcome函数只有一个入参，那就是name，点击事件对象就没了 事件修饰符 需求1：点击一个a标签，然后提示弹窗，但是不跳转页面 HTML 123&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;https://baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我跳转百度&lt;/a&gt;&lt;/div&gt; JavaScript 12345678let vm = new Vue(&#123; el: &#x27;#app&#x27;, methods:&#123; showInfo()&#123; alert(&#x27;Hello&#x27;) &#125; &#125;&#125;); 这里面的prevent就是事件修饰符。 Vue为我们提供了6种事件修饰符，用的都不是很多，大家过个眼就行 事件修饰符 作用 prevent 阻止默认事件（常用） stop 阻止事件冒泡（常用） once 事件只触发一次（常用） capture 使用事件的捕获模式 self 只有event.target是当前操作的元素时才触发事件 passive 事件的默认行为立即执行，无需等待事件回调执行完毕 这里讲一下passive的作用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .list&#123; width: 200px; height: 200px; background-color: peru; overflow: auto; &#125; li&#123; height: 100px; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul @wheel.passive=&quot;bigWork&quot; class=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;!-- wheel事件 当鼠标滚轮滚动，则触发该事件，并且当滚动条到达边界后，滚动也会触发该事件 scroll事件 当滚动条滚动则触发该事件，滚动条到了边界后，再滚动就不会触发该事件了 --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#app&#x27;, methods:&#123; bigWork()&#123; for (let i = 0; i &lt; 100000; i++) &#123; console.log(&#x27;===&#x27;) &#125; console.log(&#x27;活终于干完了&#x27;) &#125; &#125; &#125;)&lt;/script&gt; 现在滚动鼠标滚轮的时候，滚动条就会卡住不动，当我加上passive后，即变正常。这是为什么呢？ 当触发滚轮事件后，先执行事件回调，然后再执行默认事件，如果任务量很大，则默认事件就会堆积，导致页面卡顿 但是当我换成scroll的时候，就算我不加passive修饰符，滚动条依旧正常。 passive在pc端用的很少，在移动端用的较多一点 键盘事件键盘事件最常用的就两个事件keydown和keyup 前者是当按键按下后触发，后者是当按键回弹起来后触发 案例1：输入文字，当按下回车控制台打印 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; v-on:keyup.enter=&quot;showInfo&quot;&gt; &lt;!-- 简写模式 &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; @keyup.enter=&quot;showInfo&quot;&gt; --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; msg: &#x27;&#x27; &#125; &#125;, methods:&#123; showInfo()&#123; console.log(`输入框中的句子是$&#123;this.msg&#125;`) &#125; &#125; &#125;);&lt;/script&gt; 总结： 12345678910111213141516171.Vue中常用的按键别名： 回车 =&gt; enter 删除 =&gt; delete、backspace (包括“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab (特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right2.系统修饰键（用法特殊）：ctrl、alt、shift、meta(win) (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 (2).配合keydown使用：正常触发事件。3.当按下Ctrl+y的时候，再触发事件&lt;input type=&quot;text&quot; v-model=&quot;msg&quot; @keyup.ctrl.y=&quot;showInfo&quot;&gt; 计算属性与监视 案例：根据输入的姓和名展示姓名 插值语法实现123456789101112131415161718&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;firstName&#125;&#125;-&#123;&#123;secondName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125; &#125;)&lt;/script&gt; methods实现123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;!--这里的方法必须加上小括号，不然读取的就是方法的源码--&gt; &lt;span&gt;全名：&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, methods:&#123; fullName()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125; &#125; &#125;)&lt;/script&gt; 这里需要注意一个点：当data中的数据发生了改变，就会重新解析模板，所以所有在插值语法中的函数都会再执行一遍 计算属性实现全写1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, computed:&#123; fullName: &#123; get()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125;, set(value)&#123; const arr = value.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125; &#125; &#125;) 总结： 1234561、get何时被调用？ (1)页面加载好后，对此变量初次读取 (2)get中使用到的任何变量发生变化的时候2、set何时被调用 (1)当fullName被修改时 3、计算属性会被放到vm上 简写在只读不写的情况下才可以使用简写模式 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27; &#125; &#125;, computed:&#123; fullName()&#123; return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125; &#125; &#125;)&lt;/script&gt; 计算属性是一个名词，不是动词 这一点搞明白之后，就可以理解计算属性的作用其实就是拿着我现有的东西加工后再展示在页面上 既然插值语法和methods都可以实现该功能，为什么还要学一个计算属性呢？这不是经典白学吗？ NO！大NO特NO 计算属性的优势有两点 1、职责分明 2、与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。 证明：计算属性有缓存 123456computed:&#123; fullName()&#123; console.log(&#x27;我被读取了&#x27;) return `$&#123;this.firstName&#125;-$&#123;this.secondName&#125;` &#125;&#125; 页面上多次使用fullName 修改姓 由此可以证明计算属性具有缓存 缓存什么时候刷新呢？当get中使用到的任何变量发生变化的时候 监视实现监视是一个全新的配置项，作用是监视一个属性的变化 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27; &#125; &#125;, watch:&#123; firstName:&#123; handler(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125; &#125;, secondName: &#123; handler(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125; &#125;)&lt;/script&gt; 这样写就有一个问题，当firstName和secondName有初始值的情况下，页面加载后，fullName是没有值的 这时候就需要使用一个配置项immediate，使得页面加载后立即执行一次监视的回调函数 1234567891011121314watch:&#123; firstName:&#123; immediate: true, handler(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125; &#125;, secondName: &#123; immediate: true, handler(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125;&#125; 这时候小马觉得所有的数据直接写在data中不太好，他想使用一个对象来放这些数据，所以他把data改成了这样，然后他想监视person的变化 12345678910111213data()&#123; return &#123; person: &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, school: &#123; name: &#x27;南京某大学&#x27;, age: 18 &#125; &#125; &#125;&#125;, 于是乎页面就成了这样 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;person.secondName&quot;&gt; &lt;/br&gt; 学校名：&lt;input type=&quot;text&quot; v-model=&quot;person.school.name&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; person: &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, school: &#123; name: &#x27;南京某大学&#x27;, age: 18 &#125; &#125; &#125; &#125;, watch:&#123; person:&#123; handler(newValue,oldValue)&#123; console.log(&#x27;我被修改了&#x27;); console.log(newValue); &#125; &#125; &#125; &#125;)&lt;/script&gt; 小马开心的修改了学校名，发现控制台啥也没有，又修改了姓和名，发现控制台都没有输出， 其实这不是小马的错，这时候就需要另一个配置项了deep，开启对对象的深度监视 123456789watch:&#123; person:&#123; deep: true, handler(newValue,oldValue)&#123; console.log(&#x27;我被修改了&#x27;); console.log(newValue); &#125; &#125;&#125; 小马发现这样写完之后，就又可以监视这个person对象了 简写模式123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; &lt;span&gt;全名：&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;&#x27;, secondName: &#x27;&#x27;, fullName: &#x27;&#x27; &#125; &#125;, watch: &#123; firstName(newValue,oldValue)&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName &#125;, secondName(newValue,oldValue)&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue &#125; &#125; &#125;)&lt;/script&gt; 另一种写法123456789101112 vm.$watch(&#x27;firstName&#x27;,&#123; immediate:true, deep:true, handler(newValue,oldValue)&#123; console.log(&#x27;firstName被修改了&#x27;,newValue,oldValue) &#125;&#125;) //简写形式，所有被vm所管理的函数，都不要写成箭头函数 vm.$watch(&#x27;secondName&#x27;,function (newValue,oldValue)&#123; console.log(&#x27;secondName被修改了&#x27;,newValue,oldValue,this)&#125;) 区别计算属性和监视的区别 就按照这个案例看的话，好像计算属性比监视好多了，但是如果我再加一个需求：姓名输入防抖动 防抖动：就是一段时间内不展示结果，等到用户输入完毕后，再将结果放到页面中 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27;, fullName: &#x27;&#x27;, timer: &#x27;&#x27;, &#125; &#125;, watch:&#123; firstName:&#123; immediate: true, handler(newValue,oldValue)&#123; clearTimeout(this.timer); this.timer = setTimeout(()=&gt;&#123; this.fullName = newValue + &#x27;-&#x27; + this.secondName; &#125;,2000); &#125; &#125;, secondName:&#123; immediate: true, handler(newValue,oldValue)&#123; clearTimeout(this.timer); this.timer = setTimeout(()=&gt;&#123; this.fullName = this.firstName + &#x27;-&#x27; + newValue; &#125;,2000); &#125; &#125; &#125; &#125;)&lt;/script&gt; 这里大家可能会有个疑惑 这里如果不写成箭头函数的话，函数里面的this就是window 但是写成箭头函数的话，在2s过后，vs引擎执行此回调的时候，就会在函数中找this，没有找到 然后向外找，就找到了handler函数，这里面的this就是vm，那么就可以找到data中的属性了 这时候就有人说了，那我也可以用计算属性啊 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;secondName&quot;&gt; &lt;/br&gt; 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data()&#123; return &#123; firstName:&#x27;李&#x27;, secondName: &#x27;四&#x27; &#125; &#125;, computed: &#123; fullName()&#123; setTimeout(()=&gt;&#123; return this.firstName + &#x27;-&#x27; + this.secondName; &#125;,2000); &#125; &#125; &#125;)&lt;/script&gt; 当你写下这个代码的时候，你得反思一下基本功了 这个函数的返回值会返回到哪里去？ 所以，当需要使用异步计算的时候，就需要使用属性监视 小总结 1234567computed和watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以对数据进行异步的操作。两个重要的小原则： 1.所被Vue管理的函数，最好写成普通函数的形式，这样this的指向才是vm或组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数） 最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。 绑定style与class这里就不写案例了 1234567891. class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。 :class=&quot;&quot; 字符串写法适用于：类名不确定，要动态获取。 :class=&quot;&#123;classA:xxx,classB:xxx&#125;&quot; 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用，xxx是布尔值 :class=&quot;[&#x27;classA&#x27;]&quot;数组写法适用于：要绑定多个样式，个数不确定，名字也不确定2. style样式 :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。 :style=&quot;[a,b]&quot;其中a、b是样式对象。 :style=&quot;obj&quot;其中obj是样式对象或者数组","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-基础1","slug":"Vue2-基础1","date":"2022-06-20T13:54:45.000Z","updated":"2022-07-09T10:08:38.295Z","comments":true,"path":"前端/Vue2/2022/06/20/Vue2-基础1/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/20/Vue2-%E5%9F%BA%E7%A1%801/","excerpt":"","text":"Vue2基础1官网地址：https://cn.vuejs.org/ 相信大家学习什么都是以HelloWorld开头的，那我们就以一个HelloWorld的栗子开启我们的Vue学习吧 HelloWorld案例安装Vue 这里大家要注意，不要使用CLI创建Vue项目 新手阶段最好使用标签静态引入CDN的方式来安装Vue 这里补充一个知识点： script标签的src属性可以写成./???.js的形式 也可以写成一个网址，为了使用这种方式引入的加载速度更快一点，所以使用了CDN加速 这是官网提供的两种Vue.js，两者有什么区别呢？ 开发版本的体积比生产版本的体积大，其中包含了完整的警告和调试模式，在学习阶段，我们使用开发版本的即可 引入Vue.js 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; 安装开发者工具它是一个谷歌插件，如果你可以访问外网，可以直接在谷歌插件商场直接搜索下载，如果没有的话，我也在这里提供插件的文件， 12链接：https://pan.baidu.com/s/18AFI8MpW397L6obmKnAZCw 提取码：iupu 点击开发者模式 如果使用的是我提供的文件的话，直接将crx文件拖入该页面即可安装开发者工具 使用Vue123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;我的第一个Vue页面&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--这里的&#123;&#123;&#125;&#125;是Vue中的插值语法，可以读取data配置项中配置的数据--&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; &gt; Vue.config.productionTip = false //关闭vue的生产提示。 //创建Vue实例 new Vue(&#123; el:&#x27;#app&#x27;, //el用于指定当前创建的Vue实例为哪个容器服务，值为css选择器。 data:&#123; //data中用于存储我们需要用到的数据，数据供el所指定的容器去使用，值是一个对象。 msg:&#x27;Hello World&#x27; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解释： 1234567891011121314151617181920212223242526272829303132333435361、&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性 js表达式 VS js语句 (1)js表达式是一个值 (2)js语句是一个语句，控制代码走向 if()&#123;&#125; for()&#123;&#125; switch()&#123;&#125;2、容器和Vue实例的关系是一对一的3、id为app的容器内部的代码就是模板4、一旦data中的数据发生改变，页面中使用到该数据的地方都会自动更新5、el的两种写法，该配置的作用叫挂载，就是将创建的Vue实例与HTML元素绑定在一起 (1) el:&#x27;#app&#x27; (2) new Vue(&#123; data:&#123; msg:&#x27;Hello World&#x27; &#125; &#125;).$mount(&#x27;#app&#x27;) 这个$mount是Vue原型对象上提供的6、data的两种写法 (1) 对象式，data是一个对象 data:&#123; msg:&#x27;Hello World&#x27; &#125; (2) 函数式，data是个函数，返回的是一个对象 data()&#123; return &#123; msg: &#x27;Hello World&#x27; &#125; &#125; (3) 只要是Vue管理的函数，其中的this对象都是自己创建的Vue实例对象，**前提是不能是箭头函数** (4) 我们最常使用的是函数式的，大家要多写这种形式的，具体原因的话，这里埋个伏笔，以后在讲组件的时候解释 如果我们不使用new关键词创建Vue对象的话会怎么样呢？ 控制台就会出现报错 开发版 生产版 这里可以体现生产版本和开发版本之间的区别 我们来看下Vue的构造函数 1234567function Vue (options) &#123; //先判断当前调用函数的是否是Vue的实例，如果不是，则在控制台报错 if (!(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125; 模板语法刚刚我们在写HelloWorld案例的时候使用的&#123;&#123;&#125;&#125;叫插值语法 模板语法一共两种，插值语法就是其中的一种，另一种模板语法叫指令语法 1234567插值语法： 作用：解析标签体内的内容 写法：&#123;&#123;xxx&#125;&#125;双括号内是js表达式，可以直接读取到data中的所有属性。 指令语法： 功能：解析标签（包括：标签属性、标签体内容、绑定事件.....）。 写法：v-xxx(xxx为具体指令) 我们来看看指令语法是个什么东东 为了节省代码量，这里只写核心代码 v-text这个最简单，其作用就是插值语法，将其指定的内容替换标签体内的所有内容，不解析HTML 与之对应的还有一个指令v-html，那这个指令就是将内容放入标签体内后，如果内容有HTML元素，它也会解析 v-bind主要使用在给HTML元素属性动态赋值的时候使用 HTML 12345&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;点我去&#123;&#123;name&#125;&#125;学习1&lt;/a&gt; &lt;!--这是v-bind的简写模式--&gt; &lt;a :href=&quot;url&quot;&gt;点我去&#123;&#123;name&#125;&#125;学习2&lt;/a&gt;&lt;/div&gt; JavaScript 1234567new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;百度&#x27;, url:&#x27;http://www.baidu.com&#x27;, &#125;&#125;) bind的英文意思是绑定，这里先理解一下这个名词的意思，这里的v-bind是单向绑定 什么叫单向绑定？ 就是我在Vue实例中的data中的数据发生了改变，页面中的数据就会跟着更新， 但是页面中的数据发送了改变，data中的数据不会发生改变 证明： 因为我们还没学其他可以修改data中的数据的方法，我们这里就使用开发者工具开帮我们完成该任务 修改data中数据，页面更新 修改页面数据，data不更新 1document.getElementById(&#x27;app&#x27;).children[0].href=&#x27;https://juejin.cn/&#x27; 这就是单向绑定了 既然有单向绑定，那肯定与之对应的还有一个双向绑定啦，下面我们来看看双向绑定 v-model只使用在一些表单类的HTML标签 这个指令十分十分十分的重要，请一定要理解这个指令双向绑定的作用 HTML 1234&lt;div id=&quot;app&quot;&gt; &lt;!--将input的value属性和data中的name属性双向绑定起来--&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;/div&gt; JavaScript 123456new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; name:&#x27;芝麻芝麻&#x27; &#125;&#125;) 单向绑定，是页面中的数据修改后，data中的数据不会更新 那双向绑定的情况下，是不是就会更新了？是的 我们来证明一下这一点 说明： 12341、简写模式 &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;2、作用范围 只可以作用在表单元素上 MVVM模型123M: 模型(Model)对应data中的数据V: 视图/模板(View)HTML元素VM: 视图模型(ViewModel)托管数据的Vue实例，所以以后我们叫Vue的实例对象就叫vm对象 我们来输出一下vm来看看它长啥样 我们发现，橙色框中就是我们data中配置的数据，奇怪的是，它是三个点，但是点开看确实是我们刚刚配置的数据 Vue经过一些操作（我可不会告诉你这叫数据代理），将咱们在data中配置的数据直接放到了vm实例对象上 其实插值语法中可以看到vm身上所有的属性，所以可以直接写我们在data中配置的属性 数据代理回顾Object.defineProperty()在说这个之前，我们先来回顾一下Object上的一个方法defineProperty 123let person=&#123; name: &#x27;lisi&#x27;&#125; 现在我要给person对象上添加一个属性age 第一种写法 1person.age=18 第二种写法 123Object.defineProperty(person,&#x27;age&#x27;,&#123; value: 18&#125;) 那有人就要说了，谁选第二种方式啊，第一种方式那么简单，此言差矣 第二种写的方式定义的age属性有两个特性 第一个，他无法被遍历，删除，修改 无法被遍历，是什么意思？ 1234567891011121314151617// 遍历person中的所有属性for(p in person)&#123; console.log(p)&#125;// 拿到person中的属性数组console.log(Object.keys(person))// 除了age属性，其他的属性都可以被遍历到//用Object.defineProperty定义的数据有很多限制，但是可以通过一些配置项来使其解除限制Object.defineProperty(person,&#x27;age&#x27;,&#123; value: 18, enumerable: true,//可被遍历，默认值是false writable:true, //可以被修改，默认值是false configurable:true //可以被删除，默认值是false &#125;&#125;) 第二个，它可以做数据劫持 这就需要一些其他的配置项了，即get和set 1234567891011121314let number = 18;Object.defineProperty(person,&#x27;age&#x27;,&#123; // 当有人读取person的age的时候，即点了那三个点的时候 // 就会将这个函数的返回值作为person.age的值展示出来 get()&#123; console.log(&#x27;嘿嘿，旧数据被我劫持了！！&#x27;) return number &#125;, // 当有人修改person的age的时候 set(newValue)&#123; console.log(&#x27;嘿嘿，新数据被我劫持了！！我要做坏事了&#x27;) number = newValue; &#125;&#125;) 定义给数据代理下个定义：通过一个对象代理对另一个对象中属性的操作（R&#x2F;W） 我们看一下Vue中的数据代理 vm实例对象代理了data中配置的属性 我们先来证明一个事情：我们传入的data配置项和vm身上的_data是同一个对象 1234567let data = &#123; name:&#x27;芝麻芝麻&#x27;&#125;let vm = new Vue(&#123; el:&#x27;#app&#x27;, data&#125;) 这里我们观察到data已经不是原来的那个对象了，它已经被Vue加工过了 那么Vue中的数据代理就是vm代理了_data中的数据修改 当_data中的数据发生了修改，_data就会检测到这次的修改（数据劫持），页面中使用到该数据的地方都会发生更新 模拟Vue中的数据代理和数据劫持123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script type=&quot;text/javascript&quot;&gt; // 我的Vue的构造函数 function MyVue(options)&#123; // 拿到配置项传入的data let data = options[&#x27;data&#x27;]; // 数据代理，将data中出现的属性代理给实例对象 Object.keys(data).forEach((p)=&gt;&#123; Object.defineProperty(this,p,&#123; get()&#123; return data[p]; &#125;, set(newValue)&#123; data[p] = newValue; &#125; &#125;) &#125;) // 数据劫持 // 将data进行一些加工，使其可以检测属性的变化，当属性变化的时候，对页面做出更新 function Observer(data)&#123; Object.keys(data).forEach((p)=&gt;&#123; Object.defineProperty(this,p,&#123; get()&#123; console.log(&#x27;有人读取配置项中的数据&#x27;); return data[p]; &#125;, set(newValue)&#123; console.log(&#x27;有人修改配置项中的数据，我要更新页面了&#x27;); data[p]=newValue; &#125; &#125;) &#125;) &#125; // 对传入的data数据进行加工，并将其赋值给_data this._data=new Observer(data); options.data=this._data &#125; const vm = new MyVue(&#123; data: &#123; name: &#x27;zhima&#x27; &#125; &#125;)&lt;/script&gt; 证明： 123456789101112131415// 问题一// 对于嵌套类型的对象,是无效的,因为我没有写递归语句,源码是写了递归语句,将对象的每一层都加了getter/setter// 问题二// 这里的_data对象和传入的data对象是不一致的// 这里我不知道怎么实现这一点，有会的大佬可以发一下评论区 let data = &#123; name: &#x27;zhima&#x27;&#125;const vm = new MyVue(&#123; data&#125;)//consolevm._data===datafalse 这里的代码看不懂不要紧哦，我接下来还会再提一遍的，慢慢地会懂的 加油加油💪","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"Vue2-导言","slug":"Vue2-导言","date":"2022-06-18T13:17:13.000Z","updated":"2022-07-15T09:33:20.774Z","comments":true,"path":"前端/Vue2/2022/06/18/Vue2-导言/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/Vue2/2022/06/18/Vue2-%E5%AF%BC%E8%A8%80/","excerpt":"","text":"Vue学习Vue之前，我们先来看三个问题 导言什么是Vue这是官网的介绍 构建用户界面 即将数据展示在页面上，给用户看 渐进式框架 渐进即逐渐递进，简单来说就是 在简单应用中，可以只需要一个小巧的库 在复杂应用中，可以引入各种各样复杂的组件 就是一种可以从易到难开发的一种框架 谁开发的 它有什么特点Angular.js的特点是模块化开发 React.js的特点是虚拟DOM Vue则是集两家之长，它具有以下特点 组件化开发提高代码复用率和维护性 每一个框就是一个组件，就是一个文件 当我需要修改哪一块的界面，我只需要到哪个文件去修改即可 声明式编程让编码人员无需直接操作DOM，提高开发效率 需求：将下列数据显示在一个列表(&lt;ul id=&quot;container&quot;&gt;&lt;/ul&gt;)中 123456789101112131415let persons = [ &#123; id: &#x27;1&#x27;, name: &#x27;zhima&#x27; &#125;, &#123; id: &#x27;2&#x27;, name: &#x27;lizhi&#x27; &#125;, &#123; id: &#x27;3&#x27;, name: &#x27;kerwin&#x27; &#125;] 命令式编程 123456let list = document.getElementById(&#x27;container&#x27;)persons.forEach(p=&gt;&#123; let li=document.createElement(&#x27;li&#x27;); li.innerHtml=`id:$&#123;p.id&#125;-name:$&#123;name&#125;` list.append(li);&#125;) 声明式编程 12345&lt;ul id=&quot;container&quot;&gt; &lt;li v-for=&quot;p in persons&quot;&gt; id:&#123;&#123;p.id&#125;&#125;-name:&#123;&#123;p.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 虚拟DOM优秀的DIFF算法，提高DOM的复用率 这就有点让人摸不着头脑了，DOM还有复用率？ 还是刚才那个案例，如果我的数据变成了这样 123456789101112131415let persons = [ &#123; id: &#x27;1&#x27;, name: &#x27;zhima&#x27; &#125;, &#123; id: &#x27;2&#x27;, name: &#x27;lizhi&#x27; &#125;, &#123; id: &#x27;4&#x27;, name: &#x27;txy&#x27; &#125;] 传统的使用JavaScript进行命令式操作的话，直接将数据转化为页面真实DOM（Real-DOM），确实和DOM的复用率没有啥关系 但是在Vue里面，在数据变成页面上的DOM节点的之前，它会在内存中生成虚拟DOM（Virtual-DOM） 然后使用DIFF算法，比较新旧虚拟DOM，如果有一样的，则直接复用之前已经生成好的虚拟DOM，从而提高了DOM的复用率。 那么通过什么来判断两个虚拟DOM是否相同呢？ 这就要说说刚刚写的代码的一处错误了，下面看正确的代码 12345&lt;ul id=&quot;container&quot;&gt; &lt;li v-for=&quot;p in persons&quot; :key=&quot;p.id&quot;&gt; id:&#123;&#123;p.id&#125;&#125;-name:&#123;&#123;p.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 我们看到，上面的代码就是加了一处地方，就是:key=&quot;p.id&quot;，就是给每一个遍历的元素加上了唯一性标识 具体的DIFF算法，我们后面讲到虚拟DOM 的时候再说 学之前要掌握什么知识 ES6模块化开发规范 包管理器NPM 数组常用方法 axios promise","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"}]},{"title":"算法-二叉树（纲领）","slug":"算法-二叉树（纲领）","date":"2022-05-07T00:24:28.000Z","updated":"2022-09-27T13:55:11.087Z","comments":true,"path":"算法/技巧篇/2022/05/07/算法-二叉树（纲领）/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/05/07/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%BA%B2%E9%A2%86%EF%BC%89/","excerpt":"","text":"二叉树（纲领）二叉树的解题思路有两个方向 通过遍历一棵树得到答案，即遍历的思想 通过递归，将整个问题分解为子问题推导出问题的答案，即分解的思想 首先我们来回顾以下二叉树的几种遍历方式 前序遍历 中序遍历 后序遍历 层次遍历 大家在课内学习的时候，应该是这么背的 前序是根左右，中序是左根右，后序是左右根，层次遍历就是一层一层写 前序遍历集合：ABDHIECFG 中序遍历集合：HDIBEAFCG 后序遍历集合：HIDEBFGCA 层次遍历集合：ABCDEFGHI 相信这个对于大家来说都没有难度，理解前中后序对于做二叉树问题十分重要，这里给出遍历二叉树的模板代码。 12345678910public void traverse(TreeNode root)&#123; if(root==null)&#123; return; &#125; // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置&#125; 下面请你对照这段模板，看下面这张图 你会发现，每个节点都会有唯一属于自己的前中后序位置，前中后序其实对应就是处理每一个节点的三个特殊时间点。 二叉树的问题，其实就是在这三个时间点注入自己的代码逻辑，只需要单独考虑每一个节点在每个时间点该做些什么，其他的交给二叉树遍历框架即可。 前序输出集合我们来写一下前序遍历，方法签名如下public List&lt;TreeNOde&gt; getPreorderList(TreeNOde root)&#123;&#125; 一、遍历借助traverse函数和一个外部变量即可完成 在进入一个节点的时候将其加入到结果集中去，最后将结果集返回 12345678910111213List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();public List&lt;TreeNOde&gt; getPreorderList(TreeNOde root)&#123; traverse(root); return res;&#125;public void traverse(TreeNode root)&#123; if(root==null)&#123; return; &#125; res.add(root); traverse(root.left); traverse(root.right); &#125; 二、分解问题求一整个树的前序遍历即求其子树的前序遍历集合 1234567891011121314public List&lt;TreeNode&gt; getPreorderList(TreeNode root)&#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if(root==null)&#123; return res; &#125; // 将当前节点放入集合 res.add(root); // 将左节点的前序遍历放入集合 res.addAll(getPreorderList(root.left)); // 将右节点的前序遍历放入集合 res.addAll(getPreorderList(root.right)); // 讲结果集返回 return res;&#125; 104. 二叉树的最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 我们来使用两种上述思维来看这道题 一、遍历如何得到最大深度，即得到每一个节点的深度，在叶子节点处将当前深度和当前最大深度取最大，然后将最大的深度返回即可 12345678910111213141516171819202122232425class Solution &#123; int depth=0; int max=0; public int maxDepth(TreeNode root) &#123; traverse(root); return max; &#125; public void traverse(TreeNode root)&#123; if(root==null)&#123; return; &#125; // 前序位置 depth++; // 在叶子节点处更新最大深度 if(root.left==null&amp;&amp;root.right==null)&#123; max=Math.max(max,depth); &#125; traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 depth--; &#125;&#125; 前序位置是进入一个节点的时候，中序位置是从左子树切到右子树的时候，后序位置是离开一个节点返回其父母节点的时候 depth记录着当前深度，max记录着最大深度 在进入一个新的节点的时候，depth自增1，在离开这个节点的时候，depth自减1 二、分解问题求树的最大深度即求树的高度 求树的高度即可分解问题，分解到由子树高度推导出完整的树的高度 123456789101112public int maxDepth(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; // 左子树的高度 int left = maxDepth(root.left); // 右子树的高度 int right = maxDepth(root.right); // 返回自身高度 int max = Math.max(left,right)+1; return max;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【19-Medium】删除链表的倒数第N个节点","slug":"【19-Medium】删除链表的倒数第N个节点","date":"2022-05-01T05:16:28.000Z","updated":"2022-09-27T14:32:38.669Z","comments":true,"path":"算法/刷题篇/2022/05/01/【19-Medium】删除链表的倒数第N个节点/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/05/01/%E3%80%9019-Medium%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ Related Topics 链表 双指针 分析这道题目暴力解法就是，先进行一个循环用一个数字将总长度size算出来，然后取size-n-1个节点，进行删除操作 这里我们不使用这种方法，我们使用快慢指针法。 先将fast指针往后走n步 然后两者齐头并进，当fast.next为null的时候，slow已经在倒数第n-1个节点的位置了，此时进行删除操作。 该方法的原理是利用步长，fast先走的那几步，在fast到了链表末尾的null的时候，slow则表示的是倒数第n个节点， 因为这里需要执行删除操作，所以需要将fast走到链表末尾即可 代码： 123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; for (int i = 0; i &lt; n; i++) &#123; fast = fast.next; &#125; if(fast == null)&#123; return head.next; &#125; while(fast.next != null)&#123; slow = slow.next; fast = fast.next; &#125; slow.next = slow.next.next; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-递归算法","slug":"算法-递归算法","date":"2022-04-30T04:12:07.000Z","updated":"2022-09-27T13:55:50.088Z","comments":true,"path":"算法/技巧篇/2022/04/30/算法-递归算法/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/04/30/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/","excerpt":"","text":"单项递归循环与递归对比回顾1、参数传递 值传递 引用传递 2、递归三要素 递归定义 递归拆解s 递归出口 3、尾递归 ​ 特点： * 函数中所有的递归形式的调用都出现在函数的末尾 * 递归调用不属于表达式的一部分 ​ 作用： * 不会在栈中创建一个新的栈 * 覆盖当前活动记录 例题例一：二阶阶乘 题目：给定一个数n，返回该数的二阶阶乘。在数学中，正整数的二阶阶乘表示不超过这个正整数且与它有相同奇偶性的所有正整数乘积。 1234输入: n = 5输出: 15解释:5!! = 5 * 3 * 1 = 15 普通递归123456789101112131415// 普通递归 @Testpublic void example1OrdinaryWay()&#123; System.out.println(example1_ordinaryWay(5));&#125;public long example1_ordinaryWay(int n)&#123; return example1_recursion(n);&#125;public long example1_recursion(int n)&#123; if(n==2||n==1)&#123; return n; &#125; return n * example1_recursion(n-2);&#125; 尾递归123456789101112131415// 尾递归 @Testpublic void example1TailRecursion()&#123; System.out.println(example1_tailRecursion(5));&#125;private long example1_tailRecursion(int n)&#123; return example1_tailRecursion(n, 1);&#125;private long example1_tailRecursion(int n,int res)&#123; res*=n; if(n==1||n==2)&#123; return res; &#125; return example1_tailRecursion(n-2,res);&#125; 迭代12345678910111213// 迭代@Testpublic void example2Iterate()&#123; System.out.println(example1_iterate(5));&#125;private long example1_iterate(int n)&#123; long res =1; while(n!=1&amp;&amp;n!=2)&#123; res*=n; n-=2; &#125; return res;&#125; 模板 1234567private returnType function(parameters)&#123; while(true)&#123; dosomething... get new parameters parameters = new parameters &#125;&#125; 按照模板 1234567891011121314151617// 迭代@Testpublic void example2Iterate()&#123; System.out.println(example1_iterate(5));&#125;private long example1_iterate(int n)&#123; return example1_iterate(n,1);&#125;private long example1_iterate(int n,int res)&#123; while(true)&#123; res*=n; if(n==1||n==2)&#123; return res; &#125; n-=2; &#125;&#125; 例一：2. 两数相加 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return add(l1,l2,0); &#125; public ListNode add(ListNode l1, ListNode l2, int bit) &#123; if (l1 == null &amp;&amp; l2 == null &amp;&amp; bit == 0) &#123; return null; &#125; int val = bit; // bit就是表示每次是否进位 if (l1 != null) &#123; val += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; val += l2.val; l2 = l2.next; &#125; ListNode node = new ListNode(val % 10); node.next = add(l1, l2, val / 10); return node; &#125;&#125; 例二：21. 合并两个有序链表 12345678910111213public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; if(list1==null)&#123; return list2; &#125;else if(list2==null)&#123; return list1; &#125;else if(list1.val &lt;= list2.val)&#123; list1.next=mergeTwoLists(list1.next,list2); return list1; &#125;else &#123; list2.next = mergeTwoLists(list1, list2.next); return list2; &#125;&#125; 例三：两两交换节点 12345678910public ListNode swapTwoAsGroup(ListNode head)&#123; if(head==null||head.next==null)&#123; return head; &#125; ListNode newHead = head.next; ListNode tail=head.next.next; head.next.next=head; head.next=swapTwoAsGroup(tail); return newHead;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux-常用命令","slug":"Linux-常用命令","date":"2022-04-24T07:57:17.000Z","updated":"2022-10-04T13:53:31.613Z","comments":true,"path":"javaEE/Linux/2022/04/24/Linux-常用命令/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/04/24/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用命令查看文件内容123cat fileName# -n 显示行号cat -n fileName 分配查看器1more fileName 操作 功能 空白键 向下翻一页 enter 向下翻一页 q 离开 Ctrl+F 向下滚动一屏 Ctrl+B 返回上一屏 &#x3D; 输出当前行号 :f 输出文件名和当前行的行号 less指令用来分屏查看文件内容，他的功能和more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容的时候，不会一次加载整个文件，而是根据显示需要加载内容，对于显示大型文件具有较高的效率 1less fileName 操作 功能说明 空白键、pagedown 向下翻动一页 pageup 向上翻动一页 &#x2F;字符串 向下搜寻字符串的功能 ?字符串 向上搜寻字符串的功能 q 退出 输出内容123echo &quot;hello\\tworld&quot;# -e 支持控制字符echo -e &quot;hello\\tworld&quot; 控制字符 作用 \\ \\ 输出\\本身 \\n 换行符 \\t 制表符 显示头部文件1234head fileName# -n 显示前多少行，不写的话默认10行head -n 5 fileName 显示尾部文件1234tail fileName# -n 显示尾部前多少行，不写的话默认10行# -f 实时更新 输出重定向&gt;和&gt;&gt;追加&gt;是覆盖 &gt;&gt;是追加 12ls -ll &gt; fileName cat fileName &gt; fileName2 查看历史操作记录1history 查看用户是否存在1id userName 查找文件和目录12345find [搜索范围] [选项] -name 按照指定的文件名查找文件 -user 查找指定用户名查找文件 -size 按照指定的文件大小查找文件 (+大于，-小于，) 快速定位路径locate命令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查找速度较快，为了保证查询结果的准确度，管理员需要定时使用updatedb命令更新db 1locate 压缩和解压gzip&#x2F;gunzip压缩gzip只能将文件压缩为.gz文件 特点： 1、只能压缩文件，不能压缩目录 2、不能保留原来的文件 3、同时多个文件会产生多个压缩包 zip&#x2F;unzip压缩 zip可选项 作用 -r 压缩目录 unzip可选项 作用 -d 指定解压后文件的存放位置 tar 可选项 功能 -c 产生tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解包 -C 解压到指定目录 12345# 常用解压缩命令tar -zxvf# 常用压缩命令tar -zcvf 查看当前系统进程状态12345# 查看系统中的所有进程ps aux# 查看子父进程之间的关系ps -ef 特点： 1、查看进程的CPU占用率和内存占用率，可以使用aux 2、想查看进程的父进程ID可以使用-ef 显示网络状态和端口占用信息123netstat -anp |grep 进程号netstat -anp |grep 进程号 选项 功能 -a 显示所有正在监听和未监听的套接字 -n 拒绝显示别名，能显示数字的就显示数字 -l 仅列出在监听的服务状态 -p 表示显示哪个进程在调用 设置定时任务1crontab [选项] 选项 功能 -e 编辑crontab任务 -l 查询crontab任务 -r 删除当前用户所有的crontab任务","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-系统管理","slug":"Linux-系统管理","date":"2022-04-24T03:02:23.000Z","updated":"2022-10-04T13:53:51.281Z","comments":true,"path":"javaEE/Linux/2022/04/24/Linux-系统管理/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/04/24/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","excerpt":"","text":"系统服务管理开启服务 1systemctl start servieName 重启服务 1systemctl restart servieName 关闭服务 1systemctl stop servieName 查看服务状态 1systemctl status servieName 查看所有后台服务状态 1systemctl list-units --type service --all 关闭后台服务自启动 1systemctl disable name.service 开启后台服务自启动 1systemctl enable name.service","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"JVM-内存分区","slug":"JVM-内存分区","date":"2022-03-18T09:27:35.000Z","updated":"2022-11-08T06:51:50.009Z","comments":true,"path":"javaEE/JVM/2022/03/18/JVM-内存分区/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/18/JVM-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"JVM内存分区内存分区和内存模型是两个概念 操作系统内存分区 栈（Stack） 堆（Heap） 未初始化数据段（BSS） 数据段（Data Segment） 文本段（Literal Segment） 代码段（Code Segment） JVM内存分区 程序计数器（PC） 虚拟机栈（JVM Stack） 本地方法栈（Native Method Stack） 堆（Heap） 方法区（Method Area） 橙色虚线包裹的就是线程共享的，被红色实现包裹的是线程隔离的 程序计数器在硬件层面，程序计数器是寄存器，是用来存储指令地址给处理器执行， 在JVM中，它的作用就是用来存储字节码指令的地址，提供给执行引擎去执行 这里我们从侧面去查看该特新 1234567public class Demo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); &#125; &#125;&#125; 然后先编译javac Demo.java反编译javap -l -c Demo.class 得到以下字节码 123456789101112131415161718192021222324252627282930313233Compiled from &quot;Demo.java&quot;public class com.lizhi.Demo &#123; public com.lizhi.Demo(); descriptor: ()V Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V Code: // 这里的数字就是字节码指令的偏移量 0: iconst_0 1: istore_1 2: iload_1 3: bipush 10 5: if_icmpge 21 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: iload_1 12: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 15: iinc 1, 1 18: goto 2 21: return // 这里可以解释断点的原理，将源码行数和字节码行数进行映射 LineNumberTable: line 5: 0 line 6: 8 line 5: 15 line 8: 21&#125; 虚拟机栈也叫java方法栈，java方法的调用对应着栈帧的入栈与出栈。 3个重点： 栈帧 栈帧出现时机 栈帧的构成 栈帧栈帧主要有四部分组成：局部变量表、操作数栈、动态连接、返回地址 局部变量表 主要存储方法的参数、定义在方法内的局部变量，包括基本数据类型（8大）对象的引用地址，返回值地址。 局部变量表中存储的基本单元为变量槽（Slot），32位（4字节）以内的数据类型占一个slot，64位（long，double）的占两个slot。 局部变量表是一个数字数组，byte、short、char都会被转化为int,boolean类型也会被转化为int，O代表false、非0代表true。局部变量表的大小是在编译期间决定下来的，所以在运行时它的大小是不会变的。 局部变量表中含有直接或者间接指向的引用类型变量时，不会被垃圾回收处理。 操作数栈 就是用来存储操作数的栈，这里的操作数大部分就是方法内的变量 作用： 存储操作数 操作数栈可以方便指令顺序读取操作数 指令 含义 iload int型变量入栈 istore 栈顶数值存入局部变量 iadd 弹出栈顶两个操作数，并将求和的int值压入栈中 动态连接 java中的多态就是通过动态连接实现的 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用都是为了支持方法调用过程中的动态连接 连接是将部分符号引用替换为直接引用，对于有些方法，JVM并不能判断它们的具体实现，只有在真正运行的时候，才可以根据实际类型进行连接，这就是动态连接 本地方法栈本地方法是由非java语言实现的函数，一般是一些和操作系统底层相关的函数","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"JavaScript-模块化开发","slug":"JavaScript-模块化开发","date":"2022-03-16T12:34:07.000Z","updated":"2022-10-04T13:53:00.487Z","comments":true,"path":"前端/JavaScript/2022/03/16/JavaScript-模块化开发/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/JavaScript/2022/03/16/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"javaScript模块化 什么是模块化？ 即将一个复杂的程序依据一定的规则(规范)封装成几个块(文件)，并用规定语法将其组合在一起，块的内部数据&#x2F;实现是私有的,只是向外部暴露一些接口(方法)与外部其他模块通信 以前的代码 全局模式 123456function foo()&#123; &#125;function abc()&#123; &#125; 问题：所有的函数都被绑定在了window上，容易产生命名冲突和产生对window的污染 namespace模式 将函数或者数据绑定在对象上 123456789let obj = &#123; k: &#x27;asd&#x27;, foo()&#123; console.log(this.k) &#125;, abc()&#123; &#125;&#125; 问题：对象中的数据可以随意被修改，所以数据不安全 IIFE(Immedicately-invoked-function-expression) 该方法就是利用函数的作用域和即使函数的特性 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=&#123;foo&#125;&#125;)(window);-----------------------------module.foo(); 或者 12345678(function(window)&#123; function foo()&#123; console.log(&#x27;ooo&#x27;) &#125; window.module=foo&#125;)(window);-----------------------------module(); IIFE就是现代化模块化的基石 模块化的好处 避免命名冲突 根据功能点进行更好的分离 更高的复用性 高可维护性 但是以此同时就出现了问题 一个页面需要引入多个js文件，如果多个文件之间有依赖关系，先后顺序的错误就会导致报错 请求过多 依赖模糊 难以维护 这时候我们就需要引入一种模块化的规范来避免这种问题，下面我们来看看有哪些模块化规范 模块化的规范 CommonJS（nodejs就是基于这种规范） AMD （用的少） CMD（阿里的人写的。用的少） ES6 CommonJS说明： 每一个文件都是一个模块 服务器端：模块的加载是运行时同步加载的 浏览器端：需要自己编译打包将所有的模块js合并到一个js中 定义模块： 123456module.exports=&#123;&#125;---expoets.foo = function()&#123; &#125;exports.n = 2 引入模块： 1234let module1 = require(..)// 这里的..// 引入第三方的包 直接写包名// 引入自己写的js 写路径 服务器端例子： 先创建项目结构 123456-modules --module1.js --module2.js --module3.js-app.js-package.json module1.js 12345module.exports = &#123; foo()&#123; console.log(`&#x27;module1&#x27;s foo()`) &#125;&#125; module2.js 123456exports.foo = function()&#123; console.log(`&#x27;module2&#x27;s foo()`)&#125;exports.abc = function()&#123; console.log(`&#x27;module2&#x27;s abc()`)&#125; module3.js 123module.exports = function()&#123; console.log(`&#x27;module3&#x27;s foo()`)&#125; app.js 12345678let module1 = require(&#x27;./modules/module1.js&#x27;)let module2 = require(&#x27;./modules/module2.js&#x27;)let module3 = require(&#x27;./modules/module3.js&#x27;)module1.foo()module2.foo()module2.abc()module3() package.json 1234&#123; name: &#x27;applicationname&#x27;,// 这里写项目名字，不能有大写字母，不能有中文 version: &#x27;1.0.0&#x27;&#125; 可以使用npm init生成该文件 客户端例子： 结构树如下 123456789-test --dist --src ---module1.js ---module2.js ---module3.js ---app.js --index.html --package.json js代码如上 下载编译工具 12npm install browserify -g # 全局安装npm install browserify --save-dev # 开发依赖，在上线阶段不需要此工具了 使用该工具 1browserify src/app.js -o dist/budle.js index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&#x27;./dist/budle.js&#x27;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; AMD说明：AMD(（Asynchronous Module Definition）)专门用户浏览器端，模块的加载是异步的 此规范依赖于一个Require.js 基本语法： 定义模块： 12345678// 没有依赖其他模块define(function()&#123; return 模块&#125;)// 定义有依赖的模块define([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; return 模块&#125;) 引入模块 123456require([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;)requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125;) 例子： 目录结构 12345678910-test --js ---libs ----require.js//这是引入的第三方js ---modules ----module1.js ----module2.js ----modlue3.js ---main.js --index.html mudule1.js 1234567define(function()&#123; lett msg = &#x27;module1&#x27;; function foo()&#123; console.log(msg) &#125; return &#123;foo&#125;&#125;) module2.js 1234567define([&#x27;module1&#x27;],function(m1)&#123; let msg = &#x27;module2.js&#x27; function foo()&#123; console.lopg(msg,m1.foo()) &#125; return &#123;foo&#125;&#125;) main.js 12345678910111213(function()&#123; require.config(&#123; baseUrl: &#x27;js/&#x27;, path: &#123; module1: &#x27;./modules/module1.js&#x27;, module2: &#x27;./modules/module2.js&#x27; jquery: &#x27;./libs/jquery.js&#x27;//引入第三方库，不是所有的第三方库都支持AMD语法 &#125; &#125;) requirejs([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; m1.foo(); &#125;)&#125;)() 页面中只要引入该标签即可 1&lt;script data-main=&quot;js/main.js&quot; src=js/libs/require.js&gt;&lt;/script&gt; ES6规范说明：该规范也需要编译打包处理，先使用babel将ES6转化为ES5，然后使用browserify将其并为一个js文件 基本语法： 导出模板： 1234567891011121314151617181920212223export function foo()&#123; &#125;export function abc()&#123; &#125;------------------------------------------------------------------------------------------------------function foo()&#123; &#125;function abc()&#123; &#125;export &#123;foo,abc&#125;------------------------------------------------------------------------------------------------------export default &#123; function foo()&#123; &#125; function abc()&#123; &#125;&#125; 引入模块： 12345// 常规导出，这边用对象接import &#123;&#125; from &#x27;路径&#x27; //自己的js// 默认导出，这边用变量来接impoet module from &#x27;路径&#x27; 例子： 项目结构 123456789101112-test --js ---dist ---build ---src ----module1.js ----module2.js ----module3.js ----main.js --index.html --.babelrc --package.json 安装依赖 12345npm install browserify --save-devnpm install babel-cli -gnpm install babel-preset-es2015 --save-dev 创建.babelrc rc就是run control运行时控制文件 123&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125; module1.js 123456export function foo()&#123; &#125;export function abc()&#123; &#125; module2.js 1234567function f1()&#123; &#125;function f2()&#123; &#125;export &#123;f1,f2&#125; module3.js 12345678export default &#123; function d1()&#123; &#125; function d2()&#123; &#125;&#125; main.js 123456789import &#123;foo,abc&#125; from &#x27;./module1.js&#x27;import &#123;f1,f2&#125; from &#x27;./module2.js&#x27;import module3 from &#x27;./module3.js&#x27;foo();abc();f1();module3.d1();module3.d2(); es6转es5 1babel js/src -d js/build 这里如果出现这个错误： 1babel : 无法加载文件 C:\\Users\\win\\AppData\\Roaming\\npm\\babel.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/ go.micros 那么你输入以下命令一定是这样的 12get-ExecutionPolicy# restricted 这时候，先使用管理员身份打开Windows Powershell然后输入以下命令 12set-ExecutionPolicy RemoteSigned然后输入y回车 合并文件 1browserify js/build/main.js -o js/dist/bundle.js index.html导入js 1&lt;script src=&quot;js/src/dist/bundle.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"JVM-内存模型","slug":"JVM-内存模型","date":"2022-03-12T02:41:34.000Z","updated":"2022-10-04T13:53:24.374Z","comments":true,"path":"javaEE/JVM/2022/03/12/JVM-内存模型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/12/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"内存模型硬件的内存模型在讲java内存模型之前，先来看看硬件的内存模型 CPU的处理速度和内存的读写不是一个数量级的，所以在CPU和主存之间加上了一层缓存 这种结构在单CPU的时候，处理的很好 但是当多CPU的时候， 这时候就会出现缓存一致性问题 当CPUA读取主存中的数据之后，对其进行修改，在将其刷新回主存的之前，CPUB读取主存中的数据，对其进行修改，将其刷新回主存，这时候CPUA也同时将其修改后的数据刷新回主存，那么这个数据到底以哪一个为准，这个就是缓存一致性问题 针对这个问题，就出现了缓存一致性协议 1、窥探性 2、目录型 有了这一层协议，在硬件层面，就解决了缓存一致性问题，即汇编语言能够运行在一个具有缓存一致性的内存视图中 Java的内存模型设计编程语言的内存模型是为了能够该语言也可以拥有一个内存一致性的视图，于是在硬件内存模型之上，就有了高级语言的内存模型 Java内存模型就屏蔽了各种硬件的操作系统的内存差异，使得java可以正常的运行在各大操作系统上 虚拟机栈也可以叫做java方法栈，该栈中存放8大基础类型的数据和对象的引用 堆中存放着所有的java对象 内存读写指令 作用于主存 作用于工作内存 lock：锁定 load：加载数据 unlock：解锁 store：存储数据 read：读取 use：使用数据 write：写入 assign：赋值 上面的图只是一种理想状态，会出现以下两种问题 1、可见性 当线程A将本地内存中的数据修改后，刷新回主存后，线程B直接使用本地内存中的数据，没有使用刷新后的数据，这就是可见性问题 2、原子性 当线程A修改了数据，还没刷新回主存，线程B也修改了数据，也要刷新回主存，那么这时候主存中应该刷新成哪个线程修改后的值呢 线程通信之间的同步问题，当多个线程在并发操作同一个数据的时候，会引发很多的问题，这些问题被总结为并发三要素 1、可见性 2、原子性 3、有序性 可见性当一个线程修改了共享变量的值之后，其他所有使用该变量的线程都应该立刻得知此修改 两层含义 第一种含义 线程A修改了数据X，线程B需要使用到最新的数据X（这是线程B没有重新读取主存导致的） 12345678910111213141516public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 控制台不会返回响应码，而是一直死循环。 当thread1开始循环的时候，本地内存中a=1，当thread2修改了a为0的时候，thread1并不知道，而是一直使用着a=1，所以会一直循环 两种解决方法 1、将a变量加一个修饰词volatile 如果一个共享变量被volatile修饰，那么该共享变量被修改后，将会直接写入主存，当其他线程读取该共享变量的时候，也会直接从主存中读取 2、使用synchronized包裹，并使用该数据 synchronized块中读写变量会隐式调用lock和unlock指令 123456789101112131415161718public class Demo &#123; static int a =1; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; while (a == 1) &#123; synchronized(this)&#123; int b = a + 1; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; a = 0; &#125;); thread1.start(); TimeUnit.SECONDS.sleep(1); thread2.start(); &#125;&#125; 第二层含义 线程B需要读取到线程A修改后的数据x，但是因为指令重排，在线程A未修改数据x之前，线程B读到了数据x 123456789101112131415161718public class Demo2 &#123; static int a =0; static boolean b =false; public static void main(String[] args) &#123; Thread thread1 = new Thread(() -&gt; &#123; a = 1;//1 b = true;//2 &#125;); Thread thread2 = new Thread(() -&gt; &#123; if (b) &#123;//3 int x = a;// 4 // 这个x一定是1吗? System.out.println(x); // 5 &#125; &#125;); thread1.start(); thread2.start(); &#125;&#125; 在硬件内存模型的时候就说过，在底层会存在指令重排的情况， 我们觉得的顺序应该是 1-&gt;2-&gt;3-&gt;4 但是在编译后顺序有可能就变成了 2-&gt;3-&gt;4-&gt;1 这也是一种可见性的问题 同样的这里我们也可以使用上述两种方法来解决这种问题 volatile是禁止了当前变量与之前的代码语句进行指令重排 synchronized就是将两段代码分别捆绑在一起，那么无论在thread1中怎么指令重排，都不会影响thread2对于变量的读取 Happens-Before原则我们平时很少遇到可见性问题，因为我们站在了前人的肩膀上，设计内存模型的前辈已经帮我们解决了此问题，这就是Happens-Before原则 定义：对于两个操作A和操作B，这两个操作可以在不同的线程中执行，如果A Happens-Before B（即A先于B执行），那么可以保证当A操作执行完后，A操作的执行结果对B操作是可见的 程序顺序原则 锁定原则 volatile原则 线程启动原则 线程结束原则 中断规则 终结器规则 传递性原则 原子性一个操作要么全部执行成功，要么全部执行失败 1、单指令原子操作 2、利用锁的组合指令原子操作 有序性指令重排在单线程环境下不会出现什么问题，但是在多线程环境下，可能导致有的代码执行顺序修改后可能会导致与顺序执行的结果不同 这里可以使用Happens-Before原则来解决问题","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"JVM-类加载器","slug":"JVM-类加载器","date":"2022-03-11T14:47:01.000Z","updated":"2022-10-04T13:53:16.497Z","comments":true,"path":"javaEE/JVM/2022/03/11/JVM-类加载器/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/03/11/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"类的加载过程类的加载过程分三个阶段 类的加载 &#x3D;&#x3D;》类的链接 &#x3D;&#x3D;》类的初始化 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中（方法区）生成一个代表该类的Class对象，作为类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程 类构造器方法是由编译期按顺序收集类中所有类变量的赋值动作和静态代码块中的语句合并而成的（类构造器是构造类信息的，不是对象构造器） 当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 JVM会保证类构造器在多线程环境下被正确加锁 类的链接为黑盒实现 类的主动引用（一定会发生类的初始化） 当JVM启动的时候，先初始化main方法所在的类 new 一个类的对象 调用该类的静态成员（除了final）和静态方法 使用反射对其类进行反射调用 当初始化一个类时，其父类若没有初始化，则先初始化其父类 类的被动引用（不会发生类的初始化） 当访问一个静态域的时候，只有真正声明该域的类才会被初始化。举个栗子：当通过子类调用父类的静态变量，该子类是不会被初始化的 通过数组定义类引用，不会导致初始化 引用常量不会导致初始化 类加载器市面上有三种JVM，不同的JVM对类加载器的实现是不同的，我们主要学习的并且使用的是Sun公司的HotSpot 类加载器的作用就是将类（class）装进内存的 JVM规定了以下类型的加载器 引导类加载器：用C++编写的，是JVM自带的类加载器，负责java平台的核心库，用来装载核心类库，该加载器无法直接获取（获取的时候会是null） 扩展类加载器（ExtClassLoader）：负责**&#x2F;lib&#x2F;etc**目录下的jar包户或者 -d java.ext.dirs指定目录下的jar包装入工作库 系统类加载器（AppClassLoader）：负责java -classpath或者java.class.path指定目录下的类与jar包 用户加载器（User ClassLoader）：用户自定义的加载器 扩展类加载器、系统类加载器、用户加载器都是继承自java.lang.ClassLoader JVM规范：每个类加载器都有属于自己的命名空间 双亲委派机制检查顺序从下至上，加载顺序从顶至下 举个栗子：我写了一个Student类，我要加载它需要经过以下过程 先将该任务委托给AppClassLoader AppClassLoader很懒，它不想加载，将任务向上委托给ExtClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，但是在自己管理的lib目录下并没有找到该类，只能将任务再次交给ExtClassLoader去加载 那ExtClassLoader没法偷懒了，只能在自己管理的ext目录下找该类，但是也没有找到，只能将任务继续向下转交给AppClassLoader AppClassLoader不得不自己去尝试加载该类，于是加载成功 既然最后还是AppClassLoader去加载Student类何必绕一个大圈子呢？ 这是为了防止原始类被用户写的类所覆盖。 再举个栗子：我自己写了一个String类，我要加载它会经历以下过程 先将该任务委托给AppClassLoader ExtClassLoader也很懒，它不想加载，继续将任务向上委托给BootStrapClassLoader BootStrapClassLoader没法偷懒了，只能自己加载，于是在自己管理的lib目录下找到该类并加载，将加载结果向下一直传递到用户 对双亲委派模型的破坏1、自定义类加载器 我们写一个类继承java.lang.ClassLoader，重写loadClass方法，双亲委派的逻辑就在这个方法中，但是我自定义的类加载器可以不这么写，也就破坏了双亲委派。在jdk1.2之后，jdk增加了一个findClass方法提供给上层重写，也就有效地防止了双亲委派被破坏 1234567891011121314151617181920212223public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; ClassLoader myClassLoader = new ClassLoader()&#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try&#123; String fileName = name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if(is==null)&#123; return super.loadClass(name); &#125; byte[] buffer = new byte[is.available()]; is.read(buffer); return defineClass(name,buffer,0, buffer.length); &#125;catch (Exception e)&#123; e.printStackTrace(); throw new ClassNotFoundException(name); &#125; &#125; &#125;; Object o = myClassLoader.loadClass(&quot;com.test.A&quot;).newInstance(); System.out.println(o.getClass()); System.out.println(o instanceof com.test.A);&#125; 控制台输出 12class com.test.Afalse 这不仅破坏了双亲委派，并且证明了每个类加载器都有自己的命名空间 2、SPI（Service Provider Interface）服务发现机制 JDK中定义了JDBC的接口，规范各大厂家。对于JDK中的接口，使用的是BootstrapClassLoader但是对于各大厂家的实现类，使用的是ApplClassLoader 1234567891011121314151617181920212223242526272829303132333435@CallerSensitivepublic static Driver getDriver(String url) throws SQLException &#123; println(&quot;DriverManager.getDriver(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); ensureDriversInitialized(); Class&lt;?&gt; callerClass = Reflection.getCallerClass(); // Walk through the loaded registeredDrivers attempting to locate someone // who understands the given URL. for (DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if (isDriverAllowed(aDriver.driver, callerClass)) &#123; try &#123; if (aDriver.driver.acceptsURL(url)) &#123; // Success! println(&quot;getDriver returning &quot; + aDriver.driver.getClass().getName()); return (aDriver.driver); &#125; &#125; catch(SQLException sqe) &#123; // Drop through and try the next driver. &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.driver.getClass().getName()); &#125; &#125; println(&quot;getDriver: no suitable driver&quot;); throw new SQLException(&quot;No suitable driver&quot;, &quot;08001&quot;);&#125; 123456@CallerSensitivepublic static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 当前线程的ClassLoader默认为AppClassLoader ClassLoader cl = Thread.currentThread().getContextClassLoader(); return new ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);&#125; 3、热部署","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"算法-差分数组","slug":"算法-差分数组","date":"2022-03-11T04:45:24.000Z","updated":"2022-09-27T13:57:06.872Z","comments":true,"path":"算法/技巧篇/2022/03/11/算法-差分数组/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/11/%E7%AE%97%E6%B3%95-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"","text":"差分数组该技巧和前缀和数组一样都是用在数组上的， 前缀和数组是用来简化 任意区间的元素之和的， 差分数组是用来简化 频繁在任意区间减去某个值或者在任意区间加上某个值，最后输出最后的数组结果的 比如，给你一个数组nums[2,4,1,45,21,54,12,43]，我需要先将[2,4]都加3，再将[3,6]都减1，再…..，最后输出最后的数组结果 如果没学过差分数组，那么应该是使用for循环将范围内的数都进行操作，最后输出数组， 对nums的操作十分频繁，这样的效率十分低下 这里我们就使用差分数组来提高我们的效率 12345int[] diff = new int[nums.length];diff[0] = nums[0];for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i] - nums[i-1];&#125; 当i!=0的时候diff[i]代表nums[i]-nums[i-1]的值，即当前值与前一个值的差 那有了这个差分数组，我们怎么将数组还原呢？ 12345int[] res = new int[diff.length];res[0] = diff[0];for (int i = 1; i &lt; diff.length; i++) &#123; res[i] = res[i-1] + diff[i];&#125; diff的还原是先new一个新的数组来存放最后的结果，对于0之后的元素，res[i]等于前一个元素加上当前索引的diff 如果我要将[i,j]区间加2，那么就将diff[i]+=2;diff[j+1]-=2即可 我将diff[i]+=2，即达到res[i]到最后都会被加上2的效果 我将diff[j+1]-=2，即达到res[j+1]之后，会将前面的加2抵消，所以j之后的元素就不会被影响了 我们来和之前的那道前缀和数组一样，抽象出来一个类来处理数组 123456789101112class Diff&#123; private int[] diff; public Diff(int[] nums)&#123; &#125; public void increase(int left, int right, int step)&#123; &#125; public int[] getResult()&#123; &#125;&#125; 大家可以先自己写一下 这是实现： 123456789101112131415161718192021222324class Diff&#123; private int[] diff; public Diff(int[] nums)&#123; diff = new int[nums.length]; diff[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; diff[i] = nums[i]-nums[i-1]; &#125; &#125; public void increase(int left, int right, int step)&#123; diff[left]+=step; if(right&lt;diff.length-1)&#123; diff[right+1]-=step; &#125; &#125; public int[] getResult()&#123; int[] result = new int[diff.length]; result[0]=diff[0]; for (int i = 1; i &lt; diff.length; i++) &#123; result[i] = result[i-1]+diff[i]; &#125; return result; &#125;&#125; 接下来就要实践出真知，来看一下这道力扣题，这道题在力扣上是plus会员才可以查看，这里直接将题目简述给大家 力扣370：区间加法 12345678910111213141516# 370.区间加法假设你有一个长度为 n 的数组nums，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：[left,right,step]，你需要该区间[left,right] (包括left和right)增加step。请你返回 k 次操作后的数组。# 示例len=5,updates=[[1,3,3],[2,4,-5],[0,3,4]]原数组变为 [0,0,0,0,0]原数组变为 [0,3,3,3,0]原数组变为 [0,3,-2,-2,-5]原数组变为 [4,7,2,2,-5]result: [4,7,2,2,-5]# 方法签名public int[] getModifiedArray(int[] nums, int[][] updates) &#123; &#125; 只要懂了上面的Diff类的写法，这题轻轻松松拿下！ 代码： 12345678910111213141516171819public int[] getModifiedArray(int[] nums, int[][] updates) &#123; int[] diff = new int[nums.length]; diff[0]=nums[0]; for (int i = 1; i &lt; diff.length; i++) &#123; diff[i] = nums[i]-nums[i-1]; &#125; for (int[] update : updates) &#123; diff[update[0]]+=update[2]; if(update[1]+1&lt;diff.length)&#123; diff[update[1]+1]-=update[2]; &#125; &#125; int[] result = new int[diff.length]; result[0]=diff[0]; for (int i = 1; i &lt; result.length; i++) &#123; result[i] = result[i-1]+diff[i]; &#125; return result;&#125; 既然我们之前写了Diff那么我们就可以使用它 1234567public int[] getModifiedArray1(int[] nums, int[][] updates) &#123; Diff diff = new Diff(nums); for (int[] update : updates) &#123; diff.increase(update[0],update[1],update[2]); &#125; return diff.getResult();&#125; 接下来我们来尝试一下这道实际应用题力扣1109：航班预订统计 本质是一样的，只不过这边需要注意一下索引和编号的对应关系， 1234567891011121314151617class Solution &#123; public int[] corpFlightBookings(int[][] bookings, int n) &#123; int[] diff = new int[n]; for (int[] booking : bookings) &#123; diff[booking[0]-1]+=booking[2]; if(booking[1]&lt;n)&#123; diff[booking[1]]-=booking[2]; &#125; &#125; int[] answer = new int[diff.length]; answer[0]= diff[0]; for (int i = 1; i &lt; answer.length; i++) &#123; answer[i] = answer[i-1]+ diff[i]; &#125; return answer; &#125;&#125; 相信学完这些，你对差分数组的理解也比较深刻了","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-前缀和数组","slug":"算法-前缀和数组","date":"2022-03-10T10:01:29.000Z","updated":"2022-09-27T13:40:49.869Z","comments":true,"path":"算法/技巧篇/2022/03/10/算法-前缀和数组/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/10/%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"前缀和数组力扣303：区域和检索 - 数组不可变 这是一道很典型的使用前缀和数组的题目。 对于频繁计算数组的一个范围的和，学没过前缀和数组的会这样做， 1234567public int sumRange(int[] sums, int left, int right) &#123; int sum = 0; for(int i = left ;i &lt;= right;i++)&#123; sum += nums[i]; &#125; return sum;&#125; 这样确实可以达到效果，但是频繁这样操作，效率不是很高。 所以学过前缀和的会这么写从而提高效率 1234567public int sumRange(int[] sums, int left, int right) &#123; int[] preSum = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length ; i++) &#123; preSum[i] = preSum[i-1] + nums[i-1]; &#125; return preSum[right+1] - preSum[left];&#125; 我们来分析一下这个preSum 它的长度是原数组的长度加一 preSum[0]置为nums数组前0个的和 preSum[1]置为nums数组前1个的和 preSum[2]置为nums数组前2个的和 所以我如果需要[0,1]区间的和，则返回preSum[2]-preSum[0]（前2个数的和减去前0个数的和） 所以我如果需要[3,5]区间的和，则返回preSum[6]-preSum[3]（前6个数的和减去前3个数的和） 所以这道力扣303题的代码为： 1234567891011121314class NumArray &#123; private int[] preSum; public NumArray(int[] nums) &#123; preSum = new int[nums.length+1]; for (int i = 1; i &lt;= nums.length; i++) &#123; preSum[i]=preSum[i-1]+nums[i-1]; &#125; &#125; public int sumRange(int left, int right) &#123; return preSum[right+1]-preSum[left]; &#125;&#125; 小试身手：初三一班的数学期末成绩(满分120分)出来了，现将成绩乱序列表发于你，请你统计在[min,max]范围内的学生人数 方法签名：public int scoreRange(List&lt;Integer&gt; scores, int fullMarks, int min, int max) 在学前缀和数组之前 先将scores按升序排序 然后使用二分搜索两个端点，将长度返回 这样的思路确实没毛病，但是如果频繁需要查询， 就算是强如二分查找，也会消耗很多资源 学了前缀和数组之后 既然学了前缀和数组，我们就使用该技巧去优化 1234567891011121314151617181920/** * 返回成绩范围内的学生数 * @param scores 学生成绩列表 * @param fullMarks 这门成绩的满分 * @param min 最小值 * @param max 最大值 * @return 满足成绩区间的个数 */public int scoreRange(List&lt;Integer&gt; scores, int fullMarks, int min, int max)&#123; int[] counts = new int[fullMarks+1]; int[] preSums = new int[fullMarks+2]; for (Integer score : scores) &#123; counts[score]++; &#125; preSums[0]=0; for (int i = 1; i &lt;= counts.length; i++) &#123; preSums[i] = preSums[i-1]+counts[i-1]; &#125; return preSums[max+1]-preSums[min];&#125; 现在我们来解决力扣304：二维区域和检索 - 矩阵不可变 本质和一维的时候是一样的只不过变成了二维，需要预处理一个二维前缀和数组而已 1234567891011121314151617181920class NumMatrix &#123; private int[][] preSums; public NumMatrix(int[][] matrix) &#123; preSums = new int[matrix.length][matrix[0].length+1]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt;= matrix[i].length; j++) &#123; preSums[i][j] = preSums[i][j-1] + matrix[i][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int sum = 0; for (int i = row1; i &lt;= row2; i++) &#123; sum+=preSums[i][col2+1]-preSums[i][col1]; &#125; return sum; &#125;&#125; 这是另一种解法 1234567891011121314151617181920212223class NumMatrix &#123; // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和 private int[][] preSum; public NumMatrix(int[][] matrix) &#123; int m = matrix.length, n = matrix[0].length; if (m == 0 || n == 0) return; // 构造前缀和矩阵 preSum = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // 计算每个矩阵 [0, 0, i, j] 的元素和 preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1]; &#125; &#125; &#125; // 计算子矩阵 [x1, y1, x2, y2] 的元素和 public int sumRegion(int x1, int y1, int x2, int y2) &#123; // 目标矩阵之和由四个相邻矩阵运算获得 return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【25-Hard】以k个节点为一组逆转单链表","slug":"【25-Hard】以k个节点为一组逆转单链表","date":"2022-03-08T07:00:11.000Z","updated":"2022-09-27T14:32:07.343Z","comments":true,"path":"算法/技巧篇/2022/03/08/【25-Hard】以k个节点为一组逆转单链表/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/08/%E3%80%9025-Hard%E3%80%91%E4%BB%A5k%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%BA%E4%B8%80%E7%BB%84%E9%80%86%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"以k个节点为一组逆转单链表给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶： 你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 12输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5] 示例 2： 12输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5] 示例 3： 12输入：head = [1,2,3,4,5], k = 1输出：[1,2,3,4,5] 示例 4： 12输入：head = [1], k = 1输出：[1] 提示： 列表中节点的数量在范围 sz 内 1 &lt;= sz &lt;= 5000 0 &lt;= Node.val &lt;= 1000 1 &lt;= k &lt;= sz Related Topics 递归 链表 法一：递归首先我们来分析一下这道题目，题目不难理解，就是以k个节点为一组逆转单链表，我们使用递归的思想来思考一下这道题 首先需要一个逆转前n个节点的方法 方法签名：public ListNode reverseKNode(ListNode head,int k) 123456789101112ListNode processor;// 这里的k要保证不超过链表长度public ListNode reverseKNode(ListNode head,int k)&#123; if(k == 1)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode1(head.next, k-1); head.next.next = head; head.next = processor; return node;&#125; 方法签名：public ListNode reverseKNode(ListNode head,ListNode end) 123456789101112ListNode processor;// [head,end)public ListNode reverseKNode(ListNode head,ListNode end)&#123; if(head.next == end)&#123; processor = head.next; return head; &#125; ListNode node = reverseKNode(head.next, end); head.next.next = head; head.next = processor; return node;&#125; 方法签名：public ListNode reverseKGroup(ListNode head, int k) 12345678910111213141516171819202122public ListNode reverseKGroup(ListNode head, int k)&#123; ListNode node = head; for (int i = 0; i &lt; k; i++) &#123; if(node==null)&#123; return head; &#125; node=node.next; &#125; ListNode newHead = reverseKNode(head,k,node); head.next=reverseKGroup(node,k); return newHead;&#125;private ListNode reverseKNode(ListNode head,int k,ListNode tail)&#123; if(k==1)&#123; return head; &#125; ListNode newHead=reverseKNode(head.next,k-1,tail); head.next.next=head; head.next=tail; return newHead;&#125; 法二：迭代首先需要一个逆转前n个节点的方法 方法签名：public ListNode reverseKNode(ListNode head,int k) 123456789101112public ListNode reverseKNode(ListNode head,int k)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur!=null &amp;&amp; k--!=0)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; 方法签名：public ListNode reverseKNode(ListNode head,ListNode end) 12345678910111213public ListNode reverseKNode(ListNode head,ListNode end)&#123; ListNode prev = null; ListNode cur = head; ListNode suffix; while(cur != end)&#123; suffix = cur.next; cur.next = prev; prev = cur; cur = suffix; &#125; return prev;&#125; 方法签名：public ListNode reverseKGroup(ListNode head, int k) 123456789101112131415161718192021222324252627public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode end = head; for (int i = 0; i &lt; k; i++) &#123; // 如果长度不足k，则直接返回头部，不用逆转 if(end==null)&#123; return head; &#125; end = end.next; &#125; ListNode newHead = reverseKNode(head, k); head.next = reverseKGroup(end, k); return newHead;&#125;public ListNode reverseKNode(ListNode head, int k)&#123; ListNode prev=null; ListNode cur=head; ListNode suffix; while(cur!=null&amp;&amp;k--!=0)&#123; suffix=cur.next; cur.next=prev; prev=cur; cur=suffix; &#125; return prev;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-逆转单链表","slug":"算法-逆转单链表","date":"2022-03-08T01:31:19.000Z","updated":"2022-09-27T13:41:52.693Z","comments":true,"path":"算法/技巧篇/2022/03/08/算法-逆转单链表/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/08/%E7%AE%97%E6%B3%95-%E9%80%86%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"逆转单链表逆转单链表，这是一个经典的单链表问题 本节不仅讲如何迭代去逆转单链表 还讲如何使用递归去逆转一部分单链表或者整个单链表 1234567public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 反转链表力扣206：反转链表 迭代实现 1、初始化三个节点prev = null（作为前置节点）、cur = head（作为当前节点）、suffix（作为后置节点） 2、开始循环条件为cur!=null的循环，cur将一直走到最后一个节点的下一个节点为null的地方 3、先将suffix指向cur的next，然后将cur的next指向前一个指针prev，然后prev变为cur，cur变为suffix 4、返回prev节点 初始化 开始循环 1234567891011121314151617class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return head; &#125; ListNode prev=null; ListNode cur=head; ListNode suffix; while(cur!=null)&#123; suffix=cur.next; cur.next=prev; prev = cur; cur=suffix; &#125; return prev; &#125;&#125; 递归实现 我们的 reverseList 函数定义是这样的： 输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。 先递归到源链表的最后一个节点 然后当前的head节点就是需要加入到反转好的链表中， head的next指针是逆转后的链表的最后一个节点 1234567891011class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null)&#123; return head; &#125; ListNode cur = reverseList(head.next); head.next.next=head; head.next=null; return cur; &#125;&#125; 反转前n个节点n&lt;&#x3D;链表长度 12345678910111213class Solution &#123; ListNode end = null; public ListNode reverseList(ListNode head,int n) &#123; if(n==1)&#123; end = head.next; return head; &#125; ListNode node = reverseList(head.next,n-1); head.next.next=head; head.next=end; return node; &#125;&#125; 反转指定索引范围的链表力扣92：反转链表 II 反转left到right部分的链表 如果当left为1，那不就回到上面的那个问题了 所以只需要在reverseBetween中不断递归直到left的时候，right也就变成了区间长度 1234567891011121314151617181920class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; if(left==1)&#123; return reverseList(head,right); &#125; head.next=reverseBetween(head.next,left-1,right-1); return head; &#125; ListNode end = null; public ListNode reverseList(ListNode head, int n) &#123; if(n==1)&#123; end = head.next; return head; &#125; ListNode node = reverseList(head.next,n-1); head.next.next=head; head.next=end; return node; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-解决单链表问题","slug":"算法-解决单链表问题","date":"2022-03-07T09:05:29.000Z","updated":"2022-09-27T13:51:41.791Z","comments":true,"path":"算法/技巧篇/2022/03/07/算法-解决单链表问题/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/07/%E7%AE%97%E6%B3%95-%E8%A7%A3%E5%86%B3%E5%8D%95%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"单链表对于单链表的操作，有很多技巧性的东西。 下面我们使用六道题来以题明技巧 合并两个有序链表力扣21：合并两个有序链表 123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; // 这里使用了一个虚节点来充当头部存放节点 ListNode virtual = new ListNode(-1); ListNode temp=virtual; ListNode l1 = list1; ListNode l2 = list2; // 这里循环退出条件是两者都不为null，因为其中只要有一者为null，A处代码就会爆空指针异常 while(l1!=null&amp;&amp;l2!=null)&#123; // 将较小的那一个放入virtual链表中 if(l1.val&gt;l2.val)&#123;// A temp.next=l2; l2=l2.next; &#125;else&#123; temp.next=l1; l1=l1.next; &#125; temp = temp.next; &#125; // 这里是为了防止出现两者长度不一致的情况，这里不需要遍历，直接将temp.next指向还不为空的那个指针 if(l1!=null)&#123; temp.next=l1; &#125; if(l2!=null)&#123; temp.next=l2; &#125; // 最后返回虚节点的next return virtual.next; &#125;&#125; 合并 k 个有序链表力扣23：合并k个有序链表 使用一个动态数组存储所有的链表的头结点 1234567891011121314151617181920212223class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode virtual = new ListNode(-1); ListNode temp = virtual; List&lt;ListNode&gt; nodes = new ArrayList&lt;&gt;(); for (ListNode list : lists) &#123; if(list!=null)&#123; nodes.add(list); &#125; &#125; while(!nodes.isEmpty())&#123; nodes.sort((a,b)-&gt; a.val-b.val); temp.next = nodes.get(0); temp=temp.next; if(nodes.get(0).next==null)&#123; nodes.remove(0); &#125;else &#123; nodes.set(0,nodes.get(0).next); &#125; &#125; return virtual.next; &#125;&#125; 寻找单链表的倒数第 k 个节点力扣19：删除倒数第k个节点 123456789101112131415161718192021class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; // fast指针先走n步 while(n--&gt;0)&#123; fast=fast.next; &#125; // 如果fast变为了null说明是走到了尾部，则说明倒数第n个节点就是头结点 // 删除头结点，那就是直接返回头结点的下一个节点作为头结点 if(fast==null)&#123; return head.next; &#125; while(fast.next!=null)&#123; slow=slow.next; fast=fast.next; &#125; slow.next=slow.next.next; return head; &#125;&#125; 寻找单链表的中点力扣876：寻找单链表的中点 使用快慢指针法，slow走一步，fast走两步，当fast走到最后的时候，slow自然就在中间了 1234567891011class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode slow=head; ListNode fast=head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; &#125; return slow; &#125;&#125; 当单链表节点个数为奇数的时候，slow指向的是正中间的位置 当单链表节点个数为偶数的时候，slow指向的是中间靠右的位置 判断单链表是否包含环力扣141：判断单链表是否成环 1234567891011121314151617public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; if(fast==null)&#123; return false; &#125; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; return true; &#125; &#125; return false; &#125;&#125; 进阶：找到成环的起点 12345678910111213141516171819202122public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 判断两个单链表是否相交并找出交点1、将第一条链表的尾部的next指向第二条链表的头部，然后返回成环的那个起点 注意：此法只是一个思路，但是力扣中这道题的校验是不允许修改原来的链表的 123456789101112131415161718192021222324252627282930public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode ha=headA; while(ha.next!=null)&#123; ha=ha.next; &#125; ha.next=headB; return detectCycle(headA); &#125; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 2、使用技巧直接找到相交点 12345678910111213141516171819public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode ha = headA; ListNode hb = headB; while(ha!=hb)&#123; if(ha==null)&#123; ha=headB; &#125;else&#123; ha=ha.next; &#125; if(hb==null)&#123; hb=headA; &#125;else&#123; hb=hb.next; &#125; &#125; return ha; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"JavaScript-原型和原型链","slug":"JavaScript-原型和原型链","date":"2022-03-05T12:18:26.000Z","updated":"2022-09-27T14:15:19.311Z","comments":true,"path":"前端/JavaScript/2022/03/05/JavaScript-原型和原型链/","link":"","permalink":"https://li-zhi.net.cn/%E5%89%8D%E7%AB%AF/JavaScript/2022/03/05/JavaScript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链prototype在JavaScript中，所有的函数都有一个prototype属性，该属性指向该函数的原型对象 12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.name = &#x27;kerwin&#x27;;let p1 = new Person();let p2 = new Person();console.log(p1.name);// kerwinconsole.log(p2.name);// kerwin 函数的prototype指向的就是对象原型，这个对象是调用构造函数时创建实例的原型对象，就是说p1和p2的原型对象是同一个 _proto_每个对象都会有一个属性，叫做_proto_，该属性指向该对象的原型对象，也就是构造函数的原型属性指向的对象 constructor每个原型都有一个constructor属性，指向该对象的构造函数 12345678910function Person()&#123; &#125;let person = new Person();console.log(Person.prototype._proto_ ==== Person);// trueconsole.log(person._proto_ === Person.prototype);// true// 在person中找不到constructor属性，所以向上在原型中找到该属性console.log(person.constructor === Person);// trueconsole.log(person.constructor === Person.prototype.constructor);console.log(person.constructor === person._proto_.constructor) 实例与原型当读取实例中的属性的时候，如果不存在该属性，则会去查找该对象的原型对象中是否存在该属性，如果不存在，则一直向上查找，一直找到最顶部为止 12345678910function Person(age)&#123; this.age = age;&#125;Person.prototype.name = &#x27;zhima&#x27;;let p1 = new Person();person.name = &#x27;kerwin&#x27;console.log(p1.name);// kerwin// 删除person对象中的name属性delete person.nameconsole.log(p1.name);// zhima 可以看到p1的name属性 显示输出了自身的属性值kerwin 当删除了对象中name属性之后，输出的是原型中的数据 原因是当对象内部不存在该属性的时候，会向上在原型中找属性，所以会输出kerwin 原型的原型原型是随着使用构造函数创建对象时，生成的一个对象。 那么原型也是一个对象，既然是一个对象，那么它一定也有原型 它的原型其实是通过Object对象的构造函数创建的 原型链简单回顾一下之前的知识点， prototype是每个函数的一个属性，指向原型对象 _proto_是每一个对象的一个属性，指向原型对象 constructor是每一个原型对象的一个属性，指向其绑定的构造函数 1每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎么样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层次递进，就构成了原型和实例的链条，这就是所谓的原型链的概念 ----------《摘自JavaScript高级程序设计》 那Object.prototype的原型是什么呢？是null 图中蓝色的线就是原型链","categories":[{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"}]},{"title":"算法-滑动窗口","slug":"算法-滑动窗口","date":"2022-03-05T12:13:46.000Z","updated":"2022-10-04T12:37:29.061Z","comments":true,"path":"算法/技巧篇/2022/03/05/算法-滑动窗口/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/05/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口滑动窗口的思路非常简单， 就是维护一个窗口， 不断滑动， 然后更新答案 滑动窗口的骨架1234567891011121314151617181920public void slidingWindow(String s1, String s2) &#123; int left = 0; int right = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : s1.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); // 当前符合needs条件的条数 int valid=0; while(right &lt; s2.length())&#123; now = s2.charAt(right++); // 窗口内的数据更新 while(// 左窗口收缩条件)&#123; // 收缩左窗口 &#125; &#125;&#125; 看完了骨架，直接上四个题目 最小覆盖子串力扣76：最小覆盖子串 1、我们先初始化 left = right = 0，把索引区间 [left, right) 中的内容称为窗口。 2、不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（即窗口中的内容包含了 t 中的所有字符）。 3、此时，我们停止增加 right，开始不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新结果。 4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 这时候left开始向右移动，直到window中的字符不满足target的字符，即valid不等于needs的size() 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public String minWindow(String s, String t) &#123; if(t.length()&gt;s.length())&#123; return &quot;&quot;; &#125; int len = s.length(); int left = 0; int right = 0; char now; char[] chars = s.toCharArray(); Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); // valid指的是need中的所有条件的满足个数 int valid = 0; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) &#123; // 这个是java8的map新特性，当map中不存在该值，自动创建值并赋值为1，当该值存在的时候，将其加1 needs.merge(c, 1, Integer::sum); &#125; int start=0; int minLength = Integer.MAX_VALUE; while(right&lt;len)&#123; now = chars[right++]; // 只有当前这个字符是t里面的，我再去将其放入窗口中 // 如果这时候窗口中的该字符数量达到了needs中的，则valid自增 if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; // 如果needs中的条件都满足了，则left要自增 while(valid==needs.size())&#123; // 这里使用right-left充当字符串长度，因为now = chars[right++];这里right已经自增了 if(right-left&lt;minLength)&#123; start=left; minLength = right-left; &#125; now = chars[left++]; if(window.get(now)!=null)&#123; // 这个是java8的map新特性，当map中存在该值，则将其加上-1 window.merge(now,-1,Integer::sum); if(window.get(now)&lt;needs.get(now))&#123; valid--; &#125; &#125; &#125; &#125; return minLength==Integer.MAX_VALUE?&quot;&quot;:s.substring(start,start+minLength); &#125;&#125; 字符串排序力扣567：字符串排序 1、先初始化left和right为0，把[left,right)范围的数据叫做窗口 2、将需要符合的字符串条件初始化到needs中 3、不断扩大right，使窗口逐渐变大 4、直到窗口长度等于s1的长度，如果这时候已经出现了符合条件的字符串直接返回true，反之，将left向右走，缩小窗口 5、重复3、4，直到right走到最后 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int left = 0; int right = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : s1.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int valid=0; while(right &lt; s2.length())&#123; now = s2.charAt(right++); if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; if(right-left == s1.length())&#123; now = s2.charAt(left++); if(valid == needs.size())&#123; return true; &#125; if(window.get(now)!=null)&#123; if(window.get(now).equals(needs.get(now)))&#123; valid--; &#125; window.merge(now,-1, Integer::sum); &#125; &#125; &#125; return false; &#125;&#125; 找到字符串中所有字母异位词力扣438：找到字符串中所有字母异位词 其实本题就是上面那一题，只不过这一题需要将所有的异位词出现的地方都放到一个List中 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int left = 0; int right = 0; int valid = 0; char now; Map&lt;Character, Integer&gt; needs = new HashMap&lt;&gt;(); for (char c : p.toCharArray()) &#123; needs.merge(c,1, Integer::sum); &#125; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); char[] chars = s.toCharArray(); while(right&lt;s.length())&#123; now = chars[right++]; if(needs.get(now)!=null)&#123; window.merge(now,1, Integer::sum); if(window.get(now).equals(needs.get(now)))&#123; valid++; &#125; &#125; if(right-left == p.length())&#123; if(valid==needs.size())&#123; result.add(left); &#125; now = chars[left++]; if(window.get(now)!=null)&#123; if(window.get(now).equals(needs.get(now)))&#123; valid--; &#125; window.merge(now,-1, Integer::sum); &#125; &#125; &#125; return result; &#125;&#125; 无重复最长子串力扣3：无重复字符的最长子串 1、初始化left和right为0，window作为窗口 2、将当前right处的字符在window中的数目加一 3、如果当前right处的字符在window中的数目已经大于1了。说明有了重复元素，需要将left不断左移，直到当前right处的字符在window中的数目不大于1 4、重复2、3操作 代码： 12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len&lt;2)&#123; return len; &#125; int left = 0; int right = 0; int maxLength=1; char now; Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); while(right&lt;len)&#123; now = s.charAt(right++); window.merge(now,1, Integer::sum); while(window.get(now)&gt;1)&#123; window.merge(s.charAt(left++),-1, Integer::sum); &#125; maxLength = Math.max(right-left,maxLength); &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-双指针技巧","slug":"算法-双指针技巧","date":"2022-03-04T23:49:11.000Z","updated":"2022-09-27T13:40:43.809Z","comments":true,"path":"算法/技巧篇/2022/03/05/算法-双指针技巧/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/05/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7/","excerpt":"","text":"双指针技巧对于双指针，一般分为快慢指针和前后指针 前者一般使用在链表中，后者一般使用在数组中。 123456789101112class ListNode &#123; int val; ListNode next; ListNode(int val) &#123; this.val = val; this.next = null; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 快慢指针快慢指针一般初始化两个指针分别指向链表的头结点 head 前进时快指针 fast 在前 慢指针 slow 在后 这就是快慢指针的核心 判断链表是否成环力扣141题：环形链表 单链表的特点是每一个节点只知道后置节点，不知道前置节点。如果我使用单指针想去解决这个判断成环 123456789public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode temp = head; while(temp!=null)&#123; temp = temp.next; &#125; return false; &#125;&#125; 当链表成环的时候，因为没有一个节点的后置节点为null，所以该方法一定是死循环，无法退出。 经典解法就是使用两个指针，fast指针跑得快，slow指针跑得慢。 如果链表没有环，跑得快的那个指针最终会遇到 null，说明链表不含环； 如果链表有环，快指针最终会超慢指针一圈，和慢指针相等，说明链表含有环。 以下是解法 1234567891011121314public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; return true; &#125; &#125; return false; &#125;&#125; 已知链表有环，返回环开始的地方力扣142题：环形链表 II 5就是那个环开始的地方 假设快指针走了2k步，则慢指针就一定走了k步，那么k其实就是环节点个数的整数倍 黄色的线就是快指针比慢指针多走的步数，即k,图上只画了一圈，但是实际可能不止一圈 设慢指针在环中走了m个节点。 则说明在环节点之前，一共有k-m个节点，就是说我可以从头结点往后走k-m次就可以找到该环开始的地方了。 但是如果想着如何把k-m求出来的话是有点困难的，所以我们来看看关于快指针的路径中可不可以出现k-m 我们现在来看看快指针走的2k长度的路径，它在环里面走过的路径长度是k+m，从相遇点到相遇点的距离是k 那么就是说快指针从相遇点在环中走k-m步就可以走到环开始的节点， 所以我们可以将slow置于head，与fast同步前进，当两个指针相同时，返回该值 代码： 12345678910111213141516171819202122public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next; fast=fast.next.next; if(slow==fast)&#123; break; &#125; &#125; if(fast==null||fast.next==null)&#123; return null; &#125; slow=head; while(slow!=fast)&#123; slow=slow.next; fast=fast.next; &#125; return fast; &#125;&#125; 寻找链表的中点力扣876：链表的中心节点 给出一个无环的链表，要求返回该链表的中点 使用快慢指针，当fast指针走到尾部的时候，slow就在链表中间位置了 以下是节点个数为奇数的情况 以下是节点个数为偶数的结果 可以发现，当个数为奇数的时候，慢指针正好在中心位置， 当个数为偶数的时候，慢指针在中心偏右的位置 这个算法在链表的归并算法中常常被用到 代码： 123456789public ListNode middleNode(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; 这是hash实现 12345678910public ListNode middleNode(ListNode head) &#123; Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode curr = head; int i = 0; while(curr != null)&#123; map.put(i++,curr); curr = curr.next; &#125; return map.get(i/2);&#125; 删除倒数第n个节点力扣19题：删除倒数第n个节点 思路就是快指针先走n步，然后慢指针和快指针同步向前，当快指针的next是null的时候，慢指针的下一个就是倒数第n个节点 123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode slow = head; ListNode fast = head; while(n--&gt;0)&#123; fast=fast.next; &#125; if(fast==null)&#123; return head.next; &#125; while(fast.next!=null)&#123; slow=slow.next; fast=fast.next; &#125; slow.next=slow.next.next; return head; &#125;&#125; 左右指针左右指针一般初始化left right两个变量来表示左边界和右边界 二分查找这里就不赘述二分查找的细节了，之前有写，这里就写一种最常见的 查找target找到则返回索引，没有找到则返回-1 123456789101112131415161718int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = (right + left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; return -1;&#125; 两数之和 题目中说，该数组是递增的， 通过left和right来调整大小从而判断是否存在两个数使得和为target 12345678910111213141516171819202122class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int left = 0; int right = numbers.length-1; int mid; int sum; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;1; sum=numbers[left]+ numbers[right]; if(sum==target)&#123; return new int[]&#123;left+1,right+1&#125;; &#125;else if(sum&gt;target)&#123; // 使大的值变小 right--; &#125;else &#123; // 使小的值变大 left++; &#125; &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 反转数组这个就很简单了，直接上代码 12345678910void reverseString(int[] arr) &#123; int left = 0; int right = arr.length - 1; while (left &lt; right) &#123; // 交换 arr[left] 和 arr[right] int temp = arr[left]; arr[left++] = arr[right]; arr[right--] = temp; &#125;&#125; 滑动窗口这个就是左右指针的重头戏了，掌握了这个方法后，可以解决一大类子字符串匹配的问题！ 这个放在下一篇文章中详解","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2022-03-02T10:06:48.000Z","updated":"2022-03-02T10:41:36.988Z","comments":true,"path":"设计模式/2022/03/02/设计模式-观察者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式定义：定义了对象之间的一对多依赖，让多个观察者监听同一个对象的行为，当该行为发生的时候，则做出一定的动作 天气变化了，发出提示 天气模型 1234567891011121314151617181920@Data@NoArgsConstructor@AllArgsConstructorpublic class Weather &#123; private String address; private Integer temperature; private List&lt;Observer&gt; observers; public void addObserver(Observer observer)&#123; observers.add(observer); &#125; public void removeObserver(Observer observer)&#123; observers.remove(observer); &#125; public void changeTemperature(int temperature)&#123; this.temperature=temperature; for (Observer observer : observers) &#123; observer.update(temperature); &#125; &#125;&#125; 观察者的接口 123public interface Observer &#123; void update(Integer temperature);&#125; 邮件的观察者 1234567public class EmailObserver implements Observer &#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发邮件告诉用户天气改变了，变为了&quot;+temperature); &#125;&#125; 短信观察者 123456public class MsgObserver implements Observer&#123; @Override public void update(Integer temperature) &#123; System.out.println(&quot;发短信告诉用户气温改变了，变为了&quot;+temperature); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模板方法模式","slug":"设计模式-模板方法模式","date":"2022-03-02T09:24:31.000Z","updated":"2022-03-02T10:06:27.982Z","comments":true,"path":"设计模式/2022/03/02/设计模式-模板方法模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法模式定义：定义一个操作的算法骨架，将一些操作延迟到子类实现。Template Method使得子类可以在不改变算法结构的基础上即可重新定义算法的某些特定步骤 其实该模式很简单，就是定义一个抽象类，然后定义一个抽象方法给子类去实现。 处理器 12345678910public abstract class Handler &#123; public void operation()&#123; System.out.println(&quot;做前期准备&quot;); System.out.println(&quot;准备就绪，开始处理&quot;); doHandler(); System.out.println(&quot;处理完毕&quot;); &#125; abstract void doHandler();&#125; 字符处理器 123456public class CharHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;将字符串转化&quot;); &#125;&#125; 字符串处理器 123456public class StringHandler extends Handler&#123; @Override void doHandler() &#123; System.out.println(&quot;字符串转化&quot;); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式-策略模式","date":"2022-03-02T04:11:02.000Z","updated":"2022-03-02T10:19:04.792Z","comments":true,"path":"设计模式/2022/03/02/设计模式-策略模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"策略模式定义：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式的变化独立于算法的使用者 有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 下面使用策略模式来优化 Version 1.2策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"算法-二分查找的多种写法","slug":"算法-二分查找的魔鬼细节探究","date":"2022-03-02T01:07:03.000Z","updated":"2022-10-24T03:18:17.539Z","comments":true,"path":"算法/技巧篇/2022/03/02/算法-二分查找的魔鬼细节探究/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/2022/03/02/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"二分查找二分查找作为数组的基操，肯定是要牢牢掌握的，其思想十分简单，但是对于细节的处理，就可以看出你对二分算法的理解深刻与否。 如果没有真正的理解细节处的内涵，二分查找算法的编写就是玄学编写，这里加不加等号呢？这里是+1还是不变呢？最后该返回啥呢？ 接下来我们就来看看这些细节该如何处理 下面使用三个二分查找使用的场景做出分析：寻找一个数、寻找左侧边界、寻找右侧边界 二分查找的骨架12345678910111213141516public int binarySearch(int[] nums, int target) &#123; int left=0; int right=..;// nums.length-1还是nums.length int mid; while(left..right)&#123;// &lt;=还是&lt; mid = (left+right)&gt;&gt;1;// (right-left)/2+left还是(left+right)&gt;&gt;1还是(right+left)/2 if(nums[mid]==target)&#123; ..=..; // right还是left mid-1还是mid &#125;else if(target&lt;nums[mid])&#123; right=..; // mid-1还是mid &#125;else &#123; left=..;// mid+1 &#125; &#125; return ..;// left或者要做什么处理&#125; 或许你经常看见一些代码不会将等于的情况单独列出来，但是我觉得对于二分查找的分析，将等于的情况单独分离出来，会更有利于理解，等到彻底理解后，随便怎么写都不会少搜索区间的时候，那就随便合并语句了。 上述骨架中..出现的地方就是我们需要去琢磨的细节之处了，乍一看，全是细节，所以叫魔鬼细节探究。 先解决最好解决的一个细节，很多人都在LeetCode官网中看到有时候官网对于中间值的取值会使用(right-left)/2+left有时候会使用(left+right)&gt;&gt;1有时候看见别人写的代码中又是(right+left)/2，肯定会很迷糊，这三者的计算到底有什么不同之处呢？ (right-left)/2+left这种写法是为了防止(left+right)因为数据过大导致溢出，导致mid计算错误， (left+right)&gt;&gt;1这是位运算，可能处理效率会高一点 (right+left)/2这就是正常写法，一般也不会出错 接下来按照二分查找的常见使用场景来逐个做出分析 查找一个数场景1：查找一个数，存在返回索引，不存在返回-1 123456789101112131415161718int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; return -1;&#125; 循环条件是left &lt;= right而不是left &lt; right？ 这里我们要说一下什么时候应该退出循环，就是当我所有的元素都搜索完成之后（即搜索区间里面没有元素的时候），或者是找到了目标值的时候可以直接终止，返回结果。 当right赋值为nums.length - 1，则搜索区间为[left,right]，所有元素搜索完成的条件应该是left==right+1，即搜索区间为[right+1,right]，符合要求。如果循环退出条件改为 left&lt;right，则退出循环的时候，搜索区间为[left,right]，会缺少搜索第left个元素。，不符合要求。 如果**right赋值为nums.length**，则搜索区间为[left,right)，所有元素搜索完成的条件应该是left==right，即搜索区间为[left,right) 当nums[mid] &gt; target的时候，为什么是right = mid - 1; 而不是right = mid; ？ 还是回到搜索区间的问题上，当我发现当前这个元素与target不等而是大于target，那么我只需要搜索左边区间，即将[left,right]分割为左边区间[left,mid-1]和右边区间[mid+1,right]，所以下一步应该将mid-1赋值给right 此算法的用途 这种方法只可以在找到目标值的情况下返回索引，但是当nums为[1,2,2,2,4]的时候，返回的值是2，没错，但是这样可能就无法满足我们的需求了，只能在数组是严格递增的情况下使用。 如果场景变为：查找一个数，如果找到则返回索引位置，如果找不到，则返回目标值插入数组的位置。 这个时候其实只要最后返回left即可。 返回左边界123456789101112131415161718192021int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; right= mid - 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; if(left&gt;=nums.length||nums[left]!=target)&#123; return -1; &#125; return left;&#125; 为什么最后返回的时候要做出判断？ 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid - 1，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，也要做出判断 为什么找到的一定是左边界？ 因为这一段代码， 123if(nums[mid] == target)&#123; right= mid - 1;&#125; 当数组元素等于目标元素的时候，不着急返回，而是缩小查找范围。因为需要查找左边界，所以需要向左边收缩区间 这里面while的循环条件可以改为left &lt; right吗？ 当然可以，只要理解了搜索区间，只要能够保证所有的元素都被查找了，怎么写都可以。 123456789101112131415161718192021222324int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length; int mid; while(left &lt; right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; right= mid; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid; &#125; &#125; if(left==nums.length)&#123; return -1; &#125; if(nums[left]!=target)&#123; return -1; &#125; return left;&#125; 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，需要单独做出判断 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid ，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 返回右边界123456789101112131415161718192021222324int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; int mid; while(left &lt;= right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; left = mid + 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid - 1; &#125; &#125; if(left==nums.length)&#123; return -1; &#125; if(nums[left]!=target)&#123; return -1; &#125; return left;&#125; 为什么最后返回的时候要做出判断？ 当目标元素比所有的值都大的时候，在最后一次循环的时候，left= mid + 1，left此时为数组长度，这时候则说明，该元素在此数组中不存在，也要做出判断 当目标元素比所有的值都小的时候，在最后一次循环的时候，right = mid - 1，left此时为0，但是无法确定该元素是否为目标元素，所以需要做出判断， 为什么找到的一定是右边界？ 因为这一段代码， 123if(nums[mid] == target)&#123; left = mid + 1;&#125; 当数组元素等于目标元素的时候，不着急返回，而是缩小查找范围。因为需要查找右边界，所以需要向右边收缩区间 如何修改循环条件为left &lt; right？ 12345678910111213141516171819202122232425262728int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length; int mid; while(left &lt; right) &#123; mid = left + (right - left) / 2; if(nums[mid] == target)&#123; left = mid + 1; &#125; else if (nums[mid] &lt; target)&#123; left = mid + 1; &#125; else if (nums[mid] &gt; target)&#123; right = mid; &#125; &#125; // 当target比数组所有元素都大的时候，right和left都走到了数组长度的位置， // 如果数组最后一个元素不是这说明数组中没有target元素 if(nums[left-1]!=target)&#123; return -1; &#125; // 当target比数组中所有元素都小的时候，right和left都走到了-1的位置， // 这时候这说明，数组中不存在target元素，直接返回-1 if(left&lt;0)&#123; return -1; &#125; return left - 1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【704-Easy】二分查找","slug":"【704-Easy】二分查找","date":"2022-03-02T00:40:52.000Z","updated":"2022-09-27T14:25:33.426Z","comments":true,"path":"算法/刷题篇/2022/03/02/【704-Easy】二分查找/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/02/%E3%80%90704-Easy%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 Related Topics 数组 二分查找 法一：二分查找123456789101112131415161718class Solution &#123; public int search(int[] nums, int target) &#123; int left=0; int right=nums.length-1; int mid; while(left&lt;=right)&#123; mid=(left+right)&gt;&gt;1; if(target&lt;nums[mid])&#123; right=mid-1; &#125;else if(target&gt;nums[mid])&#123; left=mid+1; &#125;else &#123; return mid; &#125; &#125; return -1; &#125;&#125; 官方代码中 left + (right - left) &#x2F; 2 就和 (left + right) &#x2F; 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【74-Medium】搜索二维矩阵","slug":"【74-Medium】搜索二维矩阵","date":"2022-03-01T10:49:43.000Z","updated":"2022-10-04T12:47:21.500Z","comments":true,"path":"算法/刷题篇/2022/03/01/【74-Medium】搜索二维矩阵/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/01/%E3%80%9074-Medium%E3%80%91%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/","excerpt":"","text":"搜索二维矩阵编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例 2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 100 -104 &lt;= matrix[i][j], target &lt;= 104 Related Topics 数组 二分查找 矩阵 法一：二维看成一维根据题目所给的矩阵性质， 可以得知该二维数组的每一行顺次排下来就是一个一维的升序数组， 那我们可以依赖下标和一维索引的关系来进行二分查找 12345678910111213141516171819202122class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m=matrix.length; int n=matrix[0].length; int left=0; int right=m*n-1; int mid; int value; while(left&lt;=right)&#123; mid=(right+left)&gt;&gt;1; value=matrix[mid/n][mid%n]; if(value&gt;target)&#123; right=mid-1; &#125;else if(value&lt;target)&#123; left=mid+1; &#125;else &#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【240-Medium】搜索二维矩阵II","slug":"【240-Medium】搜索二维矩阵II","date":"2022-03-01T08:51:22.000Z","updated":"2022-03-01T10:54:05.281Z","comments":true,"path":"算法/2022/03/01/【240-Medium】搜索二维矩阵II/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/03/01/%E3%80%90240-Medium%E3%80%91%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/","excerpt":"","text":"搜索二维矩阵II编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 示例 2： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= n, m &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -109 &lt;= target &lt;= 109 Related Topics 数组 二分查找 分治 矩阵 法一：二分查找12345678910111213141516public boolean searchMatrix(int[][] matrix, int target) &#123; int m=matrix.length; int n=matrix[0].length; int i=m-1; int j=0; while(i&gt;=0&amp;&amp;j&lt;n)&#123; if(matrix[i][j]==target)&#123; return true; &#125;else if(matrix[i][j]&gt;target)&#123; i--; &#125;else &#123; j++; &#125; &#125; return false;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","slug":"【34-Medium】在排序数组中查找元素的第一个和最后一个位置","date":"2022-03-01T08:49:22.000Z","updated":"2022-09-27T14:31:49.719Z","comments":true,"path":"算法/刷题篇/2022/03/01/【34-Medium】在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/01/%E3%80%9034-Medium%E3%80%91%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 Related Topics 数组 二分查找 法一：二分查找123456789101112131415161718192021222324252627282930class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int first = binarySearch(nums,target); if(first==-1)&#123; return new int[]&#123;-1,-1&#125;; &#125; int end=binarySearch(nums,target+1); if(end&lt;=first)&#123; return new int[]&#123;-1,-1&#125;; &#125; return new int[]&#123;first,end-1&#125;; &#125; private int binarySearch(int[] nums, int target) &#123; int left=0; int right=nums.length-1; int mid; while(left&lt;=right)&#123; mid = (left+right)&gt;&gt;1; if(nums[mid]==target)&#123; right=mid-1; &#125;else if(target&lt;nums[mid])&#123; right=mid-1; &#125;else &#123; left=mid+1; &#125; &#125; return left; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【378】有序矩阵中第k小的元素","slug":"【378-Medium】有序矩阵中第k小的元素","date":"2022-03-01T04:57:57.000Z","updated":"2022-09-27T14:27:53.602Z","comments":true,"path":"算法/刷题篇/2022/03/01/【378-Medium】有序矩阵中第k小的元素/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/03/01/%E3%80%90378-Medium%E3%80%91%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"有序矩阵中第k小的元素 在做这道题之前最好把这几题做了 【74-Medium】搜索二维矩阵 【240-Medium】搜索二维矩阵II 给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。 你必须找到一个内存复杂度优于 O(n2) 的解决方案。 示例 1： 123输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8输出：13解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13 示例 2： 12输入：matrix = [[-5]], k = 1输出：-5 提示： n == matrix.length n == matrix[i].length 1 &lt;= n &lt;= 300 -109 &lt;= matrix[i][j] &lt;= 109 题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列 1 &lt;= k &lt;= n^2 进阶： 你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题? 你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。 Related Topics 数组 二分查找 矩阵 排序 堆（优先队列） 法一：暴力枚举先将所有的数据放到一个集合中，然后直接排序，取出要求的元素 123456789101112class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; List&lt;Integer&gt; list=new ArrayList(); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; list.add(matrix[i][j]); &#125; &#125; list.sort((a,b)-&gt;a-b); return list.get(k-1); &#125;&#125; 法二：二分查找该矩阵是一个行是递增的，列是递增的，则说明左上角matrix[0][0]是最小值右下角matrix[len-1][len-1]是最大值 当mid为15的时候可以将其划分为这样的两个区域，左上部分和右下部分， 左上部分为小于等于mid的所有元素 右下部分为大于mid的所有元素 如果左上部分元素的个数比k大， 这说明mid不是第k个最小元素 将区域减半，继续以上的过程 流程图粉色代表left元素，绿色代表right元素，橙色代表当前要检查的元素 这次示例是k等于8的情况 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; int len=matrix.length; int left=matrix[0][0]; int right = matrix[len-1][len-1]; int mid; while(left&lt;right)&#123; // 就是自己除以2，只是这样写的话更装B一点 mid=(left+right)&gt;&gt;1; if(check(matrix,mid,k))&#123; right = mid; &#125;else &#123; // 这个加一是因为check中将小于和等于mid的元素都划分到左上部分了，所以left必须要加一 left = mid+1; &#125; &#125; return left; &#125; private boolean check(int[][] matrix, int mid, int k) &#123; int i=0; int j=matrix.length-1; int nums=0; while(i&lt;matrix.length&amp;&amp;j&gt;=0)&#123; if(matrix[i][j]&lt;=mid)&#123; nums+=j+1; i++; &#125;else &#123; j--; &#125; &#125; return nums&gt;=k; &#125;&#125; 关于这个left+1一定在矩阵中的论证 可以先把这一题做了 【34-Medium】在排序数组中查找元素的第一个和最后一个位置 我找了官网评论区的几个评论 1234我们先看check函数.check函数的目的是统计矩阵里小等于mid的元素数目count. 再判断count和k的关系.因为mid = (l + r) / 2这种划分方法是把矩阵划分成了[left , mid] 与[mid + 1, right]两部分. 当 count &lt; k 时, 说明mid太小了, 我们应该在[mid + 1, right] 这个范围里查找. 否则在[left, mid]范围里查找.如果存在一个不在矩阵中的数a满足条件, 因为a不在矩阵中,那count统计的元素肯定都是小于a的, 那一定存在一个比a小且在矩阵中的数b满足条件,即从小于a的数变成了小于等于b的数 .等用题目中的例子,x = 13 和x = 14 都满足小于等于x的元素数目等于8, 对14来说统计的都是小于它的数, 而对13来说统计的都是小于等于它的数. 问题来了, 那为何取到的不是14而是13呢?因为我们取mid的取法是 mid = (left + right) / 2, 当left &lt; right时, mid 永远 取不到right, 想要mid取到right ,只有left == right. 但循环条件是 while(left &lt; right),当 left == right时循环已经终止. 所以我们得到会是一个左边界. 还是用题目中的例子, 假设left = 13, right = 14 则 mid = (13 + 14) / 2 = 13 1二分法的精髓是，不断排除错误答案，最后剩下的就是正确答案。先记住这句话，我们再来看题目，如果 我们从 二分取出来的 mid，恰好不在矩阵中，那么这个数字，是无法 左右两个条件都满足的，否则矩阵就少一个数了。所以在左右排除的过程中，一定会将其排除掉的。 举例说明， 一个 3*3 的矩阵，取第 3 小的元素a，那么在矩阵中，一定是有 2个 小于等于 a的元素，以及6个大于等于a的元素。如果元素b不在矩阵中，且满足这两个条件，那么矩阵一共，只能有 2+6 = 8个元素了，所以是不可能的。 1综合前几位大佬的思路，谈谈如何证明解法三中的left必出现在矩阵中。解法三中二分查找后退出循环后，left为min&#123;x|矩阵中小于等于x的元素个数大于等于k&#125;。假设left不出现在矩阵中，那么矩阵中小于等于left的元素集合实则为矩阵中小于left的元素集合。从矩阵中小于left的元素集合中选择最大值，记为b。那么矩阵中小于等于b的元素个数大于等于k，但b&lt;left与left=min&#123;x|矩阵中小于等于x的元素个数大于等于k&#125;矛盾，所以left必出现在矩阵中。 1之前考虑怎么保证算出值一定在矩阵里呢，我是这么想的，假设答案应该是m为第k个元素，s为第（k+1）个元素，那么使得矩阵中有k个比mid小于等于的元素，mid一定会在m与s之间，而算法中找到的是left，仔细想，其实就是第一个满足有k个比自身小于等于的元素，无疑m是第一个，所以找到的left一定是在矩阵中的","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-装饰者模式","slug":"设计模式-装饰者模式","date":"2022-03-01T03:31:14.000Z","updated":"2022-09-27T13:57:13.096Z","comments":true,"path":"设计模式/2022/03/01/设计模式-装饰者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"装饰者模式定义：在不改变原有对象的基础上，将功能附加到对象上 这个其实大家在平时写代码的时候就已经用过了，只是不知道这是一个模式 下面看一个案例 有一个组件的接口，然后我有一个具体的实现类，现在我需要在这个具体实现类的基础上进行功能拓展 组件接口 123public interface Component &#123; void operation();&#125; 具体接口实现 123456public class ConcreteComponent implements Component&#123; @Override public void operation() &#123; System.out.println(&quot;实现组件功能&quot;); &#125;&#125; 拓展功能抽象类 12345678public abstract class EnhanceComponent implements Component&#123; protected Component component; public EnhanceComponent(Component component) &#123; this.component = component; &#125;&#125; 具体增强类 1234567891011public class ConcreteEnhanceComponent extends EnhanceComponent&#123; public ConcreteEnhanceComponent(Component component) &#123; super(component); &#125; @Override public void operation() &#123; component.operation(); System.out.println(&quot;拓展功能一&quot;); &#125;&#125; 优点： 不改变原有代码的情况下，对原来的类进行增强 使用不同的组合可以实现不同的人效果 符合开闭原则","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-适配器模式","slug":"设计模式-适配器模式","date":"2022-03-01T03:10:43.000Z","updated":"2022-03-01T03:30:45.584Z","comments":true,"path":"设计模式/2022/03/01/设计模式-适配器模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"适配器模式定义：将一个类的接口转换为用户希望的另一个接口。这使得原本由于接口不兼容而不能一起工作的那些类就可以一起工作了 接下来我们来模拟USB转接网线口，从而使电脑上网的案例 网线接口 123public interface NetWorkThread &#123; void connectNetWork();&#125; 华为的网线 123456public class HuaWeiNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;华为网线连接网络，可以上网了&quot;); &#125;&#125; 自制的网线 123456public class CustomerNetWorkThread implements NetWorkThread&#123; @Override public void connectNetWork() &#123; System.out.println(&quot;自制网线，可以上网了&quot;); &#125;&#125; 适配器（网线口变为USB口） 123public interface Adapter &#123; void netWorkToUSB();&#125; 华为的适配器（转接口） 1234567891011121314151617public class HuaWeiAdapter implements Adapter&#123; private NetWorkThread netWorkThread; public void setNetWorkThread(NetWorkThread netWorkThread) &#123; this.netWorkThread = netWorkThread; &#125; @Override public void netWorkToUSB() &#123; if(netWorkThread==null)&#123; System.out.println(&quot;适配器没有网线插入！&quot;); return; &#125; System.out.println(&quot;华为适配器适配了网线&quot;); netWorkThread.connectNetWork(); &#125;&#125; 电脑 123456789101112131415public class Computer &#123; private Adapter adapter; public void setAdapter(Adapter adapter) &#123; this.adapter = adapter; &#125; public void connectToNetWork()&#123; if(adapter!=null)&#123; adapter.netWorkToUSB(); &#125;else &#123; System.out.println(&quot;没有插网线！&quot;); &#125; &#125;&#125; 客户端 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); HuaWeiAdapter huaWeiAdapter = new HuaWeiAdapter(); computer.setAdapter(huaWeiAdapter); computer.connectToNetWork(); System.out.println(&quot;===================&quot;); huaWeiAdapter.setNetWorkThread(new HuaWeiNetWorkThread()); computer.connectToNetWork(); &#125;&#125; 控制台输出 123456没有插网线！===================适配器没有网线插入！===================华为适配器适配了网线华为网线连接网络，可以上网了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【5-Medium】最长回文数","slug":"【5-Medium】最长回文数","date":"2022-02-28T13:24:51.000Z","updated":"2022-09-27T14:33:27.026Z","comments":true,"path":"算法/刷题篇/2022/02/28/【5-Medium】最长回文数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/28/%E3%80%905-Medium%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"最长回文数给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 Related Topics 字符串 动态规划 法一：暴力枚举123456789101112131415161718192021222324252627282930class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)&#123; return s; &#125; char[] chars = s.toCharArray(); int begin = 0; int end = 0; for (int i = 0; i &lt; s.length() - 1; i++) &#123; for (int j = i+1 ; j &lt; s.length(); j++) &#123; if((j - i + 1) &gt; (end - begin + 1) &amp;&amp; isValid(chars,i,j))&#123; begin = i; end = j; &#125; &#125; &#125; return s.substring(begin, end+1); &#125; private boolean isValid(char[] chars, int left, int right) &#123; while(left &lt; right)&#123; if(chars[left] != chars[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;&#125; 法二：中心扩散将每”一位”作为中心向两边扩撒， 每次扩散分两种情况， 第一种情况是以当前那一位为中心向两边扩散 第二种情况是以当前那一位和下一位为中心向两边扩散 取这两种情况的最值max 如果max比maxLen大的话，计算得出begin‘ 最后直接返回截取的字符串 这是我的解法 12345678910111213141516171819202122232425class Solution &#123; public String longestPalindrome(String s)&#123; if (s.length() &lt; 2) &#123; return s; &#125; int begin = 0; int maxLen = 1; for (int i = 0; i &lt; s.length(); i++) &#123; int max = Math.max(expand(s,i,i),expand(s,i,i+1)); if(max &gt; maxLen)&#123; maxLen = max; begin = i - (max - 1)/2; &#125; &#125; return s.substring(begin, maxLen+begin); &#125; public int expand(String s, int left, int right) &#123; while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; return right - left - 1; &#125;&#125; 这是官方的解法 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) &#123; return &quot;&quot;; &#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 法三：动态规划对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。 例如对于字符串 “ababa’”，如果我们已经知道 “bab” 是回文串这层关系，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是a 使用dp[][]二位数组来存储这层关系 即使用dp[i][j]来表示s字符串的i到j是否是回文数 如果当前要判断的范围是dp[left][right]，字符串长度为x 第一步先看首尾是否一致， 如果不一致，则dp[left][right]直接为false， 如果一致，则进入下一步判断 如果当前判断的字符串长度小于3 为什么是3呢？ 如果长度为1，则本身就是字符串，形成自回文 如果长度为2，则首尾一致的情况下，可以直接判断为回文 如果长度为3，则首尾一致的情况下，也可以直接判断回文 这三组数据是后面做判断的支撑 则直接将dp[left][right]赋值为true 反之将dp[left+1][right-1]（即去掉首尾的时候是否为回文数）的回文结构赋值给dp[i][j] 这些结束后，当dp[left][right]是true时， 则将当前循环长度和存储的maxLen进行比较， 如果当前循环长度较大，则将其赋值给maxLen，将left赋值给begin 反之，直接进行下一次循环 官方代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) &#123; // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) &#123; // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) &#123; break; &#125; if (charArray[i] != charArray[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125;&#125; 下面是我理解思路后写的 对于变量的命名更贴近其本身的含义 可能会更好理解一点 1234567891011121314151617181920212223242526272829303132333435363738public String longestPalindrome1(String s) &#123; int len = s.length(); if(len &lt; 2)&#123; return s; &#125; int begin = 0; int maxLen = 1; char[] chars = s.toCharArray(); boolean[][] dp = new boolean[len][len]; // dp[i][j]即表示s[i..j]是否为回文数 // 对角线即为每个字符本身那就可以直接初始化为true // 也可以不初始化这个，但是为了语义完整，最好还是加上 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; //x表示长度，从长度为2开始，因为长度为1的情况可以直接判断 for (int x = 2 ; x &lt;= len; x++) &#123; //循环次数为总长度减当前循环的长度再加一 for (int left = 0; left &lt; len - x + 1; left++) &#123; //x=right-left+1 int right = x + left - 1; if(chars[left] != chars[right])&#123; dp[left][right] = false; &#125;else &#123; if(x &lt; 4)&#123; dp[left][right] = true; &#125;else &#123; dp[left][right] = dp[left+1][right-1]; &#125; &#125; if(dp[left][right] &amp;&amp; x &gt; maxLen)&#123; begin = left; maxLen = x; &#125; &#125; &#125; return s.substring(begin, maxLen+begin);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于权限修饰符protected","slug":"关于权限修饰符protected","date":"2022-02-28T10:05:05.000Z","updated":"2022-10-04T13:56:03.490Z","comments":true,"path":"琐碎的知识/2022/02/28/关于权限修饰符protected/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/28/%E5%85%B3%E4%BA%8E%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6protected/","excerpt":"","text":"权限修饰符我们先回顾一下java中的权限修饰符 权限修饰符 同类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 对于public和private大家都很了解了，但是对于protected，大家可能对它的概念可能就一句话：被protected修饰的成员对于本包和其子类可见。 该权限修饰符的关键是 基类的protected成员属性是包内可见的，并且对所有子类可见 若子类与基类不在同一包下，则在子类中，子类实例可以访问从基类继承来的protected方法，而不能访问基类实例的protected方法 遇到protected 首先思考这个protected来自何方 接着看其和这个地方是不是同包 最后看其是否有父子类关系 可以通过以下几个Test来掌握protected的用法 注意：观察包限定名 模型 12345678910package com.lizhi.protect.p1;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 1234package com.lizhi.protect.p1;public class Son1 extends Feather1&#123;&#125; 123456package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;public class Son11 extends Feather1 &#123;&#125; 测试 1234567891011121314151617package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译通过，因为该测试类与Feather1处于同一包下 son1.clone();//编译通过，因为该测试类与Feather1处于同一包下 son2.f();//编译通过，因为该测试类与Feather1处于同一包下 son2.clone();//编译通过，因为该测试类与Feather1处于同一包下 feather1.f();//编译通过，因为该测试类与Feather1处于同一包下 feather1.clone();//编译通过，因为该测试类与Feather1处于同一包下 &#125;&#125; 测试 12345678910111213141516171819package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;import com.lizhi.protect.p11.Son11;public class Test &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 son2.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下，该类也不是Feather1的子类 &#125;&#125; 测试 123456789101112131415161718package com.lizhi.protect.p11;import com.lizhi.protect.p1.Feather1;import com.lizhi.protect.p1.Son1;public class Son11 extends Feather1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类所在的地方是Feather1的子类 son2.clone();//编译通过，因为该测试类所在的地方是Feather1的子类 feather1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 feather1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.f();//编译不通过，因为该测试类与Feather1处于不同一包下 son1.clone();//编译不通过，因为该测试类与Feather1处于不同一包下 &#125;&#125; 测试 1234567891011121314151617181920212223package com.lizhi.protect.p1;import com.lizhi.protect.p11.Son11;public class Feather1 &#123; protected void f()&#123;&#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; public static void main(String[] args) throws CloneNotSupportedException &#123; Feather1 feather1 = new Feather1(); Son1 son1 = new Son1(); Son11 son2 = new Son11(); son2.f();//编译通过，因为该测试类是Son1和Son11的父类 son2.clone();//编译通过，因为该测试类是Son1和Son11的父类 feather1.f();//编译通过，因为该测试类是Son1和Son11的父类 feather1.clone();//编译通过，因为该测试类是Son1和Son11的父类 son1.f();//编译通过，因为该测试类是Son1和Son11的父类 son1.clone();//编译通过，因为该测试类是Son1和Son11的父类 &#125;&#125; 测试 12345678910package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译不通过 &#125;&#125; 说明：myobject4的clone直接来自MyObject4类本身 其范围是MyObjcet4的子类与其同包的类 Test4都不满足 所以编译不通过 测试 1234567package com.lizhi.protect.p4;import com.lizhi.protect.p44.Test4;public class MyObject4 extends Test4&#123; &#125; 12345678910package com.lizhi.protect.p44;import com.lizhi.protect.p4.MyObject4;public class Test4 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; MyObject4 myObject4 = new MyObject4(); myObject4.clone();//编译通过 &#125;&#125; 说明：myobject4的clone直接来源于Test4 范围是Test4子类及其同包的类 满足与其同包 编译通过","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"算法-旋转的数字","slug":"算法-旋转的数字","date":"2022-02-28T07:58:54.000Z","updated":"2022-11-05T14:13:42.931Z","comments":true,"path":"算法/自己出的题目/2022/02/28/算法-旋转的数字/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84%E9%A2%98%E7%9B%AE/2022/02/28/%E7%AE%97%E6%B3%95-%E6%97%8B%E8%BD%AC%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"旋转的数字 这是自己起的题目名 直接上5阶旋转数字的示例图 分析这道题一看就知道是不可能一行一行输出的 我们需要通过一个二位数组先来计算出来这个矩阵的数据 再遍历输出这个矩阵 那么如何操作这个二位矩阵呢？ 通过一个大循环限制循环次数 有四个小循环 第一个循环用来写入这一次循环中水平向左的数据 第二个循环用来写入这一次循环中水平向下的数据 第三个循环用来写入这一次循环中水平向右的数据 第四个循环用来写入这一次循环中水平向上的数据 流程图粉红色的是标注为每次大循环的开始处 PS：图片很多，过程很详细 代码1234567891011121314151617181920212223242526272829public int[][] rotateNumber(int n)&#123; int[][] matrix = new int[n][n]; int counter=1; int timer; for (int i = 0; i &lt; n / 2; i++) &#123; timer = n - i - 1; //-&gt; for (int j = i; j &lt; timer; j++) &#123; matrix[i][j]=counter++; &#125; //↓ for (int j = i ; j &lt; timer; j++) &#123; matrix[j][timer]=counter++; &#125; //&lt;- for (int j = timer; j &gt; i ; j--) &#123; matrix[timer][j]=counter++; &#125; //↑ for (int j =timer; j &gt; i ; j--) &#123; matrix[j][i]=counter++; &#125; &#125; // 如果是奇数，单独处理中间那一格数据 if(n%2!=0)&#123; matrix[n/2][n/2]=n*n; &#125; return matrix;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"自己出的题目","slug":"算法/自己出的题目","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法-螺旋数字","slug":"算法-螺旋数字","date":"2022-02-28T01:03:17.000Z","updated":"2022-11-05T14:13:25.333Z","comments":true,"path":"算法/自己出的题目/2022/02/28/算法-螺旋数字/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84%E9%A2%98%E7%9B%AE/2022/02/28/%E7%AE%97%E6%B3%95-%E8%9E%BA%E6%97%8B%E6%95%B0%E5%AD%97/","excerpt":"","text":"螺旋数字 这是自己起的题目名字 直接上6阶螺旋数字的示例图 传入数字n，最后输出n阶的螺旋数字 123public void spiralNumber(int n)&#123; &#125; 控制台输出 1234561 2 6 7 15 16 3 5 8 14 17 4 9 13 18 10 12 19 11 20 21 分析这道题目的话，循环写的稍微多点的都知道，我不可能直接输出1 2 6 7 15 16这一行数据的 而是应该通过一个二维数组来先将数据计算好，然后将此二维数组输出，这样才可以达到目的 那么如何通过二维数组来达到目的呢？ 我是用一个大循环中套两个小循环来做的 外面大循环用来限制循环次数的 内层第一个循环是用来向右上方走的 内层第二个循环是用来向左下方走的 流程图粉红色的是标注为每次大循环的开始处 标注内层循环初始化的是该循环刚要开始时候的数据 PS：图片很多，过程很详细 代码代码很少 123456789101112131415161718192021public int[][] spiralNumber(int n)&#123; int[][] matrix = new int[n][n]; int counter = 1; int j; int end; for (int i = 0; i &lt; n; i+=2) &#123; j=0; for (int k = i; k &gt;= 0; k--) &#123; matrix[k][j++]=counter++; &#125; end=j; // 如果n是奇数，在最后一次大循环中就不会有这个小循环了 if(j &gt;= n)&#123; break; &#125; for (int k = 0; k &lt;= end; k++) &#123; matrix[k][j--]=counter++; &#125; &#125; return matrix;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"自己出的题目","slug":"算法/自己出的题目","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-门面模式","slug":"设计模式-门面模式","date":"2022-02-28T00:38:22.000Z","updated":"2022-02-28T00:59:19.367Z","comments":true,"path":"设计模式/2022/02/28/设计模式-门面模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"门面模式定义：为子系统中的一组接口提供一个一致的高层接口，使得这一子系统更加容易使用 实现子系统1 12345public class System1 &#123; public void operateA()&#123; System.out.println(&quot;子系统1的A操作&quot;); &#125;&#125; 子系统2 12345public class System2 &#123; public void operateB()&#123; System.out.println(&quot;子系统2的B操作&quot;); &#125;&#125; 子系统3 12345public class System3 &#123; public void operateC()&#123; System.out.println(&quot;子系统3的C操作&quot;); &#125;&#125; 系统门面 1234567891011public class SystemFacade &#123; private System1 system1 = new System1(); private System2 system2 = new System2(); private System3 system3 = new System3(); public void operateABC()&#123; system1.operateA(); system2.operateB(); system3.operateC(); &#125;&#125; 客户端调用 12345public class Client &#123; public static void main(String[] args) &#123; new SystemFacade().operateABC(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【981-Medium】基于时间的键值存储","slug":"【981-Medium】基于时间的键值存储","date":"2022-02-27T04:15:00.000Z","updated":"2022-09-27T14:24:24.039Z","comments":true,"path":"算法/刷题篇/2022/02/27/【981-Medium】基于时间的键值存储/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/27/%E3%80%90981-Medium%E3%80%91%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/","excerpt":"","text":"基于时间的键值存储设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。 实现 TimeMap 类： TimeMap() 初始化数据结构对象 void set(String key, String value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 &#96;&#96;&#96;String get(String key, int timestamp) 1234567 - 返回先前调用 `set(key, value, timestamp_prev)` 所存储的值，其中 `timestamp_prev &lt;= timestamp` 。 - 如果有多个这样的值，则返回对应最大的 `timestamp_prev` 的那个值。 - 如果没有值，则返回空字符串（`&quot;&quot;`）。**示例：** 输入：[“TimeMap”, “set”, “get”, “get”, “set”, “get”, “get”][[], [“foo”, “bar”, 1], [“foo”, 1], [“foo”, 3], [“foo”, “bar2”, 4], [“foo”, 4], [“foo”, 5]]输出：[null, null, “bar”, “bar”, null, “bar2”, “bar2”] 解释：TimeMap timeMap &#x3D; new TimeMap();timeMap.set(“foo”, “bar”, 1); &#x2F;&#x2F; 存储键 “foo” 和值 “bar” ，时间戳 timestamp &#x3D; 1timeMap.get(“foo”, 1); &#x2F;&#x2F; 返回 “bar”timeMap.get(“foo”, 3); &#x2F;&#x2F; 返回 “bar”, 因为在时间戳 3 和时间戳 2 处没有对应 “foo” 的值，所以唯一的值位于时间戳 1 处（即 “bar”） 。timeMap.set(“foo”, “bar2”, 4); &#x2F;&#x2F; 存储键 “foo” 和值 “bar2” ，时间戳 timestamp &#x3D; 4timeMap.get(“foo”, 4); &#x2F;&#x2F; 返回 “bar2”timeMap.get(“foo”, 5); &#x2F;&#x2F; 返回 “bar2” 12345678```java/** * Your TimeMap object will be instantiated and called as such: * TimeMap obj = new TimeMap(); * obj.set(key,value,timestamp); * String param_2 = obj.get(key,timestamp); */ 提示： 1 &lt;= key.length, value.length &lt;= 100 key 和 value 由小写英文字母和数字组成 1 &lt;= timestamp &lt;= 107 set 操作中的时间戳 timestamp 都是严格递增的 最多调用 set 和 get 操作 2 * 105 次 Related Topics 设计 哈希表 字符串 二分查找 法一：内置结构Map&lt;Integer,TreeMap&lt;Integer,String&gt;&gt;这是自己写的，但是超时了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TimeMap &#123; private Map&lt;String, TreeMap&lt;Integer,String&gt;&gt; map ; public TimeMap() &#123; map = new HashMap(); &#125; public void set(String key, String value, int timestamp) &#123; TreeMap&lt;Integer, String&gt; sm = map.get(key); if(sm==null) &#123; TreeMap&lt;Integer, String&gt; v = new TreeMap&lt;&gt;(); v.put(timestamp, value); map.put(key, v); &#125;else &#123; sm.put(timestamp,value); &#125; &#125; public String get(String key, int timestamp) &#123; TreeMap&lt;Integer, String&gt; sm = map.get(key); if(sm==null)&#123; return null; &#125; int find = binarySearch(sm.keySet().toArray(new Integer[]&#123;&#125;), timestamp); if(find==-1)&#123; return &quot;&quot;; &#125;else &#123; return sm.get(find); &#125; &#125; private int binarySearch(Integer[] nums, int target) &#123; int left = 0; int right = nums.length-1; int mid; while (left&lt;=right) &#123; mid = (left+right)/2; if(nums[mid]==target)&#123; return target; &#125;else if(nums[mid]&gt;target)&#123; right = mid - 1; &#125;else &#123; left = mid + 1; &#125; &#125; if(left==0)&#123; return -1; &#125; return nums[left-1]; &#125;&#125; 这是我看到评论区写的 123456789101112131415161718192021222324class TimeMap &#123; /** Initialize your data structure here. */ HashMap&lt;String, TreeMap&lt;Integer, String&gt;&gt; map; public TimeMap() &#123; map = new HashMap(); &#125; public void set(String key, String value, int timestamp) &#123; map.computeIfAbsent(key, k-&gt; new TreeMap()).put(timestamp, value); &#125; public String get(String key, int timestamp) &#123; if(!map.containsKey(key)) &#123; return &quot;&quot;; &#125; // 这是在对应的TreeMap中找到以timeStamp为天花板的数字 Integer time = map.get(key).floorKey(timestamp); if(time == null) &#123; return &quot;&quot;; &#125; return map.get(key).get(time); &#125;&#125; computeIfAbsent这是java8中的操作，关于java8新特性，我后面会专门写一个专栏的","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指OfferII68-Easy】查找插入位置","slug":"【剑指OfferII68-Easy】查找插入位置","date":"2022-02-27T03:19:03.000Z","updated":"2022-09-27T14:19:05.183Z","comments":true,"path":"算法/刷题篇/2022/02/27/【剑指OfferII68-Easy】查找插入位置/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/27/%E3%80%90%E5%89%91%E6%8C%87OfferII68-Easy%E3%80%91%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"查找插入位置给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 示例 4: 12输入: nums = [1,3,5,6], target = 0输出: 0 示例 5: 12输入: nums = [1], target = 0输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 注意：本题与主站 35 题相同： https://leetcode-cn.com/problems/search-insert-position/ Related Topics 数组 二分查找 法一：二分查找先设定左侧下标 left 和右侧下标 right，再计算中间下标 middle nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标 nums[mid] &lt; target 则 left右移 nums[mid] &gt; target 则 right 左移 查找结束如果没有相等值则返回left，该值为插入位置 123456789101112131415161718class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; int mid; while (left&lt;=right) &#123; mid = (left+right)/2; if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&gt;target)&#123; right = mid - 1; &#125;else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125; 拓展：以下这种递归查找只能找到目标值并返回索引，找不到则返回-1，并不能达到本题要求 12345678910111213141516public int binarySearch(int[] nums, int target) &#123; return binarySearch(nums,target,nums.length/2);&#125;public int binarySearch(int[] nums, int target,int binary)&#123; if(binary==0||binary==nums.length)&#123; return -1; &#125; if(nums[binary]==target)&#123; return binary; &#125; if(target&gt;nums[binary])&#123; return binarySearch(nums,target,(binary+nums.length)/2+1); &#125;else&#123; return binarySearch(nums,target,binary/2); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【2016-Easy】增量元素之间的最大差值","slug":"【2016-Easy】增量元素之间的最大差值","date":"2022-02-27T03:04:08.000Z","updated":"2022-10-04T12:48:12.005Z","comments":true,"path":"算法/刷题篇/2022/02/27/【2016-Easy】增量元素之间的最大差值/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/27/%E3%80%902016-Easy%E3%80%91%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","excerpt":"","text":"增量元素之间的最大差值给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。 返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。 示例 1： 12345输入：nums = [7,1,5,4]输出：4解释：最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。 示例 2： 1234输入：nums = [9,4,3,2]输出：-1解释：不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。 示例 3： 1234输入：nums = [1,5,2,10]输出：9解释：最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。 提示： n == nums.length 2 &lt;= n &lt;= 1000 1 &lt;= nums[i] &lt;= 109 Related Topics 数组 法一：暴力枚举直接遍历，然后比较最值 12345678910111213class Solution &#123; public int maximumDifference(int[] nums) &#123; int max = -1; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if(nums[i]&lt;nums[j])&#123; max = Math.max(nums[j]-nums[i],max); &#125; &#125; &#125; return max; &#125;&#125; 法二：最小前缀法0 &lt;= i &lt; j &lt; n，所以j是从1开始走 将premin作为j之前的数组内最小的那个元素 如果nums[j]大于该数字，则将其减去并比较与max的大小关系 反之该数字替代premin的地位成为j之前的最小值 上代码： 1234567891011121314class Solution &#123; public int maximumDifference(int[] nums) &#123; int max=-1; int premin = nums[0]; for (int j = 1; j &lt; nums.length; j++) &#123; if(nums[j]&gt;premin)&#123; max=Math.max(nums[j]-premin,max); &#125;else &#123; premin = nums[j]; &#125; &#125; return max; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【206-Easy】反转链表","slug":"【206-Easy】反转链表","date":"2022-02-26T15:42:36.000Z","updated":"2022-09-27T14:29:13.185Z","comments":true,"path":"算法/刷题篇/2022/02/26/【206-Easy】反转链表/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/26/%E3%80%90206-Easy%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ Related Topics 递归 链表 法一：迭代使用三个节点分别存储当前节点（now），前置节点（prev），后置节点（suffix） 将now的next指向前置节点， 将prev指向now， 将now指向suffix， 然后suffix向后走一位。 这样一次循环就走完了。 12345678910111213141516171819202122class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode prev = null; ListNode now = head; if(head.next==null)&#123; return head; &#125; ListNode suffix = now.next; while(now.next!=null)&#123; now.next=prev; prev = now; now = suffix; suffix = suffix.next; &#125; now.next=prev; head = now; return head; &#125;&#125; 优化：将获取suffix的步骤放到了每次循环的最前面，根据now来拿到，而不是自己往后走。 1234567891011121314151617class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null)&#123; return null; &#125; ListNode prev = null; ListNode now = head; ListNode suffix; while(now!=null)&#123; suffix = now.next; now.next=prev; prev = now; now = suffix; &#125; return prev; &#125;&#125; 法二：递归使用递归的，有一个缺点，就是如果链表过于长，那么就会报异常StackOverFlowException 思路和之前是一模一样的，直接上代码。 12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; return reverse(null,head); &#125; public ListNode reverse(ListNode prev, ListNode curr)&#123; if(curr==null)&#123; return prev; &#125; ListNode suffix=curr.next; curr.next = prev; return reverse(curr,suffix); &#125;&#125; 或者不想在外面定义一个递归也可以这样写 1234567891011class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; &#125;&#125; 这种递归写的就比较烂了，看看就过去了 12345678910111213141516171819public ListNode reverseList3(ListNode head) &#123; ListNode temp= head; ListNode tail; while(temp.next!=null)&#123; temp = temp.next; &#125; tail = temp; reverse3(head); return tail;&#125;public ListNode reverse3(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode suffix = reverse3(head.next); suffix.next = head; head.next = null; return head;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【876-Easy】链表的中间节点","slug":"【876-Easy】链表的中间节点","date":"2022-02-26T15:41:52.000Z","updated":"2022-09-27T14:25:11.212Z","comments":true,"path":"算法/刷题篇/2022/02/26/【876-Easy】链表的中间节点/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/26/%E3%80%90876-Easy%E3%80%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","excerpt":"","text":"链表的中间节点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 Related Topics 链表 双指针 法一：hash映射遍历链表 将索引当做key ListNode当做value 最后返回索引为长度减1的那个节点 上代码： 123456789101112class Solution &#123; public ListNode middleNode(ListNode head) &#123; Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode curr=head; int i=0; while(curr!=null)&#123; map.put(i++,curr); curr = curr.next; &#125; return map.get(i/2); &#125;&#125; 法二：快慢指针法使用两个指针，slow，fast slow一次走一步 fast一次走两步 当fasf走到底的时候slow就在中间 节点数目为奇数 节点数目为偶数 上代码： 123456789public ListNode middleNode1(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast!=null&amp;&amp;fast.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指offerII26-Medium】重排链表","slug":"【剑指offerII26-Medium】重排链表","date":"2022-02-26T14:04:54.000Z","updated":"2022-10-04T12:45:27.696Z","comments":true,"path":"算法/刷题篇/2022/02/26/【剑指offerII26-Medium】重排链表/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/26/%E3%80%90%E5%89%91%E6%8C%87offerII26-Medium%E3%80%91%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","excerpt":"","text":"重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： 1L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 12输入: head = [1,2,3,4]输出: [1,4,2,3] 示例 2: 12输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 提示： 链表的长度范围为 [1, 5 * 104] 1 &lt;= node.val &lt;= 1000 注意：本题与主站 143 题相同：https://leetcode-cn.com/problems/reorder-list/ Related Topics 栈 递归 链表 双指针 1234567public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 法一：暴力分析：使用笨办法，可以先遍历链表将所有的节点都放入队列中，用len递增来得到链表的长度。 当长度为偶数时，我需要保留半数加一个节点。 当长度为奇数时，我需要保留半数加一个节点，将这个数字赋给 len（这个可以自行推演一下） 然后出队 len 个元素，将最后一个出队的元素的next置空 这时候需要插入的节点就按顺序保存在队列中了 接着按队列出队顺序间隔插入到原链表中 对于实例二的流程图： 12345678910111213141516171819202122232425class Solution &#123; public void reorderList(ListNode head) &#123; LinkedList&lt;ListNode&gt; nodes = new LinkedList&lt;&gt;(); ListNode temp = head; int len = 0; while(temp!=null)&#123; nodes.add(temp); temp = temp.next; len++; &#125; len = len/2+1; for (int i = 0; i &lt; len; i++) &#123; temp = nodes.poll(); &#125; temp.next=null; temp = head; ListNode now; while(!nodes.isEmpty())&#123; now = nodes.pollLast(); now.next = temp.next; temp.next = now; temp = now.next; &#125; &#125;&#125; 使用栈也是可以的，代码如下： 12345678910111213141516171819202122class Solution &#123; public void reorderList(ListNode head) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); int len = 0; ListNode temp = head; while(temp!=null)&#123; len++; stack.push(temp); temp = temp.next; &#125; len = (int) (len/2.0-0.5); temp = head; ListNode now; for (int i = 0; i &lt; len; i++) &#123; now = stack.pop(); now.next = temp.next ; temp.next = now; temp = now.next; &#125; stack.pop().next = null; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-享元模式","slug":"设计模式-享元模式","date":"2022-02-26T05:05:48.000Z","updated":"2022-02-28T00:36:16.964Z","comments":true,"path":"设计模式/2022/02/26/设计模式-享元模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"享元模式定义：运用共享技术有效地支持大量细粒度的对象 优点：如果系统有大量类似的对象，可以节省大量的内存和CPU资源 实现场景：假如我要开发一款游戏，然后游戏里面的地图有很多树木 这个时候，我们不可能创建几万个树的对象 Tree 123456@Data@AllArgsConstructor@ToStringpublic class Tree &#123; private final String name;&#125; TreeNode 1234567@Data@AllArgsConstructorpublic class TreeNode &#123; private final Tree tree; private int x; private int y;&#125; TreeFactory 12345678910111213public class TreeFactory &#123; private static ConcurrentHashMap&lt;String, Tree&gt; map = new ConcurrentHashMap&lt;&gt;(); public static Tree getTree(String name)&#123; if(map.containsKey(name))&#123; return map.get(name); &#125; return null; &#125; public static void addTree(String name)&#123; map.put(name,new Tree(name)); &#125;&#125; 主函数 123456789public static void main(String[] args) &#123; TreeFactory.addTree(&quot;梧桐树&quot;); TreeFactory.addTree(&quot;香樟树&quot;); TreeFactory.addTree(&quot;银杏树&quot;); TreeFactory.addTree(&quot;面包树&quot;); TreeNode treeNode1 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,1); TreeNode treeNode2 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,2); TreeNode treeNode3 = new TreeNode(TreeFactory.getTree(&quot;梧桐树&quot;),1,3);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【64-Medium】最小路径和","slug":"【64-Medium】最小路径和","date":"2022-02-25T15:03:19.000Z","updated":"2022-09-27T14:31:39.164Z","comments":true,"path":"算法/刷题篇/2022/02/25/【64-Medium】最小路径和/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/25/%E3%80%9064-Medium%E3%80%91%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","excerpt":"","text":"最小路径和给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 123输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 12输入：grid = [[1,2,3],[4,5,6]]输出：12 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 分析：一般来说，遇到这种统计可行路径的数量，或者求最小路径的时候，使用动态规划和搜索这两种方法，但是搜索更适用于数据规模较小的题目 法一：动态规划动态规划算法，我们主要关注以下两点。 状态的设置。在这个题目里，由于要求最小路径和，我们可以令 dp[ i ] [ j ] 代表从（i，j）点走到右下角点的最小路径和。 状态转移方程。我们考虑如何来求出 dp [ i] [j]。由于每次只能往右或者下走，所以从（i，j）只能走到（i+1，j）或者（i，j+1)。换言之，dp[ i ] [ j ] 的前继状态只有dp[ i+1 ] [ j ], dp[ i ] [ j+1 ], 所以我们在两者取最小，然后加上这个格子内的数即可 dp(i,j) &#x3D; grid(i,j) + min(dp(i + 1,j),dp(i,j + 1)) 是需要特殊处理的，当然还有终点元素也是要做个排除，下面先看流程图 就以案例一的矩阵为例子： 123输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。 正向思维从终点考虑问题，思考下一点在哪 只有最后一列是只能向下走 只有最后一行是只能向右走 终点不做处理 上代码： 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; int height = grid.length; int width = grid[0].length; for (int i = height - 1 ; i &gt;= 0; i--) &#123; for (int j = width - 1 ; j &gt;= 0; j--) &#123; if(i==height-1&amp;&amp;j!=width-1)&#123; grid[i][j]+=grid[i][j+1]; &#125;else if(i!=height-1&amp;&amp;j==width-1)&#123; grid[i][j]+=grid[i+1][j]; &#125;else if(i!=height-1&amp;&amp;j!=width-1)&#123; grid[i][j]+=Math.min(grid[i+1][j],grid[i][j+1]); &#125; &#125; &#125; return grid[0][0]; &#125;&#125; 逆向思维即我从起点出发，思考上一点在哪 只有第一行是可以向左 只有第一列是可以向上 第一个元素不做处理 上代码： 123456789101112131415161718class Solution &#123; public int minPathSum(int[][] grid) &#123; int rows = grid.length; int columns = grid[0].length; for (int i = 0; i &lt; rows ; i++) &#123; for (int j = 0; j &lt; columns ; j++) &#123; if(i==0&amp;&amp;j!=0)&#123; grid[i][j]+=grid[i][j-1]; &#125;else if(j==0&amp;&amp;i!=0)&#123; grid[i][j]+=grid[i-1][j]; &#125;else if(i!=0) &#123; grid[i][j]+=Math.min(grid[i-1][j],grid[i][j-1]); &#125; &#125; &#125; return grid[rows-1][columns-1]; &#125;&#125; 优化这是官方的优化说明： 12345我们可以用一个一维数组dp来代替二维数组，dp 数组的大小和grid的行大小相同。这是因为对于某个固定状态，只需要考虑下方和右方的节点。我们就可以一行一行计算，来节省空间复杂度。 这是我个人的解读（对于逆向思维） 123想要得到最后的结果，就需要从第一行开始计算，然后该行的数据为下一行的计算提供数据。这一行计算完成后，上一行就失去了作用，而且我们需要的就只是计算完成后的最后一行数据返回的也就是这最后一行的最后一个数据也就是dp[rows-1][colums-1] 这里就不画流程图了，直接上代码 12345678910111213141516class Solution &#123; public int minPathSum(int[][] grid) &#123; int rows = grid.length; int columns = grid[0].length; int[] dp = new int[columns]; Arrays.fill(dp,Integer.MAX_VALUE); dp[0]=0; for (int i = 0; i &lt; rows; i++) &#123; dp[0]=dp[0]+grid[i][0]; for (int j = 1; j &lt; columns; j++) &#123; dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j]; &#125; &#125; return dp[columns-1]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【537-Easy】复数乘法","slug":"【537-Easy】复数乘法","date":"2022-02-25T14:41:15.000Z","updated":"2022-09-27T14:25:55.988Z","comments":true,"path":"算法/刷题篇/2022/02/25/【537-Easy】复数乘法/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/25/%E3%80%90537-Easy%E3%80%91%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/","excerpt":"","text":"复数乘法复数 可以用字符串表示，遵循 &quot;**实部**+**虚部**i&quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 示例 1： 123输入：num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;输出：&quot;0+2i&quot;解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。 示例 2： 123输入：num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;输出：&quot;0+-2i&quot;解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 提示： num1 和 num2 都是有效的复数表示。 Related Topics 数学 字符串 模拟 法一：分解数字法分析：这题直接看这个提示↑有效的复数表示，就说明测试使用的字符串都是类似这样的，”21+-21i”,”12+1i”,”0+1i”,”12+0i” 所以这就很简单了 123456789public String complexNumberMultiply(String num1, String num2) &#123; String[] complex1 = num1.split(&quot;\\\\+&quot;); String[] complex2 = num2.split(&quot;\\\\+&quot;); int x1 = Integer.parseInt(complex1[0]); int y1 = Integer.parseInt(complex1[1].split(&quot;i&quot;)[0]); int x2 = Integer.parseInt(complex2[0]); int y2 = Integer.parseInt(complex2[1].split(&quot;i&quot;)[0]); return String.format(&quot;%d+%di&quot;,(x1*x2-y1*y2),(x1*y2+x2*y1));&#125; 进阶：题目给出的复数没有固定的规范未完待续","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis-缓存穿透和雪崩","slug":"Redis-缓存穿透和雪崩","date":"2022-02-25T13:37:11.000Z","updated":"2022-10-04T13:54:23.136Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-缓存穿透和雪崩/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"缓存穿透和雪崩缓存的时候，大大提高了应用程序的性能和效率，特别是数据查询方面。但同时，它带来好处的同时，也带来了问题。 缓存穿透和雪崩就是两个经典的问题，当然业界也已经有了比较流行的解决方案 缓存穿透（查不到）概念：缓存穿透的概念很简单，用户想要查询一个数据，发现Redis内存数据库中没有，也就是缓存没有命中，于是去持久层数据库查询。发现也没有，于是本次查询失败。当这种查询情况很多的时候，缓存都没有命中，都时去请求了持久层数据库。就是意味着该缓存无用，也就是缓存穿透。 解决方案： 布隆过滤器 布隆过滤器是一种数据结构，对所有能查询到的参数以hash的形式存储，在控制层先进行校验，不符合则该请求直接丢弃，从而解决问题 置空缓存 当存储层未命中的时候，及时返回的是null对象，缓存也将其存储起来同时设置一个过期时间，之后再从数据库中查询，保护了mysql 问题： 有可能会存放很多很多值为空的键值对，浪费文件 及时设置了过期时间，但是如果mysql在这个过期时间还没到的时候，已经有查询结果了，但是因为过期时间没到，却还是访问不了mysql，从而查询到数据 缓存击穿（查得太多了）概述：这里需要注意和缓存击穿的区别，缓存击穿，是指一个key在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。解决方案： 设置热点数据永不过期，从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 加互斥锁分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限 雪崩概念：指的是在某一时间段，缓存集中过期失效或者集中宕机 正常： 雪崩： 如果是自然key过期，倒是影响不大，但是如果是节点宕机或者断电，这就很有可能会将数据库冲垮 解决方案： redis集群 限流降级：在缓存失效后，通过加锁或者队列来控制数据库写缓存的线程个数 数据预热：在正式部署前，先把可能的数据预先访问一遍，这样的话可能大量访问的数据就会加载到缓存中去，在即将发生高并发访问前，手动触发加载器缓存不同的key，设置不同的过期时间，让缓存过期时间点比较均匀","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-主从复制","slug":"Redis-主从复制","date":"2022-02-25T03:40:53.000Z","updated":"2022-10-04T13:54:59.148Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-主从复制/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"","text":"主从复制主从复制，是指将一台Redis服务器中的数据，复制到其他的Redis服务器上。 前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower) 数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。 且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 作用主从复制的作用主要包括： 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。4、高可用（集群）基石：主从复制还是哨兵模式和部署集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，最少三台（一主二从） ​ 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大​ 2、从容量上，不能将一台服务所有内存用作Redis存储内存，单台Redis最大使用内存不应该超过20G。 配置子节点我们这里使用docker来做 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 复制两份配置文件给从节点镜像使用[root@iZbp18qscowpmxk6xpk38iZ redis]# lsredis-01.conf redis-02.conf redis.conf# 需要修改这三份文件，将绑定本地的配置注释掉，关闭安全模式# 分别以后台方式启动两个从节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-01.conf:/etc/redis/redis.conf --name=salveRedis01 redisa593c51bc1100e892f5d18c34ba5a05f637d1b3a4a29e5840cfeb18a633355f5[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -P -it -d -v /home/redis/redis-02.conf:/etc/redis/redis.conf --name=salveRedis02 redis08833de79be2cf719402b4f4cf42bf06d0f0a84a22e188f2b2f4d03f54ca48c1# 查看映射端口，这里一定一定要注意！！服务器要开安全组！！！不然就是连接失败哎！！！[root@iZbp18qscowpmxk6xpk38iZ redis]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa593c51bc110 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49169-&gt;6379/tcp salveRedis0108833de79be2 redis &quot;docker-entrypoint.s…&quot; 24 minutes ago Up About a minute 0.0.0.0:49170-&gt;6379/tcp salveRedis020e9919007f5d redis &quot;docker-entrypoint.s…&quot; 38 minutes ago Up 2 minutes 0.0.0.0:49168-&gt;6379/tcp masterRedis# 查看主节点的基本信息[root@iZbp18qscowpmxk6xpk38iZ ~]# docker exec -it masterRedis redis-cli127.0.0.1:6379&gt; info replication# Replicationrole:master # 当前节点的角色connected_slaves:0 # 当前节点的子节点master_failover_state:no-failovermaster_replid:f37ca91dd3b3578e83031f9ea087d64f9994dd9amaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0# 进入子节点1号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis01 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot; #说明连接成功，如果没开安全组的话，这一行会是connecting下一行是-1，表示连接失败5) (integer) 42# 进入子节点2号的客户端，并配置父节点[root@iZbp18qscowpmxk6xpk38iZ redis]# docker exec -it salveRedis02 redis-cli127.0.0.1:6379&gt; SLAVEOF 116.62.151.26 49168OK127.0.0.1:6379&gt; role1) &quot;slave&quot;2) &quot;116.62.151.26&quot;3) (integer) 491684) &quot;connected&quot;5) (integer) 112# 查看父节点的基本信息127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2 # 两个子节点slave0:ip=116.62.151.26,port=6379,state=online,offset=112,lag=0slave1:ip=116.62.151.26,port=6379,state=online,offset=112,lag=1master_failover_state:no-failovermaster_replid:92ee701d04326eb2c74d8de1ea0fc2ec010f97dfmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:112second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:112# 在父节点测试是否数据同步127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set k1 v1OK# 子节点1号查询127.0.0.1:6379&gt; get k1&quot;v1&quot;# 子节点2号查询127.0.0.1:6379&gt; get k1&quot;v1&quot; 也可以在配置文件中配置父节点 123456# 配置主节点的ip的端口slaveof 主机ip 端口# 如果主机使用了config set masterauth password，或者主机配置文件中 requirepass password# 则这里配置文件就要加上主机的密码来验证masterauth password 主机可以写入也可以读取，但是从节点是不可以写入的，只可以读取主节点写入的值 12127.0.0.1:6379&gt; set k2 v2(error) READONLY You can&#x27;t write against a read only replica. 主机宕机了之后，从机依旧可以读，但是这样的话，就不能往里面写入数据了。 （这里需要使用哨兵模式，即当主机宕机后，从机中会选举出来一个主机，这样的话就保留了写入操作） 当主机恢复运行，则恢复写入功能 从机宕机的话，对主机没有任何影响 当从机运行后，就恢复主机中的数据 复制原理Slave 启动成功连接到 master 后会发送一个sync命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 主从连接的形式 一对多 链状 哨兵（Sentinel）模式该模式就是为了解决当主机宕机后，从机群无法有写入权限的问题。 该模式下，它会自动监控主机是否故障，当主机宕机后，从机群中会自立一个主机，从而就有了写入的功能 哨兵模式是一种特殊的模式，它是一个独立的进程。 其原理就是哨兵通过发送命令，等待redis服务器响应，从而监控多个Redis实例的功能 这里的哨兵有两个作用 监控服务器的状态 当主机宕机后，会自动选择一个子节点作为主机，然后通过发布订阅模式通知其他子节点，修改配置文件 当然，如果哨兵挂了怎么办？所以需要配置多个哨兵，然后这几个哨兵再互相监视 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行重新选举的过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。 配置文件1234567891011121314151617181920212223242526272829303132# 哨兵进程的端口port 26379# 是否以后台运行daemonize no# 绑定的线程pidfile /var/run/redis-sentinel.pid# 日志名称logfile &quot;&quot;# 日志保存目录dir /tmp# 配置监视谁# 2代表至少要有结果哨兵确认主机宕机sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 30000acllog-max-len 128sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yesSENTINEL resolve-hostnames noSENTINEL announce-hostnames no 启动哨兵进程 1[root@iZbp18qscowpmxk6xpk38iZ redis]# docker run -d -p 49103:26379 -v /home/redis/sentinel.conf:/etc/redis/sentinel.conf --name=sentinel redis redis-sentinel /etc/redis/sentinel.conf 优点： 主从可以自动切换，可用性会更好 缺点： redis不好在线扩容 实现哨兵模式的配置优点麻烦","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-发布订阅","slug":"Redis-发布订阅","date":"2022-02-25T03:02:40.000Z","updated":"2022-10-04T13:54:19.293Z","comments":true,"path":"javaEE/Redis/2022/02/25/Redis-发布订阅/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/25/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis发布订阅Redis发布订阅是一种消息通信的模式：发布者发送消息，订阅者接收消息 三个角色：消息发布者、消息接收者、订阅的频道 命令 作用 publish channel message 发布消息到指定频道 psubscribe pattern [pattern..] 订阅一个或者多个符合给点pattern的频道 pubsub subcommand [argument [argument..]] 查看订阅和发布系统状态 punsubscribe [pattern [pattern..]] 退订所有符合模式的频道 subscribe channel [channel..] 订阅指定频道 unsubscribe channel [channel..] 退订指定频道 下面直接上案例： 充当订阅者的cli 12345127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 1 充当发布者的cli 12127.0.0.1:6379&gt; PUBLISH study study(integer) 1 订阅者 12345678127.0.0.1:6379&gt; SUBSCRIBE studyReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;study&quot;3) (integer) 11) &quot;message&quot;2) &quot;study&quot;3) &quot;designpattern&quot; 原理： Redis订阅发布底层是使用C实现的 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"设计模式-原型模式","slug":"设计模式-原型模式","date":"2022-02-25T01:26:59.000Z","updated":"2022-02-25T02:59:21.994Z","comments":true,"path":"设计模式/2022/02/25/设计模式-原型模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式该设计模式主要用于对象的复制 此设计模式有多种实现： jdk内置cloneable接口 自定义接口 jdk内置cloneable接口我们都知道object中有一个protected方法，叫clone，可以看到这是一个native方法（即该方法是由C++编写的，具体实现是根据操作系统而定） 12@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 我们来自己重写一个这个方法试一试 1234567891011121314151617181920212223242526272829303132333435363738394041public class Video &#123; private String name; private Date gmtCreated; public Video(String name, Date gmtCreated) &#123; this.name = name; this.gmtCreated = gmtCreated; &#125; public Video() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getGmtCreated() &#123; return gmtCreated; &#125; public void setGmtCreated(Date gmtCreated) &#123; this.gmtCreated = gmtCreated; &#125; @Override protected Video clone() throws CloneNotSupportedException &#123; return (Video)super.clone(); &#125; @Override public String toString() &#123; return &quot;Video&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gmtCreated=&quot; + gmtCreated + &#x27;&#125;&#x27;; &#125;&#125; 主程序 1234567891011121314public static void main(String[] args) throws CloneNotSupportedException &#123; Video video = new Video(); video.setName(&quot;视频一号&quot;); video.setGmtCreated(new Date()); System.out.println(video); System.out.println(video.hashCode()); System.out.println(video.getGmtCreated().hashCode()); System.out.println(&quot;=============克隆后================&quot;); Video clone = (Video) video.clone(); System.out.println(clone); System.out.println(clone.hashCode()); System.out.println(clone.getGmtCreated().hashCode()); System.out.println();&#125; 控制台输出 12345678Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:31:04 CST 2022&#125;269468037784235907=============克隆后================Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.lizhi.demo1.Video at java.base/java.lang.Object.clone(Native Method) at com.lizhi.demo1.Video.clone(Video.java:35) at com.lizhi.demo1.CloneApplication.main(CloneApplication.java:13) 可以发现，报错了，这是怎么回事，我不是已经重写了方法吗？ 其实原因就是该类没有一个标记接口Cloneable 123456789101112131415161718192021222324252627/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object&#x27;s clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; * By convention, classes that implement this interface should override * &#123;@code Object.clone&#125; (which is protected) with a public method. * See &#123;@link java.lang.Object#clone()&#125; for details on overriding this * method. * &lt;p&gt; * Note that this interface does &lt;i&gt;not&lt;/i&gt; contain the &#123;@code clone&#125; method. * Therefore, it is not possible to clone an object merely by virtue of the * fact that it implements this interface. Even if the clone method is invoked * reflectively, there is no guarantee that it will succeed. * * @author unascribed * @see java.lang.CloneNotSupportedException * @see java.lang.Object#clone() * @since 1.0 */public interface Cloneable &#123;&#125; 将video实现该接口后，启动程序，控制台输出 1234567Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;269468037784153335=============克隆后================Video&#123;name=&#x27;视频一号&#x27;, gmtCreated=Fri Feb 25 10:37:07 CST 2022&#125;1681595665784153335 我们可以惊奇的发现， 两者的内容打印出来一模一样，两者的对象主体的hashcode是不同的，说明video和clone是货真价实的两个对象。 但是我们也发现他们的gmtCreated变量的hashcode是一样的，这说明两者指向的是同一个gmtCreated，有时候我们会有这样的需求，有时候我们不需要将复制后的对象内部指向的对象还是原来的那个对象，这时候我们就要修改clone方法 1234567@Overrideprotected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); Video v = (Video) obj; v.setGmtCreated((Date) v.getGmtCreated().clone()); return obj;&#125; 自定义接口123public interface Copyable &#123; Object copy();&#125; 具体实现就不写啦，本质是一样的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2022-02-25T01:26:35.000Z","updated":"2022-02-25T02:22:49.386Z","comments":true,"path":"设计模式/2022/02/25/设计模式-建造者模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"建造者模式该设计模式解决的问题是在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。 该模式有两种实现方向： 有一个制造者有自己的一套制造方案来制造该对象 自己指定制造计划 制造者制造场景：造汽车 汽车类 12345678910111213141516@Data@NoArgsConstructor@ToString@AllArgsConstructorpublic class Car &#123; private CarBody carBody; private Engine engine; private Lamp lamp; private Window window; public boolean isWhole()&#123; if(carBody!=null&amp;&amp;engine!=null&amp;&amp;lamp!=null&amp;&amp;window!=null)&#123; return true; &#125; return false; &#125;&#125; 组件接口 12public interface Component &#123;&#125; 车身 123public interface CarBody extends Component &#123; void printName();&#125; 引擎 123public interface Engine extends Component &#123; void printName();&#125; 车窗 123public interface Window extends Component &#123; void printName();&#125; 好的车身 123456public class GoodCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;好的车身&quot;); &#125;&#125; 不好的车身 123456public class BadCarBody implements CarBody&#123; @Override public void printName() &#123; System.out.println(&quot;差的车身&quot;); &#125;&#125; 好的引擎 123456public class GoodEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;好的发动机&quot;); &#125;&#125; 不好的引擎 123456public class BadEngine implements Engine&#123; @Override public void printName() &#123; System.out.println(&quot;差的发动机&quot;); &#125;&#125; 好的车窗 123456public class GoodWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;好的车窗&quot;); &#125;&#125; 不好的车窗 123456public class BadWindow implements Window&#123; @Override public void printName() &#123; System.out.println(&quot;差的车窗&quot;); &#125;&#125; 车的建造者 1234567public interface CarBuilder &#123; void addCarBody(CarBody carBody); void addWindow(Window window); void addLamp(Lamp lamp); void addEngine(Engine engine); Car getCar();&#125; 具体的建造者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public void addCarBody(CarBody carBody) &#123; if(carBody==null)&#123; car.setCarBody(new GoodCarBody()); return; &#125; car.setCarBody(carBody); &#125; @Override public void addWindow(Window window) &#123; if(window==null)&#123; car.setWindow(new GoodWindow()); return; &#125; car.setWindow(window); &#125; @Override public void addLamp(Lamp lamp) &#123; if(lamp==null)&#123; car.setLamp(new GoodLamp()); return; &#125; car.setLamp(lamp); &#125; @Override public void addEngine(Engine engine) &#123; if(engine==null)&#123; car.setEngine(new GoodEngine()); return; &#125; car.setEngine(engine); &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 指导者 123456789public class Director &#123; public static Car getCar(CarBuilder carBuilder)&#123; carBuilder.addWindow(null); carBuilder.addCarBody(null); carBuilder.addLamp(new BadLamp()); carBuilder.addEngine(null); return carBuilder.getCar(); &#125;&#125; 自定义建造我们发现，有车由四部分组成，这四部分可以是同一个工厂造出来的，所以我们可以结合一个抽象工厂模式，将产品制造交给工厂。 组件工厂接口 123456public interface ComponentFactory &#123; CarBody getCarBody(); Engine getEngine(); Window getWindow(); Lamp getLamp();&#125; 不好的组件工厂 123456789101112131415161718192021public class BadFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new BadCarBody(); &#125; @Override public Engine getEngine() &#123; return new BadEngine(); &#125; @Override public Window getWindow() &#123; return new BadWindow(); &#125; @Override public Lamp getLamp() &#123; return new BadLamp(); &#125;&#125; 好的组件工厂 12345678910111213141516171819202122public class GoodFactory implements ComponentFactory&#123; @Override public CarBody getCarBody() &#123; return new GoodCarBody(); &#125; @Override public Engine getEngine() &#123; return new GoodEngine(); &#125; @Override public Window getWindow() &#123; return new GoodWindow(); &#125; @Override public Lamp getLamp() &#123; return new GoodLamp(); &#125;&#125; 改造CarBuilder 1234567public interface CarBuilder &#123; CarBuilder addCarBody(CarBody carBody); CarBuilder addWindow(Window window); CarBuilder addLamp(Lamp lamp); CarBuilder addEngine(Engine engine); Car getCar();&#125; 具体制造商 12345678910111213141516171819202122232425262728293031323334353637public class DaZhongCarBulder implements CarBuilder &#123; private Car car; public DaZhongCarBulder()&#123; car = new Car(); &#125; @Override public CarBuilder addCarBody(CarBody carBody) &#123; car.setCarBody(carBody); return this; &#125; @Override public CarBuilder addWindow(Window window) &#123; car.setWindow(window); return this; &#125; @Override public CarBuilder addLamp(Lamp lamp) &#123; car.setLamp(lamp); return this; &#125; @Override public CarBuilder addEngine(Engine engine) &#123; car.setEngine(engine); return this; &#125; @Override public Car getCar() &#123; if(!car.isWhole())&#123; throw new IllegalArgumentException(&quot;零件不齐，车不能出厂&quot;); &#125; return car; &#125;&#125; 客户端自定义制造 123456789101112131415public class Customer &#123; public static void main(String[] args) &#123; DaZhongCarBulder daZhongCarBulder = new DaZhongCarBulder(); ComponentFactory goodFactory = new GoodFactory(); ComponentFactory badFactory = new BadFactory(); // 这就是链式编程 Car car = daZhongCarBulder .addCarBody(goodFactory.getCarBody()) .addEngine(badFactory.getEngine()) .addLamp(goodFactory.getLamp()) .addWindow(goodFactory.getWindow()) .getCar(); System.out.println(car); &#125;&#125; 加深理解再来个案例：kfc点餐 首先食物接口 12public interface Food &#123;&#125; 饮料接口 123public interface Drink extends Food&#123; void drink();&#125; 薯条接口 123public interface Chip extends Food&#123; void eatChip();&#125; 炸鸡接口 123public interface Chicken extends Food&#123; void eatChicken();&#125; 奥尔良炸鸡 123456public class OrleansFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;奥尔良炸鸡&quot;); &#125;&#125; 孜然炸鸡 123456public class CuminFriedChicken implements Chicken&#123; @Override public void eatChicken() &#123; System.out.println(&quot;孜然炸鸡&quot;); &#125;&#125; 可乐 123456public class Cola implements Drink&#123; @Override public void drink() &#123; System.out.println(&quot;可口可乐&quot;); &#125;&#125; 大薯条 1234567public class BigChip implements Chip&#123; @Override public void eatChip() &#123; System.out.println(&quot;大份薯条&quot;); &#125;&#125; 百事可乐 123456public class BaiShi implements Drink &#123; @Override public void drink() &#123; System.out.println(&quot;百事可乐&quot;); &#125;&#125; 订单 1234567891011@Data@ToStringpublic class Order &#123; private List&lt;Food&gt; foods; public Order()&#123; foods = new ArrayList&lt;&gt;(); &#125; public void addFood(Food food)&#123; foods.add(food); &#125;&#125; 点单小程序 12345678910111213141516171819public class OrderApplication implements Builder&#123; private Order order; public OrderApplication()&#123; order = new Order(); &#125; @Override public Builder addFood(Food food) &#123; order.addFood(food); return this; &#125; @Override public Order getOrder() &#123; if(order.getFoods().size()==0)&#123; throw new IllegalArgumentException(&quot;您未点单！&quot;); &#125; return order; &#125;&#125; 客户端 123456789public static void main(String[] args) &#123; OrderApplication orderApplication = new OrderApplication(); Order order = orderApplication .addFood(new BigChip()) .addFood(new OrleansFriedChicken()) .addFood(new Cola()) .getOrder(); System.out.println(order);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-概述","slug":"设计模式-概述","date":"2022-02-24T14:36:38.000Z","updated":"2022-02-25T01:43:48.960Z","comments":true,"path":"设计模式/2022/02/24/设计模式-概述/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"什么是设计模式？Design Pattern是前辈们对代码开发经验的总结与归纳，是解决特定问题的一系列解决方案。 1995年，由GoF（Gang of Four）四人帮合作出版了《设计模式：可复用面向对象软件的基础》一书，一共收录了23种设计模式，人称Gof23设计模式 创建型模式： 单例模式 简单工厂模式 抽象工厂模式 建造者模式 原型模式 结构型模式 适配器模式 桥接模式 装饰器模式 组合模式 门面模式 享元模式 代理模式 行为型模式 模板方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【350-Easy】两个数组的交集","slug":"【350-Easy】两个数组的交集","date":"2022-02-24T13:17:21.000Z","updated":"2022-02-25T15:06:26.487Z","comments":true,"path":"算法/2022/02/24/【350-Easy】两个数组的交集/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/24/%E3%80%90350-Easy%E3%80%91%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"","text":"两个数组的交集给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 Related Topics 数组 哈希表 双指针 二分查找 排序 ***进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 法一：暴力先将其中一个数组放到map中key存储值，value先存为0。遍历另一个数组，从map中拿值，如果有，则说明这是相交的元素，将value自增1，然后遍历map，如果value为1，说明该元素在两数组中都存在，并且只存在一次，直接将其放入list中。如果大于等于2，则说明第两个数组中相同的该元素大于了2不能确定最小出现的次数，所以只能分别遍历两个数组找最小出现次数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums1) &#123; map.put(num, 0); &#125; for (int v : nums2) &#123; if(map.get(v)!=null)&#123; map.put(v,map.get(v)+1); &#125; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (Integer v : map.keySet()) &#123; if(map.get(v)==1)&#123; list.add(v); continue; &#125; for (int i = 0; i &lt; Math.min(showTimes(nums1,v),showTimes(nums2,v)); i++) &#123; list.add(v); &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result; &#125; public int showTimes(int[] nums,int value)&#123; int time=0; for (int num : nums) &#123; if(num==value)&#123; time++; &#125; &#125; return time; &#125;&#125; 优化： 一开始的map就用来存储最小的那一个数组的k（数组元素）-v（出现次数） 遍历另一个数组，从map中取值，如果该值不为空且大于0则将其放入list，并自减1 1234567891011121314151617181920212223242526272829class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; //key存储值，value存出现次数 if(nums1.length&gt; nums2.length)&#123; int[] temp = nums1; nums1=nums2; nums2=temp; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums1) &#123; map.merge(num, 1, Integer::sum); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Integer temp; for (int t : nums2) &#123; temp = map.get(t); if(temp!=null&amp;&amp;temp&gt;0)&#123; list.add(t); map.put(t,temp-1); &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result; &#125;&#125; 同一思路的官方代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; if (nums1.length &gt; nums2.length) &#123; // 保证我是给最短的数组进行哈希映射 return intersect(nums2, nums1); &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); // 将nums数组放入map中key为元素，value为出现次数 for (int num : nums1) &#123; int count = map.getOrDefault(num, 0) + 1; map.put(num, count); &#125; // new一个最大的数组用来存放值 int[] intersection = new int[nums1.length]; // 充当索引，也是最后该返回的数组长度 int index = 0; // 遍历nums2 for (int num : nums2) &#123; // 在map中拿值 int count = map.getOrDefault(num, 0); // 如果大于0，说明该元素是重合的 // 个人觉得这里的移除元素没有必要 // 这一段可以改为 /** if(count&gt;0)&#123; intersection[index++] = num; map.put(num,--count); &#125; **/ if (count &gt; 0) &#123; // 将该元素放入intersection中 intersection[index++] = num; // 出现次数减一 count--; // 如果出现次数还是大于0的，则更新，如果已经等于0了，则移除该元素 if (count &gt; 0) &#123; map.put(num, count); &#125; else &#123; map.remove(num); &#125; &#125; &#125; return Arrays.copyOfRange(intersection, 0, index); &#125;&#125; 进阶：如果是已经排序好的。 i作为短数组nums1的索引，j作为长数组nums2的索引 挑选一个长度小的遍历，遇到一样的则放入list，如果不一样，则比大小，如果nums[j]比nums[i]大，则i往后走，然则j往后走 123456789101112131415161718192021222324252627public int[] intersect2(int[] nums1, int[] nums2) &#123; if(nums1.length&gt; nums2.length)&#123; int[] temp = nums1; nums1=nums2; nums2=temp; &#125; Arrays.sort(nums1); Arrays.sort(nums2); int j=0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums1.length; ) &#123; if(nums1[i]==nums2[j])&#123; list.add(nums1[i]); i++; j++; &#125;else if(nums1[i]&gt;nums2[j])&#123; j++; &#125;else &#123; i++; &#125; &#125; int[] result = new int[list.size()]; for (int i = 0; i &lt; result.length; i++) &#123; result[i]= list.get(i); &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【剑指Offer21-Easy】奇前偶后","slug":"【剑指Offer21-Easy】奇前偶后","date":"2022-02-24T12:05:31.000Z","updated":"2022-09-27T14:22:52.282Z","comments":true,"path":"算法/刷题篇/2022/02/24/【剑指Offer21-Easy】奇前偶后/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/24/%E3%80%90%E5%89%91%E6%8C%87Offer21-Easy%E3%80%91%E5%A5%87%E5%89%8D%E5%81%B6%E5%90%8E/","excerpt":"","text":"奇前偶后输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 0 &lt;= nums.length &lt;= 50000 0 &lt;= nums[i] &lt;= 10000 Related Topics 数组 双指针 排序 法一：分析：先new一个相同长度的数组result，接着用odd&#x3D;0标记从头开始，用even&#x3D;nums.length-1标记从尾开始，然后遍历nums，将数字放入result中 12345678910111213141516class Solution &#123; public int[] exchange(int[] nums) &#123; int len = nums.length; int[] result = new int[len]; int odd=0; int even= len -1; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]%2==0)&#123; result[even--]=nums[i]; &#125;else &#123; result[odd++]=nums[i]; &#125; &#125; return result; &#125;&#125; 进阶在原有题目基础上加一个条件：奇数和偶数部分必须是排好序的。 其实只要我们在每次插入数据之后，循环判断是否需要交换 1234567891011121314151617181920212223242526272829public int[] sortExchange(int[] nums) &#123; int len = nums.length; int[] result = new int[len]; int odd=0; int even= len -1; for (int i = 0; i &lt; len; i++) &#123; if(nums[i]%2==0)&#123; result[even--]=nums[i]; for (int j = even+1; j &lt; len-1; j++) &#123; if(result[j]&gt;result[j+1])&#123; swap(result,j,j+1); &#125; &#125; &#125;else &#123; result[odd++]=nums[i]; for (int j = odd - 1; j &gt; 0 ; j--) &#123; if(result[j]&lt;result[j-1])&#123; swap(result,j,j-1); &#125; &#125; &#125; &#125; return result;&#125;public void swap(int[] arr,int i,int j)&#123; int temp=arr[j]; arr[j]=arr[i]; arr[i]=temp;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【4-Hard】寻找两个正序数组的中位数","slug":"【4-Hard】寻找两个正序数组的中位数","date":"2022-02-24T11:07:44.000Z","updated":"2022-09-27T14:33:45.992Z","comments":true,"path":"算法/刷题篇/2022/02/24/【4-Hard】寻找两个正序数组的中位数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/24/%E3%80%904-Hard%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"寻找两个正序数组的中位数给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 123输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 123输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 Related Topics 数组 二分查找 分治 法一：合并取中间值我使用一个list集合存放两个数组的值后排序，判断集合长度是否为偶数，返回对应的结果 123456789101112131415161718class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int k : nums1) &#123; list.add(k); &#125; for (int j : nums2) &#123; list.add(j); &#125; Collections.sort(list); int size = list.size(); if(size%2==0)&#123; return (list.get(size/2)+list.get(size/2-1))/2.0; &#125;else &#123; return list.get(size/2); &#125; &#125;&#125; 显然，这肯定不是题目真正想让我们写的，不然可就愧对这hard级的难度了 更高阶的解答请去力扣官网查看","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式-OOP七大原则","slug":"设计模式-OOP七大原则","date":"2022-02-24T10:18:58.000Z","updated":"2022-10-04T13:56:09.005Z","comments":true,"path":"设计模式/2022/02/24/设计模式-OOP七大原则/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-OOP%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"OOP七大原则开闭原则(Open-Closed Principle ，OCP)定义：对拓展开放，对修改关闭 问题的由来：在软件的生命周期的，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧的代码引入错误。 解决办法：当软件需要发生变化的时候，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 为什么要遵循开闭原则 1、只要是面向对象的编程，在开发过程中都会强调开闭原则 2、是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态 3、可以提高代码的复用性 4、可以提高代码的可维护性 单一职责原则（Single Responsibility Principle,SRP）定义：如果一个类具有多个职责，应当将对象解耦，提高内聚，分别创建一些类去一 一完成这些职责， 核心：高内聚、低耦合。 优点： 1、降低类的功能复杂度 2、提高系统的可维护性 3、变更风险低 里氏替换原则（Liskov Substitution Principle ，LSP）定义： 子类对象能够替代程序中父类对象出现的任何地方，并且保证原来的程序的逻辑行为不变及正确性不被破坏 里氏替换至少包含一下两个含义： 1、如果继承是为了实现代码重用，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。 ​ 2、如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化的，也就不存在子类替换父类实例的现象。 优点：可以大大减少程序的bug以及增强代码的可读性。 依赖倒置原则（Dependency Inversion Principle ，DIP）定义：面向接口编程 本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。 接口隔离原则(Interface Segregation Principle, ISP)定义：要用各个类建立他们需要的专用接口 它包含了2层意思： 接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户使用不到的方法塞进同一个接口里。如果一个接口的有方法没有被用户使用到，则说明该接口已经臃肿了，应该将其分割成几个功能专一的接口。 接口的依赖（继承）原则：如果一个接口a继承另一个接口b，则接口a相当于继承了接口b的方法，那么接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。 迪米特法则（Law of Demeter ，LOD）定义：只与直接朋友交谈，不与陌生人通信 直接朋友的定义： 1）当前对象本身（this） 2）以参量形式传入到当前对象方法中的对象 3）当前对象的实例变量 4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 5）当前对象所创建的对象 合成复用原则（Composite&#x2F;Aggregate Reuse Principle ，CARP）定义：尽量先使用组合或者内聚等关联关系来实现，其次才考虑使用继承来实现，因为java是单继承","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis-配置文件","slug":"Redis-配置文件","date":"2022-02-24T07:13:55.000Z","updated":"2022-10-04T13:56:55.114Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-配置文件/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"配置文件redis.conf基础配置下面为常用的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf# 说明单位和不区分大小写# Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same.################################## INCLUDES #################################### 可以配置多个conf文件组合起来# Include one or more other config files here. This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings. Include files can include# other files, so use this wisely.## Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf################################## NETWORK ###################################### 网络模块bind 127.0.0.1# 开启保护模式protected-mode yes# 连接的服务器端口port 6379tcp-backlog 511# 超时时间timeout 0tcp-keepalive 300################################# GENERAL ###################################### When Redis is supervised by upstart or systemd, this parameter has no impact.# 默认为 daemonize no# 需要手动改为yes，我们需要后台启动daemonize yes# 如果以后台方式运行，就需要指定一个pid文件pidfile /var/run/redis_6379.pid# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)生产环境# warning (only very important / critical messages are logged)# 日志级别loglevel notice# 生成的日志文件名logfile &quot;&quot;# 默认有16个数据库databases 16# 是否显示logoalways-show-logo yesset-proc-title yesproc-title-template &quot;&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;&quot;################################## SECURITY #################################### 可以设置Redis的密码# auth# config set requirepass root# 设置密码使用命令requirepass root################################### CLIENTS ##################################### 客户端的一些限# 最大客户端连接数maxclients 10000############################## MEMORY MANAGEMENT ################################# 内存设置# 设置最大内存# maxmemory &lt;bytes&gt;# The default is:# 内存满了，有什么策略，和JUC中的那四种拒绝策略有点类似# 1.volatile-lru:只对设置了过期时间的key进行lru# 2.allkeys-lru:删除lru算法的key# 3.volatile-random:随机删除即将过期的# 4.allkeys-random:随机删除# 5.volatile-ttl:删除即将过期的# 6.noeviction:返回错误maxmemory-policy noeviction############################# LAZY FREEING ####################################lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush nolazyfree-lazy-user-del nolazyfree-lazy-user-flush no 配置RDB（Redis DataBase）持久化Redis是内存性数据库，如果不讲内存中的数据保存到磁盘中，那么一旦服务器退出，服务器中的服务器状态也就消失了，所以需要学会Redis中的持久化操作 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读取到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。 RDB的优点是效率高，对于数据的完整性要求不高 RDB的缺点是最后一次持久化后的数据可能丢失。 rdb文件默认保存为dump.rdb 1234567891011121314151617181920212223242526272829################################ SNAPSHOTTING ################################# 快照：做持久化的时候会用到。# 在规定的时间内执行了多少次操作就会生成一个.rdb文件或者.aof文件# Redis是内存数据库，如果没有持久化，用完数据就没了# 持久化规则# 3600s内至少有一个key进行了修改，则进行持久化操作 save 3600 1# 300s内至少有100个key进行了修改，则进行持久化操作 save 300 100# 60s内至少有10000个key进行了修改，则进行持久化操作 save 60 10000# 持久化出错后，是否还继续工作stop-writes-on-bgsave-error yes# 是否压缩rdb文件，消耗CPU资源rdbcompression yes# 是否校验rdb文件的数目rdbchecksum yes# 持久化生成的文件名字dbfilename dump.rdbrdb-del-sync-files no# 保存的目录，当前目录dir ./ 配置AOF（Append Only File）文件以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 123456789101112131415161718192021############################## APPEND ONLY MODE ################################ 持久化文件aof的配置# 默认关闭aof，默认开启rdb的持久化，大部分情况下，rdb完全够用appendonly no# 持久化文件的名字appendfilename &quot;appendonly.aof&quot;# appendfsync always # 每次修改都同步一下appendfsync everysec # 每1s都同步一下# appendfsync no # 不同步，操作系统自己同步# 是否重写# incrby view 10# incrby view 20# 重写后# incrby 30no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 如果aof中被恶意篡改了，这时候redis是启动不起来的，这时候可以使用redis提供的一个工具redis-check-aof.exe 优点：每一次修改都同步，文件的完整性会更好， 缺点：该文件远远大于rdb，修复速度远远慢于rdb，运行效率比rdb低 小结： RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协自加保存每次写的操作到文件未尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB 文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合 用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1这条规则。 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了 代价一是带来了持续的IO 代价二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF，仅靠Master-Slave Repllcation（主从复制）实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时断电，会丢失十几分钟的数据，启动脚本也要比较两个Master&#x2F;Slave中的RDB文件，载入较新的那个。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-整合SpringBoot","slug":"Redis-整合SpringBoot","date":"2022-02-24T04:08:56.000Z","updated":"2022-10-04T13:54:55.083Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-整合SpringBoot/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E6%95%B4%E5%90%88SpringBoot/","excerpt":"","text":"SpringBoot整合Redis在SpringBoot2.x之后，底层已经不再使用jedis操作Redis了，而是lettuce jedis：采用的直连，如果有多个线程操作的话，是不安全的，需要使用jedis pool连接池来解决问题（BIO模式） lettcue：采用netty，实例可以在多个实例中共享，不存在线程不安全的问题（Dubbo底层也用到了它）（NIO模式） 如何使用1、导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt;&lt;/dependency&gt; 2、观察RedisAutoConfiguration源码 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean // 这说明我们可以自定义template @ConditionalOnMissingBean( name = &#123;&quot;redisTemplate&quot;&#125; ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean // 因为我们平时使用string会非常多，所以内置了一个StringRedisTemplate @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125;&#125; 3、配置连接，看源码可以发现，就算我们不配置，springboot也默认可以连接本地的redis 4、测试 先打开命令行客户端查看全部的key 12127.0.0.1:6379&gt; keys *(empty list or set) 测试类测试 123456789101112@SpringBootTestclass SpringbootRedisApplicationTests &#123; @Autowired private StringRedisTemplate redisTemplate; @Test void contextLoads() &#123; RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); connection.flushAll(); connection.flushDb(); redisTemplate.opsForValue().set(&quot;springboot integrated Redis&quot;,&quot;success&quot;); &#125;&#125; 命令行客户端查看全部的key，可以发现数据成功插入了 12127.0.0.1:6379&gt; keys *1) &quot;springboot integrated Redis&quot; 序列化器先看下源码 如果我们没有自定义这些序列化，那么他们都会被设置为内置的defaultSerializer，那么这种jdk的序列化会使我们的中文转义，这时候我们需要使用JSON来实现序列化 123if (this.defaultSerializer == null) &#123; this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader());&#125; 下面我们直接上案例： 使用jdk内置序列化器User 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private String name; private int age;&#125; 直接测试将对象写入 12345678@Testvoid testSerialization()&#123; User user = new User(); user.setName(&quot;zhima&quot;); user.setAge(19); redisTemplate.opsForValue().set(&quot;user&quot;, user); System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));&#125; 执行发现报错了，这就想到了我们从源码中看到的JdkSerializationRedisSerializer，如果我们没有配置自己想要的序列化器，那么就默认为此序列化器，所以知道报这个错误的原因是user没有实现序列化接口，那我们来实现以下序列化接口 1org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.lizhi.springbootredis.pojo.User] 这时候再执行，看控制台 1User(name=zhima, age=19) 自定义序列化器 配置自定义redisTemplate 123456789101112131415161718192021@Bean(&quot;myRedisTemplate&quot;)public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Object&gt; objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectJackson2JsonRedisSerializer.setObjectMapper(om); // hash的value使用JSON序列化 template.setHashValueSerializer(objectJackson2JsonRedisSerializer); // value使用JSON序列化 template.setValueSerializer(objectJackson2JsonRedisSerializer); // hash表的key使用string的序列化器 template.setHashKeySerializer(stringRedisSerializer); // key采用string的序列化器 template.setKeySerializer(stringRedisSerializer); template.afterPropertiesSet(); return template;&#125; 再执行刚刚的测试，就会发现，命令行中的key已经是一个正常的字符串了 工具类RedisUtils这样使用原生的API太麻烦了，我们可以自己编写一个工具类。 12链接:https://pan.baidu.com/s/1CZG5D8QUsz1NnqBjXZf0tg 提取码:24m2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-通过Jredis操作Redis","slug":"Redis-通过Jedis操作Redis","date":"2022-02-24T03:32:22.000Z","updated":"2022-10-04T13:54:48.214Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-通过Jedis操作Redis/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E9%80%9A%E8%BF%87Jedis%E6%93%8D%E4%BD%9CRedis/","excerpt":"","text":"JedisJedis其实就是java用来操作Redis的一个工具包 如何使用1、导入依赖 12345678910111213&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、使用封装好的对象测试连接Redis 1234567public class TestPing &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379); System.out.println(jedis.ping()); &#125;&#125;// 控制台输出PONG 可以点进源码看一下 我们会发现，这些方法不就是我们当时写的那些吗，只不过都被封装成了方法供我们使用。 实现事务1234567891011121314public class TransactionTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); jedis.set(&quot;money&quot;,&quot;100&quot;); jedis.set(&quot;out&quot;,&quot;0&quot;); jedis.watch(&quot;money&quot;); Transaction multi = jedis.multi(); jedis.decrBy(&quot;mondy&quot;,30); jedis.incrBy(&quot;out&quot;,30); multi.exec(); jedis.close(); &#125;&#125; 实际上和命令行的命令是一模一样的","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-实现乐观锁","slug":"Redis-实现乐观锁","date":"2022-02-24T03:07:07.000Z","updated":"2022-10-04T13:54:41.398Z","comments":true,"path":"javaEE/Redis/2022/02/24/Redis-实现乐观锁/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/24/Redis-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81/","excerpt":"","text":"浅实现一下乐观锁这里需要使用watch，直接上案例吧 需求：现有存款100元，花出去30元，还剩下70元 12345678910111213141516127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 30QUEUED127.0.0.1:6379&gt; incrby out 30QUEUED127.0.0.1:6379&gt; exec1) (integer) 702) (integer) 30# watch在事务执行结束后就失效了 现在我们开两个客户端cli-1和cli-2，按照以下的命令和顺序执行 cli-1 12345678127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED cli-2 123456127.0.0.1:6379&gt; get money&quot;70&quot;127.0.0.1:6379&gt; incrby money 230(integer) 300127.0.0.1:6379&gt; get money&quot;300&quot; cli-1 1234127.0.0.1:6379&gt; exec # 监视的值发生了改变，所以该事务执行失败，这个时候money上的watch没有解除，可以通过unwactch解除(nil)127.0.0.1:6379&gt; get money&quot;300&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"多并发中的锁","slug":"JUC-多并发中的锁","date":"2022-02-23T07:56:59.000Z","updated":"2022-10-04T13:53:12.879Z","comments":true,"path":"javaEE/JUC/2022/02/23/JUC-多并发中的锁/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/02/23/JUC-%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"为什么需要锁？在单线程环境下，不论怎么操作数据都不会出现什么致命的操作，但是在这个多并发的时代，我们更多的要考虑多并发，并保证多并发环境的安全性。 在并发环境下，多个线程争抢操作同一份数据，这样可能会导致数据异常，这个时候就需要一种机制来保证这一份数据的安全性。 锁是如何实现的？在java中，每一个Object都有一把锁，这把锁放在对象的对象头中，锁中记录了当前对象被哪个线程所占用。 内存中的对象结构 对齐填充字节是为了满足java对象必须是8比特的倍数这一条件所设计的 实例数据是为了保存对象属性和方法的 对象头是为了保存对象的运行时数据，对象头包含了两部分，一个是Mark Word 一个是Class Pointer Class Pointer 指向Class对象 Mark Word (32 bit)存放了很多和当前对象运行时状态有关的数据 hashCode 锁状态 synchronized实现原理synchronized被编译后会生成monitorenter和monitorexit两个字节码指令，依赖这两个指令就可以实现锁的机制，从而实现线程的同步 这是未上锁的代码： 12345678910111213import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125;&#125; 123456789101112131415161718public static void main(String[] args) &#123; TestSync ts = new TestSync(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 1000; i++) &#123; ts.add(); &#125; &#125;).start();&#125; 我们来加一下synchronized代码块 1234567891011121314151617package com.lizhi;import java.util.concurrent.TimeUnit;public class TestSync &#123; private int count; public void add()&#123; synchronized(this)&#123; try &#123; TimeUnit.MILLISECONDS.sleep(30); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:===&gt;&quot;+count++); &#125; &#125;&#125; 可以发现结果十分正确，我们来反编译一下，得到以下字节码文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849javap -c .\\TestSync.classCompiled from &quot;TestSync.java&quot;public class com.lizhi.TestSync &#123; public com.lizhi.TestSync(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public void add(); Code: 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: getstatic #2 // Field java/util/concurrent/TimeUnit.MILLISECONDS:Ljava/util/concurrent/TimeUnit; 7: ldc2_w #3 // long 30l 10: invokevirtual #5 // Method java/util/concurrent/TimeUnit.sleep:(J)V 13: goto 21 16: astore_2 17: aload_2 18: invokevirtual #7 // Method java/lang/InterruptedException.printStackTrace:()V 21: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 24: invokestatic #9 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread; 27: invokevirtual #10 // Method java/lang/Thread.getName:()Ljava/lang/String; 30: aload_0 31: dup 32: getfield #11 // Field count:I 35: dup_x1 36: iconst_1 37: iadd 38: putfield #11 // Field count:I 41: invokedynamic #12, 0 // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;I)Ljava/lang/String; 46: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 49: aload_1 50: monitorexit 51: goto 59 54: astore_3 55: aload_1 56: monitorexit 57: aload_3 58: athrow 59: return Exceptio n table: from to target type 4 13 16 Class java/lang/InterruptedException 4 51 54 any 54 57 54 any&#125; 可以看到在第3行和第50行出现了monitorenter和monitorexit Monitor该单词的意思是监视器，可以将其想成一间宾馆的客房，把各个线程想像成客人。如果客人未退房，在这之后的客人则无法入住，只能等待这个客人退房后方可入住。 monitor是依赖于操作系统的mutex lock来实现的 java线程实际上是对操作系统线程的映射，每当挂起或者唤醒一个线程都要切换 操作系统内核态，这种操作是比较重量级的，在一些情况下甚至切换时间会超过任务本身执行的时间，这样的情况下，使用synchronized的会对系统的性能产生很严重的影响，但是从java6开始，synchronized进行了优化，引入了偏向锁和轻量级锁。 锁的四种状态由低到高分别是：无锁、偏向锁、轻量级锁、重量级锁。 这就与Mark Word中的四种状态对应上了 注意：锁只能升级不能降级 无锁 无锁即没有对自身资源上锁，所有线程都可以拿到资源并操作 这就可能出现两种情况 某个对象不会出现在多线程环境下，或者说即使出现在多线程环境下也不会出现竞争的情况 资源会被竞争，但是我不想对资源锁定，不过这样也不行，会导致一些问题，就想通过一种其他机制来控制多线程， 比如说，如果有多个进程想修改同一个值，但是只能有一个线程修改成功，其他失败的线程需要不断尝试，直到修改成功 ，这就是CAS（Compare And Swap）,CAS在操作系统中通过一条指令来实现，所以其就可以保证原子性，有了这种机制，我们就可以实现无锁编程 偏向锁 假如一个对象被加锁了，那么在实际运行过程中只有一个线程会获得这个对象锁，并只有当线程执行完任务，才会将锁释放。 我们设想的是，最好这个对象能够认识这个线程，当这个线程过来，那么这个对象就把自己的锁给他，这可以说这个对象偏爱这个线程，这就是偏向锁的概念 那么这个认识的人，被这个对象记在哪里呢？那就是在对象头中MarkWord的线程ID中，假如情况发生了变化，这个对象发现，不止有一个线程在争抢锁，那么该偏向锁会直接升级成轻量级锁 轻量级锁 那当锁升级为轻量级锁的时候，如何判断线程和所之间的绑定关系呢？可以再看下那张markword的表，这里已经不再使用线程ID这个字段了，而是将30bit变为指向线程栈中的锁记录（Lock Record）的指针 当一个线程想要获得对象的锁的时候，加入看到锁的标志位为00那么就知道它是轻量级锁，这时候线程会在自己的虚拟机栈中开辟一块被称为Lock Record的空间（线程私有的哦），该控件用来存放对象头中的Mark word的副本以及owner指针，线程通过CAS去尝试获得锁，一旦获取那么将会复制该对象头中的markword到本线程的Lock record中并且将Locker record中的owner指针指向该对象，并且对象的前三十位将会生成一个指针，指向线程虚拟机栈中的Lock Record，这样一来就实现了线程和对象锁的绑定。 当线程已经被抢占了，那其他想抢占的线程会自旋等待（可以理解为轮询），不断尝试拿到锁，这种操作区别于被操作系统挂起阻塞，如果对象的锁很快就被释放的话，自旋就不需要进行系统中断和重新恢复，所以它的效率会更高。 自旋相当于CPU空转，如果CPU空转时间过长，性能也会产生损耗，然后就有了一种优化，就是适应性自旋。简单来说，就是自旋的时间会根据上一次在同一个锁上自旋的时间以及锁的状态来决定的 重量级锁 如果同时有多个线程要获得这个对象锁，也就是说一旦自旋等待的线程超过一个，则会升级为重量级锁，那么这个时候，这就需要使用monitor来对线程进行控制，此时将会完全锁定资源，对线程的管控也更为严格 无锁编程java中的synchronized就是悲观锁（Pessimistic Concurrency Control），什么叫悲观锁呢？ 简单来说就是操作系统会悲观地认为，如果不严格同步线程调用，那么一定会产生异常，所以互斥锁会锁定资源，直供一个线程使用，而阻塞其他线程，因此叫悲观锁，但是悲观锁不是万能的，如果大部分操作都是读的操作，那么就没有必要在每次调用的时候都锁定资源。可能会出现同步代码块执行的耗时远远小于线程切换的耗时。使用悲观锁，会导致性能十分不容乐观，比如大量用户需要同时读取同一份资源，如果使用的是悲观锁，则同一时间只能有一个用户可以查看，其他用户都在一直白屏，但是！其实对于读的操作，即使是多个线程同时操作该数据，也不会对该数据造成影响，我们能不能在不锁定资源的情况下，也可以对线程调用进行一些协调呢？这时候就出现了乐观锁这种机制，实现原理就是CAS（Compare And Swap） CAS我们来举个栗子：人就是线程，厕所就是对象，该对象有一个值来表示是否被占用occupy 0表示空闲 1表示有人 很多人要去抢厕所，然后线程A（Old Value &#x3D; 0 ，new Value &#x3D;1）、B（Old Value &#x3D; 0，new Value &#x3D; 1）这两个人冲到了最前面，然后A率先和厕所的occupy比较（Compare）发现和oldValue一致，则将oldValue与厕所的occupy交换（And Swap），这时候B一看自己的oldValue与厕所的occupy（1）不一致，他很不甘心，但也只能在厕所外踱步（自旋），通常在等了一段时间后（设置最大自旋次数），骂出一句国粹后就离去了 这时候可能就出现了问题，因为Compare和Swap是两个操作，没有原子性，这就有可能出现，当A即将将值改为1的那一刹那，B抢到了时间片，将其改为了1，然后A也将其改为1，这就很尴尬了，两个人一起进入了厕所。 那么如何保证CAS的原子性呢？难道还是锁来实现同步吗？这不就是一个鸡生蛋蛋生鸡的问题了吗？ 其实啊，各种不同架构的CPU都提供了指令级别的CAS原子操作， 比如在X86架构下，通过cmpxchg指令可以支持CAS 在ARM下，通过LL&#x2F;SC来实现CS…… 也就是说不通过操作系统的同步原语（比如 mutex），CPU已经实现了CS，上层只需要调用即可，这样我们就可以不依赖锁来进行线程同步，但是这也不意味着无锁可以完全代替有锁 利用CAS特性来进行无锁编程需求：使用三条线程，将一个值，从0累加到1000 1、错误 123456789101112public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125;).start(); &#125; &#125;&#125; 2、使用synchronized 1234567891011121314public class Application2 &#123; static int count =0 ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count&lt;1000)&#123; synchronized (Application2.class)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count++); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 3、无锁 123456789101112public class Application2 &#123; static AtomicInteger count =new AtomicInteger(0) ; public static void main(String[] args) &#123; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; while(count.get()&lt;1000)&#123; System.out.println(Thread.currentThread().getName()+&quot;:==&gt;&quot;+count.getAndIncrement()); &#125; &#125;).start(); &#125; &#125;&#125; 探究源码 AtomicInteger的getAndIncrement方法 123public final int getAndIncrement() &#123; return U.getAndAddInt(this, VALUE, 1);&#125; U的getAndAddInt方法 1private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe(); U是一个操作底层的类 12345678@HotSpotIntrinsicCandidatepublic final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); return v;&#125; 123456@HotSpotIntrinsicCandidatepublic final boolean weakCompareAndSetInt(Object o, long offset, int expected, int x) &#123; return compareAndSetInt(o, offset, expected, x);&#125; 1234@HotSpotIntrinsicCandidatepublic final native boolean compareAndSetInt(Object o, long offset, int expected, int x); 启动次数可以通过启动参数来配置，默认是10，所以不会出现死循环 Unsafe","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"}]},{"title":"Redis-事务","slug":"Redis-事务","date":"2022-02-23T07:32:42.000Z","updated":"2022-10-04T13:54:45.002Z","comments":true,"path":"javaEE/Redis/2022/02/23/Redis-事务/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/23/Redis-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务回顾我们在MySQL中学习的事务具有ACID原则 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis中的事务事务的本质即：一组命令一起执行，不允许被插队。 在Redis中，单条命令是原子性的，但是事务不保证原子性 事务没有隔离级别的概念 123456789101112131415161718192021222324# 开启事务127.0.0.1:6379&gt; multiOK# 命令入队127.0.0.1:6379&gt; hset user:1 name zhimaQUEUED127.0.0.1:6379&gt; hset user:1 age 19QUEUED127.0.0.1:6379&gt; hset user:1 address SuzhouQUEUED127.0.0.1:6379&gt; hmget user:1 name age addressQUEUED# 执行事务127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 13) (integer) 14) 1) &quot;zhima&quot; 2) &quot;19&quot; 3) &quot;Suzhou&quot;# 中途放弃事务127.0.0.1:6379&gt; discard 编译时异常：即代码本身又问退，比如127.0.0.1:6379&gt; asdmlk (error) ERR unknown command &#39;asdmlk&#39;命令行会直接报错 12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; getset k2(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k3(nil)127.0.0.1:6379&gt; get k2(nil) 可以发现所有的命令都没有执行。 运行时异常：如果事务队列中存在这种错误，其他语句照常执行，该语句不执行，抛出异常 1234567891011127.0.0.1:6379&gt; set k1 varOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range2) &quot;var&quot;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"CS和BS架构是什么？","slug":"CS和BS架构是什么？","date":"2022-02-23T03:45:07.000Z","updated":"2022-10-04T13:52:27.206Z","comments":true,"path":"琐碎的知识/2022/02/23/CS和BS架构是什么？/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/23/CS%E5%92%8CBS%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"C&#x2F;S架构和B&#x2F;S架构C&#x2F;S架构 Client&#x2F;Server客户端&#x2F;服务器 客户端是针对某一具体业务专门开发的软件，是需要专门安装的软件。 由于客户端是专用的软件，所以客户端程序一般也具有对具体业务进行处理的能力，可以减轻服务端压力 优点：速度快，安全性较高 致命问题：版本升级成本很高 就比如QQ、微信等应用程序 B&#x2F;S架构 Browser&#x2F;Serve浏览器&#x2F;服务器 它其实也是一种特殊的C&#x2F;S架构，只不过这个Client是浏览器，是一个通用的客户端（浏览器），所以没有对具体业务进行处理的能力，速度降低。 优点：不存在客户端升级的问题 致命问题：速度慢，考虑兼容性的问题，安全性低 就比如，网页版QQ","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"【3-Medium】无重复字符的最长子串","slug":"【3-Medium】无重复字符的最长子串","date":"2022-02-22T09:10:53.000Z","updated":"2022-09-27T14:34:36.225Z","comments":true,"path":"算法/刷题篇/2022/02/22/【3-Medium】无重复字符的最长子串/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/22/%E3%80%903-Medium%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 Related Topics 哈希表 字符串 滑动窗口 法一：暴力解法分析：遍历数组的所有的区间，将满足题意区间长度的最大值返回 123456789101112131415161718192021222324252627public int lengthOfLongestSubstring(String s) &#123; int len=s.length(); if(len&lt;=1)&#123; return len; &#125; int maxLength = 1; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if(allUnique(s, i, j))&#123; maxLength = Math.max(maxLength, j-i+1); &#125; &#125; &#125; return maxLength;&#125;// 该函数的作用是返回该区间是否有重复的字符，有则返回false，没有则返回trueprivate boolean allUnique(String s, int i, int j) &#123; // 这里使用ArrayList也是可以的 Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int x = i; x &lt;= j; x++) &#123; if(set.contains(s.charAt(x)))&#123; return false; &#125; set.add(s.charAt(x)); &#125; return true;&#125; 缺点：中间会有重复的比较，导致其效率十分低下，当string长度十分大的时候，就会超时。所以我们可以优化一个这个算法 法二：暴力优化123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; len; i++) &#123; set.add(s.charAt(i)); int j = i; while(j&lt;len-1 &amp;&amp; !set.contains(s.charAt(j+1)))&#123; j++; set.add(s.charAt(j)); &#125; maxLength = Math.max(set.size(), maxLength); set.clear(); &#125; return maxLength; &#125;&#125; 法三：滑动窗口法此方法从力扣官网解题得知： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/jian-dan-yi-dong-javac-pythonjshua-dong-bff20/ 我按照此思路画了图 这是我知道此方法后写的代码： 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); while(right &lt; len)&#123; while(right &lt; len &amp;&amp; !list.contains(s.charAt(right)))&#123; maxLength = Math.max(maxLength, right-left+1); list.add(s.charAt(right++)); &#125; left++; while(right &lt; len &amp;&amp; list.pop()!=s.charAt(right))&#123; left++; &#125; &#125; return maxLength; &#125;&#125; 这是力扣官网给出的同一方法的代码：两者本质是一样的，但是显然这一种更为简便！ 12345678910111213141516171819public int lengthOfLongestSubstring2(String s) &#123; int n = s.length(); if (n &lt;= 1) return n; int maxLen = 1; int left = 0, right = 0; Set&lt;Character&gt; window = new HashSet&lt;&gt;(); while (right &lt; n) &#123; char rightChar = s.charAt(right); while (window.contains(rightChar)) &#123; window.remove(s.charAt(left)); left++; &#125; maxLen = Math.max(maxLen, right - left + 1); window.add(rightChar); right++; &#125; return maxLen;&#125; 这是我看完后，对自己代码的优化： 123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123;return len;&#125; int maxLength = 1; int left = 0; int right = 0; LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); while(right &lt; len)&#123; char now = s.charAt(right); if(list.contains(now))&#123; left++; while(list.pop()!=now)&#123; left++; &#125; &#125; maxLength = Math.max(maxLength, right-left+1); list.add(now); right++; &#125; return maxLength; &#125;&#125; 我们发现对于处理left，我们需要遍历，那我们有什么办法可以直接拿到窗口中重复的字符的后一个索引呢？没错，就是hashmap 1234567891011121314151617181920212223class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(right &lt; len)&#123; char now = s.charAt(right); if(map.get(now)!=null)&#123; // 如果拿到的索引+1比left大再赋值 left = Math.max(map.get(now)+1,left); &#125; maxLength = Math.max(maxLength, right-left+1); map.put(now,right); right++; &#125; return maxLength; &#125;&#125; 接下来，我们追求一下极致，先看下题目要求 因为字符是确定的所以，我们可以new一个128长度的数组来当hashmap，键是字符的ascll码值，值是索引，代码如下 1234567891011121314151617181920class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1)&#123; return len; &#125; int maxLength = 1; int left = 0; int right = 0; int[] window = new int[128]; while(right &lt; len)&#123; char now = s.charAt(right); left = Math.max(left, window[now] +1); maxLength = Math.max(maxLength, right-left+1); window[now] = right; right++; &#125; return maxLength; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"大O表示法","slug":"算法-大O表示法","date":"2022-02-22T08:52:02.000Z","updated":"2022-09-27T13:56:12.117Z","comments":true,"path":"算法/2022/02/22/算法-大O表示法/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/2022/02/22/%E7%AE%97%E6%B3%95-%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"如何去评判一个算法的好坏呢？我们可以从两个维度分别是时间和空间去评判，所以我们也可以根据这两点去优化我们的代码，从而使自己的算法的复杂度降低，效率提高。 那这样说的话，是不是我拿着不同的算法在不同的电脑上跑然后比较时间，谁的时间短，谁的算法更牛逼。那如果两台电脑的性能本就有着很大的差距呢？这样就不公平了，导致了比较的偏差。 大O表示法那么我们可以使用一种表示法也就是大O表示法来具体表示时间复杂度和空间复杂度。它将代码的所有步骤转换为关于数据规模n的公式项，然后排除不会对问题的整体复杂度产生较大影响的低阶、系数项和常数项。 时间复杂度其实该值表示的是，当数据的量级增加的时候，时间增长的一个趋势。 公式：T(n) &#x3D; O(f(n)) O(1)的例子： 123int x = 0;int y = 1;int temp = x + y; O(n)的例子： 12345678910111213for (int i = 1; i &lt; n; i++)&#123; System.out.println(i);&#125;/*** 该循环实际会执行多少行代码呢？* int i = 1; * 1* i &lt; n * n* i++ * n* sout(i) * n* 所以是O(1+3n)* 我们在开始就说过了需要排除不会对问题的整体复杂度产生较大影响的低阶、系数项和常数项。* 所以复杂度是O(n)*/ 再来看一个O(n^2)的案例： 12345678910111213141516for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.println(i+j); &#125;&#125;/** 一样的我们来看一下这个循环实际会执行多少次* int i = 0; * 1* int j = 0; * 1* i &lt; n * n* i++ * n* j &lt; n * n*n* j++ * n*n* sout(i+j); * 1* 也就是O(n^2+2n+3) = O(n^2)*/ O(logn)的例子： 12345678910int i=1;while(i &lt; n)&#123; i = i * 2; &#125;/** int i = 1; * 1* i &lt; n * (log2)n* i = i * 2 * (log2)n* 也就是O(2(log2)n)==(log2)n*/ O(nlogn)的例子： 1234567for (int i = 1; i &lt; n; i++)&#123; int j = 1; while(j &lt; n)&#123; j = j * 2; &#125;&#125;//这个很简单，和之前的分析是一样的 空间复杂度该复杂度表示的是内存空间随着数据的增加增长的趋势。 常用的空间复杂度O(1),O(n),O(n^2) O(1)的例子： 123int x = 0;int y = 1;int temp = x + y; O(n)的例子： 1234int[] arr = new int[n];for (int i = 0; i &lt; n; i++)&#123; arr[i] = i;&#125; O(n^2)的例子： 123456int[][] arr = new int[n][n];for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; n; j++)&#123; arr[i][j] = i+j; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Redis-三大特殊类型","slug":"Redis-三大特殊类型","date":"2022-02-22T08:41:55.000Z","updated":"2022-10-04T13:54:37.679Z","comments":true,"path":"javaEE/Redis/2022/02/22/Redis-三大特殊类型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/22/Redis-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"三种特殊类型geospatial该数据类型是用来存储地理空间的 附近的人，发送定位，分享实时位置，打车的时候的距离计算都可以通过这个实现 我们这里使用这几个城市的经纬度作为测试 城市 经度 维度 相城区 120.64239 31.36889 吴江区 120.638317 31.159815 太仓 121.10891 31.4497 常熟市 120.75225 31.65374 昆山市 120.98074 31.38464 这里有六个基本命令，我们来一个个看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# geoadd key longitude latitude member [longitude latitude member..]# 增加一个经纬度的坐标# 两极无法添加，一般我们通过java程序一次性导入127.0.0.1:6379&gt; geoadd Suzhou 120.64239 31.36889 XiangChengDistrict 120.638317 31.159815 WuJiangDistrict 121.10891 31.4497 TaiCang 120.75225 31.65374 ChangShuCity 120.98074 31.38464 KunShanCity(integer) 5# geodist key member1 member2 [unit]# 获取两地之间的距离单位为米127.0.0.1:6379&gt; GEODIST Suzhou TaiCang WuJiangDistrict&quot;55133.1652&quot;127.0.0.1:6379&gt; GEODIST Suzhou TaiCang KunShanCity km&quot;14.1556&quot;# geohash key member [member..]# 获取member的二维的空间经纬度数据编码# 这个可以csdn搜一下具体的算法实现127.0.0.1:6379&gt; geohash Suzhou TaiCang1) &quot;wtw4gvhzf10&quot;# geopos key member [member..]# 查看member的经纬度127.0.0.1:6379&gt; geopos Suzhou TaiCang XiangChengDistrict1) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;120.64238995313644&quot; 2) &quot;31.368889085683811&quot;# georadius key longitude latitude radius m|km|ft|mi [WITHSCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC| ESC]# mi是英里，ft是英尺# 以给定的经纬度为中心，找到某一半径内的元素# WITHCOORD表示显示坐标# WITHDIST表示显示距离该点的位置# WITHHASH表示显示该地址的hash值# COUNT count表示显示几个# ASC| ESC 表示正序还是倒序127.0.0.1:6379&gt; georadius Suzhou 120.98080 31.28460 30 km withdist1) 1) &quot;KunShanCity&quot; 2) &quot;11.1271&quot;2) 1) &quot;TaiCang&quot; 2) &quot;22.0285&quot;# georadiusbymember key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]# 以member为中心radius为半径，找到在此范围中的元素127.0.0.1:6379&gt; georadiusbymember Suzhou TaiCang 30 km withcoord withdist withhash asc1) 1) &quot;TaiCang&quot; 2) &quot;0.0000&quot; 3) (integer) 4054798020485654 4) 1) &quot;121.10891193151474&quot; 2) &quot;31.449701065685858&quot;2) 1) &quot;KunShanCity&quot; 2) &quot;14.1556&quot; 3) (integer) 4054794184325796 4) 1) &quot;120.98073989152908&quot; 2) &quot;31.38463984296795&quot; geo的底层其实是Zset，我们可以使用Zset的命令去操作geo 1234567127.0.0.1:6379&gt; zrem Suzhou TaiCang(integer) 1127.0.0.1:6379&gt; zrange Suzhou 0 -11) &quot;WuJiangDistrict&quot;2) &quot;XiangChengDistrict&quot;3) &quot;ChangShuCity&quot;4) &quot;KunShanCity&quot; Hyperloglog 先来了解一下基数是什么？ 基数其实就是一个集合中不重复的元素个数，其实就是一个集合去重后的集合长度 业务场景： 网站的访问量（一个人访问一个网站多次，也算一个人） 传统使用set集合的重复无序的特性，可以保存用户的id，以set集合的长度作为标准。但是，专门使用一个set来保存用户id未免优点奢侈，如果id是分布式的会很复杂，导致set集合很庞大，所以需要一个方法来解决这个问题。 Hyperloglog就是用来解决此问题的算法。 优点：占用很小的内存空间存放2^64个数据，也只占用12kb 瑕疵：会有0.81%的错误率 123456789101112131415161718192021222324# pfadd key member [member..]127.0.0.1:6379&gt; pfadd set a b c d e f g h i j k l(integer) 1# pfcount key [key..]# 返回基数127.0.0.1:6379&gt; pfcount set(integer) 12127.0.0.1:6379&gt; pfadd set2 j k l m n(integer) 1127.0.0.1:6379&gt; pfcount set set2(integer) 14# pfmerge destkey sourcekey [sourcekey..]# 将sourcekey合并到destkey127.0.0.1:6379&gt; pfmerge set set2OK# 探究底层：# 我们获取一下此数据的数据类型，可以看到实际上存储的是string127.0.0.1:6379&gt; type setstring127.0.0.1:6379&gt; get set&quot;HYLL\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00Fm\\x80I\\xe8\\x80@\\xc4\\x84K\\\\\\x80D&lt;\\x848\\x80B=\\x80K\\x83\\x80B\\xed\\x84A\\xfc\\x8cG\\x8e\\x80Bm\\x80BZ&quot; Bitmap位存储，一般使用两种状态的区分 比如统计中国的男子和女子的数目 14亿个二进制数，0代表女子，1代表男 0 0 1 1 1 0 1 … 登录，头像是亮着的，未登录，头像是灰色的。 12345678910111213141516171819202122232425# setbit key offset value# 设置offset位是value127.0.0.1:6379&gt; setbit sign 0 0(integer) 0127.0.0.1:6379&gt; setbit sign 1 1(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0# 中国sign可以代表# 星期日未打卡# 星期一已打卡# 星期二未打卡# 星期三已打卡# getbit key offset# 查看该天是否打卡127.0.0.1:6379&gt; getbit sign 3(integer) 1# bitcount key [start end]# 查看sign中为1的个数127.0.0.1:6379&gt; BITCOUNT sign(integer) 2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"【1827-Easy】最少操作使数组递增","slug":"【1827-Easy】最少操作使数组递增","date":"2022-02-21T13:49:48.000Z","updated":"2022-09-27T14:23:45.710Z","comments":true,"path":"算法/刷题篇/2022/02/21/【1827-Easy】最少操作使数组递增/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%901827-Easy%E3%80%91%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E6%95%B0%E7%BB%84%E9%80%92%E5%A2%9E/","excerpt":"","text":"最少操作使数组递增给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。 比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。 请你返回使 nums 严格递增 的 最少 操作次数。 我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &lt;= i &lt; nums.length - 1 都有 nums[i] &lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。 示例 1： 123456输入：nums = [1,1,1]输出：3解释：你可以进行如下操作：1) 增加 nums[2] ，数组变为 [1,1,2] 。2) 增加 nums[1] ，数组变为 [1,2,2] 。3) 增加 nums[2] ，数组变为 [1,2,3] 。 示例 2： 12输入：nums = [1,5,2,4,1]输出：14 示例 3： 12输入：nums = [8]输出：0 提示： 1 &lt;= nums.length &lt;= 5000 1 &lt;= nums[i] &lt;= 104 Related Topics 贪心 数组 法一：暴力分析：从第二位遍历数组，与前一位比较，将差值给后者补上并加一即可 上代码： 1234567891011121314class Solution &#123; public int minOperations(int[] nums) &#123; int sum=0; int temp; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i]-nums[i-1]&lt;=0)&#123; temp = nums[i-1]-nums[i]+1; sum += temp; nums[i] += temp; &#125; &#125; return sum; &#125;&#125; 因为不需要对原数组做出改动，所以以上可以简化成以下的代码 1234567891011class Solution &#123; public int minOperations(int[] nums) &#123; int sum=0; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i]-nums[i-1]&lt;=0)&#123; sum += nums[i-1]-nums[i]+1; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1380-Easy】矩阵中的幸运数","slug":"【1380-Easy】矩阵中的幸运数","date":"2022-02-21T13:15:58.000Z","updated":"2022-09-27T14:24:06.236Z","comments":true,"path":"算法/刷题篇/2022/02/21/【1380-Easy】矩阵中的幸运数/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%901380-Easy%E3%80%91%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","excerpt":"","text":"矩阵中的幸运数给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1： 123输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]输出：[15]解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2： 123输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]输出：[12]解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3： 12输入：matrix = [[7,8],[1,2]]输出：[7] 提示： m == mat.length n == mat[i].length 1 &lt;= n, m &lt;= 50 1 &lt;= matrix[i][j] &lt;= 10^5 矩阵中的所有元素都是不同的 Related Topics 数组 矩阵 法一：转置矩阵进行操作分析：该题其实就是马鞍数，我的思路是，转置矩阵，然后遍历原二维数组的每一行，先取得每一行的最小值所在的索引，然后取得这一列所在的最大值的索引，比较当前行数和最大值的索引是否相等，如果相等，则说明该数字即幸运数。这里不可以拿到最小值和最大值的值本身而是拿到索引，不然会有巧合出现。 上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int[][] reverse = reverse(matrix); int min; int max; for (int i = 0; i &lt; matrix.length; i++) &#123; // 拿到这一行的最小值的索引 min = indexOfMin(matrix[i]); // 拿到最小值这一列的最大值的索引， max = indexOfMax(reverse[min]); // matrix[i][min]==reverse[min][max] // 这里是先拿到每一行需要比较的值即matrix[i][min]， // 然后拿到min列i行的最大值matrix[i][max]比较是否相等, // 化简一下即为比较i与max的大小是否相等 if(i==max)&#123; result.add(matrix[i][min]); &#125; &#125; return result; &#125; public int[][] reverse(int[][] matrix)&#123; int[][] reverse = new int[matrix[0].length][matrix.length]; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; reverse[j][i]=matrix[i][j]; &#125; &#125; return reverse; &#125; public int indexOfMin(int[] arr)&#123; int min = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;arr[min])&#123; min=i; &#125; &#125; return min; &#125; public int indexOfMax(int[] arr)&#123; int max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&gt;arr[max])&#123; max=i; &#125; &#125; return max; &#125;&#125; 法二：预拿最值分析：提前将每一行和每一列的最值都拿出来，然后扫描棋盘找到满足的数据 上代码： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int rowMin = new int[matrix.length]; Arrays.fill(rowMin,Integer.MAX_VALUE); int columnMax = new int[matrix[0].length]; Arrays.fill(columnMax,Integer.MIN_VALUE); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; rowMin[i] = Math.min(rowMin[i],matrix[i][j]); columnMax[j] = Math.max(columnMax[j],matrix[i][j]); &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if(rowMin[i]==matrix[i][j]&amp;&amp;columnMax[j]==matrix[i][j])&#123; result.add(matrix[i][j]); &#125; &#125; &#125; return result; &#125; public int findMin(int[] arr)&#123; int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; return min; &#125;&#125; 对于预处理还可以这样写： 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int rowMin = new int[matrix.length]; int columnMax = new int[matrix[0].length]; Arrays.fill(columnMax,Integer.MIN_VALUE); for (int i = 0; i &lt; matrix.length; i++) &#123; rowMin[i] = findMin(matrix[i]); for (int j = 0; j &lt; matrix[i].length; j++) &#123; columnMax[j] = Math.max(columnMax[j],matrix[i][j]); &#125; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[i].length; j++) &#123; if(rowMin[i]==matrix[i][j]&amp;&amp;columnMax[j]==matrix[i][j])&#123; result.add(matrix[i][j]); &#125; &#125; &#125; return result; &#125; public int findMin(int[] arr)&#123; int min = arr[0]; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; return min; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【717-Easy】1比特与2比特字符","slug":"【717-Easy】1比特与2比特字符","date":"2022-02-21T12:27:37.000Z","updated":"2022-09-27T14:25:23.021Z","comments":true,"path":"算法/刷题篇/2022/02/21/【717-Easy】1比特与2比特字符/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%90717-Easy%E3%80%911%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/","excerpt":"","text":"1比特与2比特字符有两种特殊字符： 第一种字符可以用一个比特 0 来表示 第二种字符可以用两个比特(10 或 11)来表示、 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。 示例 1: 1234输入: bits = [1, 0, 0]输出: true解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2: 1234输入: bits = [1, 1, 1, 0]输出: false解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 提示: 1 &lt;= bits.length &lt;= 1000 bits[i] == 0 or 1 Related Topics 数组 法一：直接正序遍历分析：其实这个题目的意思数组中11、10这两种连续的组合就是一个整体，然后0是一个整体，返回的结果就是，这个数组按这种规则组合后，最后的那一个组合是不是0，如果是则返回true，反之则返回false。 首先，判断最后一个是否是1，如果为1则直接返回false 然后，遍历该数组到倒数第二个，如果当前的值是1，则用来遍历的计数器额外加1 最后，返回计时器是否等于数组的长度减1，如果相等，则说明最后一位的0未与倒数第二位匹配，满足题意 上代码： 12345678910111213141516class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int length = bits.length; if(bits[length-1]==1)&#123; return false; &#125; int i = 0; while(i&lt;length-1)&#123; if(bits[i]==1)&#123; i++; &#125; i++; &#125; return i==length-1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【2-Medium】两数相加","slug":"【2-Medium】两数相加","date":"2022-02-21T10:53:00.000Z","updated":"2022-09-27T14:35:26.476Z","comments":true,"path":"算法/刷题篇/2022/02/21/【2-Medium】两数相加/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%902-Medium%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ListNode 12345678//Definition for singly-linked list.public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;&#125; 示例1: 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 图示1： 图示2： 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 Related Topics 递归 链表 数学 法一：链表转值计算分析：遇到这种链表的题，首先要先将逻辑图画出来。 经过观察可知，链表的第一位表示该数字的个位，第二位代表该数字的十位，以此类推。 一开始解题思路应该是，先将链表表示的数字算出来，然后先将两个数字加起来，然后再用该数字构建出来结果链表。 代码如下 1234567891011121314151617181920212223242526public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; long sum=compute(l1)+compute(l2); ListNode listNode = new ListNode(); // 这里的listNode是虚拟节点，最后返回的是该节点的下一个节点 ListNode temp = listNode; while (sum != 0) &#123; // 这里需要使用强转 // (sum%10)的结果是long类型，直接赋值给ListNode的int型的val会报错 temp.next = new ListNode((int)(sum%10)); temp = temp.next; sum /= 10; &#125; return listNode.next;&#125;/*** 该函数是为了计算链表所表示的值*/private int compute(ListNode node)&#123; int result = 0; for(int i = 1 ; node != null ; node = node.next)&#123; result += node.val *i; i *= 10; &#125; return result;&#125; 我们算一下int的最大值是多少，int是4个字节也就是32位，可以表示2^32个数字， 再来看long的最大值，long是8个字节也就是64位，可以表示2^64位。 此方法乍一看确实没问题，但是，请看题目要求 题目要求告诉我们，测试的时候可能会出现100位的数字，long类型最大值远远不够，所以当数字很大的时候，该方法就会崩盘。 这时候就需要考虑其他方法。比如，递归。 法二：递归分析：我们现在有两个链表，我们对其要清楚两点 两个链表的长度不一定相同 两个链表相加后，长度不一定不变 递归需要先将递归退出条件写出来，即两者都到尾部，就简单看看我画的思路图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode listNode = new ListNode(); add(l1,l2,listNode); return listNode; &#125; public ListNode add(ListNode a,ListNode b,ListNode temp)&#123; // 当两个链表都到头了，则退出递归 if(a==null&amp;&amp;b==null)&#123; return temp; &#125; // 此变量是用来标注下一次递归的时候两个链表是否是都尾部了 boolean flag=false; // 当a到尾部的时候，将temp的数据域变为自身加上b的数据域的值 if(a==null)&#123; temp.val+=b.val; // 在a已经到尾部的情况下，b的next为null，即b将在下一次递归到尾部了，则将flag变为true if(b.next==null)&#123; flag=true; &#125; // 当b到头的时候，将temp的数据域变为自身加上b的数据域的值 &#125;else if(b==null)&#123; temp.val+=a.val; // 在b已经到尾部的情况下，a的next为null，即a将在下一次递归到尾部了，则将flag变为true if(a.next==null)&#123; flag=true; &#125; &#125;else &#123; temp.val+=a.val+b.val; if(a.next==null&amp;&amp;b.next==null)&#123; flag=true; &#125; &#125; // left用来存储当前这一位的值是否&gt;=10，如果满足，则进1 int left=temp.val&gt;=10?1:0; // 将left作为初始值new出来temp的下一个指针 temp.next = new ListNode(left); // 为了防止超过十，所以这里做了取余的操作， temp.val = temp.val%10; // 如果下一次递归的时候两者都到了尾部，并且没有进1，则不需要new出来temp的next if(flag&amp;&amp;left==0)&#123; temp.next=null; &#125; //递归调用 return add(a==null?null:a.next,b==null?null:b.next,temp.next); &#125;&#125; 其实这种递归就是化简为繁了，下面这种做法才是我觉得最好的。 第二次写 1234567891011121314151617181920212223class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return add(l1,l2,0); &#125; public ListNode add(ListNode l1, ListNode l2, int bit) &#123; if (l1 == null &amp;&amp; l2 == null &amp;&amp; bit == 0) &#123; return null; &#125; int val = bit; // bit就是表示每次是否进位 if (l1 != null) &#123; val += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; val += l2.val; l2 = l2.next; &#125; ListNode node = new ListNode(val % 10); node.next = add(l1, l2, val / 10); return node; &#125;&#125; 法三：并行遍历分析：直接两条链表一起遍历，用left存储是否进位 1234567891011121314151617181920212223242526272829class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode cur = new ListNode(0); ListNode temp = cur; int left = 0; // 当两者有一个没有遍历到尾部就一直遍历 while(l1 != null || l2 != null) &#123; int x = (l1 == null ? 0 : l1.val); int y = (l2 == null ? 0 : l2.val); int sum = x + y + left; // left = sum &gt;= 10 ? 1 : 0;两者一样的，但是下者表达更简单 left = sum / 10; sum = sum % 10; temp.next = new ListNode(sum); temp = temp.next; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; // 做单独处理 if(left == 1) &#123; temp.next = new ListNode(left); &#125; return cur; &#125;&#125; 第二次写 123456789101112131415161718192021222324252627class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode t1 = l1; ListNode t2 = l2; int bit = 0; ListNode res = new ListNode(); ListNode temp = res; // 三种情况可以继续循环 // 1、tl未到头 // 2、t2未到头 // 3、bit为1，表示进位 while(t1 != null || t2 != null || bit != 0)&#123; int a = t1 == null? 0 : t1.val; int b = t2 == null? 0 : t2.val; // a+b+bit表示该位的和，放入该地方的是余数 temp.next = new ListNode((a+b+bit)%10); temp = temp.next; // bit表示的是是否满十进位，只要该数除以10，为1则表示该数大于10了 bit = (a+b+bit)/10; if(t1 != null) t1 = t1.next; if(t2 != null) t2 = t2.next; &#125; return res.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【1-Easy】两数之和","slug":"【1-Easy】两数之和","date":"2022-02-21T10:52:45.000Z","updated":"2022-09-27T14:35:37.016Z","comments":true,"path":"算法/刷题篇/2022/02/21/【1-Easy】两数之和/","link":"","permalink":"https://li-zhi.net.cn/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/2022/02/21/%E3%80%901-Easy%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ Related Topics 数组 哈希表 法一：暴力枚举法分析：题目意思很明确，就是给你一个target，然后给你一个数组，在这个数组里面找到可以和是这个target的那两个数的索引数组 上代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[]&#123;-1,-1&#125;; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if(j!=i&amp;&amp;nums[j]==target-nums[i])&#123; result[0]=i; result[1]=j; return result; &#125; &#125; &#125; return result; &#125;&#125; 法二：哈希表分析：法一取到target-nums[i]使用的是遍历算法，那我们就可以使用hashmap在这一点提高效率 hashmap的 键为nums[i] 值为索引 上代码： 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;-1,-1&#125;; &#125;&#125; 第二个解法的核心在于：hash 表是如何将 查找 target - x，元素从 O(N),降低到 O（1）的？ 其实算法中最基本的数据结构就两个，不管多么高深的算法底层都是这两个结构 一个是数组，效率为O(1) 一个是链表，效率为O(N) 要想达到O（1）的算法，底层一定是数组。put方法内部首先对 key做了 hash（）运算，将其映射到数组上，只要不做扩容，或者缩容，key 在数组的位置就是固定的。每次通过get方法获取值得时候，先取得其hash值，然后再通过数组下标的方式，直接返回，所以是O（1）的效率","categories":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"去IOE是什么？","slug":"去IOE是什么？","date":"2022-02-21T07:58:53.000Z","updated":"2022-09-27T13:57:21.326Z","comments":true,"path":"琐碎的知识/2022/02/21/去IOE是什么？/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/21/%E5%8E%BBIOE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"什么去IOE？I是以IBM为代表的小型机小型机与X86服务器的区别： 价格 一台小型机可以买3-4台X86服务器 指令 X86 兼容性好 性能差 小型机 兼容性差 性能好 性能 领域 O是以ORACLE为代表的关系型数据库架构2013年5月17日，最后一台IBM小型机在支付宝下线了，这个是去IOE的一个重要的一个节点。ORACLE数据库告别阿里巴巴是在2013年的7月10日，这一天阿里巴巴的一个重要广告系统的ORACLE数据库也下线了，也是淘宝最后一个ORACLE数据库，这两件事情合在一起啊，也是构成阿里巴巴的一个重要的一个里程碑。 阿里巴巴呢一直是采用的是ORCALE数据库，并利用小型机和高端的存储设备提高性能和数据库的性能，但随着业务的不停的发展，数据量愈发庞大。 传统的移动式ORACLE数据库的扩展，也存在着一些瓶颈。传统的ORACLE软件为代表的关系数据库，大多数呢是以集中式架构为主，这些传统的数据库软件是最大的特点呢，就是将所有的数据集中存储在一个数据库中，依赖大型的高端设备来提高处理的性能和扩展性，集中式数据库的扩展呢，主要是采用向上扩展的那这种方式啊，就是通过增加CPU内存的方式提高处理能力，这种处理的架构就使得数据库成为一个很大的一个系统瓶颈，越来越不适合目前海量数据对计算能力的一个需求。 E是以EMC为代表的高端SAN存储设备SAN：Storage Area Network EMC是一家美国信息存储公司。","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Redis-五大基础数据类型","slug":"Redis-五大基础数据类型","date":"2022-02-21T02:00:54.000Z","updated":"2022-10-04T13:54:51.466Z","comments":true,"path":"javaEE/Redis/2022/02/21/Redis-五大基础数据类型/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/21/Redis-%E4%BA%94%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"基础知识redis默认有16个数据库Redis的瓶颈是根据机器的内存和网络带宽。 为什么单线程还可以这么快？redis是c语言写的，官网提供的性能数据 1s 11万读取 1s 8万写入 误区： 高性能的服务器一定是多线程的 多线程一定比单线程效率高 CPU—&gt;内存—&gt;硬盘 核心：redis将所有的数据都放入内存中，所以用单线程去操作效率是很高的，多线程（CPU上下文会切换，十分耗时），对于内存系统，没有上下文切换效率会很高，多次读写都是在一个CPU上的，没有线程调度的耗时 五大数据类型基础命令1234567891011121314151617181920212223242526272829303132333435363738# 切换数据库select index# 查看当前数据库的数据数dbsize# 查看当前所有符合pattern的keykeys pattern# 是否存在该key，存在则返回1，不存在则返回0exists key# 移除keymove key#设置kvset key value# 查看key存储的值get key# 查看类型type key# 设置过期时间为secondssexpire key seconds#查看剩余时间ttl key# 清空当前数据库flushdb# 清空所有的数据库的内容flushall# 随机输出一个keyrandomkey String123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# 追加key存储的value字符串# 如果key不存在，则该命令相当于set# append key valueappend key &quot;appendstring&quot;# 查看key存储的字符串的长度strlen key# 自增1，自减1的操作# incr key # decr key127.0.0.1:6379&gt; set views 1OK127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; incr views(integer) 3127.0.0.1:6379&gt; decr views(integer) 2127.0.0.1:6379&gt; decr views(integer) 1# 一次性加或者减指定数字的操作# incrby key increment# decrby key decrement127.0.0.1:6379&gt; incrby views 10(integer) 11127.0.0.1:6379&gt; decrby views 10(integer) 1# 获取一个范围内的字符串，即substring==&gt;[start,end)# 注意这里的getrange是闭区间，[start,end]# getrange key start end127.0.0.1:6379&gt; set name zhimaOK127.0.0.1:6379&gt; getrange name 0 3&quot;zhim&quot;127.0.0.1:6379&gt; getrange name 0 -1&quot;zhima&quot;# 替换字符串# setrange key offset value127.0.0.1:6379&gt; set key randomstringOK127.0.0.1:6379&gt; setrange key 3 xxx(integer) 12127.0.0.1:6379&gt; get key&quot;ranxxxstring&quot;# setex (set with expire) 设置过期时间# 设置该字段过期时间为30s# setex key seconds valuesetex key 30 &quot;expire&quot;# 如果不存在则设置值，在分布式锁中经常使用# setnx (set if not exist)# setnx key value127.0.0.1:6379&gt; set key1 value1OK127.0.0.1:6379&gt; get key1&quot;value1&quot;127.0.0.1:6379&gt; setnx key1 &quot;setnx&quot;(integer) 0127.0.0.1:6379&gt; set key1 &quot;setnx&quot;OK127.0.0.1:6379&gt; get key1&quot;setnx&quot;# 批量获取和设置值 # mget mset msetnx# mset key value [key value..]# mget key [key..]# msetex key value [key value..]127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; mget k1 k21) &quot;v1&quot;2) &quot;v2&quot;127.0.0.1:6379&gt; msetnx k1 modifiedv1 k4 v4 # 该操作是一个原子性的操作！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 删除# del key127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; keys *1) &quot;k1&quot;127.0.0.1:6379&gt; del k1(integer) 1127.0.0.1:6379&gt; keys *(empty list or set)# 对象set user:1&#123;name:zhangsan,age:3&#125; # 设置一个user:1对象 值为json字符串来保存# 这里的key是一个巧妙的属性：&#123;className&#125;:&#123;id&#125;:&#123;field&#125;，在redis中是可以的127.0.0.1:6379&gt; mset user:1:name zhima user:1:age 19OK127.0.0.1:6379&gt; keys *1) &quot;user:1:age&quot;2) &quot;user:1:name&quot;127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhima&quot;2) &quot;19&quot;# 组合命令# getset先取得当前的值并返回，然后修改当前的值# getset key value127.0.0.1:6379&gt; getset db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db modified&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;modified&quot; List可以给其设置一个使用规则，则可以将其实现栈或者队列的功能 1234567891011# 设置和取值# lrange key start stop [start,stop]127.0.0.1:6379&gt; lpush list1 v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list1 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lrange list1 0 11) &quot;v3&quot;2) &quot;v2&quot; 分析可知这里的lpush是头插入，也就是left插入，那与之对应的肯定还有个尾插入，即right插入，但是啊只有LRANGE操作来取得集合里的数据，没有RRANGE操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131127.0.0.1:6379&gt; rpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;# 删除头部的值并返回# lpop key127.0.0.1:6379&gt; lpop list&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;2) &quot;v3&quot;# 删除尾部的值并返回# rpop key127.0.0.1:6379&gt; rpop list&quot;v3&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 获取索引处的元素# lindex key index127.0.0.1:6379&gt; lpush list v1 v2 v3(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; lindex list 0&quot;v3&quot;# 获取集合长度# llen key 127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v2&quot;3) &quot;v1&quot;127.0.0.1:6379&gt; llen list(integer) 3# 移除指定个数的匹配的值# lrem key count value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;4) &quot;v1&quot;127.0.0.1:6379&gt; lrem list 1 v1(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;v3&quot;2) &quot;v3&quot;3) &quot;v2&quot;127.0.0.1:6379&gt; lrem list 2 v3(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;v2&quot;# 截取指定位置的值# ltrim key start stop127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; ltrim list 0 2OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;# 将集合尾部元素移除，并在另一个集合头部加入一个元素# rpoplpush source destination127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; rpoplpush list otherlist&quot;v1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lrange otherlist 0 -11) &quot;v1&quot;# 修改指定索引处元素的值127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;127.0.0.1:6379&gt; lset list 0 modifiedOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;modified&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;# lpush key value [value...]# 当该集合不存在的时候会自动创建# lset key index value# 当该集合不存在的时候会报错# 在指定值的前面|后面插入值# linsert key BEFORE|AFTER pivot value127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;v3&quot;4) &quot;v2&quot;5) &quot;v1&quot;127.0.0.1:6379&gt; linsert list before v2 brforev2(integer) 6127.0.0.1:6379&gt; linsert list after v4 afterv4(integer) 7127.0.0.1:6379&gt; lrange list 0 -11) &quot;v5&quot;2) &quot;v4&quot;3) &quot;afterv4&quot;4) &quot;v3&quot;5) &quot;brforev2&quot;6) &quot;v2&quot;7) &quot;v1&quot; 该List实质上是使用链表实现的 栈：出栈（Lpop）入栈（Lpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Rpush） 队列：出队（Lpop）入队（Rpush）&#x3D;&#x3D; 出栈（Rpop） 入栈（Lpush） Set该集合的特点是：无序不重复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 添加一个元素# sadd key member [member..]# 查看所有的成员# smembers key127.0.0.1:6379&gt; sadd set a b c a(integer) 3127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;# 判断是否包含某个元素127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sismember set c(integer) 1127.0.0.1:6379&gt; sismember set d(integer) 0# 查看集合的长度127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; scard set(integer) 3# 删除某个元素# srem key member [member..]127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srem set a c(integer) 2127.0.0.1:6379&gt; smembers set1) &quot;b&quot;# 随机返回指定个数的元素# srandmember key count127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; srandmember set 31) &quot;d&quot;2) &quot;b&quot;3) &quot;a# 随机删除指定个数的元素，不写count默认为1# spop key [count] 127.0.0.1:6379&gt; smembers set1) &quot;d&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;c&quot;5) &quot;e&quot;127.0.0.1:6379&gt; spop set 31) &quot;c&quot;2) &quot;e&quot;3) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;d&quot;# 将一个指定的值，移到另一个集合中# smove source destination member127.0.0.1:6379&gt; sadd set a b c d e(integer) 5127.0.0.1:6379&gt; smove set set2 a(integer) 1127.0.0.1:6379&gt; smembers set21) &quot;a&quot;127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;# 交集 sinter key [key..]# 差集 sdiff key [key..]# 并集 sunion key [key..]127.0.0.1:6379&gt; smembers set1) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;127.0.0.1:6379&gt; smembers set21) &quot;b&quot;2) &quot;a&quot;3) &quot;g&quot;127.0.0.1:6379&gt; sinter set set21) &quot;b&quot;127.0.0.1:6379&gt; sdiff set set21) &quot;d&quot;2) &quot;e&quot;3) &quot;c&quot;127.0.0.1:6379&gt; sunion set set21) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;4) &quot;e&quot;5) &quot;a&quot;6) &quot;g&quot; HashMap集合，key-Map集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# hset key field value# 放入一个map# hget key field 127.0.0.1:6379&gt; hset hashmap name zhima(integer) 1127.0.0.1:6379&gt; hget hashmap name&quot;zhima&quot;# 设置和取得多个键值对# hmset key field name [field name..]# hmget key field [field..]127.0.0.1:6379&gt; hmset user:1 name zhim age 10OK127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhim&quot;2) &quot;10&quot;# 使用hset更新键值对127.0.0.1:6379&gt; hset user:1 name zhima(integer) 0127.0.0.1:6379&gt; hmget user:1 name age1) &quot;zhima&quot;2) &quot;19&quot;# 取得所有的键值对# hgetall key 127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;19&quot;# 获取键值对个数# hlen key127.0.0.1:6379&gt; hlen user:1(integer) 2# 删除键值对# hdel key field127.0.0.1:6379&gt; hdel user:1 name(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;age&quot;2) &quot;19&quot;# 是否存在该键值对# hexists key field127.0.0.1:6379&gt; hexists user:1 name(integer) 1127.0.0.1:6379&gt; hexists user:1 unknown(integer) 0# 获得所有的键# hkeys key# 获得所有的值# hvals key127.0.0.1:6379&gt; hkeys user:11) &quot;name&quot;2) &quot;age&quot;127.0.0.1:6379&gt; hvals user:11) &quot;zhima&quot;2) &quot;19&quot;# 增加值# hincrby key field increment # ！注意：！这里没有自减的方法，但是可以为increment设置负数来实现减127.0.0.1:6379&gt; hincrby user:1 name 1(error) ERR hash value is not an integer127.0.0.1:6379&gt; hincrby user:1 age 2(integer) 21127.0.0.1:6379&gt; hmset user:2 name lizhi age &quot;19&quot;OK127.0.0.1:6379&gt; hgetall user:21) &quot;name&quot;2) &quot;lizhi&quot;3) &quot;age&quot;4) &quot;19&quot;127.0.0.1:6379&gt; hincrby user:2 age 2(integer) 21127.0.0.1:6379&gt; hincrby user:2 age -1(integer) 20# 如果不存在该字段，则添加该字段# 如果存在，则不进行操作# hsetnx key field value127.0.0.1:6379&gt; hsetnx user:1 name modified(integer) 0127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;127.0.0.1:6379&gt; hsetnx user:1 address unknown(integer) 1127.0.0.1:6379&gt; hgetall user:11) &quot;name&quot;2) &quot;zhima&quot;3) &quot;age&quot;4) &quot;21&quot;5) &quot;address&quot;6) &quot;unknown&quot; Hashmap适合存储对象 Zset（有序列表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 添加值 这个score相当于权重，用来排序# zadd key [NX|XX] [CH] [INCR] score member [score member..]127.0.0.1:6379&gt; zadd myzset 1 one(integer) 1127.0.0.1:6379&gt; zadd myzset 2 two 3 three(integer) 2# 正序输出# zrange key start stop [withscores]127.0.0.1:6379&gt; zrange myzset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;# 倒叙输出# zrevrange key start stop [withscores]127.0.0.1:6379&gt; zrevrange salary 0 -11) &quot;lizhi&quot;2) &quot;xiaozhang&quot;3) &quot;zhima&quot;# 携带权重输出127.0.0.1:6379&gt; zrange salary 0 -1 withscores1) &quot;zhima&quot;2) &quot;1000&quot;3) &quot;xiaozhang&quot;4) &quot;1500&quot;5) &quot;lizhi&quot;6) &quot;2000&quot;# zrangebyscore key min max [withscores] [limit offset count]# 获取score在min到max之间的元素，闭区间127.0.0.1:6379&gt; zrangebyscore salary 1000 16001) &quot;zhima&quot;2) &quot;xiaozhang&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf1) &quot;zhima&quot;2) &quot;xiaozhang&quot;3) &quot;lizhi&quot;# zrevrangebyscore key max min [withscores] [limit offset count]# 倒叙输出score在max到min之间的，闭区间，# [limit offset count]是指定显示从offset开始的count个数据，包括offset所在的元素127.0.0.1:6379&gt; zrevrangebyscore salary 1600 10001) &quot;xiaozhang&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zadd salary 10 xiaoming 27 ziaohzhyang 19 zhima 25 lizhi(integer) 4127.0.0.1:6379&gt; zrangebyscore salary 10 191) &quot;xiaoming&quot;2) &quot;zhima&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 withscores1) &quot;xiaoming&quot;2) &quot;10&quot;3) &quot;zhima&quot;4) &quot;19&quot;5) &quot;lizhi&quot;6) &quot;25&quot;127.0.0.1:6379&gt; zrangebyscore salary 10 25 limit 0 21) &quot;xiaoming&quot;2) &quot;zhima&quot;# 删除元素127.0.0.1:6379&gt; zrem salary xiaoming(integer) 1# 查看该集合的长度# zcard key127.0.0.1:6379&gt; zcard salary(integer) 3# 查看符合[min,max]区间的元素个数# zcount key min max127.0.0.1:6379&gt; zcount salary 10 19(integer) 2 注：以上命令只是常用命令，更多命令可以在官网查看 英文官网地址：https://redis.io/ 中文官网地址：http://www.redis.cn/","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Redis-前期准备","slug":"Redis-前期准备","date":"2022-02-19T09:36:09.000Z","updated":"2022-10-04T13:54:33.955Z","comments":true,"path":"javaEE/Redis/2022/02/19/Redis-前期准备/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Redis/2022/02/19/Redis-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","excerpt":"","text":"Nosql我们先前学的都是mysql，它是关系型数据库，表与表之间有联系。 NoSql即非关系型数据库。 MySql MySql的瓶颈 数据太大了，一个机器就放不下了 30万以上的数据，需要使用索引（B+Tree） 访问量大的话，服务器压力大 解决方案：读写分离（垂直拆分） 因为80%网站对于数据的操作都是读取，不会产生并发问题，所以为了提升效率，当我们第一次读取完数据后，将数据放入缓存中，下一次查询如果是同样的业务，则直接从缓存中读取数据，会大大提升性能，解决了读的压力 解决方案：分库分表，MySql集群（水平拆分）每一个集群放一些表和数据库，这样的操作解决了写的压力 如今的数据数据量大，变化快，导致mysql无法很好的解决问题。 有的人使用mysql来存储一些比较大的文件，博客推文，图片等，数据库非常庞大，效率十分低下。 如果有一种数据库来专门处理这种数据，mysql的压力就变小了。这时候就需要使用Nosql了 特点 方便拓展（数据之间联系低，很好拓展） 大数据高性能（Redis1s读11万次，写8万次，Nosql的缓存记录，是一种细粒度的缓存，性能比较高） 数据多样，不需要事先设计数据库 大数据时代的3V：出现的一些问题 Volume 海量 Variety 多样 Velocity 实时 大数据时代的3高：对程序的要求 高性能 高可用（扩） 高并发 Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis+Tair 阿里+百度：Redis+MemeCache 应用场景：内容缓存，主要用于处理大量数据的高访问负载，也用于些日志系统等等。 数据模型：Key 指向的键值对Value，通常用hash table来实现 优点：查找速度快 缺点：数据无结构，通常只被当做字符串或者二进制存储 文档型数据库（BSON格式） MongoDB 基于分布式文件存储的数据库，C++编写的，主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中间的产物，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的 ConthDB 应用场景：web应用 数据模型：key-value键值对（Value为结构化数据） 优点：数据结构要求不严格表结构可不需要像关系型数据库那样需要预先定义表结构 缺点：查询效率不高，而且缺乏统一的查询语句 列存储数据库 HBase 应用场景：分布式文件系统 数据模型：以列簇式存储，将同一列数据存储在一起 优点：查找速度快，可拓展性强，容易实现分布式文件系统 缺点：功能相对局限 图形关系数据库 存的是关系，不是存图形的 Neo4j InfoGrid 应用场景：社交网络、相关推荐 数据模型：图架构 优点：利用图结构相关算法，比如最短路径寻址N度关系查找等 缺点：很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方式 Redis简介概述 Redis全名是Remote Dictionary Server ，即远程字典调用 默认端口是6379 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 它使用ANSI、C语言编写的、支持网络、可以基于内存亦可持久化的日志型、Key-value数据库、并提供多种语言的API，亦被称为结构化数据库 下载下载后直接解压即可12链接：https://pan.baidu.com/s/12ozkQkUss8GH70lf7qrinQ 提取码：nv5z 点击redis-server.exe即可启动服务 备注Redis推荐我们使用Linux使用redis，所以接下来使用阿里云服务器来学习redis 12链接:https://pan.baidu.com/s/1Hy1eFwcSqfftXrWv92-zug 提取码:u1ff 将压缩文件解压到服务器的opt目录下即可，进入解压后的目录，然后安装gcc-c++ 12yum install gcc-c++make 也可以使用docker创建redis容器 1234# 开启一个redis容器并设置密码docker run -it --name studyredis -p6379:6379 --requirepass lizhi9275 redis# 查看运行的容器docker ps","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"}]},{"title":"Springboot-shiro","slug":"SpringBoot-Shiro","date":"2022-02-17T03:56:42.000Z","updated":"2022-10-04T13:55:11.308Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Shiro/","excerpt":"","text":"Shiro简介其实这个就是一个关于做安全管理的框架，他不仅可以和javaEE结合也可以和javaSE结合 提供的功能 Authentication：身份认证，登录，验证用户的身份 Authorization：授权， Session Management： Shiro内置的session，对其进行管理 Cryptography：加密，保证数据的安全性 Web Support： web支持，可以很好的集成到web环境 Caching： 缓存， Concurrency： 多并发 Testing：测试 Remember Me：”记住我”的功能 Shiro结构我们来观察一下Shiro的结构 解释一下出现的名词 subject：与当前应用交互的任何东西都可以是Subject，与Subject的所有交互都会委托给SecurityManager，Subject其实只是一个门面，SecurityManager 才是实际的执行者 SecurityManager：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，并且它管理着所有的Subject，它是Shiro的核心，它负责与Shiro的其他组件进行交互 Realm： Shiro从Realm获取安全数据（如用户，角色，权限），就是说SecurityManager 要验证用户身份，那么它需要从Realm 获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行 快速开始（看一下直接过）导入依赖 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/jcl-over-slf4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.24&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置文件 log4j.properties 123456789101112131415161718log4j.rootLogger=INF0,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n# GeneraL Apache Librarieslog4j.logger.org.apache=WARN# Springlog4j.logger.org.springframework=WARN# Defautt Shiro Logginglog4j.logger.org.apache.shiro=INF0# DisabLe verbose Logginglog4j.logger.org.apache.shiro.util.ThreadContext=WARNlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN shiro.ini 12345678910111213141516171819202122232425[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27;（&quot;That&#x27;s the same combination on# my Luggage!!!&quot; ;)), and rote &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhe met&#x27; with password &#x27;Ludicrousspeed’and rotes &#x27;darklord’and &#x27;schwartzdarkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;tonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# RoLes with assigned permissions# Each Line conforms to the format defined in the# org.apache.shiro.reatm.text.TextConfigurationReatm#setRoleDefinitions JavaDoc# -[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard&#x27;* &#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is aLlowed to &#x27;drive&#x27; (action) the winnebago (type) with# ticense plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5 ShiroQuickStart.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ShiroQuickStart &#123; private static final Logger LOG = LoggerFactory.getLogger(ShiroQuickStart.class); public static void main(String[] args) &#123; Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); Session session = currentUser.getSession(); session.setAttribute(&quot;someKey&quot;,&quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if(&quot;aValue&quot;.equals(value))&#123; LOG.info(&quot;Retrieved the correct value&quot;); &#125; if(!currentUser.isAuthenticated())&#123; UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestar&quot;, &quot;vespa&quot;); token.setRememberMe(true); try&#123; currentUser.login(token); &#125;catch (UnknownAccountException uae)&#123; LOG.info(&quot;There is no user with username whith &quot;+ token.getPrincipal()); &#125;catch (IncorrectCredentialsException ice)&#123; LOG.info(&quot;Password for account&quot;+ token.getPrincipal()+&quot;was incorrect&quot;); &#125;catch (LockedAccountException lae)&#123; LOG.info(&quot;The Account for userName&quot;+ token.getPrincipal()+&quot;is locked. &quot; + &quot;Please contact your administrator to unlocked it&quot;); &#125;catch (AuthenticationException ae)&#123; //unexpected exception &#125; &#125; LOG.info(&quot;USER[&quot;+ currentUser.getPrincipal()+&quot;] logged in successfully&quot;); if(currentUser.hasRole(&quot;schwartz&quot;))&#123; LOG.info(&quot;May the Schwartz be with you&quot;); &#125;else &#123; LOG.info(&quot;Hello,Mere mortal&quot;); &#125; if(currentUser.isPermitted(&quot;lightsaber:wield&quot;))&#123; LOG.info(&quot;You may use a lightsaber ring use it wisely&quot;); &#125;else &#123; LOG.info(&quot;Sorry, light rings are for schwartz masters only&quot;); &#125; if(currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;))&#123; LOG.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate(id) &#x27;eagle5&#x27;. &quot; + &quot;Here are the keys-have fun!&quot;); &#125;else &#123; LOG.info(&quot;Sorry,you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago&quot;); &#125; currentUser.logout(); System.exit(0); &#125;&#125; 运行输出 123456789101112131415161718192021222324252627282930313233342022-02-17 14:33:37,982 DEBUG [org.apache.shiro.io.ResourceUtils] - Opening resource from class path [shiro.ini] 2022-02-17 14:33:38,021 DEBUG [org.apache.shiro.config.Ini] - Parsing [users] 2022-02-17 14:33:38,026 DEBUG [org.apache.shiro.config.Ini] - Parsing [roles] 2022-02-17 14:33:38,523 DEBUG [org.apache.shiro.config.IniFactorySupport] - Creating instance from Ini [sections=users,roles] 2022-02-17 14:33:38,571 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [roles] section. Processing... 2022-02-17 14:33:38,575 DEBUG [org.apache.shiro.realm.text.IniRealm] - Discovered the [users] section. Processing... 2022-02-17 14:33:38,594 DEBUG [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - No sessionValidationScheduler set. Attempting to create default instance. 2022-02-17 14:33:38,595 INFO [org.apache.shiro.session.mgt.AbstractValidatingSessionManager] - Enabling session validation scheduler... 2022-02-17 14:33:38,625 DEBUG [org.apache.shiro.session.mgt.DefaultSessionManager] - Creating new EIS record for new session instance [org.apache.shiro.session.mgt.SimpleSession,id=null] 2022-02-17 14:33:39,022 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - Retrieved the correct value 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - Looked up AuthenticationInfo [null] from doGetAuthenticationInfo 2022-02-17 14:33:39,022 DEBUG [org.apache.shiro.realm.AuthenticatingRealm] - No AuthenticationInfo found for submitted AuthenticationToken [org.apache.shiro.authc.UsernamePasswordToken - lonestar, rememberMe=true]. Returning null. 2022-02-17 14:33:39,030 INFO [com.lizhi.springbootshiro.start.ShiroQuickStart] - There is no user with username whith lonestar SpringBoot整合Shiro先按照以下步骤把基本的环境搭好 导入依赖，这里只显示shiro的相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.8.0&lt;/version&gt;&lt;/dependency&gt; 实体类User.java 12345678910@Data@NoArgsConstructor@AllArgsConstructor@ToStringpublic class User &#123; private int id; private String userName; private String password; private String perms;&#125; 配置类ShiroConfig.java 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; //ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); return shiroFilterFactoryBean; &#125; //DefaultWebSecurityManager @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Autowired UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(userRealm); return securityManager; &#125; //realm,需要自定义，用来做授权和认证的 @Bean public UserRealm userRealm()&#123; return new UserRealm(); &#125; UserRealm.java 1234567891011121314151617public class UserRealm extends AuthorizingRealm &#123; @Autowired private UserMapper userMapper; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); return null; &#125;&#125; index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;ul&gt; &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; user的add页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的add&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的del页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的delete&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; user的update页面 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;user的update&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; MyController.java 1234567891011121314151617181920212223242526272829package com.lizhi.springbootshiro.contoller;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MyController &#123; @GetMapping(&quot;/index&quot;) public String index(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,shiro&quot;); return &quot;index&quot;; &#125; //这里是restful风格 @GetMapping(&quot;/user/&#123;method&#125;&quot;) public String operateUser(@PathVariable(&quot;method&quot;) String method)&#123; return &quot;user/&quot;+method; &#125;&#125; UserMapper.java user表中就三个字段。id,user_name,password,perms 12345@Mapperpublic interface UserMapper &#123; List&lt;User&gt; listAllUsers(); User getUserByName(String userName);&#125; UserMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.springbootshiro.mapper.UserMapper&quot;&gt; &lt;select id=&quot;listAllUsers&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` &lt;/select&gt; &lt;select id=&quot;getUserByName&quot; resultType=&quot;com.lizhi.springbootshiro.pojo.User&quot;&gt; select id,user_name as userName,password,perms from `user` where user_name = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt; 登录拦截登录拦截指的是，未登录的用户不得进入用户的增删改页面 下面是集中拦截规则，一般authc和perms用的比较多 1234567/** * anno： 无需认证即可访问 * authc：必须认证了才可以访问 * perms：必须拥有权限才可以访问 * roles：必须拥有某种角色才可以访问 * user：必须拥有记住我的功能的时候才可以访问（一般很少用） */ 这是在ShiroFilterFactoryBean中配置的 1234567891011121314151617@Beanpublic ShiroFilterFactoryBean getShiroFilterFactory(@Autowired DefaultWebSecurityManager defaultWebSecurityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager); Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //设置该路径只有user:add才可以访问 filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;); //设置该路径只有user:update才可以访问 filterMap.put(&quot;/user/del&quot;,&quot;perms[user:del]&quot;); //设置该路径只有user:del才可以访问 filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;); //设置登录的路径 shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;); //设置登录成功的路径 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauth&quot;); //设置未授权的用户被访问后跳转的路径 return shiroFilterFactoryBean;&#125; login.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;p style=&quot;color: red&quot;&gt;[[$&#123;error&#125;]]&lt;/p&gt; &lt;form th:action=&quot;@&#123;/login.do&#125;&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;请输入您的用户名&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入您的密码&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; MyController中配置路径 123456789101112131415161718192021222324252627282930@GetMapping(&quot;/login&quot;)public String login()&#123; return &quot;login&quot;;&#125;@GetMapping(&quot;/unauth&quot;)@ResponseBody //这里偷懒没写页面了，而是直接将消息返回到页面中public String unauthorized()&#123; return &quot;未经授权无法访问此页面&quot;;&#125;@GetMapping(&quot;/login.do&quot;)public String doLogin(String userName, String password, Model model) &#123; //获取当前用户 Subject currentUser = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(userName, password); try&#123; currentUser.login(token);//这里下一步是到userRealm的认证方法 //如果没有抛出异常，则说明登录成功 Subject currentUser = SecurityUtils.getSubject(); //拿到shiro内部的session保存数据， currentUser.getSession().setAttribute(&quot;loginInfo&quot;,user); return &quot;index&quot;; &#125;catch (UnknownAccountException uae)&#123; model.addAttribute(&quot;error&quot;,&quot;用户名错误&quot;); return &quot;login&quot;; &#125;catch (IncorrectCredentialsException ice)&#123; model.addAttribute(&quot;error&quot;,&quot;密码错误&quot;); return &quot;login&quot;; &#125;&#125; 用户认证案例走到这里，你会发现无论怎么登录都是错的，那是因为我们还没有对用户进行认证。 用户认证指的是，当用户登录的时候，对其进行验证 1234567891011121314151617@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;认证&quot;); /** * 数据库中读取数据 */ UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; User user = userMapper.getUserByName(token.getUsername()); if(user==null)&#123; //这里如果返回null的话，会自动抛出异常到下图处 return null; &#125; //这里的第一个参数user会设置给当前登录对象的Principal中。 //可以通过SecurityUtils.getSubject().getPrincipal()获取 //第二个参数传入正确的密码，即数据库中的密码，交给shiro来做密码的校验，如果密码错误，也会抛出异常到下图的地方 return new SimpleAuthenticationInfo(user, user.getPassword(),&quot;&quot;);&#125; 这里插上一嘴，在web环境中，通过subject拿到的session即web框架中的那个session。 但是如果shiro没有使用在web环境的话，内部也是有一个session的，但是那个就不是web中的session了。 用户授权好啦，现在案例已经可以跑起来了，并且如果账号密码正确的话是可以登录的，并且返回到主页 还记得我们在下图配置的这一串让人一头雾水的配置吗？ 这里就只是配置了一个规则，但是具体登录的用户的授权还没有做，我们现在去完成它吧 1234567891011121314@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;授权&quot;); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //这里需要根据用户表的数据进行增加权限 Subject subject = SecurityUtils.getSubject(); //拿到用户认证的时候传入的user User currentUser = (User) subject.getPrincipal(); System.out.println(&quot;权限为：&quot;+ currentUser.getPerms()); //数据库中perms字段是以这样的形式存储的 user:add,user:update //所以需要将其用，分割然后使用工具类将其转换为集合传入addStringPermissions info.addStringPermissions(Arrays.asList(currentUser.getPerms().split(&quot;,&quot;))); return info;&#125; 现在就完成了所有的配置啦！大家可以尝试一下 这里再多完成一个需求，就是首页只显示用户具有权限的链接 首先需要导入thymeleaf的依赖，然后再导入命名空间xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot; 12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 配置一个bean 12345//整合thymeleaf@Beanpublic ShiroDialect shiroDialect()&#123; return new ShiroDialect();&#125; index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;p&gt;[[$&#123;msg&#125;]]&lt;/p&gt; &lt;!--当session中没有登录信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo==null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;!--当session有信息的时候显示--&gt; &lt;p th:if=&quot;$&#123;session.loginInfo!=null&#125;&quot;&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;!--或者像这样写，不用将用户信息存入session &lt;p shiro:notAuthenticated&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;p shiro:authenticated&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; --&gt; &lt;ul&gt; &lt;li shiro:hasPermission=&quot;user:add&quot;&gt;&lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;用户增&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:del&quot;&gt;&lt;a th:href=&quot;@&#123;/user/del&#125;&quot;&gt;用户删&lt;/a&gt;&lt;/li&gt; &lt;li shiro:hasPermission=&quot;user:update&quot;&gt;&lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;用户改&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 注销大家都应该注意到了，上面的页面中多了一个注销的链接，接下来我们来完成一下注销的功能 12345@GetMapping(&quot;/logout&quot;)public String logout()&#123; SecurityUtils.getSubject().logout(); return &quot;index&quot;;&#125; 是的，你没有看错，就是这么简单，shiro已经将其完美得封装好了 以上","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"swagger","slug":"SpringBoot-Swagger","date":"2022-02-17T02:11:19.000Z","updated":"2022-10-04T13:55:14.714Z","comments":true,"path":"javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/17/SpringBoot-Swagger/","excerpt":"","text":"Swagger 号称世界上最流行的API框架 RestFul风格的API展示可以实现API文档和API定义同步更新 SpringBoot整合Swagger 导入相关依赖 1234567891011121314151617&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--需要web的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 写一个简单的Controller 1234567@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 开启Swagger功能 1234@Configuration@EnableSwagger2public class SwaggerConfig &#123; &#125; 访问swagger-ui.html 我们在ui的jar包中可以知道我们可以访问该页面 这是访问的页面 配置SwaggerSwagger中用来配置的bean是Docket 配置文档信息123456789101112131415161718@Beanpublic Docket docket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo());&#125;//配置swagger信息public ApiInfo apiInfo()&#123; return new ApiInfo( &quot;swagger测试&quot;,//文档名称 &quot;初次测试swagger&quot;,//文档描述 &quot;1.0&quot;,//版本号 &quot;http://li-zhi.net.cn/&quot;,//作者个人博客 new Contact(&quot;李智&quot;,&quot;http://li-zhi.net.cn/&quot;,&quot;1158778689@qq.com&quot;),//作者联系方式 &quot;Apache 2.0&quot;,//开源协议 &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() );&#125; 配置模型1234567@Controllerpublic class SwaggerModelConfig &#123; @GetMapping(&quot;/user&quot;) public User user()&#123; return new User(); &#125;&#125; 我是专门建了一个SwaggerModelConfig来放置所有的模型类 配置分组因为项目一般是分组协同开发，每个组各自开发的接口，那接口文档应该各自分开，所以就有了分组的需要 分组只需要配置一个groupName(“groupName”)即可 12345678910@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;);&#125;@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;);&#125; 配置扫描的接口这里主要讲两种方式，第一种是按路径扫描，第二种是按包名扫描 按路径扫描123456789@Beanpublic Docket docket1()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .select() .paths(PathSelectors.ant(&quot;/user/**&quot;)) // 该配置下，该组会扫描所有的/user/下的所有的API .build();&#125; 按包名扫描123456789@Beanpublic Docket docket2()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group2&quot;) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.lizhiswaggertest.controller&quot;)) //该配置下，该组会扫描所有此包下的API接口 .build();&#125; 在类RequestHandlerSelectors中还有其他的扫描机制，可自行研究 根据环境控制是否能访问swagger一般产品的开发都会有开发、测试、运维、上线等多套环境，根据不同的环境，控制是否可以访问swagger的ui界面 配置文件application.yml 1234567891011121314151617181920212223---server: port: 8081spring: profiles: dev---server: port: 8082spring: profiles: test---server: port: 8083spring: profiles: pro---spring: profiles: active: dev 配置dev环境和test环境可以使用swagger 12345678@Beanpublic Docket docket1(Environment environment)&#123; Profiles devProfile = Profiles.of(&quot;dev&quot;,&quot;test&quot;); boolean dev = environment.acceptsProfiles(devProfile); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()).groupName(&quot;group1&quot;) .enable(dev);&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"单例设计模式","slug":"设计模式-单例设计模式","date":"2022-02-16T11:02:56.000Z","updated":"2022-02-25T01:43:38.836Z","comments":true,"path":"设计模式/2022/02/16/设计模式-单例设计模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式该设计模式解决的问题是，一个环境中只会存在一个该类的对象 该模式有五种实现方式 恶汉模式 懒汉模式 静态内部类模式 枚举模式 该设计模式的核心是构造方法私有化 饿汉模式恶汉模式：见名知意，就是在类被加载的时候就创建。 案例：Runtime类 缺点：浪费内存空间 我查了资料，查到了这个缺点，但是这个缺点我不时很能理解 123456789public class Hungry &#123; private final static Hungry HUNGRY = new Hungry(); private Hungry()&#123; &#125; public static Hungry getInstance()&#123; return HUNGRY; &#125;&#125; 懒汉模式这种实现方式，我们从分几个版本从简单到复杂 Version 0112345678910111213public class LazyMan &#123; private static LazyMan lAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(lAZYMAN==null)&#123; //A lAZYMAN = new LazyMan(); &#125; return lAZYMAN; &#125;&#125; 缺点：只能在单线程中安全，多线程中是不安全的 现在有线程A和线程B，线程A走到了注解A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全 Version 02123456789101112public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public synchronized static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; LAZYMAN = new LazyMan(); &#125; return LAZYMAN; &#125;&#125; 缺点：为方法加锁，确实保证了单例模式，但是我们都知道同步方法，锁的是LazyMan的Class类，所以我们得知这种方式可以保证单例模式的线程安全。但是我们好好想想，当我们创建了第一个单例对象之后，还需要锁来保证同步吗？答案显而易见，肯定是不需要的，所以这种方式效率低下，需要改进，我们来看下一个版本 Version 03123456789101112131415public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; LAZYMAN = new LazyMan(); &#125; &#125; return LAZYMAN; &#125;&#125; 我们不使用同步方法来保证所有的线程同步，我们只对LAZYMAN对象还为null的线程同步，这时候又出现了问题。我们来分析一下 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，这时候lAZYMAN还是null，所以线程B创建了一个lAZYMAN对象，然后线程A抢回CPU，它这时候已经在if语句里面了，箭在弦上不得不发，所以线程A也创建了一个lAZYMAN对象，导致单例模式被破坏，所以该实现方式线程不安全，我们发现这和我们没有加锁的时候的情形几乎一模一样。我们来看下一个版本，双重锁机制 Version 04public class LazyMan &#123; private static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125; &#125; 我个人的理解是第一重锁是为了过滤LAZYMAN为NULL的线程，第二重锁是为了保证只能有一个线程去创建对象，这时候我们似乎找不到什么破绽了，我们来继续往下看 Version 05123456789101112131415161718public class LazyMan &#123; private volatile static LazyMan LAZYMAN; private LazyMan()&#123; &#125; public static LazyMan getInstance()&#123; if(LAZYMAN==null)&#123; //A synchronized (LazyMan.class)&#123; if(LAZYMAN==null)&#123; //B LAZYMAN = new LazyMan(); &#125; &#125; &#125; return LAZYMAN; &#125;&#125; 乍一看，好像和上一个版本没什么区别，仔细一看，其实区别是在这个单例变量的修饰符多了一个volatile。 volatile三大作用 保证可见性 不保证原子性 禁止该变量出现的地方发生指令重排 这里的话，我们使用到的特性是第三点，我们来分析一下 LAZYMAN = new LazyMan(); 这一句话其实执行了三个步骤 开辟一个内存空间 初始化对象 将该内存空间的地址指向变量 JVM内部会有一种叫指令重排的代码优化机制，这时候，这三者的顺序就有可能会改变。 现在我们有两个线程，线程A和线程B。线程A走到了注释A处，然后线程B抢占了CPU，开始执行LAZYMAN = new LazyMan();开辟内存空间后，没有先初始化对象，而是先将该内存空间的地址指向变量，这时候线程A抢回了CPU，这时候的LAZYMAN已经不是NULL了，直接将其返回了出去，但是这个对象其实还没有初始化，还是个空架子，这就出现了问题。 当然这种情况十分十分少，但是为了严谨性，最好还是加上volatile关键词禁止指令重排 静态内部类模式1234567891011public class StaticWay &#123; private StaticWay()&#123; &#125; public static class InnerClass&#123; private static final StaticWay STATICWAY = new StaticWay(); &#125; public static StaticWay getInstance()&#123; return InnerClass.STATICWAY; &#125;&#125; 该实现方式其实就是利用的JVM的一些特性 类的加载分为以下过程 类的加载：将Class文件字节码加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中生成一个代表该类的Class对象，作为方法区类数据的访问入口，可以使用反射获取该类的所有信息。 类的链接：将Java类的二进制代码合并到JVM中 验证：确保加载的类符合JVM规范 准备：为静态变量分配内存并设置成员变量的默认值 解析：JVM常量池内的符号引用（常量名）替换为直接引用（地址）的过程 类的初始化：执行类构造器&lt; clinit &gt;()方法的过程，当初始化一个类的时候，如果其父类为初始化，则先初始化其父类 ，JVM会保证类构造器在多线程环境下被正确加锁 其实最开始的饿汉单例模式也是也是这个原理 颠覆其实一路到了这里，以上方法都是不安全的。因为java有一个很牛X的包。 java.lang.reflect 我们在最开始说过，单例模式的本质就是构造器私有化，但是java的反射机制，它不讲武德，它可以直接修改权限修饰符。我们来看看代码。 12345678public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;Hungry&gt; constructor = Hungry.class.getDeclaredConstructor(null); constructor.setAccessible(true); Hungry hungry1 = Hungry.getInstance();; Hungry hungry2 = constructor.newInstance(); System.out.println(hungry1==hungry2);&#125;//可想而知最后的结果是 false 可不可以对其作出防御呢？ 1234567891011121314private Hungry()&#123; if(HUNGRY!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;&#125;Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) at com.lizhi.hungry.Hungry.main(Hungry.java:26)Caused by: java.lang.IllegalArgumentException: 请不要尝试使用反射破坏单例模式 at com.lizhi.hungry.Hungry.&lt;init&gt;(Hungry.java:15) ... 5 more 上述方法对饿汉已经作出了合适的防御，那对于懒汉模式，如果两个对象都是使用反射创建的呢？这时候这个防御就是形同虚设了，因为我们肯定是禁止反射去创建对象，所以这种肯定是不行的 123456789101112131415161718192021222324252627282930public class LazyMan &#123; private static LazyMan LazyMan; private LazyMan()&#123; if(LAZYMAN!=null)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; synchronized (LazyMan.class)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 我们引入一个布尔值来完成这个任务 12345678910111213141516171819202122232425262728293031public class LazyMan &#123; private volatile static LazyMan LazyMan; private volatile static boolean flag ; private LazyMan()&#123; if(flag)&#123; throw new IllegalArgumentException(&quot;请不要尝试使用反射破坏单例模式&quot;); &#125;else &#123; flag=true; &#125; &#125; public static LazyMan getInstance()&#123; if(LazyMan==null)&#123; synchronized (LazyMan.class)&#123; if(LazyMan==null)&#123; LazyMan = new LazyMan(); &#125; &#125; &#125; return LazyMan; &#125; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;LazyMan&gt; constructor = LazyMan.class.getDeclaredConstructor(null); constructor.setAccessible(true); LazyMan lazyMan1 = constructor.newInstance();// LazyMan lazyMan2 = constructor.newInstance(); LazyMan lazyMan2 = LazyMan.getInstance();// LazyMan lazyMan1 = LazyMan.getInstance(); System.out.println(lazyMan1==lazyMan2); &#125;&#125; 这样反射就无法控制我们的单例了！ 枚举类这时候有没有想起来我们在学javaSE的时候就学到了一个自带单例模式的类型，那就是枚举类Enum！ 我们来尝试攻击一下枚举类！ 1234567891011public enum SingleEnum &#123; SINGLETON; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Constructor&lt;SingleEnum&gt; constructor = SingleEnum.class.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); SingleEnum single1 = constructor.newInstance(&quot;single&quot;, 2); SingleEnum single2 = constructor.newInstance(&quot;single&quot;, 2); System.out.println(single1==single2); &#125;&#125; 这时候发现报错了！！ 123Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:484) at com.lizhi.SingleEnum.main(SingleEnum.java:12) 我们点进newInstance方法看下源码， 1234567891011121314151617181920@CallerSensitive@ForceInline // to ensure Reflection.getCallerClass optimizationpublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, clazz, modifiers); &#125; if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125; 我们发现了这句话throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); 这就解释通了，原来是java的反射已经处理好了枚举类，使其真正的实现了安全的单例！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂设计模式","slug":"设计模式-工厂设计模式","date":"2022-02-16T11:01:20.000Z","updated":"2022-02-25T01:45:08.928Z","comments":true,"path":"设计模式/2022/02/16/设计模式-工厂设计模式/","link":"","permalink":"https://li-zhi.net.cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2022/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工厂设计模式该设计模式解决的问题是：将类实例化的操作与使用对象的操作分开，让使用者不用知道具体参数就可以实例化出所需要的产品类，从而避免了在客户端代码中显式指定，实现了解耦。 该设计模式分为三种实现 简单工厂设计模式 工厂方法实现模式 抽象工厂实现模式 简单工厂设计模式一个汽车工厂生产汽车。有特斯拉、大众、五菱 车的接口 123public interface Car &#123; void printName();&#125; 大众 123456public class DaZhong implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;大众&quot;); &#125;&#125; 特斯拉 123456public class TeSiLa implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;特斯拉&quot;); &#125;&#125; 五菱 123456public class WuLin implements Car&#123; @Override public void printName() &#123; System.out.println(&quot;五菱宏光&quot;); &#125;&#125; 工厂 12345678910111213public class CarFactory &#123; public static Car getCar(String carName)&#123; if(&quot;大众&quot;.equals(carName))&#123; return new DaZhong(); &#125;else if(&quot;五菱宏光&quot;.equals(carName))&#123; return new WuLin(); &#125;else if(&quot;特斯拉&quot;.equals(carName))&#123; return new TeSiLa(); &#125;else &#123; return null; &#125; &#125;&#125; 缺点：很难横向拓展，如果我后期需要加新的车型，需要改变原来的代码，不符合开闭原则（OOP七大原则） 优点：简单易懂 可以简单优化 1234567891011public class CarFactory &#123; public static Car getWuLin()&#123; return new WuLin(); &#125; public static Car getDaZhong()&#123; return new DaZhong(); &#125; public static Car getTeSiLa()&#123; return new TeSiLa(); &#125;&#125; 工厂方法实现模式还是简单工厂的模型，我们来换个工厂 这一次我们定义一个汽车工厂的接口 123public interface CarFactory &#123; Car getCar();&#125; 特斯拉工厂 123456public class TeSiLaCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new TeSiLa(); &#125;&#125; 大众工厂 123456public class DaZhongCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new DaZhong(); &#125;&#125; 五菱工厂 123456public class WuLinCarFactory implements CarFactory&#123; @Override public Car getCar() &#123; return new WuLin(); &#125;&#125; 缺点：当汽车类型很多的时候，会有很多很多很多各自的工厂，没有必要 抽象工厂实现模式这次我们换一个场景：小米和华为都有路由器和手机的产品 路由器接口 1234public interface Router &#123; void doConfig(); void printInfo();&#125; 手机接口 1234public interface MobilePhone &#123; void sendMsg(); void callUp();&#125; 厂家接口 1234public interface ProductFactory &#123; MobilePhone getMobilePhone(); Router getRouter();&#125; 华为手机 1234567891011public class HuaWeiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;华为手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;华为手机打电话&quot;); &#125;&#125; 华为路由器 1234567891011public class HuaWeiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;华为路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;华为路由器打印详细信息&quot;); &#125;&#125; 小米路由器 1234567891011public class XiaoMiRouter implements Router &#123; @Override public void doConfig() &#123; System.out.println(&quot;小米路由器配置&quot;); &#125; @Override public void printInfo() &#123; System.out.println(&quot;小米路由器打印详细信息&quot;); &#125;&#125; 小米手机 1234567891011public class XiaoMiMobilePhone implements MobilePhone &#123; @Override public void sendMsg() &#123; System.out.println(&quot;小米手机发信息&quot;); &#125; @Override public void callUp() &#123; System.out.println(&quot;小米手机打电话&quot;); &#125;&#125; 华为厂商 1234567891011public class HuaWeiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new HuaWeiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new HuaWeiRouter(); &#125;&#125; 小米厂商 1234567891011public class XiaoMiFactory implements ProductFactory &#123; @Override public MobilePhone getMobilePhone() &#123; return new XiaoMiMobilePhone(); &#125; @Override public Router getRouter() &#123; return new XiaoMiRouter(); &#125;&#125; 两个维度，第一个维度是产品族（路由器、手机），第二个维度是具体厂商（华为，小米）。 根据这两种维度分别设计了接口，抽象的工厂定义生产哪些产品族，具体的工厂具体实现自己的产品族","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot-Security","slug":"SpringBoot-Security","date":"2022-02-16T08:20:46.000Z","updated":"2022-10-04T13:55:07.490Z","comments":true,"path":"javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringBoot/2022/02/16/SpringBoot-Security/","excerpt":"","text":"简介Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理! Spring Security的两个主要目标是“认证”和“授权”（访问控制） “认证”(Authentication) “授权” (Authorization) 这个概念是通用的，而不是只在Spring Security 中存在。 基本使用 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 继承WebSecurityConfigurerAdapter 123@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 重写以下方法做出权限设置 1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; //首页都可以访问，但是各个级别下的页面设置成只能各自的级别才可以访问 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/vip1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/vip2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/vip3/**&quot;).hasRole(&quot;vip3&quot;); //没有权限默认回到登录页面，loginPage设置登录页面，loginProcessingUrl设置登录提交的api //如果只写 http.formLogin();会有一个默认登录页面和默认的登录提交的api http.formLogin().loginPage(&quot;/login&quot;).loginProcessingUrl(&quot;/user/api/login&quot;); //设置退出时候使session失效，logoutSuccessUrl设置退出成功的页面 http.logout().invalidateHttpSession(true).logoutSuccessUrl(&quot;/index&quot;); //设置’记住我‘的功能 //remember-me为默认提交的参数 http.rememberMe().rememberMeParameter(&quot;remember&quot;);&#125; 重写以下方法做出授权处理 123456789101112@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; /** * 这里要从数据库读 */ //BCryptPasswordEncoder为密码设置加密，如果不设置会报错，也可以使用其他加密的类 BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); auth.inMemoryAuthentication().passwordEncoder(encoder) .withUser(&quot;zhima&quot;).password(encoder.encode(&quot;a&quot;)).roles(&quot;vip1&quot;,&quot;vip3&quot;) .and() .withUser(&quot;lizhi&quot;).password(encoder.encode((&quot;123456&quot;))).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;);&#125; 测试 thymeleaf模板结合SpringSecurity导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 观察这个页面的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;!isAuthenticated()&quot;当用户没登录的时候--&gt; &lt;p&gt;首页&lt;/p&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt; &lt;!--sec:authorize=&quot;isAuthenticated()&quot;当用户登录的时候--&gt; 用户名：&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;name&quot;取出用户的用户名--&gt; 授权：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt; &lt;!--sec:authentication=&quot;principal.authorities&quot;取出用户的roles--&gt; &lt;p&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;注销&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;如果当前登录用户有vip1权限则显示此div--&gt; &lt;span&gt;vip1&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/1&#125;&quot;&gt;vip1-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/2&#125;&quot;&gt;vip1-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip1/3&#125;&quot;&gt;vip1-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;如果当前登录用户有vip2权限则显示此div--&gt; &lt;span&gt;vip2&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/1&#125;&quot;&gt;vip2-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/2&#125;&quot;&gt;vip2-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip2/3&#125;&quot;&gt;vip2-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt; &lt;!--sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;如果当前登录用户有vip3权限则显示此div--&gt; &lt;span&gt;vip3&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/1&#125;&quot;&gt;vip3-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/2&#125;&quot;&gt;vip3-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=&quot;@&#123;vip3/3&#125;&quot;&gt;vip3-3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"}]},{"title":"ForkJoin","slug":"ForkJoin","date":"2022-02-11T08:48:02.000Z","updated":"2022-10-04T13:52:53.878Z","comments":true,"path":"javaEE/JUC/2022/02/11/ForkJoin/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JUC/2022/02/11/ForkJoin/","excerpt":"","text":"ForkJoin什么是ForkJoin？并行执行任务，提交效率，大数据量的时候使用！ 把大任务拆分成小任务 ForkJoin特点：工作窃取内部维护的双端队列，两端都可以出 如何使用 创建ForkJoinPool对象 新建一个计算任务ForkJoinTask放入池子中计算 1234567891011121314151617181920212223242526272829303132package com.lizhi;import java.util.concurrent.RecursiveTask;public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private long start; private long end; private long temp = 10000L; public ForkJoinDemo(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override public Long compute()&#123; long result = 0; if(end-start&lt;temp)&#123; for (long i = start; i &lt;= end; i++) &#123; result+=i; &#125; &#125;else &#123; long middle = (start + end) / 2; ForkJoinDemo forkJoinDemo1 = new ForkJoinDemo(start,middle); forkJoinDemo1.fork(); ForkJoinDemo forkJoinDemo2 = new ForkJoinDemo(middle,end); forkJoinDemo2.fork();//把任务压入线程队列 result = forkJoinDemo1.join()+ forkJoinDemo2.join(); &#125; return result; &#125;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"}],"tags":[{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"}]},{"title":"函数式接口","slug":"函数式接口","date":"2022-02-11T07:13:29.000Z","updated":"2022-10-04T13:56:05.902Z","comments":true,"path":"琐碎的知识/2022/02/11/函数式接口/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/11/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"函数式接口函数式接口，即只有一个抽象方法的接口即为函数式接口，可以使用lambda表达式简化使用。 函数式接口一般接口上都会有@FunctionInterface注解做标记，作用是检查该接口是否只有一个抽象方法，如果不写，但是接口中确实只有一个抽象方法，也不会影响lambda的使用，下面我们来看一下一些常见的函数式接口 Function&lt; T , R &gt;函数型接口 T为传入参数的类型 R为返回值类型 123Function&lt;String, String&gt; f = s -&gt; s.substring(2,4);String apply = f.apply(&quot;asdas asd &quot;);System.out.println(apply); Predicate&lt; T &gt;断言型接口 T为传入参数的类型 返回值为Boolean 123Predicate&lt;String&gt; p = t-&gt;t.length()&gt;5;System.out.println(p.test(&quot;3223&quot;));System.out.println(p.test(&quot;saf223&quot;)); Consumer&lt; T &gt;消费者型接口 T为传入的参数 无返回值 123Consumer&lt;String&gt; consumer = c-&gt; System.out.println(&quot;我使用了&quot;+c);consumer.accept(&quot;123&quot;);consumer.accept(&quot;456&quot;); Supplier&lt; T &gt;生产者型接口 T为返回值类型 12Supplier&lt;String&gt; supplier = ()-&gt; UUID.randomUUID().toString();System.out.println(supplier.get());","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"线程池","slug":"JUC-线程池","date":"2022-02-11T06:31:26.000Z","updated":"2022-10-04T13:53:09.177Z","comments":true,"path":"javaEE/多线程/2022/02/11/JUC-线程池/","link":"","permalink":"https://li-zhi.net.cn/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022/02/11/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"线程池三大方法我们先看使用Executors创建的三种线程池 123Executors.newSingleThreadExecutor();//创建一个只有一个线程的线程池Executors.newFixedThreadPool();//创建一个固定数目的线程的线程池Executors.newCachedThreadPool();//缓存池，会复用之前使用过的线程 执行线程 12345678public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); &#125;); &#125;&#125; 七大参数阿里巴巴规范中有这么一条 12345线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下：1）FixedThreadPool和SingleThreadPool: 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。2）CachedThreadPool: 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 我们来看看创建这三种线程池的构造方法 1234567891011121314151617public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以发现，这三个构造方法创建的对象其实都是ThreadPoolExecutor对象，只不过就是构造参数不一样。 参数 作用 int corePoolSize 核心线程池的大小 int maximumPoolSize 最大线程池的大小 long keepAliveTime 超时时间过后就释放 TimeUnit unit 超时时间单位 BlockingQueue&lt; Runnable&gt; workQueue 阻塞队列 ThreadFactory threadFactory 线程工厂，创建线程的，一般不用动 RejectedExecutionHandler handler 拒绝策略 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize为一直开着的线程数，当workQueue已经满了，则继续开启线程直到maximumPoolSize，当线程数到了maximumPoolSize，然后workQueue也满了，如果还有新的任务，则使用handler拒绝策略对其进行处理。 当corePoolSize-maximumPoolSize区间的线程等待了workQueue时间后，还是没任务来，则关闭该区间的线程 123456789ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); CPU密集型和IO密集型最大线程数到底如何定义？ CPU密集型几核CPU就是几，可以保证效率最高 1Runtime.getRuntime().availableProcessors()//动态获取cpu核数 IO密集型程序里面有多少个非常消耗IO的线程，一般最大线程数设置为该数字的两倍 四大拒绝策略 AbortPolicy不处理此任务，并且抛出异常 CallerRunsPolicy不处理此任务，往上传递此任务，哪来的回哪里去 DiscardOldestPolicy不处理此任务，不会抛出异常 DiscardPolicy尝试和最老的那一个线程竞争，不会抛出异常","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"https://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JVM-简介","slug":"JVM-简介","date":"2022-02-10T04:24:26.000Z","updated":"2022-10-04T13:53:05.830Z","comments":true,"path":"javaEE/JVM/2022/02/10/JVM-简介/","link":"","permalink":"https://li-zhi.net.cn/javaEE/JVM/2022/02/10/JVM-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"JVM的体系结构下面是简易的结构图 栈中不会有垃圾回收 大部分JVM调优都是在堆内存上进行调优 详细的结构图如下 沙箱安全机制​ java安全模型的核心就是java沙箱（sandbox）。沙箱是一个限制程序运行的环境。沙箱机制就是将java代码限定在JVM特定的运行范围内，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源（CPU，内存，文件系统，网络）访问。不同级别的沙箱对这些资源的限制就不一样 ​ 所有的java程序运行都可以指定沙箱，可以指定安全策略。 ​ 在java中，将执行过程分为本地代码和远程代码两部分，本地代码是默认可信任的，而远程代码则被看做是不受信任的。对于授予信任的本地代码，可以访问一切本地资源。而对于非授予信任的远程代码在早期的java实现中，完全依赖于java沙箱机制。下图是jdk1.0的安全模型 ​ 但是如此严格的安全机制也给程序的功能拓展带来了障碍，比如用户希望远程代码访问本地资源的时候，就会被沙箱机制所拒绝。所以在后来的jdk1.1版本中，针对安全机制做出了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。下图是jdk1.1的安全模型 ​ 在jdk1.2的版本中，再次引进安全机制，增加了代码签名，不论是本地代码还是远程代码，都会按照用户的安全策略设定，由类加载器加载到JVM中权限不同的运行空间，来实现差异化的代码执行权限控制。下图是jdk1.2的安全模型 ​ 当前最新的安全机制实现，则引入了域（domain）的概念。JVM会把所有的代码加载到不同的系统和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。下图是jdk1.6的安全模型 ​ 组成沙箱的基本组件: 字节码校验器(bytecode verifier):确保java类文件遭循java语言规范。这样可以帮助ava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器(classloader):其中类装载器在3个方面对java沙箱起作用 它防止恶意代码去干涉善意的代码; 它守护了被信任的类库边界; 它将代码归入保护域，确定了代码可以进行哪些操作。 ​ 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由ava虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 从最内层IVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用; 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 存取控制器(access controller):存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包(security package):javasecurity下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括: 安全提供者 消息摘要 数字签名 加密 鉴别 native凡是带了native关键词的方法，说明这个方法java语言实现不了，此方法会被放入本地方法栈中，该栈通过JNI（Java Native Interface）去调用底层的C或者C++语言写的方法。 方法区Method Area 方法区是被所有线程共享的，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单来说，所有定义的方法的信息都会被保存在该区域 静态变量、常量、类信息（构造方法，接口定义），运行时的常量池存放在方法区中，但是实例变量存在于内存区中，与方法区无关 PC寄存器程序计数器：Program Counter Register ​ 每个线程都有一个程序计数器，实现程序私有的，就是一个指针，指向方法区中的方法字节码 堆（Heap）一个JVM只有一个堆内存，堆内存的大小是可以调节的，里面一般放实例对象 堆内存细分为三个区域： 新生区 Young&#x2F;New 养老区 old 永久区 perm GC垃圾回收主要在伊甸园区和养老区 堆内存满了就会爆OOM（OutOfMemoryError）错误 所有的对象都是在伊甸园区产生的 伊甸园满了会触发轻GC，有的就直接死了，然后留下来的去往幸存区 如果幸存区满了，就去往老年区 如果老年区满了，触发一次重GC（伊甸园区和幸存者区都清一遍，活下来的去老年区） 垃圾处理器GCGC的作用区域只有堆 两种回收：轻GC 、Full GC GC的算法 标记清除法 标记整理法 标记复制算法 引用计数法（给每一个对象分配一个计数器，将计数器为0的对象清除） 标记复制法谁空谁是to幸存区 新生区主要使用复制算法 好处：没有内存碎片 坏处：浪费了内存空间 复制算法使用最佳场景：对象存活度较低的时候 标记清除法扫描这些活着的对象，清除没有标记的对象进行清除 缺点：两次扫描，浪费时间，会产生内存碎片 优点：不需要额外空间 标记整理法再次扫描，向一端移动存活的对象 分代收集算法 年轻代： 存活率低 复制算法 老年代 存活率高 标记清除+标记压缩混合实现 这五道面试题可以试着做一做 请你谈谈你对JVM的理解？java8虚拟机和之前的有什么不同？ 什么是OOM，什么是栈溢出？怎么分析？ JVM的常用调优参数有哪些？ 内存快照如何抓取？怎么分析Dump文件？ 谈谈你对类加载器的认识？","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"}]},{"title":"if语句减少嵌套","slug":"if语句减少嵌套","date":"2022-02-07T12:32:09.000Z","updated":"2022-10-04T13:52:57.435Z","comments":true,"path":"琐碎的知识/2022/02/07/if语句减少嵌套/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/if%E8%AF%AD%E5%8F%A5%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97/","excerpt":"","text":"if的多重嵌套直接举栗子：有一个电商平台，当用户消费满1000元，根据vip等级可享受优惠 普通会员 不打折 白银会员 优惠50元 黄金会员 打8折 白金会员 优惠50元，再打七折 Version 1.0会员类型枚举 1234567891011121314151617181920public enum UserType &#123; /** * ORDINARY_VIP: 普通会员 * SILVER_VIP: 白银会员 * GOLD_VIP： 黄金会员 * PLATINUM_VIP：白金会员 */ ORDINARY_VIP(1), SILVER_VIP(2), GOLD_VIP(3), PLATINUM_VIP(4); private int code; UserType(int code) &#123; this.code = code; &#125; public int getCode() &#123; return code; &#125;&#125; 12345678910111213private static double getResult(long money, int type)&#123; double result = money; if(money &gt;= 1000)&#123; if(type == UserType.SILVER_VIP.getCode())&#123; result = money - 50; &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = money * 0.8; &#125;else if(type == UserType.PLATNUM_VIP.getCode())&#123; result = (money - 50)*0.7; &#125; &#125; return result;&#125; 可以看到这里的if语句可能不是那么繁琐，但是当业务十分复杂或者当策略会经常变动的时候，需要经常修改源代码，这就严重违反了开闭原则，但是我可不可减少if的出现甚至不出现呢？ 下面我们结合以下两种解决方案来一步一步尝试解决问题 卫语句 策略模式 Version 1.1卫语句，就是将不符合的情况直接返回 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.0策略模式就是将各个会员的优惠方式提出一个接口，分别实现 策略接口 123public interface Strategy &#123; double compute(long money);&#125; 普通会员 123456public class OrdinaryStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money; &#125;&#125; 黄金会员 123456public class GoldStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money*0.8; &#125;&#125; 白金会员 123456public class PlatinumStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125;&#125; 白银会员 123456public class SilverStrategy implements Strategy&#123; @Override public double compute(long money) &#123; return money-50; &#125;&#125; 12345678910111213141516public static double getResult(long money,int type)&#123; double result = money; if(money&lt;1000)&#123; return result; &#125; if(type== UserType.ORDINARY_VIP.getCode())&#123; result = new OrdinaryStrategy().compute(money); &#125;else if(type == UserType.SILVER_VIP.getCode())&#123; result = new SilverStrategy().compute(money); &#125;else if(type == UserType.GOLD_VIP.getCode())&#123; result = new GoldStrategy().compute(money); &#125;else if(type==UserType.PLATINUM_VIP.getCode())&#123; result = new PlatinumStrategy().compute(money); &#125; return result;&#125; Version 2.112345678910111213public class StrategyFactory &#123; public static Map&lt;Integer,Strategy&gt; map; private StrategyFactory()&#123; map = new HashMap&lt;&gt;(); init(); &#125; private void init()&#123; map.put(UserType.ORDINARY_VIP.getCode(), new OrdinaryStrategy()); map.put(UserType.SILVER_VIP.getCode(), new SilverStrategy()); map.put(UserType.GOLD_VIP.getCode(),new GoldStrategy()); map.put(UserType.PLATINUM_VIP.getCode(),new PlatinumStrategy()); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125; 这里的工厂还可以通过这种方式来实现 Version 2.2策略接口 1234public interface Strategy &#123; double compute(long money); int getType();&#125; 黄金会员 123456789101112public class GoldStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money*0.8; &#125; @Override public int getType() &#123; return UserType.GOLD_VIP.getCode(); &#125;&#125; 普通会员 1234567891011public class OrdinaryStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money; &#125; @Override public int getType() &#123; return UserType.ORDINARY_VIP.getCode(); &#125;&#125; 白金会员 1234567891011public class PlatinumStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return (money-50)*0.7; &#125; @Override public int getType() &#123; return UserType.PLATINUM_VIP.getCode(); &#125;&#125; 白银会员 1234567891011public class SilverStrategy implements Strategy &#123; @Override public double compute(long money) &#123; return money-50; &#125; @Override public int getType() &#123; return UserType.SILVER_VIP.getCode(); &#125;&#125; 策略工厂 12345678910111213141516public class StrategyFactory &#123; private static Map&lt;Integer, Strategy&gt; map; public StrategyFactory() &#123; map=new HashMap&lt;&gt;(); init(); &#125; private void init() &#123; List&lt;Strategy&gt; strategies=new ArrayList&lt;&gt;(); strategies.add(new GoldStrategy()); strategies.add(new OrdinaryStrategy()); strategies.add(new PlatinumStrategy()); strategies.add(new SilverStrategy()); map=strategies.stream().collect(Collectors.toMap(Strategy::getType,strategy -&gt; strategy)); &#125;&#125; 123456789public static double getResult(int userType, long money)&#123; if(money&lt;1000)&#123; return money; &#125; if(StrategyFactory.map.get(userType)==null)&#123; throw new IllegalArgumentException(&quot;参数错误，无此类型的用户&quot;); &#125; return map.get(userType).compute(money);&#125;","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2022-02-07T10:04:34.000Z","updated":"2022-09-27T14:17:58.259Z","comments":true,"path":"琐碎的知识/2022/02/07/Cookie和Session/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Cookie%E5%92%8CSession/","excerpt":"","text":"情景在线我们在登录完一个网站后，很长一段时间都不需要输入用户名和密码。大家有没有好奇这是为什么呢？ 学过HTTP的都知道，HTTP访问是无状态的，也就是说，服务器是不知道你这是第几次访问该网站的。 那么Cookie，Session就是来做到让服务器预先知道一些信息，其核心其实就是存储。 Cookie是存储在客户端的，Session是存储在服务器端的 下面我们来说说Cookie CookieCookie翻译为小饼干 该技术可以实现每次HTTP请求都自动带数据给服务器，从而实现服务器可以在请求的时候就预先知道一些信息。 流程图如下 我们可以在浏览器中查看Cookie 如果使用Cookie保存账号密码，那只要别人盗到你的Cookie，那么你的账号密码就泄露了！所以就出现了Session的技术 SessionSession翻译为会话 当我们打开一个浏览器进去网站，则开始一个会话，但是会话的结束比较模糊，可以自动设置session过期时间，也可以设置永不过期。 Session保存在服务器，当产生了一次会话，则服务器返回的时候携带存储session相关信息的Cookie，并保存在客户端，而这个session对象的信息则保存在服务器的数据库中。 下面是流程图","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Token","slug":"Token","date":"2022-02-07T10:01:03.000Z","updated":"2022-10-04T13:55:47.583Z","comments":true,"path":"琐碎的知识/2022/02/07/Token/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Token/","excerpt":"","text":"为什么会出现Token相信大家都知道Cookie和Session（不知道这两者的在我另外两篇博客里面有写，附上链接，Cookie和Session） 随着技术的发展，用户群体变的越来越大，如果服务器依旧使用基于Cookie的Session，在某一时间段有大量用户访问的话，服务器就会将大量的Session保存在数据库中，导致服务器性能降低，为了处理这种问题，就出现了一种技术，也就是JWT(JSON Web Token) Token JWT是由三部分组成的，分别是header、payload、signature header部分申明用什么算法生成签名 payload部分保存一些数据 signature部分保存header申明的算法生成的签名 小结Session、Cookie、Token都是是在服务器产生的 Cookie是保存SessionID的载体，但是Session对象是保存在服务器数据库中的 Token在服务器端生成，保存服务器端的密文，将token放入cookie发送诶客户端并交由客户端保存","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"Ngrok","slug":"Ngrok","date":"2022-02-07T09:30:02.000Z","updated":"2022-10-04T13:54:15.986Z","comments":true,"path":"琐碎的知识/2022/02/07/Ngrok/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/Ngrok/","excerpt":"","text":"使用Ngrok快速部署项目 打开https://ngrok.cc/ 注册一个账户 支付2块钱进行支付宝实名认证 点击开通隧道并翻到最后 开通隧道选项 说明： 隧道协议，两者即可 HTTP HTTPS（HTTPS需要绑定自己的域名，并且已经申请了SSL证书，才能有效，否则无法使用https。） 隧道名称 随便写即可 前置域名 写自己喜欢的 http验证用户名和密码 这里可以不写 确认信息，开通 进入隧道管理页面 ps：这里和我之前写的配置不一样，是因为一个用户只能免费开通一个http隧道 下载客户端 下载对应系统的软件，并解压 启动批处理命令 ps：我第一次使用的不是乱码，我也不理解这次使用为什么会乱码，这里不影响使用 输入隧道id，回车 如果之前配置了账号密码，则在此处需要输入账号密码 启动本地项目 注：本地项目启动的端口一定要和之前写的端口映射一致 打开网址测试 本地 Ngrok提供的网站访问","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"关于路径","slug":"关于路径","date":"2022-02-07T08:57:28.000Z","updated":"2022-10-04T13:56:00.923Z","comments":true,"path":"琐碎的知识/2022/02/07/关于路径/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/02/07/%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84/","excerpt":"","text":"访问路径URL统一资源定位符，用于定位资源的一种方式。 通常的URL资源访问路径由两部分构成:资源路径与资源名称。 资源名称指的是要访问资源的直接名称，如show.html,或与要访问资源存在映射关系的间接名称，如show.do 资源路径，则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。 根据“资源路径是否可以独立完成资源准确定位”的判别标准,可以将访问路径分为绝对路径与相对路径 绝对路径绝对路径，是指根据给出的访问路径可以精确的定位到这个资源的路径 对于计算机中Web应用的绝对路径，则是指带访问协议的路径。即URL 相对路径相对路径,是指仅根据访问路径无法准确定位资源的路径。 相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。 参照路径的不同，所形成的可以准确定位资源的绝对路径也是不同的。 在进行资源访问时,必须要将相对路径转换为绝对路径才可完成资源的精确定位 绝对路径 &#x3D; 参照路径 + 相对路径 根据相对路径是否以斜杠开头，且路径指向的文件不同，其默认的参照路径是不一样的 以斜杠开头的相对路径前台路径所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。 例如，html、 css、 js中的路径，及jsp文件中静态部分的路径(HTML标签中的路径)。html 及jsp文件中的&lt; img src-&#x3D;*&#x2F;&gt;、&lt; a href&#x3D;””&gt;. &lt; form action&#x3D;””&gt;等标签中的以斜杠开头的路径都属于前台路径 前台路径的参照路径是Web服务器的根路径,即http://127.0.0.1:8080 将前台路径转换为绝对路径的工作,是由浏览器自动完成的。 该路径的作用是要为用户提交对某种资源的请求,是要查找并定位服务器中的某资源。 简单来说,前台路径的作用是“查找” 后台路径所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。 例如，java 代码中的路径、jsp文件动态部分java代码块)中的路径、xml等配置文件中的路径(配置文件是要被java代码解析后加载到内存的，其中的路径会出现在Java 代码中) 后台路径的参照路径是Web应用的根路径。http://127.0.0.1:8080/projectName 将后台路径转换为绝对路径的工作,是由服务器自动完成的。该路径的作用是标识出该资源在服务器中的路径，以便客户端能够按照这个设定路径来查找相应资源。简单来说,后台路径的作用是“标识” 以路径开头的相对路径以路径名称开头的相对路径，无论是出现在前台页面,还是出现在后台Java代码或配置文件中，其参照路径都是当前访问路径的资源路径。 即使是response 的sendRedirect()方法的参数路径,若不以斜杠开头，其也属于“以斜杠开头的相对路径”类的路径，参照路径为当前服务器的根路径 总结 相对路径类型 参照路径 相对路径转绝对路径的完成者 前台路径 当前Web服务器的根路径 浏览器 后台路径 当前Web应用的根路径 Web服务器 以路径名称开头的路径 当前访问路径的资源路径 浏览器&#x2F;Web服务器 PS： 对于response的sendRedirect( )方法完成的重定向 若其参数路径为“以斜杠开头的相对路径”这个后台路径是个特例。是由sendRedirect( )方法的本质决定的。这个方法不仅可以完成在当前项目中资源的跳转,还可以跳转到其它项目中的资源。所以这个后台路径的参照路径为“当前Web服务器的根”。所以要加resquest.getContextPath(); 注意，只有这一种重定向是特例,将来我们还会学习到其它方式实现的重定向，但那里的重定向就不是特例,而是遵循我们之前的路径转换理论 如果加斜杠和不加斜杠都可以完成跳转，就加上斜杠","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"SpringMVC-文件下载","slug":"SpringMVC-文件下载","date":"2022-01-31T06:57:54.000Z","updated":"2022-10-04T13:55:44.776Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件下载/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"文件下载文件下载很简单，只要设置一下响应头即可 页面： 123456789101112131415161718192021&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; ul li &#123; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;javascript:&quot;&gt;点击文字下载&lt;/a&gt;&lt;ul id=&quot;ul&quot;&gt; &lt;c:forEach items=&quot;$&#123;fileList&#125;&quot; var=&quot;file&quot;&gt; &lt;li&gt;&lt;a href=&quot;/fileDownLoad.do?fileName=$&#123;file&#125;&quot;&gt;$&#123;file&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:forEach&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; Controller： 123456789101112131415161718@GetMapping(&quot;/fileDownLoad.do&quot;)public String fileDownLoad(String fileName,HttpServletRequest req,HttpServletResponse resp) throws IOException &#123; String realPath = req.getServletContext().getRealPath(&quot;\\\\download&quot;)+&quot;\\\\&quot;; File file = new File(realPath.concat(fileName)); resp.setHeader(&quot;Content-disposition&quot;,&quot;attachment; filename=&quot;+ URLEncoder.encode(file.getName(),&quot;UTF-8&quot;)); ServletOutputStream outputStream = resp.getOutputStream(); FileInputStream fis = new FileInputStream(file); byte[] buffer = new byte[1024]; int len=0; while((len=fis.read(buffer))&gt;0)&#123; outputStream.write(buffer,0,len); &#125; outputStream.flush(); fis.close(); outputStream.close(); return &quot;filedownload&quot;;&#125;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-文件上传","slug":"SpringMVC-文件上传","date":"2022-01-31T06:55:40.000Z","updated":"2022-10-04T13:55:41.444Z","comments":true,"path":"javaEE/SpringMVC/2022/01/31/SpringMVC-文件上传/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/31/SpringMVC-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"准备工作首先对于表单中的enctype属性做一个了解 application&#x2F;x-www&#x3D;form-urlencoded:默认方式，只处理表单中的value的属性值，采用这种编码方式的表单会将表单域中的值处理成URL编码方式 multipart&#x2F;form-data:这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会将文件域中的文件夜风撞到请求参数中 text&#x2F;plain:除了把空格改为“+”号外，其他字符不做编码处理，这种方式适合直接通过表单来发送邮件 文件上传是一个web项目中很常见的功能，在springmvc中有着很好的支持，但是springmvc默认上下文没有配置MultipartResolver，所以在做文件上传和下载前，需要配置MultipartResolver， 在原有包的基础上导入此包 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt; 注册MultipartResolver实例，id必须为multipartResolver，id必须为multipartResolver，id必须为multipartResolver，不然报错 12345&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; 以下就不赘述springMVC的配置文件了 上传单个文件页面： 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; controller： 12345678910111213141516171819202122@PostMapping(&quot;/singleFileUpload.do&quot;)public String singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false) CommonsMultipartFile avatar,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); return &quot;singleFileUpload&quot;;&#125; 上传多个文件其实和上传单个文件很像，只要input控件的name属性是一样的，那它们就是一组，下面来看看代码 controller：（两法，个人偏向于第二种） 12345678910111213141516171819202122232425@PostMapping(&quot;/multiFileUpload.do&quot;)public String multiFileUploadDo(@RequestParam(value = &quot;file&quot;,required = false) CommonsMultipartFile[] files,HttpServletRequest req, Model model) throws IOException &#123; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload/multipart&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; for (int i = 0; i &lt; files.length; i++) &#123; //文件的全称，包括后缀 String avatarWholeName = files[i].getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 files[i].transferTo(new File(realSavePath)); &#125; return &quot;multiFileUpload&quot;;&#125; 1234567891011121314151617181920212223@PostMapping(&quot;/multiFileUpload.do&quot;)public Map multiFileUploadDo(HttpServletRequest request) throws IOException &#123; String realPath = request.getServletContext().getRealPath(&quot;\\\\multipartUpload&quot;)+&quot;\\\\&quot;; CommonsMultipartResolver cmr = new CommonsMultipartResolver(request.getServletContext()); if(cmr.isMultipart(request))&#123; MultipartHttpServletRequest req = (MultipartHttpServletRequest) request; MultiValueMap&lt;String, MultipartFile&gt; multiFileMap = req.getMultiFileMap(); for (String fieldName : multiFileMap.keySet()) &#123; String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); //创建存放文件的文件夹 File dir = new File(realPath + uuidPath + fieldName); dir.mkdirs(); List&lt;MultipartFile&gt; multipartFiles = multiFileMap.get(fieldName); for (MultipartFile f : multipartFiles) &#123; //如果文件为空，则忽略，不然会报错 if(!f.isEmpty())&#123; f.transferTo(new File(dir.getPath()+&quot;\\\\&quot;+f.getOriginalFilename())); &#125; &#125; &#125; &#125; return &quot;multiFileUpload&quot;;&#125; 页面： 12345678910111213141516171819202122232425&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/multiFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 以上都是同步提交，下面我们使用异步提交并且将图片预览出来，这次只演示单个文件上传，多个文件上传同理。 异步提交并提供预览Controller： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@PostMapping(&quot;/reg.do&quot;)@ResponseBodypublic Map reg(User user,String relativePath)&#123; user.setAvatarUrl(&quot;\\\\upload\\\\&quot;.concat(relativePath)); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); System.out.println(user); map.put(&quot;result&quot;,&quot;success&quot;); return map;&#125;@PostMapping(&quot;/singleFileUpload.do&quot;)@ResponseBodypublic Map singleFileUploadDo(@RequestParam(value = &quot;avatar&quot;,required = false)CommonsMultipartFile avatar, HttpServletRequest req) throws IOException &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); if(avatar==null||avatar.isEmpty())&#123; map.put(&quot;result&quot;,&quot;fail&quot;); return map; &#125; //真实的保存上传文件的文件夹 String realSaveDirPath = req.getSession().getServletContext().getRealPath(&quot;/upload&quot;); File dir = new File(realSaveDirPath); if(!dir.exists())&#123; dir.mkdirs(); &#125; //文件的全称，包括后缀 String avatarWholeName = avatar.getOriginalFilename(); //文件的后缀 String suffix = avatarWholeName.substring(avatarWholeName.lastIndexOf(&#x27;.&#x27;)+1); //这里可以对文件后缀做出一些逻辑处理，这里就不作处理了 //这里为了保证文件名一定不一致，所以加入一个UUID随机值 String uuidPath = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); String realFileName = uuidPath.concat(avatarWholeName); //文件的真实保存全路径 String realSavePath = realSaveDirPath.concat(&quot;/&quot;).concat(realFileName); //这里也可以自己用流读写 avatar.transferTo(new File(realSavePath)); map.put(&quot;result&quot;,&quot;success&quot;); //用来给页面显示图片 map.put(&quot;relativePath&quot;,&quot;\\\\upload\\\\&quot;.concat(realFileName)); //用来给前端判断是否需要再次上传 map.put(&quot;fileName&quot;,avatarWholeName); return map;&#125; 页面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单个文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;form&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;userName&quot; id=&quot;userName&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;number&quot; placeholder=&quot;请输入年龄&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;avatar&quot;&gt; &lt;div style=&quot;display: none&quot; id=&quot;showimgcontainer&quot;&gt; &lt;img id=&quot;showimg&quot; width=&quot;400px&quot; height=&quot;400px&quot; style=&quot;border: solid 1px black&quot;/&gt; &lt;/div&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;button&quot; id=&quot;submitBtn&quot; value=&quot;注册&quot;&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/js/jquery.form.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; let fileName; let relativePath; $(&#x27;#avatar&#x27;).change(()=&gt;&#123; if(fileName===$(&#x27;#avatar&#x27;)[0].files[0].name)&#123; return; &#125; let options = &#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/singleFileUpload.do&#x27;, dataType:&#x27;text&#x27;, success(data)&#123; data = JSON.parse(data); if(data.result===&#x27;fail&#x27;)&#123; alert(&quot;文件为空或者不存在&quot;); return; &#125; relativePath = data.relativePath; fileName = data.fileName; $(&#x27;#showimgcontainer&#x27;).show(); $(&#x27;#showimg&#x27;).attr(&#x27;src&#x27;,relativePath); &#125; &#125; $(&#x27;#form&#x27;).ajaxSubmit(options); &#125;) $(&#x27;#submitBtn&#x27;).click(()=&gt;&#123; $.ajax(&#123; url: &#x27;$&#123;pageContext.request.contextPath&#125;/reg.do&#x27;, method:&#x27;post&#x27;, data: &#123;relativePath:relativePath,userName:$(&#x27;#userName&#x27;).val(),age:$(&#x27;#age&#x27;).val()&#125;, success(data) &#123; if(data.result===&#x27;success&#x27;)&#123; alert(&quot;注册成功&quot;); window.location = &#x27;$&#123;pageContext.request.contextPath&#125;/login&#x27;; &#125;else &#123; alert(&quot;出错！请重试！&quot;); &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"Linux-管理（了解即可）","slug":"Linux-管理（了解即可）","date":"2022-01-31T06:14:13.000Z","updated":"2022-10-04T13:53:36.235Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-管理（了解即可）/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89/","excerpt":"","text":"账号管理 简介 在一开始的时候我们就提到，Linux是一个多用户的分时操作系统，任何一个需要使用系统资源的用户，都必须向系统管理员申请一个账号，然后以这个账号登录系统。 用户的账号一方面可以帮助系统管理员对使用系统资源的用户进行跟踪，并控制他们对资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护 每个用户都拥有一个唯一的用户名和密码 对于账号的管理，主要有以下操作 用户账号的添加，删除和修改 增加用户 1useradd -选项 用户名 选项 -m 自动创建这个用户的主目录 -d 指定用户的主目录在哪 -c 指定一段注释 -g 指定该用户的用户组 -G 指定用户所属的附加组 -s shell文件，指定用户的登录shell -u 用户号 ，如果有-o属性，则可以与其他人的标识号重复 用户名 指定用来登录的用户名 删除用户 12userdel -r 用户名 -g 分配组#删除用户的时候将其目录一并删除 修改用户信息 1usermod 创建的时候的一些参数，对应修改的内容的参数 修改用户密码 root用户 1passwd 用户名 普通用户 12passwdcurrent password 切换用户 root用户 切换用户的命令是：su username 从普通用户切换到root用户，可以使用命令：sudo su 在终端输入exit或者logout的时或者快捷方式Ctrl+d（其实就是exit），可以退回原来账户 在切换用户的之后，如果也想切换新用户的工作环境，则可以再su和username之间加入一个-，比如su - root $代表普通用户 #代表超级用户，即root用户 锁定账户 1234#锁定之后就不能登录了passwd -l 用户名#清空该用户的密码，也不能登录passwd -d 用户名 查看账户信息 1234cat /etc/passwd用户名：口令(不可见为X)：用户标识号：组标识号：注释性描述：主目录：登录shellcat /etc/shadom查看加密的密码 用户组的管理 属主，属组 每个用户都有一个用户组，root用户可以对一个用户组的全部用户进行集中管理（开发组，运维组、、、）。不同的Linux系统对于用户组的规定有所不同，如Linux下的用户属于与他同名的组，这个用户组在创建用户的时候创建 用户组的管理涉及，用户组的添加，用户组的删除和修改。其实这些操作都是在对&#x2F;etc&#x2F;group的文件进行更新 创建一个用户组 1gruopadd 用户组名称 创建用户组后可以得到一个id，可以通过-g参数指定该id 删除一个用户组 1groupdel 用户组名称 修改用户组权限信息和名字 1groupmod -g 用户组id -n 修改后用户组名称 用户组名称 查看所有的用户组 1cat /etc/group 磁盘管理 df [-h]，列出文件系统整体的磁盘使用量 du [-h]，检查当前磁盘的使用量 12du -sm /*#检查根目录下每个文件占用的容量 1234#将外部设备filename挂载到/mnt/filename下来实现访问mount /dev/filename /mnt/filename#unmount -f强制卸载unmount -f [挂载位置] 进程管理1、每一个程序都有自己的一个进程，每个进程都有一个id号 2、每个进程都会有一个父进程 3、两种运行方式，前台运行，后台运行 4、一般情况下，服务都是后台运行的 命令1ps 查看当前系统中正在执行的各种进程的信息 ps -xx： -a 显示当前终端运行的所有的进程信息 -u 以用户的信息显示进程 -x 显示后台运行进程的参数 123456#查看所有的进程ps -aux|grep mysqlps -aux|grep redis#|这个在Linux叫管道符 A|B#grep 过滤符合条件的字符串 这里只要知道就行 123456#可以查看父进程的信息ps -ef|grep mysql#进程树，更推荐pstree -p 显示父id -u 显示用户组 结束进程 123kill -9 进程id# 这个-9是信号代码，代表强制结束#如果有死循环了，就可以选择强制结束该进程 拓展内容查看网络123#在/etc/sysconfig/network-scripts/目录下是配置网络的#查看IP地址，网络配置ifconfig 创建文件1touch 文件名 往文件尾部写入值1echo &quot;Hello&quot; &gt;&gt;filename 关于主机名称1234#查看主机名称hostname#修改主机名称hostname newhostname 清屏1clear 链接在Linux中，链接分为软链接和硬链接 硬链接：A–B，B是A的硬链接，类似于拷贝了一份 可以这么理解，如果我把A删了，B也是可以访问到A这个文件 软链接：就是一种类似Windows下的快捷方式，A–B，B是A的软链接。 可以这么理解，如果我把A删了，则B无法再次访问A文件了 创建链接基础命令：ln 1234#设置B为A的硬链接，这时候的B是白色ln A B#设置C为A的软链接（又名符号链接），这时候的C是特殊颜色ln -s A C 会感觉这个硬链接和复制有点像，但是两者是有区别的 链接文件，他们的内容是同步的但是复制只是复制，不会同步数据 端口有关操作12345678910111213141516171819#查看开放的端口firewall-cmd --list-ports#开启防火墙service firewalld start#重启防火墙service firewalld restart#关闭防火墙service firewalld stop#查看当前firewalld的状态systemctl status firewalld#开启端口，记得在阿里云配置安全组firewall-cmd --zone=public --add-port=80/tcp --permanent#重启防火墙服务systemctl restart firewalld.service","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-vim编辑器","slug":"Linux-vim编辑器","date":"2022-01-31T06:12:29.000Z","updated":"2022-10-04T13:53:28.058Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-vim编辑器/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-vim%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"","text":"VIM编辑器 什么是VIM编辑器 VIM是从vi发展出来的一个文本编辑器，代码补全，编译，及错误跳转等功能特别丰富。Linux中必须会使用vim 三种使用模式基本上vim&#x2F;vi分为三种使用模式，分别是命令模式（Command mode）、输入模式（Insert mode）、底线命令模式（Last Line mode） 命令模式（Command mode）用户刚刚启动vim，便进入了命令模式 此状态下敲击键盘会被识别为命令，不会输入字符 以下为常用命令： 命令 作用 i 切换到输入模式 ： 切换到底线命令模式 k或者上箭头 光标向上移 j或者下箭头 光标向下移 h或者左箭头 光标向左移 l或者右箭头 光标向右移 Ctrl+f 向下移动一页，相当于pageDown Ctrl+b 向上移动一页，相当于pageUp Ctrl+d 向下移动半页 Ctrl+u 向上移动半页 0&#x2F;功能键[home] 将光标移动到该行的开头处 $&#x2F;功能键[end] 将光标移动到该行的结尾处 H 将光标移动到这个屏幕第一行的第一个字符所在的位置 M 将光标移动到这个屏幕中央的那一行的第一个字符所在的位置 L 将光标移动到这个屏幕最后一行的一个字符所在的位置 G 将光标移动到这个屏幕最后一行的一个字符所在的位置 nG n代表数字，表示移动到该文件的第几行 gg 移动到这个文件的第一行 n&lt;回车&gt; 光标向下移动n个字符（单独摁空格光标向下移动一个字符） n&lt;退格键&gt; 光标向左移动n个字符（单独摁退格键光标向左移动一个字符） n&lt;空格&gt; 光标向右移动n个字符（单独摁空格光标向右移动一个字符） 替换搜索 命令 作用 &#x2F; keyword 向下查询字符串keyword ？keyword 向上查询字符串keyword n 继续当前的查询动作 N 反向进行当前的查询动作 删除、复制、黏贴 命令 作用 x ，X 删除当前光标所在的字符 nx n为数字，连续向后删除n个字符 &lt;数字&gt;dd&#x2F;D 删除光标所在的那n整行(默认n为1) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除所在光标到该行最后 d0 删除所在光标到该行开头 &lt;数字&gt;yy 复制那一整行（默认n为1） y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在到该行的开始位置 y$ 复制光标所在到该行的结束位置 p，P p将复制的数据在光标的下一行黏贴，P将复制的数据在光标的上一行黏贴 J 将光标所在行与下一行的数据结合成同一行 Ctrl+r 重做 u 撤销 从命令模式切换到输入模式的其他命令 命令 i、I i为在当前光标处进入输入模式，I为在当前光标所在行的第一个字符所在处进入输入模式 a、A a为在当前光标的下一个字符处进入输入模式，A为在当前光标所在行的最后一个字符所在处进入输入模式 o、O o为在当前光标所在行的下一行输入一个新的一行，O为在当前光标所在行的上一行输入一个新的一行 r、R 进入取代模式，r为只取代一次，R为一直取代直到按下esc esc 退出到命令模式 输入模式（Insert mode）在此模式下，可以使用以下按键 这些操作和我们平时用的是一样的 底线命令模式（Last Line mode）在此模式下，我们的光标会移动到最底下，就可以输入一些命令了 命令 :w 保存 :w！ 若文件为只读属性，强制写入，跟权限有关 :q 退出vim :q! 不保存退出 !在vim中一般表示强制的意思 :wq 保存退出 :ZZ 如果档案没有改动，则不储存离开，若修改了，则储存后离开 :w[filename] 另存为到另一个文件 :r[filename] 在编辑的数据中，读入另一个档案的数据。亦将filename中的内动追加到光标所在行的后面 :n1,n2 w[filename] 将n1到n2的数据存储到filename这个文件中 :!command 暂时离开vim执行command命令，【例如：:! ls &#x2F;home】 :set nu 显示行号 :set nonu 取消显示行号","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-文件操作","slug":"Linux-文件操作","date":"2022-01-31T06:11:31.000Z","updated":"2022-10-04T13:53:47.460Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-文件操作/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"文件操作文件属性Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统no的安全性，Linux系统对于不同的用户访问同一文件夹的权限做出了规定 先前我们使用ls -al查看了文件属性，我们现在来看看这些开头的字符到底是什么意思吧 我们将每一行分为六组来看 第一组 这一组固定一共十个字符，拆分为第一个字符和后9个字符来看 第一个字符的含义 [d]代表目录 [-]代表文件 [l]代表这是一个链接文档（link file） [b]代表装置文件，里面可能有供存储的接口设备 [c]代表装置文件里面的串行端口设备，例如键盘或者鼠标 后九个字符的含义 接下来的字符中以三个为一组，且均是以[rwx]的三个参数的组合 r–》read读操作 w–》write写操作 x–》execute执行操作 如果对应位置没有权限，就会出现-号 第一组为属主的权限（该文件的所有者） 第二组为属组的权限（所有者的同组用户） 第三组为其他用户的权限（其他用户） 第二组 如果该项是文件夹，该数字表示文件夹中的包含文件数 如果是文件，则显示1 第三组 第一个参数表示属主 第二个参数表示属组（root组） 第四组 文件大小 第五组 创建时间 第六组 文件名 修改文属性件更改文件属组基础命令：chgrp 1chgrp [-R] 属组名 文件名 更改文件属主，也可以同时更改文件属组12chown [-R] 属主名 文件名chown [-R] 属主名：属组名 文件名 更改文件九大属性1chomd [-R] xyz 文件或者目录 Linux文件系统属性有两种设置方法，一种数字，一种符号。 Linux文件的基本权限有九个，分别是owner&#x2F;group&#x2F;others三种身份各自有自己的read&#x2F;write&#x2F;execute权限 文件的权限字符是[rwxrwxrwx]，这九个权限是三三一组的！我们可以使用数字来代表各个权限，各个权限的分数对照表如下： 1r:4 w:2 x:1 每种身份（owner&#x2F;group&#x2F;others）各自的三个权限（r&#x2F;w&#x2F;x）分数是需要累加的，举个栗子：[rwxrwx—] owner &#x3D; rwx &#x3D; 4 + 2 + 1&#x3D; 7 group &#x3D; rwx &#x3D; 4 + 2 + 1&#x3D; 7 others &#x3D; — &#x3D; 0 1chmod 770 filename 查看文件Linux系统中使用以下命令来查看文件的内容 cat 由第一行开始显示文件的内容 tac 由最后一行开始显示文件的内容 nl 显示的时候，输出行号 more 一页一页的显示文件的内容 空格翻页，enter代表向下看一行，:f代表当前行数，退出查看输入q，向下查询字符串使用命令/要查找的字符串向上查询使用命令?要查找的字符串，n代表继续搜寻下一个，N代表继续搜寻上一个 less 与 more相似，但是他可以往前翻页 上下键代表向上下翻页 head 只查看前几行 通过 -n 参数可以控制查看几行 tail 只查看尾巴几行 通过 -n 参数可以控制查看几行","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-目录操作","slug":"Linux-目录操作","date":"2022-01-31T06:10:26.000Z","updated":"2022-10-04T13:53:44.086Z","comments":true,"path":"javaEE/Linux/2022/01/31/Linux-目录操作/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/31/Linux-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/","excerpt":"","text":"目录结构 以下是对这些目录的解释 &#x2F;bin: bin是Binary的缩写，这个目录存放着最经常使用的命令 &#x2F;boot: 这里存放的是启动Linux的时候使用的一些核心文件（不要动） &#x2F;dev: dev是Device的缩写，存放的是Linux的外设设备， &#x2F;etc: 这个目录是用来存放所有的系统管理所需要的配置文件和子目录 &#x2F;home: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是使用用户的账号来命名的 &#x2F;lib: 这里存放着系统最基本的动态连接共享库（不要动） &#x2F;lost+found: 这个目录一般是空的，但是当服务器意外关闭的时候，里面会存在一些错误文件（不要动） &#x2F;media: Linux系统会自动识别一些设备，例如u盘，光驱等等 &#x2F;mnt: 这个目录是给用户来临时挂载别的文件系统的（后面会把本地文件挂载在这个目录下） &#x2F;opt: 给主机额外安装软件所在的目录 &#x2F;proc: 这是一个虚拟的目录，他是系统内存的映射，我们可以通过直接访问这个目录来获得系统信息（不用管） &#x2F;root（也就是 ~ ）: 该目录是系统管理员目录，也称作超级权限者的用户主目录 &#x2F;sbin: s就是super的意思，这里存放的是系统管理员使用的系统管理程序 &#x2F;srv: 该目录用来存放一些守护进程启动之后需要提取的数据 &#x2F;sys: 这是Linux2.6内核的一个很大的改变，该目录下安装了2.6内核中新出现的一个文件系统sysfs &#x2F;tmp: 这个目录使用来存放一些临时文件的 &#x2F;usr: 这个目录用来存放用户的应用程序和文件 &#x2F;usr&#x2F;bin: 系统用户使用的应用程序 &#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护进程 **&#x2F;usr&#x2F;src: ** 内核源代码默认存放的地址 &#x2F;var: 这个目录用来存放着一些不断在拓充的东西，习惯性的将一些经常修改的目录放在该目录下 &#x2F;run: 是一个临时文件系统，存储系统启动以来的信息，当系统重启时，该目录下的文件应该被删掉（不用管） &#x2F;www: 存放服务器网站的相关的资源，环境，网站 不是每一个目录都一定会存在 关机指令基础指令：shutdown 123456789101112131415161718# Linux系统中为了提高磁盘的读写效率，对磁盘采用了“预读迟写”操作方式。当用户保存文件时，Linux核心并不一定立即将数据写入物理磁盘中，而是将数据保存在缓存区中，等到缓存区被填满了之后再将数据写入磁盘，这种方式确实极大地提高了读写效率，但是也有其所在的一些问题，当服务器遭受到断电或者其他意外情况的时候，缓存中的数据会直接丢失，这就会导致一些问题，sync就是将缓存中的东西直接写入到磁盘中去，无需等待缓存被填满#将数据同步到硬盘（关机前必须做）sync#服务器在十分钟后关机shutdown -h 10#立即关机shutdown -h now#在20:35关机shutdown -h 20:35#立马重启shutdown -r now#立马重启reboot 切换目录基础指令：cd 首先要知道这两个概念 决定路径 相对路径 绝对路径：指的是资源的全路径，比如D:\\APP\\Typora 相对路径：指的是资源在当前目录下的路径，比如我现在在D:\\APP目录下，我要定位到Typora这个目录，我可以直接使用Typora来表示该文件夹 12345678#进入根路径下的usr目录cd /usr#当前在根路径下，我要进入usr目录[root@iZbp18qscowpmxk6xpk38iZ /]#cd usr#返回上一级目录cd .. 查看目录基础指令：ls 123456789#查看所有的文件，包括隐藏文件，简写形式ls -a#以列表方式查看所有的文件的属性和权限，不包括隐藏文件ls -l#Linux中命令可以组合#以列表方式查看所有的文件，包括隐藏文件ls -al 目录操作创建一个目录1234mkdir 文件名#创建多级目录mkdir -p test1/test2/test3 删除一个目录12345#删除一个空目录rmdir test1#删除多级文件rmdir -p test1/test2/test3 复制一个目录1cp 源文件 目的文件夹 查看当前目录路径12345678910# 文件呈现不同颜色代表不同的含义# 白色 代表它是一个普通文件# 蓝色 代表它是一个文件夹# 绿色 代表它是一个可执行文件# 红色 代表它是一个压缩文件# 浅蓝色 代表它是一个链接文件# 红色闪烁 代表链接的文件有问题# 黄色 代表设备文件# 灰色 代表它是其他文件pwd 移除目录或者文件基础命令：rm -f 忽略不存在的文件，不会出现警告，强制删除 -r 递归删除根目录 -i 互动，删除询问是否删除 1rm -rf install.sh 移动目录或者文件基础命令：mv -f 强制 -u 只替换已经更新过的文件 1234mv 源文件 目标文件夹#重命名dir1为dir2mv dir1 dir2","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"Linux-简介","slug":"Linux-简介","date":"2022-01-29T10:32:02.000Z","updated":"2022-10-04T13:53:40.648Z","comments":true,"path":"javaEE/Linux/2022/01/29/Linux-简介/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Linux/2022/01/29/Linux-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux简介其实Linux这个词本身指的是Linux内核。 我们所说的Linux操作系统其实是基于Linux内核的操作系统，就是Linux的发行版。 目前市面上比较知名的是：Ubuntu、RedHat、CnetOS、Oracle Linux等等 准备工作 准备一个Linux系统的服务器 如果没有经济基础，可以使用VMware，自己创建一个虚拟机用来学习。 这里建议大家去阿里云或者腾讯云购买一个服务器用来学习，这样的环境更真实，并且也不是很贵，具体如何购买，这里就不赘述了，可以自行到b站搜一搜。 工具 这里要下载两个工具，一个叫XShell，另一个叫XFtp。 XShell是用ssh来远程连接你购买的服务器。 XFtp是用来上传本地文件的。 这里我把安装包分享一下。 12链接:https://pan.baidu.com/s/1AgF6l1Bn74QGMpkwQRIHqA 提取码:hr1x 通常服务器会在一开始搭建一些环境，有这两种比较流行的组合 LAMP(Linux+Apache+MySQL+PHP) LNMP(Linux+Nginx+MySQL+PHP)（推荐） 这里嫌麻烦的可以安装一个宝塔，一键部署。 走进Linux系统开机会启动许多程序，在windows中我们叫它服务（“Service”），在Linux中我们叫它守护进程（“daemon”） 计算机中，一个正在执行的程序或命令，被叫做“进程”（process） 启动之后一直存在、常驻内存的进程，一般被叫做“服务”（service） 在Linux中记住两句话 一切皆文件，根目录是&#x2F; 最高权限为root，可以操作一切","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"}]},{"title":"SpringMVC-JSON","slug":"SpringMVC-JSON","date":"2022-01-29T02:05:17.000Z","updated":"2022-10-04T13:55:22.980Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-JSON/","excerpt":"","text":"JSON(JavaScript Object Notation)JSON是一种十分轻量级的数据交换的格式，我们来讲一下处理JSON字符串的两个库 Jackson 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.1&lt;/version&gt;&lt;/dependency&gt; 将对象转为JSON字符串 12ObjectMapper mapper = new ObjectMapper();String json = mapper.writeValueAsString(user); 这时候，页面再次出现乱码问题 第一种原生的解决方案是 1@GetMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 第二种使用springmvc的配置文件，这段配置只针对jackson库 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 那我们怎么处理时间对象呢？ 12345678@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; Date date = new Date(); ObjectMapping objectMapping = new ObjectMapper(); return objectMapping.writeValueAsString(date);&#125;//返回的是当时的时间戳 下面是第一种方法 123456@GetMapping(&quot;/datejson&quot;)@ResponseBodypublic String jsonDate() throws JsonProcessingException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); return new ObjectMapper().writeValueAsString(sdf.format(new Date()));&#125; 这是第二种方法 123456789@GetMapping(&quot;/datejson2&quot;)@ResponseBodypublic String jsonDate2() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); mapper.setDateFormat(sdf); return mapper.writeValueAsString(new Date());&#125; FastJson 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt;&lt;/dependency&gt; 主要的三个类 JSONObject 对应JSON对象，可以使用get方法获取JSON对象的值 JSONArray 代表JSON数据 JSON代表JSONarray和JSONObject的转化 主要用这个类的静态方法去转化JSON字符串和对象","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-Controller","slug":"SpringMVC-Controller","date":"2022-01-29T02:02:36.000Z","updated":"2022-10-04T13:55:19.525Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-Controller/","excerpt":"","text":"Controller控制器和mybatis不同，在springmvc中，注解开发才是主流，所以接下来都会使用注解来开发。 被@Controller标注的类是一个控制器类，其中的每一个方法都是一个控制器，都各自映射一个url地址 在spring中我们说过，使用注解的时候需要在spring的配置文件中开启注解扫描 12&lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt;&lt;!--这里最好写到controller包，因为该配置文件专注于处理Controller层的事情，不要将包扫描的范围扩大--&gt; 回顾spring中的常用注册bean的注解 12345@Component 普通组件@Service 服务层@Repository 持久层@Mapper mybatis的接口层@Controller 控制器层 因为我们配置的DispatcherServlet会拦截所有的请求，但是对于静态资源，我们不需要拦截对他做出处理，所以有了以下配置 12&lt;!-- Springmvc不处理静态文件--&gt;&lt;mvc:default-servlet-handler/&gt; @RequestMapping该注解可以作用于类上面或者方法上面 方法上面 该方法映射的url地址即为注解中的值 类上面 当其作用在类上面的时候，该控制器类中所有的方法的映射路径的前面都会加上该注解中的值 @GetMapping 该注解代表请求是get请求 @PostMapping 该注解代表请求是post请求 @PutMapping 该注解代表请求是put请求 @DeleteMapping该注解代表请求是delete请求 @RestController当类上不是@Controller注解而是@RestController时候，该类中所有的方法返回的值，不会跳转视图，而是返回JSON字符串 如果不想让类中所有的方法都返回字符串 则类上面使用@Controller注解，方法上使用@ResponseBody标注此方法返回的结果是一个JSON字符串不要被视图解析器解析 RestFul风格概念：RestFul就是一个资源定位及资源操作的风格。 它不是标准也不是协议，它就只是一个style。基于这种风格设计的软件可以更加简洁，更有层次，并且安全，更易于实现缓存等机制 传统方式操作资源通过不用的参数来实现不同的功能，方法单一，post和get http:&#x2F;locoalhost:8080&#x2F;item&#x2F;insertItem post提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;deleteitem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;queryItem get提交 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;updateitem post提交 使用RestFul风格操作资源 http:&#x2F;locoalhost:8080&#x2F;item&#x2F;add&#x2F;参数&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;query&#x2F;参数&#x2F;… http:&#x2F;locoalhost:8080&#x2F;item&#x2F;update&#x2F;参数&#x2F;… 本质其实就是通过不同的提交方式走不同的方法 结果跳转方式控制器最后直接return字符串的话默认请求转发 如果想要重定向字符串前面加“**redirect:**”即可 处理前端数据 如果提交参数的名称和方法的参数名一致的话， 提交数据：http://localhost:8080/user/add?name=lizhi&amp;age=20 1234@GetMapping(&quot;user/add&quot;)public String test01(String name,int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交参数和方法参数不一致的话 提交数据：http://localhost:8080/user/add?username=lizhi&amp;userage=20 1234@GetMapping(&quot;user/add&quot;)public String add(@RequestParam(&quot;username&quot;) String name,@RequestParam(&quot;userage&quot;)int age,Model model)&#123; return &quot;user&quot;;&#125; 如果提交的是一个对象 提交数据：http://localhost:8080/user/add 要求提交的表单要和属性的属性名一致，方法参数即可直接使用对象 1234@PostMapping(&quot;user/add&quot;)public String add(User user,Model model)&#123; return &quot;user&quot;;&#125; 返回前端数据 ModelAndView 该对象在初识mvc的时候已经见过，不再赘述 Model（这是一个接口） 该对象在使用注解开发的时候也已经见过，这里也不再赘述 ModelMap ModelMap实现了Model接口，继承了LinkedHashMap，所以它更强大，但是大部分情况下Model会更常用","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-简述","slug":"SpringMVC-简述","date":"2022-01-29T02:01:23.000Z","updated":"2022-10-04T13:55:30.676Z","comments":true,"path":"javaEE/SpringMVC/2022/01/29/SpringMVC-简述/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/29/SpringMVC-%E7%AE%80%E8%BF%B0/","excerpt":"","text":"Spring MVCModel 1时代所有请求直接转发到jsp然后在jsp编写业务代码，然后根据不同的结果跳转不同的页面 Model 2时代Controller 取得表单数据 处理业务逻辑 根据不同的情况跳转不同的页面 View 展示数据 Model 业务逻辑 保存数据 简介SpringMVC的特点： 轻量级，简单易学 与spring无缝结合，可以将mvc中所有需要的类注册到ioc容器中 高效，基于请求和响应的mvc框架 功能强大，RESTFUL风格，格式化，数据验证 约定大于配置 说白了学它就一个原因，因为它让我们开发变得简单了 原理 回顾servlet我们都学过java web，那时候我们对于前端的请求都是通过一个servlet来处理的，然后在servlet里面，处理前端传来的数据，调用业务逻辑，返回处理之后的数据，然后servlet根据这些数据，进行重定向或者请求转发 一个请求对应一个servlet，这就会导致我们在开发中写了大量的servlet，而且每次都需要在web.xml中注册，十分繁琐。 没有什么是加一层解决不了的，所以，springmvc在servlet之前加了一层来简化我们的开发 SpringMVC的web框架是以围绕DispatcherServlet（前端控制器，调度器，请求分发器）设计的。它的作用就是将请求分发到不同的处理器（方法或者类，下面的初识mvc是以类级作为处理器，但是一般都会使用方法级去做处理器） 下图是DispatcherServlet的结构图，我们可以看到一些在javaweb阶段比较眼熟的类，比如Servlet，GenericServlet，HttpServlet。因此我们可以得出，DispatcherServlet本质就是一个和我们当时写的servlet是一样的，只是他帮我们做了很多事情。 人到中年有三大件，枸杞大枣保温杯。 SpringMVC中也有三大件，分别是 处理器映射器（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 我们来看看这三大件是如何在springmvc中发挥作用的，原理图如下： 核心类图 简要分析 DispatcherServlet就可以简单理解为前端控制器，他会将所有客户端的请求拦截 将该请求发送给HandlerMapping实现类，该实现类根据url查找到对应的控制器，将结果返回给DispatcherServlet DispatcherServlet根据HandlerMapping解析的结果，适配并执行对应的控制器的逻辑， 控制器返回信息，HandlerAdapter实现类接收该信息并将其解析成ModelAndView对象返回到DispatcherServlet DispatcherServlet调用ViewResolver实现类将HandlerAdapter实现类传回来的视图逻辑和模型解析 视图解析器将解析后的逻辑视图名传回DispatcherServlet DispatcherServlet根据解析后的视图名称找到该视图 渲染视图，返回页面，作出响应","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-拦截器","slug":"SpringMVC-拦截器","date":"2022-01-28T14:48:50.000Z","updated":"2022-10-04T13:55:34.517Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-拦截器/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"SpringMVC中的拦截器其实此拦截器就是我们在javaweb阶段使用的过滤器，只不过是换了一个名字而已，换汤不换药，本质是一样的。 只不过拦截器是AOP思想的具体应用 过滤器： Servlet规范中的一部分，任何javaweb工程都可以使用 在url-pattern中配置了&#x2F;*后，会拦截所有的请求 拦截器： 拦截器是SpringMVC中才会有的，只有使用了此框架的工程才可以使用 拦截器只会拦截访问的控制器方法，如果访问的是静态资源是不会进行拦截的 自定义拦截器实现HandlerInterceptor接口 1234567891011121314151617181920212223242526272829package com.lizhi.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; /** * return true才会执行下一个拦截器 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;===处理前===&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;===处理后===&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;===清理===&quot;); &#125;&#125; 在Spring核心文件中注册拦截器 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/**会拦截这个请求下面的所有请求--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.lizhi.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-乱码","slug":"SpringMVC-乱码","date":"2022-01-28T14:48:01.000Z","updated":"2022-10-04T13:55:37.492Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-乱码/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E4%B9%B1%E7%A0%81/","excerpt":"","text":"乱码！一生之敌！！！UserController 123456789101112131415161718package com.lizhi.controller;import com.lizhi.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @PostMapping(&quot;/login.do&quot;) public String login(User user, Model model)&#123; model.addAttribute(&quot;user&quot;,user); return &quot;index&quot;; &#125;&#125; login.jsp 123456789101112131415161718&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/user/login.do&quot; method=&quot;post&quot;&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;name:$&#123;user.name&#125;age:$&#123;user.age&#125;&lt;/body&gt;&lt;/html&gt; 结果如下： 我们先尝试一下配置一个过滤器，这是第一种方案 1234567891011121314151617181920212223package com.lizhi.filter;import javax.servlet.*;import java.io.IOException;public class CharsetFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 记得去web.xml中注册 12345678&lt;filter&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.CharsetFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charsetFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 我们尝试后发现，没有任何效果，那既然我们写的过滤器不行 那springmvc给我们写了一个专门处理乱码的过滤器，我们来配置一下，这是第二种方案，很稳妥 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 测试后发现，还是乱码！！这时候我们可以去看一下tomcat的config目录下的server.xml，找到connector标签并修改属性 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 发现还是不行，我们去找一个其他大佬自己写的过滤器试一试，这是第三种方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.lizhi.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.util.Map;public class EncodeFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse resp = (HttpServletResponse) servletResponse; resp.setContentType(&quot;text/html;utf-8&quot;); HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletRequest myreq = new MyRequest(req); filterChain.doFilter(myreq, resp); &#125; @Override public void destroy() &#123; &#125;&#125;class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; private boolean hasEncode; public MyRequest(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public Map getParameterMap() &#123; String method = request.getMethod(); if(&quot;post&quot;.equalsIgnoreCase(method))&#123; try&#123; request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;else if(&quot;get&quot;.equalsIgnoreCase(method))&#123; Map&lt;String,String[]&gt; parameterMap = request.getParameterMap(); if(!hasEncode)&#123; for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if(values!=null)&#123; for (int i = 0; i &lt; values.length; i++) &#123; try&#123; values[i] = new String(values[i].getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; @Override public String getParameter(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if(values==null)&#123; return null; &#125; return values[0]; &#125; @Override public String[] getParameterValues(String name) &#123; Map&lt;String,String[]&gt; parameterMap = getParameterMap(); return parameterMap.get(name); &#125;&#125; 结果测试发现，还是不对！其实乱码的问题到这里一般都会解决了，但是为什么还是不行呢？ 其实是在注册filter的时候就出错了，接下来看下面的正确配置，大家可以看一下有什么区别， 12345678&lt;filter&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lizhi.filter.EncodeFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;otherEncodeFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 有的小伙伴可能在一开始就看出来了，没错，就是&lt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&gt;这里的拦截路径我们应该使用/*而不是/ 两者有什么区别呢？ 前者是拦截一切请求，包括jsp 而后者会拦截除了jsp的所有资源 相信吃了这次亏，大家之后就再也不会忘记这个坑了！而且也了解了大部分乱码问题的解决方案！","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"SpringMVC-第一个SpringMVC工程","slug":"SpringMVC-第一个SpringMVC工程","date":"2022-01-28T14:26:57.000Z","updated":"2022-10-04T13:55:26.774Z","comments":true,"path":"javaEE/SpringMVC/2022/01/28/SpringMVC-第一个SpringMVC工程/","link":"","permalink":"https://li-zhi.net.cn/javaEE/SpringMVC/2022/01/28/SpringMVC-%E7%AC%AC%E4%B8%80%E4%B8%AASpringMVC%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"初识SpringMVC第一步：创建普通maven工程 第二步：导入所需依赖 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.14&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 第三步：添加web支持 第四步：在web.xml中配置DispatcherServlet 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 第五步：在资源路径下创建springmvc-servlet.xml配置文件，配置处理器映射器，处理器适配器，视图解析器 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.lizhi.controller.HelloServlet&quot;/&gt;&lt;/beans&gt; 第六步：创建HelloController实现Controller接口，并注册，id为路径 12345678910111213141516171819package com.lizhi.controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloServlet implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;msg&quot;,&quot;HelloSpringMVC&quot;); modelAndView.setViewName(&quot;hello&quot;); return modelAndView; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 第八步：启动tomcat测试 使用注解开发前四步如上 第五步：在springmvc-servlet中开启注解支持 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lizhi.controller&quot;/&gt; &lt;!-- Springmvc不处理静态文件--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--支持springmvc注解驱动在spring中一般采用@RequestMapping来完成映射关系要想让注解生效，则必须要向上下文注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerMapping实例这两个处理器分别是类级别和方法级别的而annotation-driven则帮助我们自动完成了这两个类的配置--&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第六步：创建Controller 123456789101112131415package com.lizhi.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class UserController &#123; @GetMapping(&quot;login&quot;) public String login(Model model)&#123; //model对象是页面模型，可以在此对象中放入业务返回的前端需要的数据 model.addAttribute(&quot;msg&quot;,&quot;请登录&quot;); return &quot;login&quot;; &#125;&#125; 第七步：在WEB-INF文件夹下创建jsp文件夹，在jsp文件夹中创建login.jsp 第八步：启动tomcat测试 如果出现404或者500错误可，尝试以下两种解决方案 在pom.xml中加入此段配置 123456789101112131415161718192021&lt;!--在build中配置resources，来防止我们资源导出出现的问题--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在artifact中加入lib目录，并将所需jar包导入其中","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"}]},{"title":"MyBatis映射器文件","slug":"MyBatis映射器文件","date":"2022-01-27T10:59:36.000Z","updated":"2022-10-04T13:54:12.745Z","comments":true,"path":"javaEE/MyBatis/2022/01/27/MyBatis映射器文件/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/27/MyBatis%E6%98%A0%E5%B0%84%E5%99%A8%E6%96%87%E4%BB%B6/","excerpt":"","text":"映射器文件mybatis的真正强大之处就在于它的语句映射。 正是因为此映射器文件，才使我们减少了将近95%的JDBC代码，使我们更专注于书写SQL语句 映射器文件只有这些顶级元素 cache cache-ref delete insert resultMap select sql update select该标签对标SQL语句的DQL语句，也就是select语句 123&lt;select id=&quot;getStudentById&quot; resultType=&quot;student&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 这个select语句映射namespace绑定的接口中的listTeachers方法 resultType定义返回值类型 #{id}是取到方法传入的参数 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 insert，update和delete这三个标签对标SQL语句的DML语句 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 sql该标签用来定义sql片段，一般用来定义一些可复用的SQL语句片段，使用include标签以在其他语句中使用 12345678910111213&lt;sql id=&quot;userColumns&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql&gt;&lt;select id=&quot;selectUsers&quot; resultType=&quot;map&quot;&gt; select &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt; &lt;/include&gt;, &lt;include refid=&quot;userColumns&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t2&quot;/&gt; &lt;/include&gt; from some_table t1 cross join some_table t2&lt;/select&gt; 参数如果传入一个复杂的对象，行为就会有点不一样了。比如： 1234&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; insert into users (id, username, password) values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)&lt;/insert&gt; JDBC 要求，如果一个列允许使用 null 值，并且可能会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType) 字符串替换默认情况下，使用#{}获取参数的值的时候，mybatis会创建一个PreparedStatement对象，通过预编译，生成与#{}出现次数相同的占位符（即 ? ）这样更安全并且更迅速。 但是有时候想直接在SQL语句中插入一个字符串，不需要转义此字符串（即不需要占位符），比如ORDER BY语句，这时候可以使用${}语句，这样的话，mybatis就不会转义该字符串了 当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个栗子，如果你想 select 一个表任意一列的数据时，不需要这样写： 12345678910@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User findById(@Param(&quot;id&quot;) long id);@Select(&quot;select * from user where name = #&#123;name&#125;&quot;)User findByName(@Param(&quot;name&quot;) String name);@Select(&quot;select * from user where email = #&#123;email&#125;&quot;)User findByEmail(@Param(&quot;email&quot;) String email);// 其它的 &quot;findByXxx&quot; 方法 而是可以只写这样一个方法： 12@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 其中 $&#123;column&#125; 会被直接替换，而 #&#123;value&#125; 会使用 ? 预处理。 这样，就能完成同样的任务： 123User userOfId1 = userMapper.findByColumn(&quot;id&quot;, 1L);User userOfNameKid = userMapper.findByColumn(&quot;name&quot;, &quot;kid&quot;);User userOfEmail = userMapper.findByColumn(&quot;email&quot;, &quot;noone@nowhere.com&quot;); 结果集映射可以自定义一些复杂的返回值对象 简单结果集映射123456789@Data@NoArgsConstructor@AllArgsConstructor@Alias(&quot;aliasStudent&quot;)public class Student &#123; private Integer id; private String name; private Integer tid;&#125; 12345678&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select student_id,student_name,student_tid from student where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;studentMap&quot;&gt; &lt;id column=&quot;student_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;student_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;student_tid&quot; property=&quot;tid&quot;/&gt;&lt;/resultMap&gt; 高级结果集映射1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class Teacher &#123; private int id; private String name;&#125; 123456789101112&lt;resultMap id=&quot;teacherMap&quot; type=&quot;com.lizhi.pojo.Teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt; resultMap的子标签 constructor 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association 一个复杂类型的关联,许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 constructor有些情况下，你会使用一个不可变类，即那些很少改变或者基本不变的类，即可以使用构造方法注入 12345&lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; name=&quot;id&quot; /&gt; &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot; name=&quot;age&quot; /&gt; &lt;arg column=&quot;username&quot; javaType=&quot;String&quot; name=&quot;username&quot; /&gt;&lt;/constructor&gt; id &amp; result12&lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;&lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; 这些元素是结果映射的基础。 id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。 这两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 两个元素都有一些属性： 属性 描述 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 column 数据库中的列名，或者是列的别名。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 jdbcType支持的 JDBC 类型 为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。 BIT FLOAT CHAR TIMESTAMP OTHER UNDEFINED TINYINT REAL VARCHAR BINARY BLOB NVARCHAR SMALLINT DOUBLE LONGVARCHAR VARBINARY CLOB NCHAR INTEGER NUMERIC DATE LONGVARBINARY BOOLEAN NCLOB BIGINT DECIMAL TIME NULL CURSOR ARRAY association该标签处理一个对象聚合另一个对象的关系。 mybatis有两种不同方式去加载关联 嵌套select查询：通过另一个SQL语句去加载复杂对象 嵌套结果查询：通过连接查询直接将所有的结果查询出来，放在一张表里面 嵌套select查询（不推荐）12345678910111213&lt;resultMap id=&quot;StudentMap&quot; type=&quot;student&quot;&gt; &lt;result column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;teacher&quot; select=&quot;getTeacherById&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;StudentMap&quot;&gt; select * from student where id = #&#123;id&#125;&lt;/select&gt; 优点：SQL语句写起来方便 缺点：多层SQL嵌套，不易于维护，使用了mybatis的相关插件会导致select语句爆红，看起来不舒服 对于大型数据上，这里有一个“N+1查询问题”，问题描述如下 执行了一个单独的SQL语句去加载每一条记录的详细信息（就是+1） 对返回的列表的每一条记录，都需要执行这样的一个单独的SQL语句去加载详细信息（就是N） 这样会导致运行成千上万条sql语句，大大增加系统开销，这是我们不希望看到的 嵌套结果查询（推荐）123456789101112131415&lt;resultMap id=&quot;studentMap&quot; type=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; javaType=&quot;string&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot; javaType=&quot;_int&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot; javaType=&quot;string&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentById&quot; resultMap=&quot;studentMap&quot;&gt; select s.id sid, s.name sname, tid, t.name tname from student s inner join teacher t on s.id = #&#123;id&#125; and tid = t.id&lt;/select&gt; 优点：配置resultMap十分方便，逻辑十分清楚，方便查错和维护 缺点：连接查询的SQL语句写起来难度大， collectioncollection可以说是多个类型的关联，所以与association的处理十分相似 嵌套select查询123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;student&quot; select=&quot;getStudentsByTid&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentsByTid&quot; resultType=&quot;student&quot;&gt; select * from student where tid = #&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt; 注意：这里需要使用ofType来指定集合的泛型 嵌套结果查询1234567891011121314&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacherMap&quot;&gt; SELECT t.name tname,t.id tid,s.id sid, s.name sname FROM teacher t inner join student s on t.id=#&#123;id&#125; and s.tid=#&#123;id&#125;&lt;/select&gt; 缓存首先我们先来看一下到底什么是缓存？ 缓存这个词，相信大家对其不会陌生，因为我们在b站，腾讯视频这一类视频APP中都会缓存过一些视频。 那我们可以从中归纳出，缓存就是程序以某种形式将数据保存下来，方便下一次的使用。 那我们为什么需要使用缓存呢？ 我们都知道，我们程序员要追求三高，当然不会是高血脂，高血糖，高血压。我们所说的三高是高并发，高可用，高性能。众所周知，对于数据库的操作是比较消耗资源的。因此，多次连接数据库不利于我们达到三高，那么缓存就是会帮助我们达到三高的一种技术。 我们将用户经常查询，并且很少发生改变的数据放入缓存中，当用户下一次查询同样的数据时，就不用再去连接数据库查询数据了，减少了访问数据库的次数，减少了系统开销，从而提高了性能。 在mybatis中，存在着两种缓存机制：一级缓存和二级缓存 一级缓存该级别的缓存，mybatis是默认开启的，并且无法关闭。 该缓存是sqlSession级别的，也就是说作用域和我们之前谈过的sqlSession的作用域一致 因为用户大部分操作都是查询，但是如果出现了DML语句（即增删改）的时候，可能会对缓存中的数据造成了修改，为了安全起见，当发生增删改操作的时候，一级缓存即刻失效。 当然我们也可以手动清理缓存 二级缓存该级别的缓存，是默认关闭的，需手动打开 在mapper映射器文件中，添加以下一行代码 1234567&lt;cache/&gt;//或者加一些配置&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 在mybatis-config.xml文件中 123//可能有的小伙伴会说，该设置默认就是true，不需要写这一行代码//但是，为了显式说明我们开启了二级缓存，最好还是标注出来&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 注：如果在cache标签中没有加入readOnly&#x3D;“true”，则需要将模型类实现序列化接口（Serializable） 该缓存是namespace级别的，也就是和应用程序的生命周期一致 附上一张关于mybatis的原理图，仅供参考","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Spring-aop","slug":"Spring-aop","date":"2022-01-27T08:25:19.000Z","updated":"2022-10-04T13:55:04.331Z","comments":true,"path":"javaEE/Spring/2022/01/27/Spring-aop/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Spring/2022/01/27/Spring-aop/","excerpt":"","text":"AOPAOP为Aspect Oriented Programming的缩写，意思是面向切面编程，是通过预编译和运行期动态代理实现程序功能的统一维护的一种技术。 Spring框架两大重点，AOP和IOC(Inversion Of Control)控制反转 AOP是OOP的延续,是软件开发中的一个热点, 也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行解耦合,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性，同时提高了开发的效率。 作用及优势 作用：在程序运行期间，在不修改源码的情况下进行功能增强 优势：减少代码重复性，提高开发效率，并且便于维护 底层原理实际上，AOP的底层是通过Spring提供的的动态代理技术实现的。 在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 常用代理技术 JDK代理：基于接口的动态代理技术 Adivce.java 12345678public class Advice &#123; public void before()&#123; System.out.println(&quot;前置增强&quot;); &#125; public void after()&#123; System.out.println(&quot;后置增强&quot;); &#125;&#125; TargetInterface.java 123public interface TargetInterface &#123; void save();&#125; Target.java 123456public class Target implements TargetInterface &#123; @Override public void save()&#123; System.out.println(&quot;saving running......&quot;); &#125;&#125; ProxyTest.java 1234567891011121314151617181920public class ProxyTest &#123; public static void main(String[] args) &#123; final Target = new Target(); final Adivice = new Advice(); TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandle()&#123; public Object invoke(Object proxy,Method method,Object[] args) throws Throwable &#123; advice.before(); Object invoke = method.invoke(target,args); advice.after(); return invoke; &#125; &#125; ); proxy.save(); &#125;&#125; cglib代理：基于父类的动态代理技术 ProxyTest.java 123456789101112131415161718192021222324public class ProxyTest &#123; public static void main(String[] args) &#123; Target target = new Target(); Enhance enhance = new Enhance(); //创建增强其 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(Target.class); //设置回调 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; enhance.before(); Object invoke = method.invoke(target, args); enhance.after(); return invoke; &#125; &#125;); //创建代理对象 Target proxy = (Target) enhancer.create(); proxy.save(); &#125;&#125; AOP相关术语Spring的AOP实现底层就是对上面的动态代理的代码进行了封装,封装后我们只需要对需要关注的部分进行代码编写,并通过配置的方式完成指定目标的方法增强。 Target (目标对象) :代理的目标对象 Proxy (代理) :一个类被AOP织入增强后,就产生一 个结果代理类 Joinpoint (连接点) :所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut (切入点) :所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice (通知&#x2F;增強) :所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect (切面) :是切入点和通知(引介)的结合 Weaving (织入) :是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect采用编译期织入和类装载期织入 开发明确事项 需要编写的内容 编写核心业务代码(目标类的目标方法) 编写切面类,切面类中有通知(增强功能方法) 在配置文件中，配置织入关系,即将哪些通知与哪些连接点进行结合 AOP技术实现的内容 Spring框架监控切入点方法的执行。 一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置,将通知对应的功能织入，完成完整的代码逻辑运行。 基于XML的AOP开发 步骤 导入AOP坐标 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8.M1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建目标类和目标接口 创建切面类（内部有增强方法） 将目标类和切面类的对象的创建权交给Spring 在applicationContext.xml中配置中织入关系 测试 切点表达式1execution([修饰符]返回值类型 包名.类名.方法名(参数列表)) 访问修饰符可以省略 返回值类型、 包名、类名、方法名可以使用星号*代表任意 包名与类名之间一 个点.代表当前包下的类,两个点.. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数,任意类型的参数列表 1234567891011121314//代表切口是com.lizhi.aop.Target类的返回void的method的无参数方法execution (public void com.itheima.aop.Target.method() )//代表切口是com.lizhi.aop.Target类的返回void的所有方法，参数个数为任意execution (void com.itheima.aop.Target.*(.. ))//代表切口是com.lizhi.aop包下的所有类的所有方法，参数个数为任意execution(* com.lizhi.aop.*.*(..))//代表切口是com.lizhi.aop包及其子包下的所有类所有方法，参数个数为任意execution(* com.lizhi.aop..*.* (..) )//代表切口是项目下的所有包的所有方法，参数为任意参数execution(* *..*.*(..) ) 通知类型 名称 通知类型 说明 前置通知 aop:before 指定增强的方法在切入点之前执行 后置通知 aop:after-returning 指定增强的方法在切入点之后执行 环绕通知 aop:around 指定增强的方法在切入点之前和之后都会执行 异常抛出通知 aop:throwing 指定增强的方法在出现切点异常时执行 最终通知 aop:after 无论增强方式执行是否有异常都会执行 around 1234567//ProceedingJoinPoint指的是正在执行的连接点==切点public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;环绕前增强。。。。。&quot;); Object obj = pjp.proceed();//切点方法 System.out.println(&quot;环绕后增强。。。。。&quot;); return obj;&#125; 切点表达式的抽取 123456&lt;apo:config&gt; &lt;aop:aspect&gt; &lt;apo:pointcut id=&quot;myPointcut&quot; expression=&quot;excution( * com.lizhi.apo.*.*(..))&quot;&gt;&lt;/apo:pointcut&gt; &lt;apo:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/apo:before&gt; &lt;/aop:aspect&gt;&lt;/apo:config&gt; 基于注解的AOP开发 创建目标接口和目标类(内部有切点) 创建切面类(内部有增强方法) 将目标类和切面类的对象创建权交给spring 在切面类中使用注解配置织入关系 在配置文件中开启组件扫描和AOP的自动代理 测试","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"https://li-zhi.net.cn/categories/javaEE/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://li-zhi.net.cn/tags/Spring/"}]},{"title":"面向接口编程","slug":"面向接口编程","date":"2022-01-27T08:21:11.000Z","updated":"2022-09-27T13:57:24.767Z","comments":true,"path":"琐碎的知识/2022/01/27/面向接口编程/","link":"","permalink":"https://li-zhi.net.cn/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/2022/01/27/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","excerpt":"","text":"面向接口编程是什么大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因:解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了: 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解接口从更深层次的理解，应是定义(规范，约束)与实现(名实分离的原则)的分离。 接口的本身反映了系统设计人员对系统的抽象理解。接口应有两类: 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class) 第二类是对一个个体某一方面的抽象，即形成一个抽象面(interface) 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向的区别面向对象编程指的是，我们考虑问题的时候，以对象为单位，考虑它的属性和方法 面向过程编程指的是，我们考虑问题的时候，以一个具体的流程（事务过程）为单位，考虑它的实现 接口设计与非接口设计是针对复用技术层面的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构","categories":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"}]},{"title":"MyBatis的xml配置","slug":"MyBatis配置","date":"2022-01-26T15:44:33.000Z","updated":"2022-10-04T13:54:05.280Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis配置/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置Configuration在MyBatis中，配置文件的顶层结构如下 Configuration properties settings typeAliases typeHandlers objectFactory plugins environments environment dataSource transactionManager databaseIdProvider mappers 属性properties123&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;/properties&gt; resource属性可以导入在外部properties配置文件中的属性到properties标签中 property标签可以定义一些属性 配置好的属性可以在该文件中使用${}来替换需要动态配置的属性值 123456&lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;&lt;/dataSource&gt; 比如上方的driver的值会由db.properties文件中对应的值来替换 如果在多个地方进行了配置Java代码，外部文件，properties标签，则按照以下顺序加载 先加载properties标签中的属性 再加载外部文件中配置的属性，如果有重复的属性，则覆盖旧的属性 最后加载Java代码中的属性，如果有重复的属性，覆盖旧的属性 因此，通过java方法传入的属性具有最高的优先级，外部文件优先级次之，properties标签中的属性优先级最为低 设置settings以下为重要的几个配置，需要掌握 设置名 描述 有效值 默认值 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 true | false false useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 true | false False mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true | false False logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 类型别名typeAliases在映射器XML文件中，resultType属性在配置了类型别名后，可以不需要写全限定名，可以写在这里起的别名 在此包下的所有类都被默认起别名为类名开头小写，该默认值被注解@Alias()覆盖 123&lt;typeAliases&gt; &lt;package name=&quot;com.lizhi.pojo&quot;/&gt;&lt;/typeAliases&gt; 可以单独为一个类起别名， 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.lizhi.pojo.Teacher&quot; alias=&quot;teacher&quot;/&gt;&lt;/typeAliases&gt; 下面为一些常见的java类型内建的类型别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date map Map 环境配置Environmentsmybatis可以配置多套环境，这种机制有利于将SQL映射应用于多种数据库之中。开发，测试，生成环境需要有不同的配置。 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意一些关键点 environment的id属性，该属性是唯一性标识环境的值 在environments的default属性中通过id指定环境配置 事务管理器transactionManagertype指定事务管理器 mybatis中有两种事务管理器（也就是type &#x3D; “JDBC|MANAGED”） JDBC-这个配置直接使用了JDBC的提交和回滚机制，依赖于数据源的连接来管理事务管理作用域 MANAGED-这个配置几乎什么都不做，一般不选用 如果使用mybatis+Spring 则没有必要配置事务管理器，因为Spring模块会使用自带的事务管理器来覆盖此配置 数据源dataSourcetype指定数据源类型 dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源 有三种内置的数据源格式 UNPOOLED这个数据源的实现每次连接会打开和关闭连接会有点慢，但是对于一些小型应用已经足够了， 此类型的数据源只需要配置以下几种属性 driver – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 defaultNetworkTimeout – 等待数据库操作完成的默认网络超时时间（单位：毫秒） POOLED这个数据源的实现利用了池的概念将JDBC的连接对象组织起来，避免了创建新的连接实例的时候所必需的初始化和认证时间，可以使web应用响应速度变快，该类型的数据源除了以上UNPOOLED的属性外还有以下常用配置 poolMaximumActiveConnections – 在任意时间可存在的活动（正在使用）连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。 JNDI(用得少，略)","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"MyBatis入门","slug":"MyBatis入门","date":"2022-01-26T15:43:33.000Z","updated":"2022-10-04T13:54:08.504Z","comments":true,"path":"javaEE/MyBatis/2022/01/26/MyBatis入门/","link":"","permalink":"https://li-zhi.net.cn/javaEE/MyBatis/2022/01/26/MyBatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"MyBatis回顾JDBC 注册驱动 获取连接 获取数据库操作对象 执行SQL，操作数据库 处理结果集 关闭连接 Connection可以获得PreparedStatement或者Statement ResultSet是SQL语句执行后返回的对象 PreparedStatement和Statement是用来执行SQL语句的对象 两者的区别： PreparedStatement对SQL语句做了预编译，很好的解决了SQL注入的问题。 Statement是单纯的对字符串进行拼接，会产生SQL注入的问题 简介Def： MyBatis是一个优秀的持久层的框架，支持定制化SQL语句，存储过程以及高级映射，大大简化了JDBC的笨重的代码。 MyBatis可以使用XML配置文件或者注解的方式来配置和映射原生类型、接口和pojo（Plain Object Java Object） 持久层是什么？持久层是一个将应用中产生的数据保存到数据库的过程 思路：导入依赖—》编写代码—》测试 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 入门MyBatis中最重要的三个类 SqlSessionFactoryBuilder SqlSessionFactory SqlSession 每个基于MyBatis的应用都是以一个SqlSessionFactory实例为核心的。这个实例需要通过SqlSessionFactoryBuilder加载配置文件获得。这个配置文件可以通过两种方式获得，第一种是以XML文件的形式存在，第二种是在java代码对象的形式存在 构建SqlSessionFactory mybatis-config.xml配置构建SqlSessionFactory所需要的参数 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 在java中加载配置文件，通过SqlSessionFactoryBuilder构建SqlSessionFactory实例 123String resource=&quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 通过java代码配置不推荐，略 构建SqlSessionSqlSession，通过此对象获得接口的映射器实例，该映射对象对标JDBC中接口的实现类 123456//开启一个sqlSession对象，默认关闭自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession();//开启自动提交事务SqlSession sqlSession = sqlSessionFactory.openSession(true);TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); 映射SQL语句 通过XML配置文件的方式和接口做绑定，实现接口方法 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lizhi.mapper.TeacherMapper&quot;&gt; &lt;select id=&quot;listTeachers&quot; resultType=&quot;com.lizhi.pojo.Teacher&quot;&gt; SELECT * FROM teacher &lt;/select&gt;&lt;/mapper&gt; mapper标签的namespace属性指向被绑定的接口 标签内书写SQL语句，id为接口中的方法名 select标签实现select方法 insert标签实现insert方法 update标签实现update方法 delete标签实现delete方法 通过注解的方式实现SQL映射 12@Select(&quot;SELECT * FROM teacher WHERE id = #&#123;id&#125;&quot;)Teacher getTeacherById(int id); 选择何种方式实现SQL映射，取决于自身。 但是如果SQL复杂的情况下，尽量不要使用注解开发，使用XML的方式去做SQL映射 三个对象的作用域（Scope） SqlSessionFactoryBuilder 该对象就一个作用，通过读取一些配置获取SqlSessionFactory实例对象。 我们没有理由一直保留它，因为SqlSessionFactory将被保存在全局作用域中，以保证所有的XML解析资源可以被释放给做其他事情，所以它的作用域应该是局部变量 SqlSession 该对象就一个作用，通过getMapper方法获取映射器实例。 每个线程都应该有它自己的SqlSession对象，因为该对象不是线程安全的，因此它是不能被共享的，所以它的最佳作用域是局部变量。 在web框架中，可以将其放到request的作用域中，返回一个响应前，关闭SqlSession对象，这个关闭操作很重要 SqlSessionFactory 该对象就一个作用，通过openSession方法获取SqlSession对象。 因为SqlSession对象是线程不安全的，所以每次查询数据库都需要一个新的SqlSession对象，既然SqlSessionFactoryBuilder的作用域为局部变量，那么在我们第一次创建出来SqlSessionFactory对象的时候，就可以将其保存在全局作用域中，下次就不需要再创建SqlSessionFactoryBuilder对象了，所以SqlSessionFactory的最佳作用域是全局唯一变量。","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"}]},{"title":"Maven","slug":"Maven","date":"2022-01-26T15:36:37.000Z","updated":"2022-10-04T13:54:01.800Z","comments":true,"path":"javaEE/Maven/2022/01/26/Maven/","link":"","permalink":"https://li-zhi.net.cn/javaEE/Maven/2022/01/26/Maven/","excerpt":"","text":"MavenMaven简介学maven首先记住一句话，约定大于配置 Maven是什么 本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（pom） POM(Project Object Model)：项目对象模型 pom.xml—&gt;项目管理模型——&gt;依赖管理（Dependency）—&gt;本地仓库—&gt;私服仓库—&gt;中央 Maven有什么用 项目构建：提供标准化，跨平台的自动化项目构建方式 依赖管理：方便快捷的管理项目依赖的资源包，避免资源间的版本冲突问题 统一开发结构：提供标准的，统一的项目结构 下载与安装 官网：http://maven.apache.org/ 下载地址：http://maven.apache.org/download.cgi Maven环境配置 依赖java，所以需要JAVA_HOME 设置Maven自身的运行环境，需要配置MAVEN_HOME Maven基础概要仓库仓库：用于存储资源，包含各种jar包 仓库分类 本地仓库：自己电脑上的存储资源的仓库，连接远程仓库获取资源 远程仓库：非本机上的仓库，为本地仓库提供资源 中央仓库：由Maven团队维护，存储所有开源资源的仓库 私服：部门&#x2F;公司范围内存储资源的仓库，从中央仓库中获取资源 私服的作用 保护具有版权的资源，包含购买或者自主研发的jar 中央仓库中的jar都是开源的，不能存储具有版权的资源 一定范围内共享资源，就对内开放，不对外开放 坐标GAV 坐标：Maven中的坐标主要用于描述仓库中资源的位置，记住这个网站 https://mvnrepository.com/ Maven主要组成部分 groupId：定义当前项目隶属的组织名称（通常是域名反写 org.mybatis） artifactId：定义该项目的项目名称（通常是模块名称） version：定义当前项目的版本号 packaging：定义该项目的打包方式 作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成 本地仓库配置maven默认的本地仓库目录在c盘用户文件夹下的.m2文件夹中，如有需要，可在配置文件中自行配置。 在这里举个例子，我需要将D:\\APP\\Maven\\mvn-repo该目录作为我的maven本地仓库的路径。 创建mvn-repo文件夹，在此文件夹中创建repository目录 在maven安装根目录下的config文件夹下找到settings.xml找到以下配置所在，照着以下配置修改 12345678910//这里改成自己需要配置的仓库目录&lt;localRepository&gt;D:\\APP\\Maven\\mvn-repo\\repository&lt;/localRepository&gt;//阿里云的镜像服务器，会加快jar包的下载速度，直接复制即可&lt;mirrors&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirrors&gt; 将此份配置文件保存并复制到mvn-repo文件夹中 全局setting（maven的config中的setting文件）和用户setting（尽量和全局setting一样）区别 全局setting定义了当前计算机中Maven的公共配置 用户setting定义了当前用户的配置 创建maven项目手工普通maven工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-quickstart -Dversion = 0.0.1-snapshot -DinteractiveMode = false web工程 123456mvn archetype:generate -DgroupId = com.lizhi -DartifactId = project -DarchetypeArtifactId = maven-archetype-webapp -Dversion = 0.0.1-snapshot -DinteractiveMode = false 依赖管理依赖配置123456789101112&lt;!--设置当前项目所需要的依赖--&gt;&lt;dependencies&gt; &lt;!--设置具体的依赖--&gt; &lt;dependency&gt; &lt;!--依赖所属的群组id--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!--依赖所属的项目id--&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--依赖的版本号--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖传递依赖具有传递性 直接传递：在当前项目中，通过依赖配置建立的依赖关系 间接关系：被依赖的资源如果依赖其他的资源，当前项目间接依赖其他项目 依赖冲突 路径优先：当依赖中出现相同的资源时，层次越深，优先级越低，层次越浅，优先级越高 声明优先：当资源在相同层次被依赖时，配置顺序靠前的覆盖顺序靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖（主动表示断开）123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;!--不透明--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 排除依赖（主动断开） 排除依赖指的是主动断开依赖的资源，被排除的资源无需指定版本—不需要 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖范围12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies 依赖的jar包默认情况下可以在任何地方使用，可以通过scope标签设定起作用范围 作用范围 主程序范围有效（main文件范围内） 测试范围有效（test文件夹范围） 是否参与打包（package指令范围内） scope 主代码 测试代码 打包 示例 compile Y Y Y log4j test Y junit provided Y Y servlet-api runtime Y jdbc 依赖范围的传递性 带有依赖范围的资源在进行传递的时候，作用范围将会受到影响 行是直接依赖，列是间接依赖 compile test provided runtime compile compile test provided runtime test provided runtime runtime test provided runtime 生命周期以及插件生命周期 Maven对项目构建的生命周期划分为3套 clean：清理工作 default：核心工作，例如编译、测试、打包、部署等 site：产生报告，发布站点等 clean生命周期 pre-clean 执行一些需要在clean之前立即完成的工作 clean 移除所有上一次构件生成的文件 post-clean 执行一些需要在clean之后立即完成的工作 default生命周期 site生命周期 pre-site 执行一些需要在生成站点文档之前完成的工作 site 生成站点文档 post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备工作 site-deploy 将生成的站点文档部署到特定服务器上面去 插件 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能 默认maven在各个生命周期上绑定有预设的功能 通过插件可以自定义其他功能","categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"https://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://li-zhi.net.cn/tags/Maven/"}]},{"title":"first","slug":"first","date":"2022-01-16T10:39:26.000Z","updated":"2022-10-04T13:52:45.460Z","comments":true,"path":"uncategorized/2022/01/16/first/","link":"","permalink":"https://li-zhi.net.cn/uncategorized/2022/01/16/first/","excerpt":"","text":"测试博客的发布","categories":[],"tags":[]}],"categories":[{"name":"javaEE","slug":"javaEE","permalink":"https://li-zhi.net.cn/categories/javaEE/"},{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"刷题篇","slug":"算法/刷题篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E7%AF%87/"},{"name":"JUC","slug":"javaEE/JUC","permalink":"https://li-zhi.net.cn/categories/javaEE/JUC/"},{"name":"Docker","slug":"javaEE/Docker","permalink":"https://li-zhi.net.cn/categories/javaEE/Docker/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/categories/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"前端","slug":"前端","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue2","slug":"前端/Vue2","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/Vue2/"},{"name":"技巧篇","slug":"算法/技巧篇","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%AF%87/"},{"name":"Linux","slug":"javaEE/Linux","permalink":"https://li-zhi.net.cn/categories/javaEE/Linux/"},{"name":"JVM","slug":"javaEE/JVM","permalink":"https://li-zhi.net.cn/categories/javaEE/JVM/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://li-zhi.net.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"自己出的题目","slug":"算法/自己出的题目","permalink":"https://li-zhi.net.cn/categories/%E7%AE%97%E6%B3%95/%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84%E9%A2%98%E7%9B%AE/"},{"name":"Redis","slug":"javaEE/Redis","permalink":"https://li-zhi.net.cn/categories/javaEE/Redis/"},{"name":"SpringBoot","slug":"javaEE/SpringBoot","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringBoot/"},{"name":"多线程","slug":"javaEE/多线程","permalink":"https://li-zhi.net.cn/categories/javaEE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"javaEE/SpringMVC","permalink":"https://li-zhi.net.cn/categories/javaEE/SpringMVC/"},{"name":"MyBatis","slug":"javaEE/MyBatis","permalink":"https://li-zhi.net.cn/categories/javaEE/MyBatis/"},{"name":"Spring","slug":"javaEE/Spring","permalink":"https://li-zhi.net.cn/categories/javaEE/Spring/"},{"name":"Maven","slug":"javaEE/Maven","permalink":"https://li-zhi.net.cn/categories/javaEE/Maven/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://li-zhi.net.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"并发","slug":"并发","permalink":"https://li-zhi.net.cn/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Docker","slug":"Docker","permalink":"https://li-zhi.net.cn/tags/Docker/"},{"name":"琐碎的知识","slug":"琐碎的知识","permalink":"https://li-zhi.net.cn/tags/%E7%90%90%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"name":"Vue","slug":"Vue","permalink":"https://li-zhi.net.cn/tags/Vue/"},{"name":"Linux","slug":"Linux","permalink":"https://li-zhi.net.cn/tags/Linux/"},{"name":"JVM","slug":"JVM","permalink":"https://li-zhi.net.cn/tags/JVM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://li-zhi.net.cn/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"https://li-zhi.net.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"Redis","permalink":"https://li-zhi.net.cn/tags/Redis/"},{"name":"JUC","slug":"JUC","permalink":"https://li-zhi.net.cn/tags/JUC/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://li-zhi.net.cn/tags/SpringBoot/"},{"name":"多线程","slug":"多线程","permalink":"https://li-zhi.net.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://li-zhi.net.cn/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://li-zhi.net.cn/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"https://li-zhi.net.cn/tags/Spring/"},{"name":"Maven","slug":"Maven","permalink":"https://li-zhi.net.cn/tags/Maven/"}]}